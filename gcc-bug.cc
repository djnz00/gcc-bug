//  -*- mode:c++; indent-tabs-mode:t; tab-width:8; c-basic-offset:2; -*-
//  vi: noet ts=8 sw=2 cino=+0,(s,l1,m1,g0,N-s,j1,U1,W2,i2

// (c) Copyright 2024 Psi Labs
// This code is licensed by the MIT license (see LICENSE for details)

// Z library main header

#define ZuLib_HH

#include <assert.h>
#include <string.h>
#include <math.h>
#include <float.h>
#include <unistd.h>
#include <signal.h>
#include <semaphore.h>
#include <limits.h>
#include <stdint.h>
#include <stddef.h>
#include <stdlib.h>

#include <utility>
#include <memory>
#include <cstring>
#include <iostream>
#include <vector>
#include <set>
#include <algorithm>
#include <functional>

#define ZuAPI
#define ZuExplicit
#define ZuExtern extern

#ifdef __GNUC__

#define ZuLikely(x) __builtin_expect(!!(x), 1)
#define ZuUnlikely(x) __builtin_expect(!!(x), 0)

#ifdef ZDEBUG
#define ZuInline inline
#define ZuNoInline inline
#else
#define ZuInline inline __attribute__((always_inline))
#define ZuNoInline inline __attribute__((noinline))
#endif

#endif

#ifdef __GNUC__
#define ZuMayAlias(x) __attribute__((__may_alias__)) x
#else
#define ZuMayAlias(x) x
#endif

#if defined(linux) || defined(__mips64)
#include <endian.h>
#if __BYTE_ORDER == __BIG_ENDIAN
#define Zu_BIGENDIAN 1
#else
#define Zu_BIGENDIAN 0
#endif
#else
#ifdef _WIN32
#define Zu_BIGENDIAN 0
#endif
#endif

template <typename T_> struct ZuDeref_ {
  using T = T_;
};
template <typename T_> struct ZuDeref_<T_ &> {
  using T = T_;
};
template <typename T_> struct ZuDeref_<const T_ &> {
  using T = const T_;
};
template <typename T_> struct ZuDeref_<volatile T_ &> {
  using T = volatile T_;
};
template <typename T_> struct ZuDeref_<const volatile T_ &> {
  using T = const volatile T_;
};
template <typename T_> struct ZuDeref_<T_ &&> {
  using T = T_;
};
template <typename T> using ZuDeref = typename ZuDeref_<T>::T;

template <typename T_> struct ZuStrip_ {
  using T = T_;
};
template <typename T_> struct ZuStrip_<const T_> {
  using T = T_;
};
template <typename T_> struct ZuStrip_<volatile T_> {
  using T = T_;
};
template <typename T_> struct ZuStrip_<const volatile T_> {
  using T = T_;
};
template <typename T> using ZuStrip = typename ZuStrip_<T>::T;

template <typename T> using ZuDecay = ZuStrip<ZuDeref<T>>;

template <typename T> using ZuAsIs = T;
template <typename T> using ZuMkConst = const T;
template <typename T> using ZuMkVolatile = volatile T;
template <typename T> using ZuMkRRef = T &&;
template <typename T> using ZuMkLRef = T &;
template <typename T> using ZuMkCRef = const T &;

template <typename T> inline constexpr T &&ZuFwd(ZuDeref<T> &v) noexcept {
  return static_cast<T &&>(v);
}
template <typename T> inline constexpr T &&ZuFwd(ZuDeref<T> &&v) noexcept {
  return static_cast<T &&>(v);
}

template <typename T> inline constexpr ZuDeref<T> &&ZuMv(T &&v) noexcept {
  return static_cast<ZuDeref<T> &&>(v);
}

template <typename L> struct ZuGuard {
  L fn;
  bool cancelled = false;

  ZuGuard(L fn_) : fn{ZuMv(fn_)} { }
  ~ZuGuard() {
    if (!cancelled) fn();
  }
  ZuGuard(const ZuGuard &) = delete;
  ZuGuard &operator=(const ZuGuard &) = delete;
  ZuGuard(ZuGuard &&o) : fn{ZuMv(o.fn)} { o.cancelled = true; }
  ZuGuard &operator=(ZuGuard &&o) {
    if (this != &o) {
      this->~ZuGuard();
      new (this) ZuGuard{ZuMv(o)};
    }
    return *this;
  }

  void cancel() { cancelled = true; }
  void cancel(bool v) { cancelled = v; }
};

template <typename T_> struct ZuBind {
  using T = ZuDecay<T_>;

  template <typename Mv, typename Cp>
  static constexpr auto mvcp(const T &v, Mv, Cp cp_) {
    return cp_(v);
  }
  template <typename Mv, typename Cp>
  static constexpr auto mvcp(T &&v, Mv mv_, Cp) {
    return mv_(ZuMv(v));
  }

  template <typename Mv> static void mv(const T &v, Mv);

  template <typename Mv> static constexpr auto mv(T &&v, Mv mv_) {
    return mv_(ZuMv(v));
  }

  template <typename Cp> static constexpr auto cp(const T &v, Cp cp_) {
    return cp_(v);
  }

  template <typename Cp> static void cp(T &&v, Cp);
};

template <typename T1, typename T2, bool B> struct ZuIf_;
template <typename T1, typename T2> struct ZuIf_<T1, T2, true> {
  using T = T1;
};
template <typename T1, typename T2> struct ZuIf_<T1, T2, false> {
  using T = T2;
};
template <bool B, typename T1, typename T2>
using ZuIf = typename ZuIf_<T1, T2, B>::T;

template <bool, typename U = void> struct ZuIfT_ { };
template <typename U> struct ZuIfT_<true, U> {
  using T = U;
};
template <bool B, typename U = void> using ZuIfT = typename ZuIfT_<B, U>::T;

template <typename T_, T_ V> struct ZuConstant {
  using T = T_;
  constexpr operator T() const noexcept { return V; }
  constexpr T operator()() const noexcept { return V; }
};
template <int I> using ZuInt = ZuConstant<int, I>;
template <unsigned I> using ZuUnsigned = ZuConstant<unsigned, I>;
template <auto B> using ZuBool = ZuConstant<bool, static_cast<bool>(B)>;
using ZuFalse = ZuBool<false>;
using ZuTrue = ZuBool<true>;

template <typename U> struct ZuDeclVal__ {
  using T = U;
};
template <typename T> auto ZuDeclVal_(int) -> typename ZuDeclVal__<T &&>::T;
template <typename T> auto ZuDeclVal_(...) -> typename ZuDeclVal__<T>::T;
template <typename U> decltype(ZuDeclVal_<U>(0)) ZuDeclVal();

template <typename...> struct ZuVoid_ {
  using T = void;
};
template <typename... Ts> using ZuVoid = typename ZuVoid_<Ts...>::T;

template <typename T, bool = __is_empty(T)>
struct ZuSize__ : public ZuUnsigned<sizeof(T)> { };
template <typename T> struct ZuSize__<T, true> : public ZuUnsigned<0> { };
template <typename T, typename = void>
struct ZuSize_ : public ZuUnsigned<sizeof(T)> { };
template <typename T>
struct ZuSize_<T, decltype(sizeof(T), (int T::*){}, void())> :
  public ZuSize__<T> { };
template <typename T> struct ZuSize : public ZuSize_<T> { };
template <> struct ZuSize<void> : public ZuUnsigned<0> { };

template <typename U> struct ZuIsConst : public ZuFalse { };
template <typename U> struct ZuIsConst<const U> : public ZuTrue { };

template <typename U> struct ZuIsVolatile : public ZuFalse { };
template <typename U> struct ZuIsVolatile<volatile U> : public ZuTrue { };

template <typename U, typename R, bool = ZuIsConst<U>{}> struct ZuConst_;
template <typename U, typename R> struct ZuConst_<U, R, true> {
  using T = R;
};
template <typename U, typename R = void>
using ZuConst = typename ZuConst_<U, R>::T;

template <typename U, typename R, bool = !ZuIsConst<U>{}> struct ZuMutable_;
template <typename U, typename R> struct ZuMutable_<U, R, true> {
  using T = R;
};
template <typename U, typename R = void>
using ZuMutable = typename ZuMutable_<U, R>::T;

template <typename U, typename R, bool = ZuIsVolatile<U>{}> struct ZuVolatile_;
template <typename U, typename R> struct ZuVolatile_<U, R, true> {
  using T = R;
};
template <typename U, typename R = void>
using ZuVolatile = typename ZuVolatile_<U, R>::T;

template <typename U, typename R, bool = !ZuIsVolatile<U>{}>
struct ZuNonVolatile_;
template <typename U, typename R> struct ZuNonVolatile_<U, R, true> {
  using T = R;
};
template <typename U, typename R = void>
using ZuNonVolatile = typename ZuNonVolatile_<U, R>::T;

template <typename U> struct ZuIsRRef : public ZuFalse { };
template <typename U> struct ZuIsRRef<U &&> : public ZuTrue { };

template <typename U> struct ZuIsLRef : public ZuFalse { };
template <typename U> struct ZuIsLRef<U &> : public ZuTrue { };

template <typename U, typename R, bool = ZuIsRRef<U>{}> struct ZuRRef_;
template <typename U, typename R> struct ZuRRef_<U, R, true> {
  using T = R;
};
template <typename U, typename R = void>
using ZuRRef = typename ZuRRef_<U, R>::T;

template <typename U, typename R, bool = !ZuIsRRef<U>{}> struct ZuNotRRef_;
template <typename U, typename R> struct ZuNotRRef_<U, R, true> {
  using T = R;
};
template <typename U, typename R = void>
using ZuNotRRef = typename ZuNotRRef_<U, R>::T;

template <typename U, typename R, bool = ZuIsLRef<U>{}> struct ZuLRef_;
template <typename U, typename R> struct ZuLRef_<U, R, true> {
  using T = R;
};
template <typename U, typename R = void>
using ZuLRef = typename ZuLRef_<U, R>::T;

template <typename U, typename R, bool = !ZuIsLRef<U>{}> struct ZuNotLRef_;
template <typename U, typename R> struct ZuNotLRef_<U, R, true> {
  using T = R;
};
template <typename U, typename R = void>
using ZuNotLRef = typename ZuNotLRef_<U, R>::T;

struct ZuDefaultRDecayer {
  template <typename T_> struct Decay {
    using T = T_;
  };
};
ZuDefaultRDecayer ZuRDecayer(...);
template <typename T_> struct ZuRDecay_ {
  using Decayer = decltype(ZuRDecayer(ZuDeclVal<T_ *>()));
  using T = typename Decayer::template Decay<T_>::T;
};
template <typename T> using ZuRDecay = typename ZuRDecay_<ZuDecay<T>>::T;

template <typename U1, typename U2> struct ZuIsExact : public ZuFalse { };
template <typename U> struct ZuIsExact<U, U> : public ZuTrue { };

template <typename U1, typename U2, typename R> struct ZuExact_;
template <typename U, typename R> struct ZuExact_<U, U, R> {
  using T = R;
};
template <typename U1, typename U2, typename R = void>
using ZuExact = typename ZuExact_<U1, U2, R>::T;

template <typename U1, typename U2, typename R, bool = !ZuIsExact<U1, U2>{}>
struct ZuNotExact_;
template <typename U1, typename U2, typename R>
struct ZuNotExact_<U1, U2, R, true> {
  using T = R;
};
template <typename U1, typename U2, typename R = void>
using ZuNotExact = typename ZuNotExact_<U1, U2, R>::T;

inline constexpr auto ZuDefaultAxor() {
  return []<typename T>(T &&v) -> decltype(auto) { return ZuFwd<T>(v); };
}

template <typename L> struct ZuLambda {
  L lambda;

  template <
    typename L_ = L,
    decltype(ZuDeclVal<L_ &&>()(ZuDeclVal<ZuLambda &&>()), int()) = 0>
  constexpr decltype(auto) operator()() && {
    return lambda(ZuMv(*this));
  }
  template <
    typename... Args, typename L_ = L,
    decltype(ZuDeclVal<L_ &&>()(ZuDeclVal<ZuLambda &&>(), ZuFwd<Args>(ZuDeclVal<Args &&>())...), int()) =
      0>
  constexpr decltype(auto) operator()(Args &&...args) && {
    return lambda(ZuMv(*this), ZuFwd<Args>(args)...);
  }

  template <
    typename L_ = L,
    decltype(ZuDeclVal<L_ &>()(ZuDeclVal<ZuLambda &>()), int()) = 0>
  constexpr decltype(auto) operator()() & {
    return lambda(*this);
  }
  template <
    typename... Args, typename L_ = L,
    decltype(ZuDeclVal<L_ &>()(ZuDeclVal<ZuLambda &>(), ZuFwd<Args>(ZuDeclVal<Args &&>())...), int()) =
      0>
  constexpr decltype(auto) operator()(Args &&...args) & {
    return lambda(*this, ZuFwd<Args>(args)...);
  }

  template <
    typename L_ = L,
    decltype(ZuDeclVal<const L_ &>()(ZuDeclVal<const ZuLambda &>()), int()) = 0>
  constexpr decltype(auto) operator()() const & {
    return lambda(*this);
  }
  template <
    typename... Args, typename L_ = L,
    decltype(ZuDeclVal<const L_ &>()(ZuDeclVal<const ZuLambda &>(), ZuFwd<Args>(ZuDeclVal<Args &&>())...), int()) =
      0>
  constexpr decltype(auto) operator()(Args &&...args) const & {
    return lambda(*this, ZuFwd<Args>(args)...);
  }
};
template <typename L> ZuLambda(L) -> ZuLambda<L>;

template <typename U, bool = __is_enum(U)> struct ZuUnder__ {
  using T = U;
};
template <typename U> struct ZuUnder__<U, true> {
  using T = __underlying_type(U);
};

struct ZuUnder_AsIs { };
ZuUnder_AsIs ZuUnderType(...);
template <typename U, typename V = decltype(ZuUnderType(ZuDeclVal<U *>()))>
struct ZuUnder_ {
  using T = V;
};
template <typename U> struct ZuUnder_<U, ZuUnder_AsIs> {
  using T = typename ZuUnder__<U>::T;
};
template <typename T_, T_ V> struct ZuUnder_<ZuConstant<T_, V>> {
  using T = T_;
};
template <typename U> using ZuUnder = typename ZuUnder_<ZuDecay<U>>::T;

template <typename U> auto ZuUnderlying(U &&v) {
  return ZuUnder<U>(ZuFwd<U>(v));
}

struct ZuEmpty { };

using int128_t = __int128_t;
using uint128_t = __uint128_t;

template <int128_t I> using ZuInt128 = ZuConstant<int128_t, I>;
template <uint128_t I> using ZuUInt128 = ZuConstant<uint128_t, I>;

inline uint32_t Zu_popcnt(uint32_t v) {
  v -= ((v >> 1) & 0x55555555);
  v = (((v >> 2) & 0x33333333) + (v & 0x33333333));
  v = (((v >> 4) + v) & 0x0f0f0f0f);
  v += (v >> 8);
  v += (v >> 16);
  return v & 0x3f;
}

namespace ZuIntrin {

template <typename T, ZuIfT<sizeof(T) == 4, int> = 0> inline unsigned clz(T v) {
  return __builtin_clz(v);
}
template <typename T, ZuIfT<sizeof(T) == 8, int> = 0> inline unsigned clz(T v) {
  return __builtin_clzll(v);
}

template <typename T, ZuIfT<sizeof(T) == 4, int> = 0> inline unsigned ctz(T v) {
  return __builtin_ctz(v);
}
template <typename T, ZuIfT<sizeof(T) == 8, int> = 0> inline unsigned ctz(T v) {
  return __builtin_ctzll(v);
}

template <typename T, ZuIfT<sizeof(T) == 2, int> = 0> inline T bswap(T v) {
  return T(__builtin_bswap16(v));
}
template <typename T, ZuIfT<sizeof(T) == 4, int> = 0> inline T bswap(T v) {
  return T(__builtin_bswap32(v));
}
template <typename T, ZuIfT<sizeof(T) == 8, int> = 0> inline T bswap(T v) {
  return T(__builtin_bswap64(v));
}
template <typename T, ZuIfT<sizeof(T) == 16, int> = 0> inline T bswap(T v) {
  return T(__builtin_bswap128(v));
}

template <typename L, typename R, typename O> inline bool add(L l, R r, O *o) {
  return __builtin_add_overflow(l, r, o);
}
template <typename L, typename R, typename O> inline bool sub(L l, R r, O *o) {
  return __builtin_sub_overflow(l, r, o);
}
template <typename L, typename R, typename O> inline bool mul(L l, R r, O *o) {
  return __builtin_mul_overflow(l, r, o);
}

template <typename T, ZuExact<float, T, int> = 0> inline T nan() {
  return __builtin_nanf("0");
}
template <typename T, ZuExact<double, T, int> = 0> inline T nan() {
  return __builtin_nan("0");
}
template <typename T, ZuExact<long double, T, int> = 0> inline T nan() {
  return __builtin_nanl("0");
}

} // namespace ZuIntrin

template <typename T, unsigned Size = sizeof(T)> struct ZuFP;

template <typename T> struct ZuFP__;
template <> struct ZuFP__<float> {
  inline static float floor_(float f) { return floorf(f); }
  inline static float log10_(float f) { return log10f(f); }
  inline static float frexp_(float f, int *n) { return frexpf(f, n); }
  inline static float ldexp_(float f, int n) { return ldexpf(f, n); }
  inline static float fabs_(float f) { return fabsf(f); }
};
template <> struct ZuFP__<double> {
  inline static double floor_(double f) { return floor(f); }
  inline static double log10_(double f) { return log10(f); }
  inline static double frexp_(double f, int *n) { return frexp(f, n); }
  inline static double ldexp_(double f, int n) { return ldexp(f, n); }
  inline static double fabs_(double f) { return fabs(f); }
};
template <> struct ZuFP__<long double> {
  inline static long double floor_(long double f) { return floorl(f); }
  inline static long double log10_(long double f) { return log10l(f); }
  inline static long double frexp_(long double f, int *n) {
    return frexpl(f, n);
  }
  inline static long double ldexp_(long double f, int n) {
    return ldexpl(f, n);
  }
  inline static long double fabs_(long double f) { return fabsl(f); }
};

template <class FP, typename T> struct ZuFP_ : public ZuFP__<T> {
  inline static constexpr T inf() {
    return static_cast<T>(

      (__builtin_inff())

    );
  }
  inline static constexpr bool inf(T v) { return v == inf(); }
  inline static T epsilon(T v) {
    if (__builtin_expect(!!(FP::nan(v)), 0)) return v;
    if (__builtin_expect(!!(FP::inf(v)), 0)) return v;
    if (__builtin_expect(!!(FP::inf(-v)), 0)) return -v;
    if (v == static_cast<T>(0)) return v;
    return FP::epsilon_(v);
  }
};

template <typename T> struct ZuFP<T, 2U> : public ZuFP_<ZuFP<T, 2U>, T> {
  enum { Bits = 10, MinDigits = 4, MaxDigits = 4 };
  inline static T nan() {
    static const uint16_t i = ~(uint16_t)0;
    const T *__attribute__((__may_alias__)) i_ =
      reinterpret_cast<const T *>(&i);
    return *i_;
  }
  inline static constexpr bool nan(T v) {
    return isnan(static_cast<double>(v));
  }
  inline static T epsilon_(T v) {
    v = ZuFP::fabs_(v);
    T b = v;
    uint16_t *__attribute__((__may_alias__)) v_ =
      reinterpret_cast<uint16_t *>(&v);
    *v_ += 5;
    return v - b;
  }
};
template <typename T> struct ZuFP<T, 4U> : public ZuFP_<ZuFP<T, 4U>, T> {
  enum { Bits = 23, MinDigits = 7, MaxDigits = 8 };

  inline static constexpr T nan() { return ZuIntrin::nan<float>(); }
  inline static constexpr bool nan(T v) {
    return isnan(static_cast<double>(v));
  }
  inline static T epsilon_(T v) {
    v = ZuFP::fabs_(v);
    T b = v;
    uint32_t *__attribute__((__may_alias__)) v_ =
      reinterpret_cast<uint32_t *>(&v);
    *v_ += 5;
    return v - b;
  }
};
template <typename T> struct ZuFP<T, 8U> : public ZuFP_<ZuFP<T, 8U>, T> {
  enum { Bits = 52, MinDigits = 16, MaxDigits = 16 };

  inline static constexpr T nan() { return ZuIntrin::nan<double>(); }
  inline static constexpr bool nan(T v) {
    return isnan(static_cast<double>(v));
  }
  inline static T epsilon_(T v) {
    v = ZuFP::fabs_(v);
    T b = v;
    uint64_t *__attribute__((__may_alias__)) v_ =
      reinterpret_cast<uint64_t *>(&v);
    *v_ += 5;
    return v - b;
  }
};
template <class ZuFP, typename T> struct ZuFP_64 : public ZuFP_<ZuFP, T> {
  enum { Bits = 64, MinDigits = 20, MaxDigits = 20 };

  struct I_ {
    uint64_t mantissa;
    uint16_t exponent;
    inline void inc() {
      uint64_t prev = mantissa;
      if (__builtin_expect(!!((mantissa += 5) < prev), 0))
	(mantissa |= (1ULL << 63U)), ++exponent;
    }
  };

  inline static T epsilon_(T v) {
    v = ZuFP::fabs_(v);
    T b = v;
    I_ *__attribute__((__may_alias__)) v_ = reinterpret_cast<I_ *>(&v);
    v_->inc();
    return v - b;
  }
};
template <typename T> struct ZuFP<T, 12U> : public ZuFP_64<ZuFP<T, 12U>, T> {
  inline static constexpr T nan() { return ZuIntrin::nan<long double>(); }
  inline static constexpr bool nan(T v) {
    return isnan(static_cast<double>(v));
  }
};
template <typename T> struct ZuFP<T, 16U> : public ZuFP_64<ZuFP<T, 16U>, T> {
  inline static constexpr T nan() { return ZuIntrin::nan<long double>(); }
  inline static constexpr bool nan(T v) {
    return isnan(static_cast<double>(v));
  }
};

template <typename T, typename = void>
struct ZuTraits_Composite : public ZuFalse { };
template <typename T>
struct ZuTraits_Composite<T, decltype((int T::*){}, void())> :
  public ZuTrue { };

template <typename T, typename = void>
struct ZuTraits_Empty : public ZuFalse { };
template <typename T>
struct ZuTraits_Empty<T, decltype(sizeof(T), (int T::*){}, void())> :
  public ZuBool<__is_empty(T)> { };

template <typename T> struct ZuTraits_Enum : public ZuBool<__is_enum(T)> { };

template <typename T, typename = void>
struct ZuTraits_POD : public ZuBool<!ZuTraits_Composite<T>{}> { };
template <typename T>
struct ZuTraits_POD<T, decltype(sizeof(T), void())> :
  public ZuBool<__is_standard_layout(T) && __is_trivial(T)> { };

template <typename, typename Iterator> struct ZuBaseTraits_Array___ {
  enum { IsSpan = 0 };
  using Elem = ZuDecay<decltype(*ZuDeclVal<const Iterator &>())>;
};

template <typename U, typename Elem_> struct ZuBaseTraits_Array___<U, Elem_ *> {
  enum { IsSpan = 1 };
  using Elem = ZuDecay<Elem_>;
  static auto data(U &v) { return &v[0]; }
  static auto data(const U &v) { return &v[0]; }
};

template <typename U, typename = void> struct ZuBaseTraits_Array__ {
  enum { IsArray = 0, IsSpan = 0 };
  using Elem = void;
};

template <typename U>
struct ZuBaseTraits_Array__<
  U,
  decltype(ZuDeclVal<const U &>().end() - ZuDeclVal<const U &>().begin(), void())> :
  public ZuBaseTraits_Array___<U, decltype(ZuDeclVal<const U &>().begin())> {
  enum { IsArray = 1 };
  using Elem = ZuDecay<decltype(*(ZuDeclVal<const U &>().begin()))>;
  static unsigned length(const U &v) { return v.end() - v.begin(); }
};

template <typename U, bool = ZuTraits_Composite<U>{}>
struct ZuBaseTraits_Array_ { };

template <typename Elem_> struct ZuBaseTraits_Array_<Elem_ *, false> {
  enum { IsArray = 0, IsSpan = 0 };
  using Elem = ZuDecay<Elem_>;
};
template <typename U>
struct ZuBaseTraits_Array_<U, true> : public ZuBaseTraits_Array__<U> { };

template <typename U, typename = void> struct ZuBaseTraits_Array {
  enum { IsArray = 0, IsSpan = 0 };
  using Elem = void;
};

template <typename U>
struct ZuBaseTraits_Array<
  U, decltype(ZuDeclVal<const ZuDecay<U> &>()[0], void())> :
  public ZuBaseTraits_Array_<ZuDecay<U>> { };

template <typename T> struct ZuBaseTraits : public ZuBaseTraits_Array<T> {
  enum { IsComposite = ZuTraits_Composite<T>{} };
  enum { IsEmpty = ZuTraits_Empty<T>{} };
  enum { IsEnum = ZuTraits_Enum<T>{} };
  enum { IsPOD = ZuTraits_POD<T>{} };
  enum {
    IsReference = 0,
    IsRValueRef = 0,
    IsPointer = 0,
    IsPrimitive = IsEnum,
    IsReal = IsEnum,
    IsSigned = IsEnum,
    IsIntegral = IsEnum,
    IsFloatingPoint = 0,
    IsString = 0,
    IsCString = 0,
    IsWString = 0,
    IsVoid = 0,
    IsBool = 0
  };
};

void ZuTraitsType(...);
template <typename T_, typename Traits> struct ZuDefaultTraits_ {
  using T = Traits;
};
template <typename T_> struct ZuDefaultTraits_<T_, void> {
  using T = ZuBaseTraits<T_>;
};
template <typename T>
using ZuDefaultTraits =
  typename ZuDefaultTraits_<T, decltype(ZuTraitsType(ZuDeclVal<T *>()))>::T;

template <typename T> struct ZuTraits : public ZuDefaultTraits<T> { };

template <typename T> struct ZuTraits<const T> : public ZuTraits<T> { };
template <typename T> struct ZuTraits<volatile T> : public ZuTraits<T> { };
template <typename T>
struct ZuTraits<const volatile T> : public ZuTraits<T> { };

template <typename T> struct ZuTraits_Real : public ZuBaseTraits<T> {
  enum { IsPrimitive = 1, IsReal = 1, IsPOD = 1 };
};

template <typename T> struct ZuTraits_Signed : public ZuTraits_Real<T> {
  enum { IsIntegral = 1, IsSigned = 1 };
};

template <typename T> struct ZuTraits_Unsigned : public ZuTraits_Real<T> {
  enum { IsIntegral = 1 };
};

template <> struct ZuTraits<bool> : public ZuTraits_Unsigned<bool> {
  enum { IsBool = 1 };
};

template <> struct ZuTraits<char> : public ZuTraits_Signed<char> { };

template <>
struct ZuTraits<signed char> : public ZuTraits_Signed<signed char> { };
template <>
struct ZuTraits<unsigned char> : public ZuTraits_Unsigned<unsigned char> { };

template <> struct ZuTraits<wchar_t> : public ZuTraits_Signed<wchar_t> { };

template <> struct ZuTraits<short> : public ZuTraits_Signed<short> { };
template <>
struct ZuTraits<unsigned short> : public ZuTraits_Unsigned<unsigned short> { };
template <> struct ZuTraits<int> : public ZuTraits_Signed<int> { };
template <>
struct ZuTraits<unsigned int> : public ZuTraits_Unsigned<unsigned int> { };
template <> struct ZuTraits<long> : public ZuTraits_Signed<long> { };
template <>
struct ZuTraits<unsigned long> : public ZuTraits_Unsigned<unsigned long> { };
template <> struct ZuTraits<long long> : public ZuTraits_Signed<long long> { };
template <>
struct ZuTraits<unsigned long long> :
  public ZuTraits_Unsigned<unsigned long long> { };
template <>
struct ZuTraits<__int128_t> : public ZuTraits_Signed<__int128_t> { };
template <>
struct ZuTraits<__uint128_t> : public ZuTraits_Unsigned<__uint128_t> { };

template <typename T>
struct ZuTraits_Floating : public ZuTraits_Real<T>, public ZuFP<T> {
  enum { IsSigned = 1, IsFloatingPoint = 1 };
};

template <> struct ZuTraits<float> : public ZuTraits_Floating<float> { };
template <> struct ZuTraits<double> : public ZuTraits_Floating<double> { };
template <>
struct ZuTraits<long double> : public ZuTraits_Floating<long double> { };

template <typename T> struct ZuTraits<T &> : public ZuTraits<T> {
  enum { IsReference = 1 };
};

template <typename T> struct ZuTraits<const T &> : public ZuTraits<T &> { };
template <typename T> struct ZuTraits<volatile T &> : public ZuTraits<T &> { };
template <typename T>
struct ZuTraits<const volatile T &> : public ZuTraits<T &> { };

template <typename T> struct ZuTraits<T &&> : public ZuTraits<T> {
  enum { IsRValueRef = 1 };
};

template <typename T, typename Elem_>
struct ZuTraits_Pointer : public ZuBaseTraits<T> {
  enum { IsPrimitive = 1, IsPOD = 1, IsPointer = 1 };
  using Elem = Elem_;
};

template <typename T>
struct ZuTraits<T *> : public ZuTraits_Pointer<T *, T> { };
template <typename T>
struct ZuTraits<const T *> : public ZuTraits_Pointer<const T *, const T> { };
template <typename T>
struct ZuTraits<volatile T *> :
  public ZuTraits_Pointer<volatile T *, volatile T> { };
template <typename T>
struct ZuTraits<const volatile T *> :
  public ZuTraits_Pointer<const volatile T *, const volatile T> { };

template <typename T, typename Elem_>
struct ZuTraits_PArray : public ZuBaseTraits<T> {
  using Elem = Elem_;
  enum {
    IsPrimitive = 1,
    IsPOD = ZuTraits<Elem>::IsPOD,
    IsArray = 1,
    IsSpan = 1
  };
  template <typename U = T> static ZuMutable<U, Elem *> data(U &a) {
    return &a[0];
  }
  static const Elem *data(const T &a) { return &a[0]; }
  static unsigned length(const T &a) { return sizeof(a) / sizeof(a[0]); }
};

template <typename T> struct ZuTraits<T[]> : public ZuTraits_PArray<T[], T> { };
template <typename T>
struct ZuTraits<const T[]> : public ZuTraits_PArray<const T[], const T> { };
template <typename T>
struct ZuTraits<volatile T[]> :
  public ZuTraits_PArray<volatile T[], volatile T> { };
template <typename T>
struct ZuTraits<const volatile T[]> :
  public ZuTraits_PArray<const volatile T[], const volatile T> { };

template <typename T, int N>
struct ZuTraits<T[N]> : public ZuTraits_PArray<T[N], T> { };
template <typename T, int N>
struct ZuTraits<const T[N]> : public ZuTraits_PArray<const T[N], const T> { };
template <typename T, int N>
struct ZuTraits<volatile T[N]> :
  public ZuTraits_PArray<volatile T[N], volatile T> { };
template <typename T, int N>
struct ZuTraits<const volatile T[N]> :
  public ZuTraits_PArray<const volatile T[N], const volatile T> { };

template <typename T, int N>
struct ZuTraits<T (&)[N]> : public ZuTraits_PArray<T[N], T> { };
template <typename T, int N>
struct ZuTraits<const T (&)[N]> :
  public ZuTraits_PArray<const T[N], const T> { };
template <typename T, int N>
struct ZuTraits<volatile T (&)[N]> :
  public ZuTraits_PArray<volatile T[N], volatile T> { };
template <typename T, int N>
struct ZuTraits<const volatile T (&)[N]> :
  public ZuTraits_PArray<const volatile T[N], const volatile T> { };

template <class Base> struct ZuTraits_CString : public Base {
  enum { IsCString = 1, IsString = 1 };
  static const char *data(const char *s) { return s; }
  static unsigned length(const char *s) { return s ? strlen(s) : 0; }
};

template <>
struct ZuTraits<char *> :
  public ZuTraits_CString<ZuTraits_Pointer<char *, char>> { };
template <>
struct ZuTraits<const char *> :
  public ZuTraits_CString<ZuTraits_Pointer<const char *, const char>> { };
template <>
struct ZuTraits<volatile char *> :
  public ZuTraits_CString<ZuTraits_Pointer<volatile char *, volatile char>> { };
template <>
struct ZuTraits<const volatile char *> :
  public ZuTraits_CString<
    ZuTraits_Pointer<const volatile char *, const volatile char>> { };

template <>
struct ZuTraits<char[]> :
  public ZuTraits_CString<ZuTraits_PArray<char[], char>> { };
template <>
struct ZuTraits<const char[]> :
  public ZuTraits_CString<ZuTraits_PArray<const char[], const char>> { };
template <>
struct ZuTraits<volatile char[]> :
  public ZuTraits_CString<ZuTraits_PArray<volatile char[], volatile char>> { };
template <>
struct ZuTraits<const volatile char[]> :
  public ZuTraits_CString<
    ZuTraits_PArray<const volatile char[], const volatile char>> { };

template <int N>
struct ZuTraits<char[N]> :
  public ZuTraits_CString<ZuTraits_PArray<char[N], char>> { };
template <int N>
struct ZuTraits<const char[N]> :
  public ZuTraits_CString<ZuTraits_PArray<const char[N], const char>> { };
template <int N>
struct ZuTraits<volatile char[N]> :
  public ZuTraits_CString<ZuTraits_PArray<volatile char[N], volatile char>> { };
template <int N>
struct ZuTraits<const volatile char[N]> :
  public ZuTraits_CString<
    ZuTraits_PArray<const volatile char[N], const volatile char>> { };

template <int N>
struct ZuTraits<char (&)[N]> :
  public ZuTraits_CString<ZuTraits_PArray<char[N], char>> { };
template <int N>
struct ZuTraits<const char (&)[N]> :
  public ZuTraits_CString<ZuTraits_PArray<const char[N], const char>> { };
template <int N>
struct ZuTraits<volatile char (&)[N]> :
  public ZuTraits_CString<ZuTraits_PArray<volatile char[N], volatile char>> { };
template <int N>
struct ZuTraits<const volatile char (&)[N]> :
  public ZuTraits_CString<
    ZuTraits_PArray<const volatile char[N], const volatile char>> { };
template <class Base> struct ZuTraits_WString : public Base {
  enum { IsCString = 1, IsString = 1, IsWString = 1 };
  static const wchar_t *data(const wchar_t *s) { return s; }
  static unsigned length(const wchar_t *s) { return s ? wcslen(s) : 0; }
};

template <>
struct ZuTraits<wchar_t *> :
  public ZuTraits_WString<ZuTraits_Pointer<wchar_t *, wchar_t>> { };
template <>
struct ZuTraits<const wchar_t *> :
  public ZuTraits_WString<ZuTraits_Pointer<const wchar_t *, const wchar_t>> { };
template <>
struct ZuTraits<volatile wchar_t *> :
  public ZuTraits_WString<
    ZuTraits_Pointer<volatile wchar_t *, volatile wchar_t>> { };
template <>
struct ZuTraits<const volatile wchar_t *> :
  public ZuTraits_WString<
    ZuTraits_Pointer<const volatile wchar_t *, const volatile wchar_t>> { };

template <>
struct ZuTraits<wchar_t[]> :
  public ZuTraits_WString<ZuTraits_PArray<wchar_t[], wchar_t>> { };
template <>
struct ZuTraits<const wchar_t[]> :
  public ZuTraits_WString<ZuTraits_PArray<const wchar_t[], const wchar_t>> { };
template <>
struct ZuTraits<volatile wchar_t[]> :
  public ZuTraits_WString<
    ZuTraits_PArray<volatile wchar_t[], volatile wchar_t>> { };
template <>
struct ZuTraits<const volatile wchar_t[]> :
  public ZuTraits_WString<
    ZuTraits_PArray<const volatile wchar_t[], const volatile wchar_t>> { };

template <int N>
struct ZuTraits<wchar_t[N]> :
  public ZuTraits_WString<ZuTraits_PArray<wchar_t[N], wchar_t>> { };
template <int N>
struct ZuTraits<const wchar_t[N]> :
  public ZuTraits_WString<ZuTraits_PArray<const wchar_t[N], const wchar_t>> { };
template <int N>
struct ZuTraits<volatile wchar_t[N]> :
  public ZuTraits_WString<
    ZuTraits_PArray<volatile wchar_t[N], volatile wchar_t>> { };
template <int N>
struct ZuTraits<const volatile wchar_t[N]> :
  public ZuTraits_WString<
    ZuTraits_PArray<const volatile wchar_t[N], const volatile wchar_t>> { };

template <int N>
struct ZuTraits<wchar_t (&)[N]> :
  public ZuTraits_WString<ZuTraits_PArray<wchar_t[N], wchar_t>> { };
template <int N>
struct ZuTraits<const wchar_t (&)[N]> :
  public ZuTraits_WString<ZuTraits_PArray<const wchar_t[N], const wchar_t>> { };
template <int N>
struct ZuTraits<volatile wchar_t (&)[N]> :
  public ZuTraits_WString<
    ZuTraits_PArray<volatile wchar_t[N], volatile wchar_t>> { };
template <int N>
struct ZuTraits<const volatile wchar_t (&)[N]> :
  public ZuTraits_WString<
    ZuTraits_PArray<const volatile wchar_t[N], const volatile wchar_t>> { };

template <> struct ZuTraits<void> : public ZuBaseTraits<void> {
  enum { IsPrimitive = 1, IsPOD = 1, IsVoid = 1 };
};

template <typename U, typename R = void>
using ZuMatchArray = ZuIfT<ZuTraits<U>::IsArray, R>;
template <typename U, typename R = void>
using ZuNotArray = ZuIfT<!ZuTraits<U>::IsArray, R>;
template <typename U, typename R = void>
using ZuMatchSpan = ZuIfT<ZuTraits<U>::IsSpan, R>;
template <typename U, typename R = void>
using ZuNotSpan = ZuIfT<!ZuTraits<U>::IsSpan, R>;
template <typename U, typename R = void>
using ZuMatchComposite = ZuIfT<ZuTraits<U>::IsComposite, R>;
template <typename U, typename R = void>
using ZuNotComposite = ZuIfT<!ZuTraits<U>::IsComposite, R>;
template <typename U, typename R = void>
using ZuMatchEmpty = ZuIfT<ZuTraits<U>::IsEmpty, R>;
template <typename U, typename R = void>
using ZuNotEmpty = ZuIfT<!ZuTraits<U>::IsEmpty, R>;
template <typename U, typename R = void>
using ZuMatchEnum = ZuIfT<ZuTraits<U>::IsEnum, R>;
template <typename U, typename R = void>
using ZuNotEnum = ZuIfT<!ZuTraits<U>::IsEnum, R>;
template <typename U, typename R = void>
using ZuMatchPOD = ZuIfT<ZuTraits<U>::IsPOD, R>;
template <typename U, typename R = void>
using ZuNotPOD = ZuIfT<!ZuTraits<U>::IsPOD, R>;
template <typename U, typename R = void>
using ZuMatchReference = ZuIfT<ZuTraits<U>::IsReference, R>;
template <typename U, typename R = void>
using ZuNotReference = ZuIfT<!ZuTraits<U>::IsReference, R>;
template <typename U, typename R = void>
using ZuMatchRValueRef = ZuIfT<ZuTraits<U>::IsRValueRef, R>;
template <typename U, typename R = void>
using ZuNotRValueRef = ZuIfT<!ZuTraits<U>::IsRValueRef, R>;
template <typename U, typename R = void>
using ZuMatchPointer = ZuIfT<ZuTraits<U>::IsPointer, R>;
template <typename U, typename R = void>
using ZuNotPointer = ZuIfT<!ZuTraits<U>::IsPointer, R>;
template <typename U, typename R = void>
using ZuMatchPrimitive = ZuIfT<ZuTraits<U>::IsPrimitive, R>;
template <typename U, typename R = void>
using ZuNotPrimitive = ZuIfT<!ZuTraits<U>::IsPrimitive, R>;
template <typename U, typename R = void>
using ZuMatchReal = ZuIfT<ZuTraits<U>::IsReal, R>;
template <typename U, typename R = void>
using ZuNotReal = ZuIfT<!ZuTraits<U>::IsReal, R>;
template <typename U, typename R = void>
using ZuMatchSigned = ZuIfT<ZuTraits<U>::IsSigned, R>;
template <typename U, typename R = void>
using ZuNotSigned = ZuIfT<!ZuTraits<U>::IsSigned, R>;
template <typename U, typename R = void>
using ZuMatchIntegral = ZuIfT<ZuTraits<U>::IsIntegral, R>;
template <typename U, typename R = void>
using ZuNotIntegral = ZuIfT<!ZuTraits<U>::IsIntegral, R>;
template <typename U, typename R = void>
using ZuMatchFloatingPoint = ZuIfT<ZuTraits<U>::IsFloatingPoint, R>;
template <typename U, typename R = void>
using ZuNotFloatingPoint = ZuIfT<!ZuTraits<U>::IsFloatingPoint, R>;
template <typename U, typename R = void>
using ZuMatchString = ZuIfT<ZuTraits<U>::IsString, R>;
template <typename U, typename R = void>
using ZuNotString = ZuIfT<!ZuTraits<U>::IsString, R>;
template <typename U, typename R = void>
using ZuMatchCString = ZuIfT<ZuTraits<U>::IsCString, R>;
template <typename U, typename R = void>
using ZuNotCString = ZuIfT<!ZuTraits<U>::IsCString, R>;
template <typename U, typename R = void>
using ZuMatchWString = ZuIfT<ZuTraits<U>::IsWString, R>;
template <typename U, typename R = void>
using ZuNotWString = ZuIfT<!ZuTraits<U>::IsWString, R>;
template <typename U, typename R = void>
using ZuMatchVoid = ZuIfT<ZuTraits<U>::IsVoid, R>;
template <typename U, typename R = void>
using ZuNotVoid = ZuIfT<!ZuTraits<U>::IsVoid, R>;
template <typename U, typename R = void>
using ZuMatchBool = ZuIfT<ZuTraits<U>::IsBool, R>;
template <typename U, typename R = void>
using ZuNotBool = ZuIfT<!ZuTraits<U>::IsBool, R>;

template <typename U, typename R = void>
using ZuMatchCharString =
  ZuIfT<ZuTraits<U>::IsString && !ZuTraits<U>::IsWString, R>;

template <typename Wrapper, typename Under>
struct ZuWrapTraits : public ZuTraits<Under> {
  enum { IsPrimitive = 0, IsPOD = 0 };
  using Elem = typename ZuTraits<Under>::Elem;
  template <typename U = Under>
  static ZuIfT<ZuTraits<U>::IsSpan && !ZuIsConst<U>{}, Elem *>
  data(Wrapper &v) {
    return ZuTraits<U>::data(v.get());
  }
  template <typename U = Under>
  static ZuMatchSpan<U, const Elem *> data(const Wrapper &v) {
    return ZuTraits<U>::data(v.get());
  }
  template <typename U = Under>
  static ZuMatchArray<U, unsigned> length(const Wrapper &v) {
    return ZuTraits<U>::length(v.get());
  }
};

template <typename T, T V>
struct ZuTraits<ZuConstant<T, V>> :
  public ZuWrapTraits<ZuConstant<T, V>, T> { };

template <typename T, typename Char>
struct ZuStdStringTraits_ : public ZuBaseTraits<T> {
  enum { IsString = 1 };
  using Elem = Char;
  template <typename U = T> static ZuMutable<U, Char *> data(T &s) {
    return s.data();
  }
  static const Char *data(const T &s) { return s.data(); }
  static unsigned length(const T &s) { return s.length(); }
};
template <typename T_>
struct ZuStdStringTraits : public ZuStdStringTraits_<T_, char> { };
template <typename T_>
struct ZuStdWStringTraits : public ZuStdStringTraits_<T_, wchar_t> {
  enum { IsWString = 1 };
};

template <typename T, typename Elem_>
struct ZuStdArrayTraits_ : public ZuBaseTraits<T> {
  using Elem = Elem_;
  enum { IsArray = 1 };
  template <typename U = T> static ZuMutable<U, Elem *> data(T &a) {
    return a.data();
  }
  static const Elem *data(const T &a) { return a.data(); }
  static unsigned length(const T &a) { return a.size(); }
};
template <typename T, typename Elem>
struct ZuStdVectorTraits : public ZuStdArrayTraits_<T, Elem> { };
template <typename T, typename Elem, size_t N>
struct ZuStdArrayTraits : public ZuStdArrayTraits_<T, Elem> { };

namespace std {
template <typename, class> class vector;
template <typename, size_t> class array;
}
template <typename Traits, typename Alloc>
struct ZuTraits<std::basic_string<char, Traits, Alloc>> :
  public ZuStdStringTraits<std::basic_string<char, Traits, Alloc>> { };
template <typename Traits, typename Alloc>
struct ZuTraits<std::basic_string<wchar_t, Traits, Alloc>> :
  public ZuStdWStringTraits<std::basic_string<wchar_t, Traits, Alloc>> { };
template <typename T, typename Alloc>
struct ZuTraits<std::vector<T, Alloc>> :
  public ZuStdVectorTraits<std::vector<T, Alloc>, T> { };
template <typename T, size_t N>
struct ZuTraits<std::array<T, N>> :
  public ZuStdArrayTraits<std::array<T, N>, T, N> { };

namespace boost {
template <typename, typename> class basic_string_ref;
template <typename, size_t> class array;
}
template <typename Traits>
struct ZuTraits<boost::basic_string_ref<char, Traits>> :
  public ZuStdStringTraits<boost::basic_string_ref<char, Traits>> { };
template <typename Traits>
struct ZuTraits<boost::basic_string_ref<wchar_t, Traits>> :
  public ZuStdWStringTraits<boost::basic_string_ref<wchar_t, Traits>> { };
template <typename T, size_t N>
struct ZuTraits<boost::array<T, N>> :
  public ZuStdArrayTraits<boost::array<T, N>, T, N> { };

namespace std {
template <typename> class initializer_list;
}
template <typename Elem_>
struct ZuTraits<std::initializer_list<Elem_>> :
  public ZuBaseTraits<std::initializer_list<Elem_>> {
  enum { IsArray = 1 };
  using Elem = Elem_;

private:
  using T = std::initializer_list<Elem_>;

public:
  static const Elem *data(const T &a) { return a.begin(); }
  static unsigned length(const T &a) { return a.size(); }
};

template <typename T, bool = ZuTraits<T>::IsString> struct ZuCmp_;

template <typename T> struct ZuCmp_Cannot;

template <typename T, int Size, bool Signed> struct ZuCmp_IntSentinel;
template <typename T> struct ZuCmp_IntSentinel<T, 1, false> {
  static constexpr T minimum() { return static_cast<T>(0); }
  static constexpr T maximum() { return static_cast<T>(0xfe); }
  static constexpr T null() { return static_cast<T>(0xff); }
};
template <typename T> struct ZuCmp_IntSentinel<T, 1, true> {
  static constexpr T minimum() { return static_cast<T>(-0x7f); }
  static constexpr T maximum() { return static_cast<T>(0x7f); }
  static constexpr T null() { return static_cast<T>(-0x80); }
};
template <typename T> struct ZuCmp_IntSentinel<T, 2, false> {
  static constexpr T minimum() { return static_cast<T>(0); }
  static constexpr T maximum() { return static_cast<T>(0xfffe); }
  static constexpr T null() { return static_cast<T>(0xffff); }
};
template <typename T> struct ZuCmp_IntSentinel<T, 2, true> {
  static constexpr T minimum() { return static_cast<T>(-0x7fff); }
  static constexpr T maximum() { return static_cast<T>(0x7fff); }
  static constexpr T null() { return static_cast<T>(-0x8000); }
};
template <typename T> struct ZuCmp_IntSentinel<T, 4, false> {
  static constexpr T minimum() { return static_cast<T>(0); }
  static constexpr T maximum() { return null() - 1; }
  static constexpr T null() { return ~static_cast<T>(0); }
};
template <typename T> struct ZuCmp_IntSentinel<T, 4, true> {
  static constexpr T minimum() { return static_cast<T>(-0x7fffffff); }
  static constexpr T maximum() { return static_cast<T>(0x7fffffff); }
  static constexpr T null() { return static_cast<T>(-0x80000000); }
};
template <typename T> struct ZuCmp_IntSentinel<T, 8, false> {
  static constexpr T minimum() { return static_cast<T>(0); }
  static constexpr T maximum() { return null() - 1; }
  static constexpr T null() { return ~static_cast<T>(0); }
};
template <typename T> struct ZuCmp_IntSentinel<T, 8, true> {
  static constexpr T minimum() { return static_cast<T>(-0x7fffffffffffffffLL); }
  static constexpr T maximum() { return static_cast<T>(0x7fffffffffffffffLL); }
  static constexpr T null() { return static_cast<T>(-0x8000000000000000LL); }
};
template <typename T> struct ZuCmp_IntSentinel<T, 16, false> {
  static constexpr T minimum() { return static_cast<T>(0); }
  static constexpr T maximum() { return null() - 1; }
  static constexpr T null() { return ~static_cast<T>(0); }
};
template <typename T> struct ZuCmp_IntSentinel<T, 16, true> {
  static constexpr T minimum() { return null() + 1; }
  static constexpr T maximum() { return ~null(); }
  static constexpr T null() { return (static_cast<T>(1)) << 127; }
};

template <typename T, bool isSmallInt>
struct ZuCmp_Integral :
  public ZuCmp_IntSentinel<T, sizeof(T), ZuTraits<T>::IsSigned> {
  using Base = ZuCmp_IntSentinel<T, sizeof(T), ZuTraits<T>::IsSigned>;
  using Base::minimum;
  using Base::maximum;
  using Base::null;
  static constexpr int cmp(T l, T r) { return (l > r) - (l < r); }
  static constexpr bool less(T l, T r) { return l < r; }
  static constexpr bool equals(T l, T r) { return l == r; }
  static constexpr bool null(T i) { return i == null(); }
  static constexpr T epsilon(T f) { return 0; }
};

template <typename T>
struct ZuCmp_Integral<T, true> :
  public ZuCmp_IntSentinel<T, sizeof(T), ZuTraits<T>::IsSigned> {
  using Base = ZuCmp_IntSentinel<T, sizeof(T), ZuTraits<T>::IsSigned>;
  using Base::minimum;
  using Base::maximum;
  using Base::null;
  static constexpr int cmp(T l, T r) {
    return static_cast<int>(l) - static_cast<int>(r);
  }
  static constexpr bool less(T l, T r) { return l < r; }
  static constexpr bool equals(T l, T r) { return l == r; }
  static constexpr bool null(T i) { return i == null(); }
  static constexpr T epsilon(T) { return 0; }
};

template <typename T> struct ZuCmp_Floating {
  static constexpr int cmp(T l, T r) { return (l > r) - (l < r); }
  static constexpr bool less(T l, T r) { return l < r; }
  static constexpr bool equals(T l, T r) { return l == r; }
  static constexpr T null() { return ZuTraits<T>::nan(); }
  static constexpr bool null(T f) { return ZuTraits<T>::nan(f); }
  static T inf() { return ZuTraits<T>::inf(); }
  static bool inf(T f) { return ZuTraits<T>::inf(f); }
  static T epsilon(T f) { return ZuTraits<T>::epsilon(f); }
};

template <typename T, bool isIntegral> struct ZuCmp_Real;
template <typename T>
struct ZuCmp_Real<T, false> : public ZuCmp_Floating<T> { };
template <typename T>
struct ZuCmp_Real<T, true> :
  public ZuCmp_Integral<T, sizeof(T) < sizeof(int)> { };

template <typename T, bool IsReal, bool IsVoid>
struct ZuCmp_Primitive : public ZuCmp_Cannot<T> { };
template <typename T>
struct ZuCmp_Primitive<T, true, false> :
  public ZuCmp_Real<T, ZuTraits<T>::IsIntegral> { };

template <typename, typename, typename = void>
struct ZuCmp_Can_starship : public ZuFalse { };
template <typename P1, typename P2>
struct ZuCmp_Can_starship<
  P1, P2,
  decltype((ZuDeclVal<const P1 &>() <=> ZuDeclVal<const P2 &>()), void())> :
  public ZuTrue { };

template <typename> struct ZuCmp_Can_cmp_;
template <> struct ZuCmp_Can_cmp_<int> {
  using T = void;
};
template <typename, typename, typename = void>
struct ZuCmp_Can_cmp : public ZuFalse { };
template <typename P1, typename P2>
struct ZuCmp_Can_cmp<
  P1, P2,
  typename ZuCmp_Can_cmp_<
    decltype(ZuDeclVal<const P1 &>().cmp(ZuDeclVal<const P2 &>()))>::T> :
  public ZuTrue { };

template <typename T, typename = void> struct ZuCmp_NullFn {
  template <typename P> static bool null(const P &p) { return !p; }
  static T null() { return T{}; }
};
template <typename T>
struct ZuCmp_NullFn<T, decltype(T{ZuDeclVal<const T &>()}, void())> {
  template <typename P> static bool null(const P &p) { return !p; }
  static const T &null() {
    static T v;
    return v;
  }
};

template <typename T> struct ZuCmp_NonPrimitive : public ZuCmp_NullFn<T> {
  template <typename L, typename R>
  static constexpr ZuIfT<ZuCmp_Can_cmp<L, R>{}, int>
  cmp(const L &l, const R &r) {
    return l.cmp(r);
  }
  template <typename L, typename R>
  static constexpr ZuIfT<
    ZuCmp_Can_starship<L, R>{} && !ZuCmp_Can_cmp<L, R>{}, int>
  cmp(const L &l, const R &r) {
    auto v = l <=> r;
    return (v > 0) - (v < 0);
  }
  template <typename L, typename R>
  static constexpr ZuIfT<
    !ZuCmp_Can_cmp<L, R>{} && !ZuCmp_Can_starship<L, R>{}, int>
  cmp(const L &l, const R &r) {
    return (l > r) - (l < r);
  }
  template <typename L, typename R>
  static constexpr bool less(const L &l, const R &r) {
    return l < r;
  }
  template <typename L, typename R>
  static constexpr bool equals(const L &l, const R &r) {
    return l == r;
  }
};

template <typename T> struct ZuCmp_Pointer {
  using P = typename ZuTraits<T>::Elem;
  static int cmp(const P *l_, const P *r_) {
    auto l = reinterpret_cast<const uint8_t *>(l_);
    auto r = reinterpret_cast<const uint8_t *>(r_);
    return (l > r) - (l < r);
  }
  static bool less(const P *l, const P *r) { return l < r; }
  static bool equals(const P *l, const P *r) { return l == r; }
  static bool null(const P *p) { return !p; }
  static constexpr T null() { return nullptr; }
};

template <typename T, bool IsCString>
struct ZuCmp_PrimitivePointer : public ZuCmp_Cannot<T> { };

template <typename T>
struct ZuCmp_PrimitivePointer<T, false> : public ZuCmp_Pointer<T> { };

template <typename T, bool IsPrimitive, bool IsPointer> struct ZuCmp_NonString;

template <typename T>
struct ZuCmp_NonString<T, false, false> : public ZuCmp_NonPrimitive<T> { };

template <typename T>
struct ZuCmp_NonString<T, false, true> : public ZuCmp_Pointer<T> { };

template <typename T>
struct ZuCmp_NonString<T, true, false> :
  public ZuCmp_Primitive<T, ZuTraits<T>::IsReal, ZuTraits<T>::IsVoid> { };

template <typename T>
struct ZuCmp_NonString<T, true, true> :
  public ZuCmp_PrimitivePointer<T, ZuTraits<T>::IsCString> { };

template <
  typename T1, typename T2, bool T1IsCStringAndT2IsCString, bool T1IsString,
  bool T1IsWStringAndT2IsWString>
struct ZuCmp_StrCmp;

template <typename L, typename R, bool LIsString>
struct ZuCmp_StrCmp<L, R, 1, LIsString, 0> {
  static int cmp(const L &l_, const R &r_) {
    const char *l = ZuTraits<L>::data(l_);
    const char *r = ZuTraits<R>::data(r_);
    if (!l) {
      if (!r) return 0;
      l = "";
    } else {
      if (!r) r = "";
    }
    return strcmp(l, r);
  }
  static bool less(const L &l_, const R &r_) {
    const char *l = ZuTraits<L>::data(l_);
    const char *r = ZuTraits<R>::data(r_);
    if (!l) {
      if (!r) return false;
      l = "";
    } else {
      if (!r) return false;
    }
    return strcmp(l, r) < 0;
  }
  static bool equals(const L &l_, const R &r_) {
    const char *l = ZuTraits<L>::data(l_);
    const char *r = ZuTraits<R>::data(r_);
    if (!l) {
      if (!r) return true;
      l = "";
    } else {
      if (!r) r = "";
    }
    return !strcmp(l, r);
  }
};
template <typename L, typename R> struct ZuCmp_StrCmp<L, R, 0, 1, 0> {
  static int cmp(const L &l_, const R &r_) {
    const char *l = ZuTraits<L>::data(l_);
    const char *r = ZuTraits<R>::data(r_);
    if (!l) return -!!r;
    if (!r) return 1;
    int ln = ZuTraits<L>::length(l_), rn = ZuTraits<R>::length(r_);
    if (int i = strncmp(l, r, ln > rn ? rn : ln)) return i;
    return ln - rn;
  }
  static bool less(const L &l_, const R &r_) {
    const char *l = ZuTraits<L>::data(l_);
    const char *r = ZuTraits<R>::data(r_);
    if (!l) return !!r;
    if (!r) return false;
    int ln = ZuTraits<L>::length(l_), rn = ZuTraits<R>::length(r_);
    if (int i = strncmp(l, r, ln > rn ? rn : ln)) return i < 0;
    return ln < rn;
  }
  static bool equals(const L &l_, const R &r_) {
    const char *l = ZuTraits<L>::data(l_);
    const char *r = ZuTraits<R>::data(r_);
    if (!l) return !r;
    if (!r) return false;
    int ln = ZuTraits<L>::length(l_), rn = ZuTraits<R>::length(r_);
    if (ln != rn) return false;
    return !strncmp(l, r, ln);
  }
};
template <typename L, typename R, bool LIsString>
struct ZuCmp_StrCmp<L, R, 1, LIsString, 1> {
  static int cmp(const L &l_, const R &r_) {
    const wchar_t *l = ZuTraits<L>::data(l_);
    const wchar_t *r = ZuTraits<R>::data(r_);
    if (!l) return -!!r;
    if (!r) return 1;
    return wcscmp(l, r);
  }
  static bool less(const L &l_, const R &r_) {
    const wchar_t *l = ZuTraits<L>::data(l_);
    const wchar_t *r = ZuTraits<R>::data(r_);
    if (!l) return !!r;
    if (!r) return false;
    return wcscmp(l, r) < 0;
  }
  static bool equals(const L &l_, const R &r_) {
    const wchar_t *l = ZuTraits<L>::data(l_);
    const wchar_t *r = ZuTraits<R>::data(r_);
    if (!l) return !r;
    if (!r) return false;
    return !wcscmp(l, r);
  }
};
template <typename L, typename R> struct ZuCmp_StrCmp<L, R, 0, 1, 1> {
  static int cmp(const L &l_, const R &r_) {
    const wchar_t *l = ZuTraits<L>::data(l_);
    const wchar_t *r = ZuTraits<R>::data(r_);
    if (!l) return -!!r;
    if (!r) return 1;
    int ln = ZuTraits<L>::length(l_), rn = ZuTraits<R>::length(r_);
    if (int i = wcsncmp(l, r, ln > rn ? rn : ln)) return i;
    return ln - rn;
  }
  static bool less(const L &l_, const R &r_) {
    const wchar_t *l = ZuTraits<L>::data(l_);
    const wchar_t *r = ZuTraits<R>::data(r_);
    if (!l) return !!r;
    if (!r) return false;
    int ln = ZuTraits<L>::length(l_), rn = ZuTraits<R>::length(r_);
    if (int i = wcsncmp(l, r, ln > rn ? rn : ln)) return i < 0;
    return ln < rn;
  }
  static bool equals(const L &l_, const R &r_) {
    const wchar_t *l = ZuTraits<L>::data(l_);
    const wchar_t *r = ZuTraits<R>::data(r_);
    if (!l) return !r;
    if (!r) return false;
    int ln = ZuTraits<L>::length(l_), rn = ZuTraits<R>::length(l_);
    if (ln != rn) return false;
    return !wcsncmp(l, r, ln);
  }
};

template <typename T, bool IsCString, bool IsString, bool IsWString>
struct ZuCmp_String;

template <typename T, bool IsString> struct ZuCmp_String<T, 1, IsString, 0> {
  template <typename L, typename R>
  static ZuIfT<
    ZuTraits<L>::IsCString &&
      (ZuTraits<R>::IsCString || ZuTraits<R>::IsString) &&
      !ZuTraits<R>::IsWString,
    int>
  cmp(const L &l, const R &r) {
    return ZuCmp_StrCmp<
      L, R, ZuTraits<R>::IsCString, ZuTraits<L>::IsString, 0>::cmp(l, r);
  }
  template <typename L, typename R>
  static ZuIfT<
    ZuTraits<L>::IsCString &&
      (ZuTraits<R>::IsCString || ZuTraits<R>::IsString) &&
      !ZuTraits<R>::IsWString,
    bool>
  less(const L &l, const R &r) {
    return ZuCmp_StrCmp<
      L, R, ZuTraits<R>::IsCString, ZuTraits<L>::IsString, 0>::less(l, r);
  }
  template <typename L, typename R>
  static ZuIfT<
    ZuTraits<L>::IsCString &&
      (ZuTraits<R>::IsCString || ZuTraits<R>::IsString) &&
      !ZuTraits<R>::IsWString,
    bool>
  equals(const L &l, const R &r) {
    return ZuCmp_StrCmp<
      L, R, ZuTraits<R>::IsCString, ZuTraits<L>::IsString, 0>::equals(l, r);
  }
  static bool null(const char *s) { return !s || !*s; }
  static const T &null() {
    static const T r = static_cast<const T>(static_cast<const char *>(nullptr));
    return r;
  }
};
template <typename T> struct ZuCmp_String<T, 0, 1, 0> {
  template <typename L, typename R>
  static ZuIfT<
    ZuTraits<L>::IsString &&
      (ZuTraits<R>::IsCString || ZuTraits<R>::IsString) &&
      !ZuTraits<R>::IsWString,
    int>
  cmp(const L &l, const R &r) {
    return ZuCmp_StrCmp<L, R, 0, 1, 0>::cmp(l, r);
  }
  template <typename L, typename R>
  static ZuIfT<
    ZuTraits<L>::IsString &&
      (ZuTraits<R>::IsCString || ZuTraits<R>::IsString) &&
      !ZuTraits<R>::IsWString,
    bool>
  less(const L &l, const R &r) {
    return ZuCmp_StrCmp<L, R, 0, 1, 0>::less(l, r);
  }
  template <typename L, typename R>
  static ZuIfT<
    ZuTraits<L>::IsString &&
      (ZuTraits<R>::IsCString || ZuTraits<R>::IsString) &&
      !ZuTraits<R>::IsWString,
    bool>
  equals(const L &l, const R &r) {
    return ZuCmp_StrCmp<L, R, 0, 1, 0>::equals(l, r);
  }
  static bool null(const T &s) { return !s; }
  static const T &null() {
    static const T v;
    return v;
  }
};
template <typename T, bool IsString> struct ZuCmp_String<T, 1, IsString, 1> {
  template <typename L, typename R>
  static ZuIfT<
    ZuTraits<L>::IsCString &&
      (ZuTraits<R>::IsCString || ZuTraits<R>::IsString) &&
      ZuTraits<R>::IsWString,
    int>
  cmp(const L &l, const R &r) {
    return ZuCmp_StrCmp<
      L, R, ZuTraits<R>::IsCString, ZuTraits<L>::IsString, 1>::cmp(l, r);
  }
  template <typename L, typename R>
  static ZuIfT<
    ZuTraits<L>::IsCString &&
      (ZuTraits<R>::IsCString || ZuTraits<R>::IsString) &&
      ZuTraits<R>::IsWString,
    bool>
  less(const L &l, const R &r) {
    return ZuCmp_StrCmp<
      L, R, ZuTraits<R>::IsCString, ZuTraits<L>::IsString, 1>::less(l, r);
  }
  template <typename L, typename R>
  static ZuIfT<
    ZuTraits<L>::IsCString &&
      (ZuTraits<R>::IsCString || ZuTraits<R>::IsString) &&
      ZuTraits<R>::IsWString,
    bool>
  equals(const L &l, const R &r) {
    return ZuCmp_StrCmp<
      L, R, ZuTraits<R>::IsCString, ZuTraits<L>::IsString, 1>::equals(l, r);
  }
  static bool null(const wchar_t *w) { return !w || !*w; }
  static const T &null() {
    static const T r =
      static_cast<const T>(static_cast<const wchar_t *>(nullptr));
    return r;
  }
};
template <typename T> struct ZuCmp_String<T, 0, 1, 1> {
  template <typename L, typename R>
  static ZuIfT<
    ZuTraits<L>::IsString &&
      (ZuTraits<R>::IsCString || ZuTraits<R>::IsString) &&
      ZuTraits<R>::IsWString,
    int>
  cmp(const L &l, const R &r) {
    return ZuCmp_StrCmp<L, R, 0, 1, 1>::cmp(l, r);
  }
  template <typename L, typename R>
  static ZuIfT<
    ZuTraits<L>::IsString &&
      (ZuTraits<R>::IsCString || ZuTraits<R>::IsString) &&
      ZuTraits<R>::IsWString,
    bool>
  less(const L &l, const R &r) {
    return ZuCmp_StrCmp<L, R, 0, 1, 1>::less(l, r);
  }
  template <typename L, typename R>
  static ZuIfT<
    ZuTraits<L>::IsString &&
      (ZuTraits<R>::IsCString || ZuTraits<R>::IsString) &&
      ZuTraits<R>::IsWString,
    bool>
  equals(const L &l, const R &r) {
    return ZuCmp_StrCmp<L, R, 0, 1, 1>::equals(l, r);
  }
  static bool null(const T &s) { return !s; }
  static const T &null() {
    static const T v;
    return v;
  }
};

template <typename T>
struct ZuCmp_<T, false> :
  public ZuCmp_NonString<T, ZuTraits<T>::IsPrimitive, ZuTraits<T>::IsPointer> {
};

template <typename T>
struct ZuCmp_<T, true> :
  public ZuCmp_String<
    T, ZuTraits<T>::IsCString, ZuTraits<T>::IsString, ZuTraits<T>::IsWString> {
};

template <> struct ZuCmp_<bool> {
  static int cmp(bool b1, bool b2) { return (int)b1 - (int)b2; }
  static bool less(bool b1, bool b2) { return b1 < b2; }
  static bool equals(bool b1, bool b2) { return b1 == b2; }
  static bool null(bool b) { return !b; }
  static constexpr bool null() { return false; }
};

template <> struct ZuCmp_<char> {
  static int cmp(char c1, char c2) { return (int)c1 - (int)c2; }
  static bool less(char c1, char c2) { return c1 < c2; }
  static bool equals(char c1, char c2) { return c1 == c2; }
  static bool null(char c) { return !c; }
  static constexpr char null() { return 0; }
};

template <> struct ZuCmp_<void> {
  static void null() { }
};

template <typename T> struct ZuCmp : public ZuCmp_<ZuDecay<T>> { };

template <typename T> struct ZuCmp0 : public ZuCmp<T> {
  using U = ZuDecay<T>;
  static bool null(U v) { return !v; }
  static constexpr U null() { return 0; }
};

template <typename T> struct ZuCmp_1 : public ZuCmp<T> {
  using U = ZuDecay<T>;
  static bool null(U v) { return v < 0; }
  static constexpr U null() { return -1; }
};

template <typename T, ZuDecay<T> N> struct ZuCmpN : public ZuCmp<T> {
  using U = ZuDecay<T>;
  static bool null(U v) { return v == N; }
  static constexpr U null() { return N; }
};

template <typename T, typename Cmp, typename R = decltype(Cmp::null())>
struct ZuNullRef_ {
  static const T &null() noexcept {
    static const T null = Cmp::null();
    return null;
  }
};
template <typename T, typename Cmp> struct ZuNullRef_<T, Cmp, const T &> {
  inline static const T &null() noexcept { return Cmp::null(); }
};
template <typename T, typename Cmp = ZuCmp<T>>
inline const T &ZuNullRef() noexcept {
  return ZuNullRef_<T, Cmp>::null();
}

template <typename T, bool = ZuTraits<T>::IsString> struct ZuHash_;

namespace ZuHash_GoldenRatio32 {
inline constexpr const uint32_t ratio() { return 0x61c88647; }
inline constexpr const uint32_t hash(uint32_t i) { return i * ratio(); }
}

namespace ZuHash_GoldenRatio64 {
inline constexpr const uint64_t ratio() { return 0x61c8864680b583ebULL; }
inline constexpr const uint32_t hash(uint64_t i) { return (i * ratio()) >> 32; }
}

namespace ZuHash_GoldenRatio128 {
inline constexpr const uint128_t ratio() {
  return (uint128_t(0x61c8864680b583eaULL) << 64) | 0x0c633f9fa31237ccULL;
}
inline constexpr const uint32_t hash(uint128_t i) {
  return (i * ratio()) >> 96;
}
}

struct ZuHash_FNV_ {
  using Value = uint64_t;

  static Value initial_() { return 0xcbf29ce484222325ULL; }

  static Value hash_(Value v, Value i) {
    v ^= i;
    v *= 0x100000001b3ULL;
    return v;
  }
};

struct ZuHash_FNV : public ZuHash_FNV_ {
  using Value = ZuHash_FNV_::Value;

  static uint32_t hash(const uint8_t *p, int n) {
    Value v = initial_();
    while (--n >= 0) v = hash_(v, *p++);
    return uint32_t(v);
  }
};

template <typename T> struct ZuHash_Floating;
template <> struct ZuHash_Floating<float> {
  static uint32_t hash(float v) {
    if (v == 0) return 0;
    if (ZuCmp<float>::null(v)) return uint32_t(1) << 31;
    double d = v;
    return ZuHash_FNV::hash(
      reinterpret_cast<const uint8_t *>(&d), sizeof(double)
    );
  }
};
template <> struct ZuHash_Floating<double> {
  static uint32_t hash(double v) {
    if (v == 0) return 0;
    if (ZuCmp<double>::null(v)) return uint32_t(1) << 31;
    return ZuHash_FNV::hash(
      reinterpret_cast<const uint8_t *>(&v), sizeof(double)
    );
  }
};
template <> struct ZuHash_Floating<long double> {
  static uint32_t hash(long double v) {
    if (v == 0) return 0;
    if (ZuCmp<long double>::null(v)) return uint32_t(1) << 31;
    double d = v;
    return ZuHash_FNV::hash(
      reinterpret_cast<const uint8_t *>(&d), sizeof(double)
    );
  }
};

template <typename T, int Size> struct ZuHash_Integral {
  static uint32_t hash(const T &t) {
    return ZuHash_GoldenRatio32::hash(uint32_t(t));
  }
};

template <typename T> struct ZuHash_Integral<T, 8> {
  static uint32_t hash(const T &t) {
    return uint32_t(ZuHash_GoldenRatio64::hash(t));
  }
};

template <typename T> struct ZuHash_Integral<T, 16> {
  static uint32_t hash(const T &t) {
    return uint32_t(ZuHash_GoldenRatio128::hash(t));
  }
};

template <typename T, bool IsIntegral>
struct ZuHash_Real : public ZuHash_Integral<T, sizeof(T)> { };

template <typename T>
struct ZuHash_Real<T, false> : public ZuHash_Floating<T> { };

template <typename T, bool IsReal, bool IsVoid> struct ZuHash_Primitive;

template <typename T>
struct ZuHash_Primitive<T, true, false> :
  public ZuHash_Real<T, ZuTraits<T>::IsIntegral> { };

template <typename> struct ZuCmp_Can_hash_;
template <> struct ZuCmp_Can_hash_<uint32_t> {
  using T = void;
};
template <typename, typename = void>
struct ZuHash_Can_hash : public ZuFalse { };
template <typename T>
struct ZuHash_Can_hash<
  T, typename ZuCmp_Can_hash_<decltype(ZuDeclVal<const T &>().hash())>::T> :
  public ZuTrue { };

template <typename> struct ZuCmp_Can_hash_code_;
template <> struct ZuCmp_Can_hash_code_<std::size_t> {
  using T = void;
};
template <typename, typename = void>
struct ZuHash_Can_hash_code : public ZuFalse { };
template <typename T>
struct ZuHash_Can_hash_code<
  T,
  typename ZuCmp_Can_hash_code_<decltype(ZuDeclVal<const T &>().hash_code()
  )>::T> : public ZuTrue { };

template <typename T> struct ZuHash_NonPrimitive {
  template <typename U>
  static ZuIfT<ZuHash_Can_hash_code<U>{}, uint32_t> hash(const U &v) {
    return v.hash_code();
  }
  template <typename U>
  static ZuIfT<ZuHash_Can_hash<U>{} && !ZuHash_Can_hash_code<U>{}, uint32_t>
  hash(const U &v) {
    return v.hash();
  }
};

template <typename T, int Size> struct ZuHash_Pointer;

template <typename T> struct ZuHash_Pointer<T, 4> {
  static uint32_t hash(T v) { return ZuHash_GoldenRatio32::hash(uint32_t(v)); }
};

template <typename T> struct ZuHash_Pointer<T, 8> {
  static uint32_t hash(T v) {
    return uint32_t(ZuHash_GoldenRatio64::hash(uint64_t(v)));
  }
};

template <typename T> struct ZuHash_PrimitivePointer;

template <typename T>
struct ZuHash_PrimitivePointer<T *> :
  public ZuHash_Pointer<const T *, sizeof(T *)> { };

template <typename T, bool IsPrimitive, bool IsPointer> struct ZuHash_NonString;

template <typename T>
struct ZuHash_NonString<T, false, false> : public ZuHash_NonPrimitive<T> { };

template <typename T>
struct ZuHash_NonString<T, false, true> :
  public ZuHash_Pointer<T, sizeof(T)> { };

template <typename T>
struct ZuHash_NonString<T, true, false> :
  public ZuHash_Primitive<T, ZuTraits<T>::IsReal, ZuTraits<T>::IsVoid> { };

template <typename T>
struct ZuHash_NonString<T, true, true> : public ZuHash_PrimitivePointer<T> { };

template <typename T> struct ZuCSpanHash;
template <> struct ZuCSpanHash<char> {
  static uint32_t hash(const char *data_, size_t len) {
    auto data = reinterpret_cast<const uint8_t *>(data_);
    uint32_t hash = len;

    if (len <= 0 || !data) return 0;

    while (len >> 2) {
      hash += reinterpret_cast<const uint16_t *>(data)[0];
      hash = (hash << 16) ^
	(reinterpret_cast<const uint16_t *>(data)[1] << 11) ^ hash;

      hash += hash >> 11;
      data += 4, len -= 4;
    }

    switch (len & 3) {
    case 3:

      hash += reinterpret_cast<const uint16_t *>(data)[0];

      hash ^= hash << 16;
      hash ^= data[2] << 18;
      hash += hash >> 11;
      break;
    case 2:

      hash += reinterpret_cast<const uint16_t *>(data)[0];

      hash ^= hash << 11;
      hash += hash >> 17;
      break;
    case 1:
      hash += data[0];
      hash ^= hash << 10;
      hash += hash >> 1;
    }

    hash ^= hash << 3;
    hash += hash >> 5;
    hash ^= hash << 4;
    hash += hash >> 17;
    hash ^= hash << 25;
    hash += hash >> 6;

    return hash;
  }
};
template <int WCharSize> struct ZuWSpanHash;
template <> struct ZuWSpanHash<2> {
  static uint32_t hash(const wchar_t *data_, size_t len) {
    auto data = reinterpret_cast<const uint16_t *>(data_);
    uint32_t hash = len;

    if (len <= 0 || !data) return 0;

    while (len >> 1) {
      hash += data[0];
      hash = (hash << 16) ^ (data[1] << 11) ^ hash;
      hash += hash >> 11;
      data += 2, len -= 2;
    }

    if (len & 1) {
      hash += data[0];
      hash ^= hash << 11;
      hash += hash >> 17;
    }

    hash ^= hash << 3;
    hash += hash >> 5;
    hash ^= hash << 4;
    hash += hash >> 17;
    hash ^= hash << 25;
    hash += hash >> 6;

    return hash;
  }
};
template <> struct ZuWSpanHash<4> {
  static uint32_t hash(const wchar_t *data_, size_t len) {
    auto data = reinterpret_cast<const uint16_t *>(data_);
    uint32_t hash = len;

    if (len <= 0 || !data) return 0;

    while (len) {
      hash += data[0];
      hash = (hash << 16) ^ (data[1] << 11) ^ hash;
      hash += hash >> 11;
      data++, len--;
    }

    hash ^= hash << 3;
    hash += hash >> 5;
    hash ^= hash << 4;
    hash += hash >> 17;
    hash ^= hash << 25;
    hash += hash >> 6;

    return hash;
  }
};
template <>
struct ZuCSpanHash<wchar_t> : public ZuWSpanHash<sizeof(wchar_t)> { };

template <typename T>
struct ZuHash_<T, false> :
  public ZuHash_NonString<T, ZuTraits<T>::IsPrimitive, ZuTraits<T>::IsPointer> {
};

template <typename T> struct ZuHash_<T, true> {
  template <typename S> static uint32_t hash(const S &s) {
    using Traits = ZuTraits<S>;
    using Char = ZuDecay<typename Traits::Elem>;
    return ZuCSpanHash<Char>::hash(Traits::data(s), Traits::length(s));
  }
};

template <typename T> struct ZuHash : public ZuHash_<ZuDecay<T>> { };

namespace ZuInspect_ {

template <typename U, typename = void> struct P1_ {
  using T = ZuStrip<U>;
};
template <typename U> struct P1_<U, decltype((int U::*){}, void())> {
  using T = U &;
};
template <typename U> using P1 = typename P1_<U>::T;

template <typename U, typename = void> struct P2_ {
  using T = ZuStrip<U>;
};
template <typename U> struct P2_<U, decltype((int U::*){}, void())> {
  using T = const U &;
};
template <typename U> using P2 = typename P2_<U>::T;

struct Convertible_ {
  typedef char Small;
  struct Big {
    char _[2];
  };
};
template <typename T1, typename T2> struct Convertible : public Convertible_ {
private:
  static Small test(P2<T2>);
  static Big test(...);

public:
  enum { Converts = sizeof(test(ZuDeclVal<P1<T1>>())) == sizeof(Small) };
};

template <typename T1, typename T2, typename = void> struct Constructible_ {
  enum { Constructs = 0 };
};
template <typename T1, typename T2>
struct Constructible_<T1, T2, decltype(T2(ZuDeclVal<P1<T1>>()), void())> {
  enum { Constructs = 1 };
};

template <typename T1, typename T2, bool = (sizeof(P1<T1>) < sizeof(T2))>
struct Constructible : public Constructible_<T1, T2> { };
template <typename T1, typename T2> struct Constructible<T1, T2 *, true> {
  enum { Constructs = 0 };
};
template <typename T1, typename T2> struct Constructible<T1, T2 *const, true> {
  enum { Constructs = 0 };
};
template <typename T1, typename T2>
struct Constructible<T1, T2 *volatile, true> {
  enum { Constructs = 0 };
};
template <typename T1, typename T2>
struct Constructible<T1, T2 *const volatile, true> {
  enum { Constructs = 0 };
};

template <typename T1, typename T2>
struct Inspect__ : public Convertible<T1, T2>, public Constructible<T1, T2> {
  enum { Same = 0 };
};

template <typename T> struct Inspect__<T, T> {
  enum { Converts = 1, Constructs = 1, Same = 1 };
};

template <typename T_> struct Inspect_Array {
  using T = T_;
};
template <typename T_> struct Inspect_Array<T_[]> {
  using T = T_ *const;
};
template <typename T_> struct Inspect_Array<const T_[]> {
  using T = const T_ *const;
};
template <typename T_> struct Inspect_Array<volatile T_[]> {
  using T = volatile T_ *const;
};
template <typename T_> struct Inspect_Array<const volatile T_[]> {
  using T = const volatile T_ *const;
};
template <typename T_, int N> struct Inspect_Array<T_[N]> {
  using T = T_ *const;
};
template <typename T_, int N> struct Inspect_Array<const T_[N]> {
  using T = const T_ *const;
};
template <typename T_, int N> struct Inspect_Array<volatile T_[N]> {
  using T = volatile T_ *const;
};
template <typename T_, int N> struct Inspect_Array<const volatile T_[N]> {
  using T = const volatile T_ *const;
};

template <typename T1, typename T2> struct Inspect_ {
  using U1 = typename Inspect_Array<T1>::T;
  using U2 = typename Inspect_Array<T2>::T;
  enum {
    Converts = Inspect__<U1, U2>::Converts,
    Constructs = Inspect__<U1, U2>::Constructs,
    Same = Inspect__<const volatile U1, const volatile U2>::Same,
    Is = Inspect__<const volatile U2 *, const volatile U1 *>::Converts &&
      !Inspect__<const volatile U1 *, const volatile void *>::Same
  };
};
template <> struct Inspect_<void, void> {
  enum { Converts = 1, Constructs = 1, Same = 1, Is = 1 };
};
template <typename T> struct Inspect_<void, T> {
  enum { Converts = 0, Constructs = 0, Same = 0, Is = 0 };
};
template <typename T> struct Inspect_<T, void> {
  enum { Converts = 0, Constructs = 0, Same = 0, Is = 0 };
};
template <> struct Inspect_<std::nullptr_t, std::nullptr_t> {
  enum { Converts = 1, Constructs = 1, Same = 1, Is = 1 };
};
template <typename T> struct Inspect_<std::nullptr_t, T *> {
  enum { Converts = 1, Constructs = 1, Same = 0, Is = 0 };
};
template <typename T> struct Inspect_<std::nullptr_t, const T *> {
  enum { Converts = 1, Constructs = 1, Same = 0, Is = 0 };
};
template <typename T> struct Inspect_<std::nullptr_t, volatile T *> {
  enum { Converts = 1, Constructs = 1, Same = 0, Is = 0 };
};
template <typename T> struct Inspect_<std::nullptr_t, const volatile T *> {
  enum { Converts = 1, Constructs = 1, Same = 0, Is = 0 };
};

template <typename T_> struct Inspect_Void {
  using T = T_;
};
template <> struct Inspect_Void<const void> {
  using T = void;
};
template <> struct Inspect_Void<volatile void> {
  using T = void;
};
template <> struct Inspect_Void<const volatile void> {
  using T = void;
};

template <typename T1, typename T2> class Inspect {
  using U1 = typename Inspect_Void<ZuDeref<T1>>::T;
  using U2 = typename Inspect_Void<ZuDeref<T2>>::T;

public:
  enum {
    Same = Inspect_<U1, U2>::Same,
    Converts = Inspect_<U1, U2>::Converts,
    Constructs = Inspect_<U1, U2>::Constructs,
    Is = Inspect_<U1, U2>::Is,
    Base = Inspect_<U1, U2>::Is && !Inspect_<U1, U2>::Same
  };
};

} // namespace ZuInspect_

template <typename T1, typename T2>
using ZuInspect = ZuInspect_::Inspect<T1, T2>;

template <typename T1, typename T2, typename R = void>
using ZuSame = ZuIfT<ZuInspect<T1, T2>::Same, R>;
template <typename T1, typename T2, typename R = void>
using ZuNotSame = ZuIfT<!ZuInspect<T1, T2>::Same, R>;
template <typename T1, typename T2, typename R = void>
using ZuConvertible = ZuIfT<ZuInspect<T1, T2>::Converts, R>;
template <typename T1, typename T2, typename R = void>
using ZuNotConvertible = ZuIfT<!ZuInspect<T1, T2>::Converts, R>;
template <typename T1, typename T2, typename R = void>
using ZuConstructible = ZuIfT<ZuInspect<T1, T2>::Constructs, R>;
template <typename T1, typename T2, typename R = void>
using ZuNotConstructible = ZuIfT<!ZuInspect<T1, T2>::Constructs, R>;
template <typename T1, typename T2, typename R = void>
using ZuBase = ZuIfT<ZuInspect<T1, T2>::Base, R>;
template <typename T1, typename T2, typename R = void>
using ZuNotBase = ZuIfT<!ZuInspect<T1, T2>::Base, R>;
template <typename T1, typename T2, typename R = void>
using ZuIs = ZuIfT<ZuInspect<T1, T2>::Is, R>;
template <typename T1, typename T2, typename R = void>
using ZuIsNot = ZuIfT<!ZuInspect<T1, T2>::Is, R>;

struct ZuPrintable { };

struct ZuPrintCannot {
  enum { OK = 0, String = 0, Delegate = 0, Buffer = 0 };
};

struct ZuPrintFn {
  enum { OK = 1, String = 0, Delegate = 1, Buffer = 0 };
  template <typename S, typename T> static void print(S &s, const T &v) {
    v.print(s);
  }
};

template <auto Fn> struct ZuPrintLambda {
  enum { OK = 1, String = 0, Delegate = 1, Buffer = 0 };
  template <typename S, typename T> static void print(S &s, const T &v) {
    Fn()(s, v);
  }
};

ZuPrintCannot ZuPrintType(...);

template <typename U> struct ZuPrintT_ {
  using T = U;
};
template <typename U> struct ZuPrintT_<U *> {
  using T = typename ZuPrintT_<ZuDecay<U>>::T *;
};
template <typename U> using ZuPrintT = typename ZuPrintT_<ZuDecay<U>>::T *;

template <typename U>
using ZuPrint = decltype(ZuPrintType(ZuDeclVal<ZuPrintT<U>>()));

ZuPrintFn ZuPrintType(ZuPrintable *);

struct ZuPrintString {
  enum { OK = 1, String = 1, Delegate = 0, Buffer = 0 };
};
struct ZuPrintDelegate {
  enum { OK = 1, String = 0, Delegate = 1, Buffer = 0 };
};
struct ZuPrintBuffer {
  enum { OK = 1, String = 0, Delegate = 0, Buffer = 1 };
};

struct ZuPrintNull : public ZuPrintable {
  template <typename S> void print(S &) const { }
};

template <typename T> struct ZuPrintPtr {
  T *ptr;
  template <typename S> void print(S &s) const {
    if (!ptr)
      s << "(null)";
    else
      s << *ptr;
  }
  friend ZuPrintFn ZuPrintType(ZuPrintPtr *);
};
template <typename T> ZuPrintPtr(T *) -> ZuPrintPtr<T>;

template <typename Impl, typename S> struct ZuStdStream_ {
  enum { OK = 1 };
  template <typename P>
  static ZuIfT<ZuPrint<P>::String> print(S &s, const P &p) {
    const typename ZuTraits<P>::Elem *ptr = ZuTraits<P>::data(p);
    if (__builtin_expect(!!(ptr), 1))
      Impl::append(s, ptr, ZuTraits<P>::length(p));
  }
  template <typename P>
  static ZuIfT<ZuPrint<P>::Delegate> print(S &s, const P &p) {
    ZuPrint<P>::print(s, p);
  }
  template <typename P>
  static ZuIfT<ZuPrint<P>::Buffer> print(S &s, const P &p) {
    unsigned len = ZuPrint<P>::length(p);
    auto buf = static_cast<char *>(__builtin_alloca_with_align(len, (1) << 3));
    if (__builtin_expect(!!(buf), 1))
      Impl::append(s, buf, ZuPrint<P>::print(buf, len, p));
  }
};

template <typename S, bool = ZuInspect<std::ios_base, S>::Base>
struct ZuStdStream {
  enum { OK = 0 };
};
template <typename S>
struct ZuStdStream<S, true> : public ZuStdStream_<ZuStdStream<S, true>, S> {
  static S &append(S &s, const char *data, unsigned length) {
    if (__builtin_expect(!!(data), 1))
      s.write(data, static_cast<size_t>(length));
    return s;
  }
};
template <typename T, typename A>
struct ZuStdStream<std::basic_string<char, T, A>, false> :
  public ZuStdStream_<
    ZuStdStream<std::basic_string<char, T, A>, false>,
    std::basic_string<char, T, A>> {
  using S = std::basic_string<char, T, A>;
  static S &append(S &s, const char *data, unsigned length) {
    if (__builtin_expect(!!(data), 1))
      s.append(data, static_cast<size_t>(length));
    return s;
  }
};

template <typename S, typename P, bool = ZuStdStream<S>::OK>
struct ZuStdStreamable {
  enum { OK = 0 };
};
template <typename S, typename P> struct ZuStdStreamable<S, P, true> {
  enum { OK = ZuPrint<P>::OK };
};

template <typename S, typename P>
inline ZuIfT<ZuStdStreamable<S, P>::OK, S &> operator<<(S &s, const P &p) {
  ZuStdStream<S>::print(s, p);
  return s;
}

template <typename S, typename P>
inline ZuIfT<ZuStdStreamable<S, P>::OK, S &> operator+=(S &s, const P &p) {
  ZuStdStream<S>::print(s, p);
  return s;
}

extern "C" {

  extern void __assert_fail(
    const char *__assertion, const char *__file, unsigned int __line,
    const char *__function
  ) noexcept(true) __attribute__((__noreturn__));

  extern void __assert_perror_fail(
    int __errnum, const char *__file, unsigned int __line,
    const char *__function
  ) noexcept(true) __attribute__((__noreturn__));

  extern void __assert(
    const char *__assertion, const char *__file, int __line
  ) noexcept(true) __attribute__((__noreturn__));
}

template <typename T, class Cmp, bool IsPrimitive> class ZuArrayFn_ItemOps_;

template <typename T, class Cmp> class ZuArrayFn_ItemOps_<T, Cmp, false> {
public:
  inline static void initItem(void *dst) { new (dst) T{}; }
  template <typename P> inline static void initItem(void *dst, P &&p) {
    new (dst) T{ZuFwd<P>(p)};
  }
  inline static void destroyItem(T *dst) { (*dst).~T(); }
};

template <typename T, class Cmp> class ZuArrayFn_ItemOps_<T, Cmp, true> {
public:
  inline static void initItem(void *dst) {
    *static_cast<T *>(dst) = Cmp::null();
  }
  template <typename P> inline static void initItem(void *dst, P &&p) {
    *static_cast<T *>(dst) = ZuFwd<P>(p);
  }
  inline static void destroyItem(T *dst) { }
};

template <typename T, class Cmp>
class ZuArrayFn_ItemOps :
  public ZuArrayFn_ItemOps_<T, Cmp, ZuTraits<T>::IsPrimitive> {
  using Base = ZuArrayFn_ItemOps_<T, Cmp, ZuTraits<T>::IsPrimitive>;

public:
  static void initItems(T *dst, unsigned length) {
    if (__builtin_expect(!!(length), 1)) do {
	Base::initItem((void *)dst++);
      } while (--length > 0);
  }
};

template <typename T, class Cmp, bool IsPOD>
class ZuArrayFn_Ops : public ZuArrayFn_ItemOps<T, Cmp> {
public:
  static void destroyItems(T *dst, unsigned length) {
    if (__builtin_expect(!!(length), 1)) do {
	(*dst++).~T();
      } while (--length > 0);
  }

  template <typename S>
  static void copyItems(T *dst, const S *src, unsigned length) {
    ptrdiff_t diff =
      reinterpret_cast<const char *>(dst) - reinterpret_cast<const char *>(src);
    if (__builtin_expect(!!(!length || !diff), 0)) return;
    if (diff < 0 || diff > static_cast<ptrdiff_t>(length * sizeof(T))) {
      do { new (dst++) T{*src++}; } while (--length > 0);
    } else {
      dst += length;
      src += length;
      do { new (--dst) T{*--src}; } while (--length > 0);
    }
  }

  template <typename S> static void moveItems(T *dst, S *src, unsigned length) {
    ptrdiff_t diff =
      reinterpret_cast<const char *>(dst) - reinterpret_cast<const char *>(src);
    if (__builtin_expect(!!(!length || !diff), 0)) return;
    if (diff < 0 || diff > static_cast<ptrdiff_t>(length * sizeof(T))) {
      do {
	new (dst++) T{ZuMv(*src)};
	(*src++).~T();
      } while (--length > 0);
    } else {
      dst += length;
      src += length;
      do {
	new (--dst) T{ZuMv(*--src)};
	(*src).~T();
      } while (--length > 0);
    }
  }
};

template <typename T1, typename T2> struct ZuArrayFn_POD {
  enum {
    Same = ZuInspect<T1, T2>::Same ||
      (sizeof(T1) == sizeof(T2) && ZuTraits<T1>::IsIntegral &&
       ZuTraits<T1>::IsPrimitive && ZuTraits<T2>::IsIntegral &&
       ZuTraits<T2>::IsPrimitive)
  };
};
template <typename T1, typename T2, typename R = void>
using ZuArrayFn_SamePOD = ZuIfT<ZuArrayFn_POD<T1, T2>::Same, R>;
template <typename T1, typename T2, typename R = void>
using ZuArrayFn_NotSamePOD = ZuIfT<!ZuArrayFn_POD<T1, T2>::Same, R>;

template <typename T, class Cmp>
class ZuArrayFn_Ops<T, Cmp, true> : public ZuArrayFn_ItemOps<T, Cmp> {
public:
  inline static void destroyItems(T *dst, unsigned length) { }
  template <typename S>
  static ZuArrayFn_NotSamePOD<T, S>
  copyItems(T *dst, const S *src, unsigned length) {
    if (__builtin_expect(!!(!length || dst == static_cast<const T *>(src)), 0))
      return;
    if (static_cast<T *>(src) > dst ||
	length < static_cast<unsigned>(dst - static_cast<const T *>(src))) {
      do { new (dst++) T{*src++}; } while (--length > 0);
    } else {
      dst += length;
      src += length;
      do { new (--dst) T{*--src}; } while (--length > 0);
    }
  }
  template <typename S>
  inline static ZuArrayFn_SamePOD<T, S>
  copyItems(T *dst, const S *src, unsigned length) {
    memmove((void *)dst, src, length * sizeof(T));
  }
  template <typename S>
  static ZuArrayFn_NotSamePOD<T, S>
  moveItems(T *dst, const S *src, unsigned length) {
    if (__builtin_expect(!!(!length || dst == static_cast<const T *>(src)), 0))
      return;
    if (static_cast<T *>(src) > dst ||
	length < static_cast<unsigned>(dst - static_cast<const T *>(src))) {
      do { new (dst++) T{ZuMv(*src++)}; } while (--length > 0);
    } else {
      dst += length;
      src += length;
      do { new (--dst) T{ZuMv(*--src)}; } while (--length > 0);
    }
  }
  template <typename S>
  inline static ZuArrayFn_SamePOD<T, S>
  moveItems(T *dst, const S *src, unsigned length) {
    memmove((void *)dst, src, length * sizeof(T));
  }
};

template <typename T, class Cmp, class DefltCmp, bool IsIntegral, unsigned Size>
struct ZuArrayFn_Cmp {
  static int cmp(const T *dst, const T *src, unsigned length) {
    while (__builtin_expect(!!(length--), 1))
      if (int i = Cmp::cmp(*dst++, *src++)) return i;
    return 0;
  }
  static bool equals(const T *dst, const T *src, unsigned length) {
    while (__builtin_expect(!!(length--), 1))
      if (!Cmp::equals(*dst++, *src++)) return false;
    return true;
  }
};

template <typename T, class Cmp> struct ZuArrayFn_Cmp<T, Cmp, Cmp, true, 1> {
  inline static int cmp(const T *dst, const T *src, unsigned length) {
    return memcmp(dst, src, length * sizeof(T));
  }
  inline static bool equals(const T *dst, const T *src, unsigned length) {
    return !memcmp(dst, src, length * sizeof(T));
  }
};

template <typename T> struct ZuArrayFn_Hash {
  static uint32_t hash(const T *data, unsigned length) {
    ZuHash_FNV::Value v = ZuHash_FNV::initial_();
    if (__builtin_expect(!!(length), 1)) do {
	v = ZuHash_FNV::hash_(v, ZuHash<T>::hash(*data++));
      } while (--length > 0);
    return (uint32_t)v;
  }
};
template <typename T> struct ZuArrayFn_StringHash {
  inline static uint32_t hash(const T *data, unsigned length) {
    return ZuCSpanHash<T>::hash(data, length);
  }
};
template <> struct ZuArrayFn_Hash<char> : public ZuArrayFn_StringHash<char> { };
template <>
struct ZuArrayFn_Hash<wchar_t> : public ZuArrayFn_StringHash<wchar_t> { };

template <typename T, class Cmp = ZuCmp<T>>
class ZuArrayFn :
  public ZuArrayFn_Ops<T, Cmp, ZuTraits<T>::IsPOD>,
  public ZuArrayFn_Cmp<T, Cmp, ZuCmp<T>, ZuTraits<T>::IsIntegral, sizeof(T)>,
  public ZuArrayFn_Hash<T> { };

template <typename T> class ZuArrayFn_Null {
public:
  inline static void initItem(T *dst) { }
  template <typename P> inline static void initItem(T *dst, P &&p) { }
  inline static void destroyItem(T *dst) { }
  inline static void initItems(T *dst, unsigned length) { }
  inline static void destroyItems(T *dst, unsigned length) { }
  template <typename S>
  inline static void copyItems(T *dst, const S *src, unsigned length) { }
  inline static void moveItems(T *dst, const T *src, unsigned length) { }
  inline static int cmp(const T *dst, const T *src, unsigned length) {
    return 0;
  }
  inline static bool equals(const T *dst, const T *src, unsigned length) {
    return true;
  }
  inline static uint32_t hash(const T *data, unsigned length) { return 0; }
};

template <typename Cmp>
class ZuArrayFn<void, Cmp> : public ZuArrayFn_Null<void> { };

template <
  typename U, typename W = wchar_t,
  bool = bool{ZuIsExact<U, char>{}} || bool{ZuIsExact<U, signed char>{}} ||
    bool{ZuIsExact<U, unsigned char>{}} || bool{ZuIsExact<U, int8_t>{}} ||
    bool{ZuIsExact<U, uint8_t>{}},
  bool = bool{ZuIsExact<U, W>{}} ||
    (sizeof(W) == 2 &&
     (bool{ZuIsExact<U, short>{}} || bool{ZuIsExact<U, unsigned short>{}} ||
      bool{ZuIsExact<U, int16_t>{}} || bool{ZuIsExact<U, uint16_t>{}})) ||
    (sizeof(W) == 4 &&
     (bool{ZuIsExact<U, int32_t>{}} || bool{ZuIsExact<U, uint32_t>{}}))>
struct ZuNormChar_ {
  using T = U;
};

template <typename U, typename W, bool _> struct ZuNormChar_<U, W, 1, _> {
  using T = char;
};

template <typename U, typename W> struct ZuNormChar_<U, W, 0, 1> {
  using T = W;
};

template <typename U> using ZuNormChar = typename ZuNormChar_<ZuDecay<U>>::T;

template <typename U1, typename U2>
struct ZuEquiv : public ZuIsExact<ZuNormChar<U1>, ZuNormChar<U2>> { };

template <typename T> struct ZuSpan_ { };
template <> struct ZuSpan_<char> {
  friend ZuPrintString ZuPrintType(ZuSpan_ *);
};

template <typename T_, typename Cmp_ = ZuCmp<T_>>
class ZuSpan : public ZuSpan_<ZuStrip<T_>> {
  template <typename, typename> friend class ZuSpan;

public:
  using T = T_;
  using Cmp = Cmp_;
  using Elem = T;
  using Ops = ZuArrayFn<T, Cmp>;

  ZuSpan() : m_data{0}, m_length{0} { }
  ZuSpan(const ZuSpan &a) : m_data{a.m_data}, m_length{a.m_length} { }
  ZuSpan &operator=(const ZuSpan &a) {
    if (__builtin_expect(!!(this != &a), 1)) {
      m_data = a.m_data;
      m_length = a.m_length;
    }
    return *this;
  }
  ZuSpan(ZuSpan &&a) : m_data{a.m_data}, m_length{a.m_length} { }
  ZuSpan &operator=(ZuSpan &&a) {
    m_data = a.m_data;
    m_length = a.m_length;
    return *this;
  }

  ZuSpan(std::initializer_list<T> a) :
    m_data(const_cast<T *>(a.begin())), m_length(a.size()) { }
  ZuSpan &operator=(std::initializer_list<T> a) {
    m_data = const_cast<T *>(a.begin());
    m_length = a.size();
    return *this;
  }

protected:
  template <typename U, typename V = T>
  struct IsPrimitiveArray_ :
    public ZuBool<
      ZuTraits<U>::IsArray && ZuTraits<U>::IsPrimitive &&
      ZuInspect<typename ZuTraits<U>::Elem, V>::Same> { };
  template <typename U, typename V = T>
  struct IsChar_ :
    public ZuBool<
      (ZuInspect<char, U>::Same || ZuInspect<wchar_t, U>::Same) &&
      ZuInspect<U, V>::Same> { };
  template <typename U>
  struct IsCharElem_ : public IsChar_<typename ZuTraits<U>::Elem> { };
  template <typename U, typename V = T>
  struct IsStrLiteral :
    public ZuBool<
      IsCharElem_<U>{} && ZuIsExact<U, const V (&)[sizeof(U) / sizeof(V)]>{}> {
  };
  template <typename U, typename R = void>
  using MatchStrLiteral = ZuIfT<IsStrLiteral<U>{}, R>;

  template <typename U>
  struct IsPrimitiveArray :
    public ZuBool<IsPrimitiveArray_<U>{} && !IsCharElem_<U>{}> { };
  template <typename U, typename R = void>
  using MatchPrimitiveArray = ZuIfT<IsPrimitiveArray<ZuDecay<U>>{}, R>;

  template <typename U>
  struct IsCString :
    public ZuBool<
      !IsStrLiteral<U>{} && IsCharElem_<U>{} && ZuTraits<U>::IsCString &&

      ZuTraits<U>::IsPrimitive> { };
  template <typename U, typename R = void>
  using MatchCString = ZuIfT<IsCString<U>{}, R>;

  template <typename U, typename V = T>
  struct IsZuArray :
    public ZuBool<
      bool(ZuIsExact<ZuSpan<typename ZuTraits<U>::Elem>, U>{}) &&
      bool{ZuEquiv<typename ZuTraits<U>::Elem, V>{}}> { };
  template <typename U, typename R = void>
  using MatchZuArray = ZuIfT<IsZuArray<ZuDecay<U>>{}, R>;

  template <typename U, typename V = T>
  struct IsOtherArray :
    public ZuBool<
      !ZuIsExact<ZuSpan<typename ZuTraits<U>::Elem>, U>{} &&
      !IsPrimitiveArray_<U>{} && !IsCString<U>{} &&
      (ZuTraits<U>::IsSpan || ZuTraits<U>::IsString) &&
      bool{ZuEquiv<typename ZuTraits<U>::Elem, V>{}}> { };
  template <typename U, typename R = void>
  using MatchOtherArray = ZuIfT<IsOtherArray<ZuDecay<U>>{}, R>;

  template <typename U, typename V = T>
  struct IsPtr :
    public ZuBool<ZuInspect<ZuNormChar<U> *, ZuNormChar<V> *>::Converts> { };
  template <typename U, typename R = void>
  using MatchPtr = ZuIfT<IsPtr<ZuDecay<U>>{}, R>;

public:
  template <typename A, decltype(MatchStrLiteral<A>(), int()) = 0>
  ZuSpan(A &&a) :
    m_data(&a[0]),
    m_length(
      (__builtin_expect(!!(!(sizeof(a) / sizeof(a[0])) || !a[0]), 0)) ?
	0U :
	(sizeof(a) / sizeof(a[0])) - 1U
    ) { }
  template <typename A> MatchStrLiteral<A, ZuSpan &> operator=(A &&a) {
    m_data = &a[0];
    m_length = (__builtin_expect(!!(!(sizeof(a) / sizeof(a[0])) || !a[0]), 0)) ?
      0U :
      (sizeof(a) / sizeof(a[0])) - 1U;
    return *this;
  }

  template <typename A, decltype(MatchPrimitiveArray<A>(), int()) = 0>
  ZuSpan(const A &a) : m_data(&a[0]), m_length(sizeof(a) / sizeof(a[0])) { }
  template <typename A> MatchPrimitiveArray<A, ZuSpan &> operator=(A &&a) {
    m_data = &a[0];
    m_length = sizeof(a) / sizeof(a[0]);
    return *this;
  }

  template <typename A, decltype(MatchCString<A>(), int()) = 0>
  ZuSpan(A &&a) : m_data(a), m_length(!a ? 0 : -1) { }

  template <typename A> MatchCString<A, ZuSpan &> operator=(A &&a) {
    m_data = a;
    m_length = !a ? 0 : -1;
    return *this;
  }

  template <typename A, decltype(MatchZuArray<A>(), int()) = 0>
  ZuSpan(A &&a) :
    m_data{reinterpret_cast<T *>(a.m_data)}, m_length{a.m_length} { }
  template <typename A> MatchZuArray<A, ZuSpan &> operator=(A &&a) {
    m_data = reinterpret_cast<T *>(a.m_data);
    m_length = a.m_length;
    return *this;
  }

  template <typename A, decltype(MatchOtherArray<A>(), int()) = 0>
  ZuSpan(A &&a) :
    m_data{reinterpret_cast<T *>(ZuTraits<A>::data(a))},
    m_length{!m_data ? 0 : static_cast<int>(ZuTraits<A>::length(a))} { }
  template <typename A> MatchOtherArray<A, ZuSpan &> operator=(A &&a) {
    m_data = reinterpret_cast<T *>(ZuTraits<A>::data(a));
    m_length = !m_data ? 0 : static_cast<int>(ZuTraits<A>::length(a));
    return *this;
  }

  template <typename V, decltype(MatchPtr<V>(), int()) = 0>
  ZuSpan(V *data, unsigned length) :
    m_data{reinterpret_cast<T *>(data)}, m_length{int(length)} { }

  const T *data() const { return m_data; }
  T *data() { return m_data; }

  unsigned length() const { return length_(); }

private:
  template <typename V = T>
  ZuIfT<bool{ZuEquiv<V, char>{}} || bool{ZuEquiv<V, wchar_t>{}}, unsigned>
  length_() const {
    using Char = ZuNormChar<V>;
    if (__builtin_expect(!!(m_length < 0), 0))
      return const_cast<ZuSpan *>(this)->m_length =
	       ZuTraits<const Char *>::length(
		 reinterpret_cast<const Char *>(m_data)
	       );
    return m_length;
  }
  template <typename V = T>
  ZuIfT<!bool{ZuEquiv<V, char>{}} && !bool{ZuEquiv<V, wchar_t>{}}, unsigned>
  length_() const {
    return m_length;
  }

public:
  const T &operator[](int i) const { return m_data[i]; }
  T &operator[](int i) { return m_data[i]; }

  bool operator!() const { return !length(); }
  operator const void *() const {
    return !*this ? reinterpret_cast<const void *>(0) :
		    static_cast<const void *>(this);
  }

  void offset(unsigned n) {
    if (__builtin_expect(!!(!n), 0)) return;
    if (__builtin_expect(!!(n < length()), 1))
      m_data += n, m_length -= n;
    else
      m_data = nullptr, m_length = 0;
  }

  void trunc(unsigned n) {
    if (__builtin_expect(!!(n < length()), 1)) {
      if (__builtin_expect(!!(n), 1))
	m_length = n;
      else
	m_data = nullptr, m_length = 0;
    }
  }

private:
  bool equals_(const ZuSpan &v) const {
    unsigned l = length();
    unsigned n = v.length();
    if (l != n) return false;
    return Ops::equals(data(), v.data(), l);
  }

public:
  bool equals(const ZuSpan &v) const {
    if (this == &v) return true;
    return equals_(v);
  }
  template <typename V> bool equals(const V &v_) const {
    ZuSpan v{v_};
    return equals_(v);
  }

private:
  int cmp_(const ZuSpan &v) const {
    int l = length();
    int n = v.length();
    if (int i = Ops::cmp(data(), v.data(), l < n ? l : n)) return i;
    return ZuCmp<int>::cmp(l, n);
  }

public:
  template <typename V> int cmp(const V &v_) const {
    ZuSpan v{v_};
    return cmp_(v);
  }
  int cmp(const ZuSpan &v) const {
    if (this == &v) return 0;
    return cmp_(v);
  }

  template <typename L, typename R>
  friend inline ZuIfT<
    ZuInspect<ZuSpan, L>::Is && ZuInspect<R, ZuSpan>::Constructs, bool>
  operator==(const L &l, const R &r) {
    return l.equals(r);
  }
  template <typename L, typename R>
  friend inline ZuIfT<
    ZuInspect<ZuSpan, L>::Is && ZuInspect<R, ZuSpan>::Constructs, int>
  operator<=>(const L &l, const R &r) {
    return l.cmp(r);
  }

  uint32_t hash() const { return ZuHash<ZuSpan>::hash(*this); }

  template <bool Mutable = false, typename L> ZuIfT<!Mutable> all(L l) const {
    for (unsigned i = 0, n = length(); i < n; i++) l(m_data[i]);
  }
  template <bool Mutable, typename L> ZuIfT<Mutable> all(L l) {
    for (unsigned i = 0, n = length(); i < n; i++) l(m_data[i]);
  }

  using iterator = T *;
  using const_iterator = const T *;
  const T *begin() const { return m_data; }
  const T *end() const { return m_data + length(); }
  const T *cbegin() const { return m_data; }
  const T *cend() const { return m_data + length(); }
  T *begin() { return m_data; }
  T *end() { return m_data + length(); }

private:
  T *m_data;
  int m_length;
};

template <typename T> class ZuSpan_Null {
  const T *data() const { return nullptr; }
  unsigned length() const { return 0; }

  T operator[](int i) const { return ZuCmp<T>::null(); }

  bool operator!() const { return true; }

  void offset(unsigned n) { }

  template <typename L> void all(L l) { }
};

template <typename Cmp> class ZuSpan<void, Cmp> : public ZuSpan_Null<void> {
public:
  using Elem = void;

  ZuSpan() { }
  ZuSpan(const ZuSpan &a) { }
  ZuSpan &operator=(const ZuSpan &a) { return *this; }

  template <
    typename A,
    decltype(ZuIfT<ZuTraits<A>::IsArray && ZuInspect<typename ZuTraits<A>::Elem, void>::Constructs>(), int()) =
      0>
  ZuSpan(const A &a) { }
  template <typename A>
  ZuIfT<
    ZuTraits<A>::IsArray &&
      ZuInspect<typename ZuTraits<A>::Elem, void>::Converts,
    ZuSpan &>
  operator=(const A &a) {
    return *this;
  }

  ZuSpan(const void *data, unsigned length) { }
};

template <typename T, typename N> ZuSpan(T *data, N length) -> ZuSpan<T>;

template <typename Elem_>
struct ZuTraits<ZuSpan<Elem_>> : public ZuBaseTraits<ZuSpan<Elem_>> {
  using Elem = Elem_;

private:
  using Array = ZuSpan<Elem>;

public:
  enum {
    IsArray = 1,
    IsPrimitive = 0,
    IsString = bool{ZuIsExact<char, ZuDecay<Elem>>{}} ||
      bool{ZuIsExact<wchar_t, ZuDecay<Elem>>{}},
    IsWString = bool{ZuIsExact<wchar_t, ZuDecay<Elem>>{}}
  };
  static Elem *data(Array &a) { return a.data(); }
  static const Elem *data(const Array &a) { return a.data(); }
  static unsigned length(const Array &a) { return a.length(); }
};

using ZuCSpan = ZuSpan<const char>;
using ZuWSpan = ZuSpan<const wchar_t>;

class ZmTrap {
public:
  static void trap();

  typedef void (*Fn)();

  static void sigintFn(Fn fn);
  static Fn sigintFn();

  static void sighupFn(Fn fn);
  static Fn sighupFn();

  static void log(ZuCSpan s);
};

namespace ZuFmt {
enum { MaxWidth = 54 };
enum { MaxNDP = 19 };

struct Just {
  enum { None = 0, Left, Right, Frac };
};

struct Default {
  enum { Justification_ = Just::None };
  enum { Hex_ = 0 };
  enum { Upper_ = 0 };
  enum { Alt_ = 0 };
  enum { Comma_ = 0 };
  enum { Width_ = 0 };
  enum { Pad_ = 0 };
  enum { NDP_ = -MaxNDP };
  enum { Trim_ = 0 };
  enum { Negative_ = 0 };
};

template <unsigned Width, char Pad = '\0', typename NTP = Default>
struct Left : public NTP {
  enum { Justification_ = Just::Left };
  enum { Width_ = Width > MaxWidth ? MaxWidth : Width };
  enum { Pad_ = Pad };
};

template <unsigned Width, char Pad = '0', typename NTP = Default>
struct Right : public NTP {
  enum { Justification_ = Just::Right };
  enum { Width_ = (int)Width > MaxWidth ? MaxWidth : (int)Width };
  enum { Pad_ = Pad };
};

template <
  unsigned Width, unsigned NDP, char Trim = '\0', typename NTP = Default>
struct Frac : public NTP {
  enum { Justification_ = Just::Frac };
  enum { Width_ = Width };
  enum { NDP_ = int(NDP) > MaxNDP ? MaxNDP : int(NDP) };
  enum { Trim_ = Trim };
};

template <bool Upper = 0, typename NTP = Default> struct Hex : public NTP {
  enum { Hex_ = 1 };
  enum { Upper_ = Upper };
};
template <bool Enable, bool Upper = 0, typename NTP = Default>
struct HexEnable : public NTP {
  enum { Hex_ = Enable };
  enum { Upper_ = Upper };
};

template <char Char = ',', typename NTP = Default> struct Comma : public NTP {
  enum { Comma_ = Char };
};

template <typename NTP = Default> struct Alt : public NTP {
  enum { Alt_ = 1 };
};
template <bool Enable = 1, typename NTP = Default>
struct AltEnable : public NTP {
  enum { Alt_ = Enable };
};

template <int NDP = -MaxNDP, char Trim = '\0', typename NTP = Default>
struct FP : public NTP {
  enum { NDP_ = NDP < -MaxNDP ? -MaxNDP : NDP > MaxNDP ? MaxNDP : NDP };
  enum { Trim_ = Trim };
};
}; // namespace ZuFmt

struct ZuVFmt {
  ZuVFmt() :
    m_justification{ZuFmt::Just::None}, m_hex{0}, m_upper{0}, m_alt{0},
    m_comma{'\0'}, m_width{0}, m_pad{-1}, m_ndp{-ZuFmt::MaxNDP}, m_trim{'\0'} {
  }

  template <typename Fmt>
  ZuVFmt(Fmt) :
    m_justification{Fmt::Justification_}, m_hex{Fmt::Hex_},
    m_upper{Fmt::Upper_}, m_alt{Fmt::Alt_}, m_comma{Fmt::Comma_},
    m_width{Fmt::Width_}, m_pad{Fmt::Pad_}, m_ndp{Fmt::NDP_},
    m_trim{Fmt::Trim_} { }

  ZuVFmt(const ZuVFmt &) = default;
  ZuVFmt &operator=(const ZuVFmt &) = default;
  ZuVFmt(ZuVFmt &&) = default;
  ZuVFmt &operator=(ZuVFmt &&) = default;

  ZuVFmt &reset() {
    using namespace ZuFmt;
    m_justification = Just::None;
    m_hex = 0;
    m_upper = 0;
    m_alt = 0;
    m_comma = '\0';
    m_width = 0;
    m_pad = -1;
    m_ndp = -ZuFmt::MaxNDP;
    m_trim = '\0';
    return *this;
  }
  ZuVFmt &left(unsigned width, char pad = '\0') {
    using namespace ZuFmt;
    m_justification = Just::Left;
    m_width = __builtin_expect(!!(width > MaxWidth), 0) ? MaxWidth : width;
    m_pad = pad;
    return *this;
  }
  ZuVFmt &right(unsigned width, char pad = '0') {
    using namespace ZuFmt;
    m_justification = Just::Right;
    m_width = __builtin_expect(!!(width > MaxWidth), 0) ? MaxWidth : width;
    m_pad = pad;
    return *this;
  }
  ZuVFmt &frac(unsigned width, unsigned ndp, char trim = '\0') {
    using namespace ZuFmt;
    m_justification = Just::Frac;
    m_width = width;
    m_ndp = __builtin_expect(!!(ndp > MaxNDP), 0) ? MaxNDP : ndp;
    m_trim = trim;
    return *this;
  }
  ZuVFmt &hex() {
    m_hex = 1;
    m_upper = 0;
    return *this;
  }
  ZuVFmt &hex(bool upper) {
    m_hex = 1;
    m_upper = upper;
    return *this;
  }
  ZuVFmt &hex(bool hex_, bool upper) {
    m_hex = hex_;
    m_upper = upper;
    return *this;
  }
  ZuVFmt &comma(char comma_ = ',') {
    m_comma = comma_;
    return *this;
  }
  ZuVFmt &alt() {
    m_alt = 1;
    return *this;
  }
  ZuVFmt &alt(bool alt_) {
    m_alt = alt_;
    return *this;
  }
  ZuVFmt &fp(int ndp = -ZuFmt::MaxNDP, char trim = '\0') {
    using namespace ZuFmt;
    m_ndp = __builtin_expect(!!(ndp < -MaxNDP), 0) ? -MaxNDP :
      __builtin_expect(!!(ndp > MaxNDP), 0)        ? MaxNDP :
						     ndp;
    m_trim = trim;
    return *this;
  }

  int justification() const { return m_justification; }
  bool hex() const { return m_hex; }
  bool upper() const { return m_upper; }
  bool alt() const { return m_alt; }
  char comma() const { return m_comma; }
  unsigned width() const { return m_width; }
  int pad() const { return m_pad; }
  int ndp() const { return m_ndp; }
  char trim() const { return m_trim; }

private:
  int8_t m_justification;
  uint8_t m_hex:1, m_upper:1, m_alt:1;
  char m_comma;
  uint8_t m_width;
  int8_t m_pad;
  int8_t m_ndp;
  char m_trim;
};

template <typename Impl> struct ZuVFmtWrapper {
  ZuVFmt fmt;

  auto impl() const { return static_cast<const Impl *>(this); }
  auto impl() { return static_cast<Impl *>(this); }

  Impl &reset() {
    fmt.reset();
    return *impl();
  }
  Impl &left(unsigned width, char pad = '\0') {
    fmt.left(width, pad);
    return *impl();
  }
  Impl &right(unsigned width, char pad = '0') {
    fmt.right(width, pad);
    return *impl();
  }
  Impl &frac(unsigned width, unsigned ndp, char trim = '\0') {
    fmt.frac(width, ndp, trim);
    return *impl();
  }
  Impl &hex() {
    fmt.hex();
    return *impl();
  }
  Impl &hex(bool upper) {
    fmt.hex(upper);
    return *impl();
  }
  Impl &hex(bool hex_, bool upper) {
    fmt.hex(hex_, upper);
    return *impl();
  }
  Impl &comma(char comma_ = ',') {
    fmt.comma(comma_);
    return *impl();
  }
  Impl &alt() {
    fmt.alt();
    return *impl();
  }
  Impl &alt(bool alt_) {
    fmt.alt(alt_);
    return *impl();
  }
  Impl &fp(int ndp = -ZuFmt::MaxNDP, char trim = '\0') {
    fmt.fp(ndp, trim);
    return *impl();
  }
};

namespace ZuDecimalFn {
inline constexpr const unsigned pow10_32(unsigned i) {
  static constexpr unsigned pow10[] = {1U,         10U,       100U,
				       1000U,      10000U,    100000U,
				       1000000U,   10000000U, 100000000U,
				       1000000000U};
  return pow10[i];
}

inline constexpr const uint64_t pow10_64(unsigned i) {
  static constexpr uint64_t pow10[] = {
    1ULL,
    10ULL,
    100ULL,
    1000ULL,
    10000ULL,
    100000ULL,
    1000000ULL,
    10000000ULL,
    100000000ULL,
    1000000000ULL,
    10000000000ULL,
    100000000000ULL,
    1000000000000ULL,
    10000000000000ULL,
    100000000000000ULL,
    1000000000000000ULL,
    10000000000000000ULL,
    100000000000000000ULL,
    1000000000000000000ULL,
    10000000000000000000ULL
  };
  return pow10[i];
}

inline constexpr const uint128_t pow10_128(unsigned i) {
  uint128_t v;
  if (__builtin_expect(!!(i < 20U), 1))
    v = pow10_64(i);
  else
    v = uint128_t(pow10_64(i - 19U)) * uint128_t(10000000000000000000ULL);
  return v;
}

template <unsigned Size>
inline ZuIfT<Size <= 4, const uint32_t> pow10(unsigned v) {
  return pow10_32(v);
}
template <unsigned Size>
inline ZuIfT<Size == 8, const uint64_t> pow10(unsigned v) {
  return pow10_64(v);
}
template <unsigned Size>
inline ZuIfT<Size == 16, const uint128_t> pow10(unsigned v) {
  return pow10_128(v);
}

template <unsigned I> struct Pow10 { };
template <> struct Pow10<0U> : public ZuConstant<unsigned, 1U> { };
template <> struct Pow10<1U> : public ZuConstant<unsigned, 10U> { };
template <> struct Pow10<2U> : public ZuConstant<unsigned, 100U> { };
template <> struct Pow10<3U> : public ZuConstant<unsigned, 1000U> { };
template <> struct Pow10<4U> : public ZuConstant<unsigned, 10000U> { };
template <> struct Pow10<5U> : public ZuConstant<unsigned, 100000U> { };
template <> struct Pow10<6U> : public ZuConstant<unsigned, 1000000U> { };
template <> struct Pow10<7U> : public ZuConstant<unsigned, 10000000U> { };
template <> struct Pow10<8U> : public ZuConstant<unsigned, 100000000U> { };
template <> struct Pow10<9U> : public ZuConstant<unsigned, 1000000000U> { };
template <> struct Pow10<10U> : public ZuConstant<uint64_t, 10000000000ULL> { };
template <>
struct Pow10<11U> : public ZuConstant<uint64_t, 100000000000ULL> { };
template <>
struct Pow10<12U> : public ZuConstant<uint64_t, 1000000000000ULL> { };
template <>
struct Pow10<13U> : public ZuConstant<uint64_t, 10000000000000ULL> { };
template <>
struct Pow10<14U> : public ZuConstant<uint64_t, 100000000000000ULL> { };
template <>
struct Pow10<15U> : public ZuConstant<uint64_t, 1000000000000000ULL> { };
template <>
struct Pow10<16U> : public ZuConstant<uint64_t, 10000000000000000ULL> { };
template <>
struct Pow10<17U> : public ZuConstant<uint64_t, 100000000000000000ULL> { };
template <>
struct Pow10<18U> : public ZuConstant<uint64_t, 1000000000000000000ULL> { };
template <>
struct Pow10<19U> : public ZuConstant<uint64_t, 10000000000000000000ULL> { };
template <unsigned I>
struct Pow10_128 :
  public ZuConstant<
    uint128_t,
    static_cast<uint128_t>(Pow10<I - 19U>{}) *
      static_cast<uint128_t>(10000000000000000000ULL)> { };
template <> struct Pow10<20U> : public Pow10_128<20U> { };
template <> struct Pow10<21U> : public Pow10_128<21U> { };
template <> struct Pow10<22U> : public Pow10_128<22U> { };
template <> struct Pow10<23U> : public Pow10_128<23U> { };
template <> struct Pow10<24U> : public Pow10_128<24U> { };
template <> struct Pow10<25U> : public Pow10_128<25U> { };
template <> struct Pow10<26U> : public Pow10_128<26U> { };
template <> struct Pow10<27U> : public Pow10_128<27U> { };
template <> struct Pow10<28U> : public Pow10_128<28U> { };
template <> struct Pow10<29U> : public Pow10_128<29U> { };
template <> struct Pow10<30U> : public Pow10_128<30U> { };
template <> struct Pow10<31U> : public Pow10_128<31U> { };
template <> struct Pow10<32U> : public Pow10_128<32U> { };
template <> struct Pow10<33U> : public Pow10_128<33U> { };
template <> struct Pow10<34U> : public Pow10_128<34U> { };
template <> struct Pow10<35U> : public Pow10_128<35U> { };
template <> struct Pow10<36U> : public Pow10_128<36U> { };
template <> struct Pow10<37U> : public Pow10_128<37U> { };
template <> struct Pow10<38U> : public Pow10_128<38U> { };
template <> struct Pow10<39U> : public Pow10_128<39U> { };
} // namespace ZuDecimalFn

namespace Zu_ntoa {
using namespace ZuFmt;

template <typename T_, unsigned Size = sizeof(T_)> struct Unsigned_;
template <typename T_> struct Unsigned_<T_, 1> {
  using T = uint8_t;
};
template <typename T_> struct Unsigned_<T_, 2> {
  using T = uint16_t;
};
template <typename T_> struct Unsigned_<T_, 4> {
  using T = uint32_t;
};
template <typename T_> struct Unsigned_<T_, 8> {
  using T = uint64_t;
};
template <typename T_> struct Unsigned_<T_, 16> {
  using T = uint128_t;
};
template <typename T> using Unsigned = typename Unsigned_<T>::T;

template <typename T, typename R = void>
using Is128Bit = ZuIfT<(sizeof(T) > 8) && ZuTraits<T>::IsIntegral, R>;
template <typename T, typename R = void>
using Is64Bit = ZuIfT<(sizeof(T) <= 8) && ZuTraits<T>::IsIntegral, R>;

template <unsigned Size> struct Log10_MaxLog;
template <> struct Log10_MaxLog<1U> {
  enum { N = 3 };
};
template <> struct Log10_MaxLog<2U> {
  enum { N = 5 };
};
template <> struct Log10_MaxLog<4U> {
  enum { N = 10 };
};
template <> struct Log10_MaxLog<8U> {
  enum { N = 20 };
};
template <> struct Log10_MaxLog<16U> {
  enum { N = 39 };
};

template <unsigned Size> struct Log16_MaxLog {
  enum { N = (Size << 1U) };
};

template <unsigned Size, bool Hex>
struct LogN_MaxLog : public Log10_MaxLog<Size> { };
template <unsigned Size>
struct LogN_MaxLog<Size, 1> : public Log16_MaxLog<Size> { };

template <unsigned Size> struct Log10;
template <> struct Log10<1> {
  inline static unsigned log(unsigned v) {
    unsigned l;
    if (__builtin_expect(!!(v < 10U), 1))
      l = 1U;
    else if (__builtin_expect(!!(v < 100U), 1))
      l = 2U;
    else
      l = 3U;
    return l;
  }
};
template <> struct Log10<4> {
  static unsigned log(unsigned v) {
    static constexpr uint8_t clz10[] = {20, 20, 19, 18, 18, 17, 16, 16,
					15, 14, 14, 14, 13, 12, 12, 11,
					10, 10, 9,  8,  8,  8,  7,  6,
					6,  5,  4,  4,  3,  2,  2,  2};
    unsigned l;
    if (__builtin_expect(!!(!v), 0))
      l = 1U;
    else {
      unsigned n = clz10[ZuIntrin::clz(v)];
      if (__builtin_expect(!!(!(n & 1U)), 1))
	l = n >> 1U;
      else {
	n >>= 1U;
	l = n + (v >= ZuDecimalFn::pow10_32(n));
      }
    }
    return l;
  }
};
template <> struct Log10<2> : public Log10<4> { };
template <> struct Log10<8> {
  static unsigned log(uint64_t v) {
    static constexpr uint8_t clz10[] = {
      39, 38, 38, 38, 37, 36, 36, 35, 34, 34, 33, 32, 32, 32, 31, 30,
      30, 29, 28, 28, 27, 26, 26, 26, 25, 24, 24, 23, 22, 22, 21, 20,
      20, 20, 19, 18, 18, 17, 16, 16, 15, 14, 14, 14, 13, 12, 12, 11,
      10, 10, 9,  8,  8,  8,  7,  6,  6,  5,  4,  4,  3,  2,  2,  2
    };
    unsigned l;
    if (__builtin_expect(!!(!v), 0))
      l = 1U;
    else {
      unsigned n = clz10[ZuIntrin::clz(v)];
      if (__builtin_expect(!!(!(n & 1U)), 1))
	l = n >> 1U;
      else {
	n >>= 1U;
	l = n + (v >= ZuDecimalFn::pow10_64(n));
      }
    }
    return l;
  }
};
template <> struct Log10<16> {
  static unsigned log(uint128_t v) {
    constexpr uint128_t f = static_cast<uint128_t>(10000000000000000000ULL);
    unsigned l;
    if (__builtin_expect(!!(v < f), 1))
      l = Log10<8>::log(v);
    else {
      v /= f;
      if (__builtin_expect(!!(v < f), 1))
	l = Log10<8>::log(v) + 19U;
      else {
	v /= f;
	l = Log10<4>::log(v) + 38U;
      }
    }
    return l;
  }
};

struct Log10FP {
  template <unsigned Bits> static unsigned log(uint64_t v) {
    static constexpr uint8_t clz10[] = {
      2,  2,  2,  3,  4,  4,  5,  6,  6,  7,  8,  8,  8,  9,  10, 10, 11,
      12, 12, 13, 14, 14, 14, 15, 16, 16, 17, 18, 18, 19, 20, 20, 20, 21,
      22, 22, 23, 24, 24, 25, 26, 26, 26, 27, 28, 28, 29, 30, 30, 31, 32,
      32, 32, 33, 34, 34, 35, 36, 36, 37, 38, 38, 38, 39, 40
    };
    unsigned digits = clz10[Bits];
    digits = (digits >> 1U) + (digits & 1U);
    unsigned l;
    if (__builtin_expect(!!(v), 1)) {
      unsigned f = 64U - ZuIntrin::clz(v);
      unsigned i = clz10[f - 1];
      i = (i >> 1U) +
	((__builtin_expect(!!(i & 1U), 0)) &&
	 (v >= ZuDecimalFn::pow10_64(i >> 1U)));
      if (__builtin_expect(!!(f < Bits), 1)) {
	f = clz10[(Bits - f) - 1];
	f = (f >> 1U) + (f & 1U);
      } else
	f = 0U;
      if (__builtin_expect(!!((i + f) > digits), 0))
	f = (__builtin_expect(!!(i > digits), 0) ? 0U : digits - i);
      l = (i << 8U) | f;
    } else {
      l = (1U << 8U) | (digits - 1U);
    }
    return l;
  }
};

template <typename T>
inline uint64_t frac(T v, uint64_t &iv, unsigned &i, unsigned f) {
  uint64_t fv = 0;
  if (__builtin_expect(!!(f), 1)) {
    uint64_t pow10 = ZuDecimalFn::pow10_64(f);
    v = (v - (T)iv) * (T)pow10;
    if (__builtin_expect(!!(v >= (T)0.5), 1)) {
      fv = (uint64_t)v;
      if (__builtin_expect(!!((T)0.5 < (v - (T)fv)), 0)) ++fv;
      if (__builtin_expect(!!(fv >= pow10), 0)) {
	if (__builtin_expect(!!(++iv >= ZuDecimalFn::pow10_64(i)), 0)) ++i;
	fv = 0;
      }
    }
  }
  return fv;
}

template <typename T>
inline Is64Bit<T> Base10_print(T v_, unsigned n, char *buf) {
  uint64_t v = v_;
  while (__builtin_expect(!!(n), 1)) {
    buf[--n] = (v % 10) + '0';
    v /= 10;
  }
}
template <typename T>
inline Is128Bit<T> Base10_print(T v_, unsigned n, char *buf) {
  uint128_t v = v_;
  if (__builtin_expect(!!(v < 10000000000000000000ULL), 1))
    Base10_print((uint64_t)v, n, buf);
  else
    while (__builtin_expect(!!(n), 1)) {
      buf[--n] = (v % 10) + '0';
      v /= 10;
    }
}
template <typename T>
inline Is64Bit<T> Base10_print_comma(T v_, unsigned n, char *buf, char comma) {
  if (__builtin_expect(!!(!n), 0)) return;
  uint64_t v = v_;
  unsigned c = 3;
  if (__builtin_expect(!!(n), 1))
    for (;;) {
      buf[--n] = (v % 10) + '0';
      v /= 10;
      if (__builtin_expect(!!(!n), 0)) break;
      if (__builtin_expect(!!(!--c), 0)) {
	buf[--n] = comma;
	c = 3;
      }
    }
}
template <typename T>
inline Is128Bit<T> Base10_print_comma(T v_, unsigned n, char *buf, char comma) {
  uint128_t v = v_;
  if (__builtin_expect(!!(v < 10000000000000000000ULL), 1))
    Base10_print_comma((uint64_t)v, n, buf, comma);
  else {
    unsigned c = 3;
    if (__builtin_expect(!!(n), 1))
      for (;;) {
	buf[--n] = (v % 10) + '0';
	v /= 10;
	if (__builtin_expect(!!(!n), 0)) break;
	if (__builtin_expect(!!(!--c), 0)) {
	  buf[--n] = comma;
	  c = 3;
	}
      }
  }
}
template <typename T>
inline void Base10_print_frac(T v, unsigned m, unsigned n, char c, char *buf) {
  if (__builtin_expect(!!(n < m), 0)) v /= ZuDecimalFn::pow10<sizeof(T)>(m - n);
  Base10_print(v, n, buf);
  if (__builtin_expect(!!(n), 1))
    for (;;) {
      if (buf[--n] != '0') return;
      if (__builtin_expect(!!(n <= 1), 0)) return;
      buf[n] = c;
    }
}
template <typename T>
inline unsigned
Base10_print_frac_truncate(T v, unsigned m, unsigned n, char *buf) {
  if (__builtin_expect(!!(n < m), 0)) v /= ZuDecimalFn::pow10<sizeof(T)>(m - n);
  Base10_print(v, n, buf);
  if (__builtin_expect(!!(!n), 0)) return 0;
  for (;;) {
    if (buf[--n] != '0') return n + 1;
    if (__builtin_expect(!!(n <= 1), 0)) return 1;
    buf[n] = 0;
  }
}
template <char Comma> struct Base10 {
  template <typename T> inline static void print(T v, unsigned n, char *buf) {
    Base10_print_comma(v, n, buf, Comma);
  }
};
template <> struct Base10<'\0'> {
  template <typename T> inline static void print(T v, unsigned n, char *buf) {
    Base10_print(v, n, buf);
  }
};

template <unsigned Size> struct Log16;
template <> struct Log16<1> {
  inline static unsigned log(unsigned v) {
    return __builtin_expect(!!(v < 0x10), 1) ? 1U : 2U;
  }
};
template <> struct Log16<4> {
  inline static unsigned log(uint32_t v) {
    return __builtin_expect(!!(!v), 0) ? 1U : (35U - ZuIntrin::clz(v)) >> 2;
  }
};
template <> struct Log16<2> : public Log16<4> { };
template <> struct Log16<8> {
  inline static unsigned log(uint64_t v) {
    return __builtin_expect(!!(!v), 0) ? 1U : (67U - ZuIntrin::clz(v)) >> 2;
  }
};
template <> struct Log16<16> {
  inline static unsigned log(uint128_t v) {
    return __builtin_expect(!!(!(v >> 64)), 1) ? Log16<8>::log(v) :
						 Log16<8>::log(v >> 64) + 16U;
  }
};

template <bool Hex, unsigned Size> struct LogN;
template <unsigned Size> struct LogN<0, Size> : public Log10<Size> { };
template <unsigned Size> struct LogN<1, Size> : public Log16<Size> { };

template <bool Upper> inline static ZuIfT<Upper, char> hexDigit(unsigned v) {
  static constexpr const char digits[] = "0123456789ABCDEF";
  return digits[v];
}
template <bool Upper> inline static ZuIfT<!Upper, char> hexDigit(unsigned v) {
  static constexpr const char digits[] = "0123456789abcdef";
  return digits[v];
}
template <typename T> Is64Bit<T> Base16_print(T v_, unsigned n, char *buf) {
  uint64_t v = v_;
  while (__builtin_expect(!!(n), 1)) {
    buf[--n] = hexDigit<0>(v & 0xf);
    v >>= 4U;
  }
}
template <typename T> Is128Bit<T> Base16_print(T v_, unsigned n, char *buf) {
  uint128_t v = v_;
  if (__builtin_expect(!!(!(v >> 64U)), 1))
    Base16_print((uint64_t)v, n, buf);
  else
    while (__builtin_expect(!!(n), 1)) {
      buf[--n] = hexDigit<0>(v & 0xf);
      v >>= 4U;
    }
}
template <typename T>
Is64Bit<T> Base16_print_upper(T v_, unsigned n, char *buf) {
  uint64_t v = v_;
  while (__builtin_expect(!!(n), 1)) {
    buf[--n] = hexDigit<1>(v & 0xf);
    v >>= 4U;
  }
}
template <typename T>
Is128Bit<T> Base16_print_upper(T v_, unsigned n, char *buf) {
  uint128_t v = v_;
  if (__builtin_expect(!!(!(v >> 64U)), 1))
    Base16_print_upper((uint64_t)v, n, buf);
  else
    while (__builtin_expect(!!(n), 1)) {
      buf[--n] = hexDigit<1>(v & 0xf);
      v >>= 4U;
    }
}
template <bool Upper> struct Base16 {
  template <typename T> inline static void print(T v, unsigned n, char *buf) {
    Base16_print(v, n, buf);
  }
};
template <> struct Base16<1> {
  template <typename T> inline static void print(T v, unsigned n, char *buf) {
    Base16_print_upper(v, n, buf);
  }
};

template <bool Hex, char Comma, bool Upper, bool Alt>
struct BaseN : public Base10<Comma> { };
template <char Comma, bool Upper>
struct BaseN<1, Comma, Upper, 0> : public Base16<Upper> { };
template <char Comma, bool Upper>
struct BaseN<1, Comma, Upper, 1> : public Base16<Upper> {
  template <typename T> inline static void print(T v, unsigned n, char *buf) {
    *buf++ = '0';
    *buf++ = 'x';
    Base16<Upper>::print(v, n - 2, buf);
  }
};

template <bool Hex, char Comma, bool Alt> struct Len;
template <bool Alt> struct Len<0, '\0', Alt> {
  inline static constexpr unsigned len(unsigned n) { return n; }
};
template <char Comma, bool Alt> struct Len<0, Comma, Alt> {
  inline static constexpr unsigned len(unsigned n) {
    return n + ((n - 1U) / 3U);
  }
};
template <char Comma> struct Len<1, Comma, 0> {
  inline static constexpr unsigned len(unsigned n) { return n; }
};
template <char Comma> struct Len<1, Comma, 1> {
  inline static constexpr unsigned len(unsigned n) { return 2 + n; }
};

template <
  bool Hex, char Comma, bool Alt, int Justification, unsigned Width, int NDP,
  bool Negative, unsigned Log>
struct MaxLen {
  enum { N = Width };
};
template <
  bool Hex, char Comma, bool Alt, unsigned Width, int NDP, bool Negative,
  unsigned Log>
struct MaxLen<Hex, Comma, Alt, Just::Frac, Width, NDP, Negative, Log> {
  enum { N = NDP };
};
template <
  bool Hex, char Comma, bool Alt, unsigned Width, int NDP, bool Negative,
  unsigned Log>
struct MaxLen<Hex, Comma, Alt, Just::None, Width, NDP, Negative, Log> {
  enum {
    N = Negative +
      (Hex     ? (Alt ? 2U : 0U) :
	 Comma ? ((Log - 1U) / 3U) :
		 0U) +
      Log
  };
};

template <bool Hex, char Comma, bool Upper, bool Alt, bool Negative>
struct Print_;
template <bool Hex, char Comma, bool Upper, bool Alt>
struct Print_<Hex, Comma, Upper, Alt, 0> {
  template <typename T>
  inline static unsigned print(T v, unsigned n, char *buf) {
    n = Len<Hex, Comma, Alt>::len(n);
    BaseN<Hex, Comma, Upper, Alt>::print(v, n, buf);
    return n;
  }
};
template <bool Hex, char Comma, bool Upper, bool Alt>
struct Print_<Hex, Comma, Upper, Alt, 1> {
  template <typename T>
  inline static unsigned print(T v, unsigned n, char *buf) {
    n = Len<Hex, Comma, Alt>::len(n);
    *buf++ = '-';
    BaseN<Hex, Comma, Upper, Alt>::print(v, n, buf);
    return n + 1;
  }
};

template <unsigned Width, bool Truncate> struct Print_LeftLen;
template <unsigned Width> struct Print_LeftLen<Width, 0> {
  inline static constexpr unsigned len(unsigned) { return Width; }
};
template <unsigned Width> struct Print_LeftLen<Width, 1> {
  inline static constexpr unsigned len(unsigned n) { return n; }
};
template <
  bool Hex, char Comma, bool Upper, bool Alt, char Pad, unsigned Width,
  bool Negative>
struct Print_Left;
template <bool Hex, char Comma, bool Upper, bool Alt, char Pad, unsigned Width>
struct Print_Left<Hex, Comma, Upper, Alt, Pad, Width, 0> {
  template <typename T>
  inline static unsigned print(T v, unsigned n, char *buf) {
    n = Len<Hex, Comma, Alt>::len(n);
    if (__builtin_expect(!!(n > Width), 0)) return 0;
    BaseN<Hex, Comma, Upper, Alt>::print(v, n, buf);
    if (__builtin_expect(!!(n < Width), 1)) memset(buf + n, Pad, Width - n);
    return Print_LeftLen<Width, Pad == 0>::len(n);
  }
};
template <bool Hex, char Comma, bool Upper, bool Alt, char Pad, unsigned Width>
struct Print_Left<Hex, Comma, Upper, Alt, Pad, Width, 1> {
  template <typename T>
  inline static unsigned print(T v, unsigned n, char *buf) {
    n = Len<Hex, Comma, Alt>::len(n) + 1;
    if (__builtin_expect(!!(n > Width), 0)) return 0;
    *buf++ = '-';
    BaseN<Hex, Comma, Upper, Alt>::print(v, n - 1, buf);
    if (__builtin_expect(!!(n < Width), 1)) memset(buf + n - 1, Pad, Width - n);
    return Print_LeftLen<Width, Pad == 0>::len(n);
  }
};

template <
  bool Hex, char Comma, bool Upper, bool Alt, char Pad, unsigned Width,
  bool Negative>
struct Print_Right;
template <bool Hex, char Comma, bool Upper, bool Alt, char Pad, unsigned Width>
struct Print_Right<Hex, Comma, Upper, Alt, Pad, Width, 0> {
  template <typename T>
  inline static unsigned print(T v, unsigned n, char *buf) {
    n = Len<Hex, Comma, Alt>::len(n);
    if (__builtin_expect(!!(n > Width), 0)) return 0;
    if (__builtin_expect(!!(n < Width), 1)) memset(buf, Pad, Width - n);
    BaseN<Hex, Comma, Upper, Alt>::print(v, n, buf + Width - n);
    return Width;
  }
};
template <bool Hex, char Comma, bool Upper, bool Alt, char Pad, unsigned Width>
struct Print_Right<Hex, Comma, Upper, Alt, Pad, Width, 1> {
  template <typename T>
  inline static unsigned print(T v, unsigned n, char *buf) {
    n = Len<Hex, Comma, Alt>::len(n) + 1;
    if (__builtin_expect(!!(n > Width), 0)) return 0;
    if (__builtin_expect(!!(n < Width), 1)) memset(buf, Pad, Width - n);
    buf += Width - n;
    *buf++ = '-';
    BaseN<Hex, Comma, Upper, Alt>::print(v, n - 1, buf);
    return Width;
  }
};
template <bool Hex, char Comma, bool Upper, bool Alt, unsigned Width>
struct Print_Right<Hex, Comma, Upper, Alt, '0', Width, 1> {
  template <typename T>
  inline static unsigned print(T v, unsigned n, char *buf) {
    n = Len<Hex, Comma, Alt>::len(n) + 1;
    if (__builtin_expect(!!(n > Width), 0)) return 0;
    *buf++ = '-';
    if (__builtin_expect(!!(n < Width), 1)) memset(buf, '0', Width - n);
    buf += Width - n;
    BaseN<Hex, Comma, Upper, Alt>::print(v, n - 1, buf);
    return Width;
  }
};
template <char Comma, bool Upper, unsigned Width>
struct Print_Right<1, Comma, Upper, 1, '0', Width, 0> {
  template <typename T>
  inline static unsigned print(T v, unsigned n, char *buf) {
    n = Len<1, 0, 0>::len(n) + 2;
    if (__builtin_expect(!!(n > Width), 0)) return 0;
    *buf++ = '0';
    *buf++ = 'x';
    if (__builtin_expect(!!(n < Width), 1)) memset(buf, '0', Width - n);
    BaseN<1, 0, Upper, 0>::print(v, n - 2, buf + Width - n);
    return Width;
  }
};
template <char Comma, bool Upper, unsigned Width>
struct Print_Right<1, Comma, Upper, 1, '0', Width, 1> {
  template <typename T>
  inline static unsigned print(T v, unsigned n, char *buf) {
    n = Len<1, 0, 0>::len(n) + 3;
    if (__builtin_expect(!!(n > Width), 0)) return 0;
    *buf++ = '-';
    *buf++ = '0';
    *buf++ = 'x';
    if (__builtin_expect(!!(n < Width), 1)) memset(buf, '0', Width - n);
    buf += Width - n;
    BaseN<1, 0, Upper, 0>::print(v, n - 3, buf);
    return Width;
  }
};

template <
  bool Hex, char Comma, bool Upper, bool Alt, int Justification, unsigned Width,
  char Pad, bool Negative>
struct Print;
template <
  bool Hex, char Comma, bool Upper, bool Alt, unsigned Width, char Pad,
  bool Negative>
struct Print<Hex, Comma, Upper, Alt, Just::None, Width, Pad, Negative> :
  public Print_<Hex, Comma, Upper, Alt, Negative> { };
template <
  bool Hex, char Comma, bool Upper, bool Alt, unsigned Width, char Pad,
  bool Negative>
struct Print<Hex, Comma, Upper, Alt, Just::Left, Width, Pad, Negative> :
  public Print_Left<Hex, Comma, Upper, Alt, Pad, Width, Negative> { };
template <
  bool Hex, char Comma, bool Upper, bool Alt, unsigned Width, char Pad,
  bool Negative>
struct Print<Hex, Comma, Upper, Alt, Just::Right, Width, Pad, Negative> :
  public Print_Right<Hex, Comma, Upper, Alt, Pad, Width, Negative> { };

template <typename T> inline constexpr T ftoa_max() { return (T)(~0ULL); }
template <typename T> unsigned ftoa_variable(T v, unsigned f, char *buf) {
  using FP = ZuFP<T>;
  if (__builtin_expect(!!(FP::nan(v)), 0)) {
    *buf++ = 'n', *buf++ = 'a', *buf = 'n';
    return 3U;
  }
  bool negative = 0;
  if (v < 0) negative = 1, v = -v, *buf++ = '-';
  if (__builtin_expect(!!(v > ftoa_max<T>()), 0)) {
    *buf++ = 'i', *buf++ = 'n', *buf = 'f';
    return negative + 3U;
  }
  uint64_t iv = (uint64_t)v;
  unsigned i = Log10FP::log<FP::Bits>(iv);
  {
    unsigned j = i & 0xffU;
    if (f > j) f = j;
  }
  i >>= 8U;
  if (!f) {
    Base10_print(iv, i, buf);
    return negative + i;
  }
  uint64_t fv = frac(v, iv, i, f);
  Base10_print(iv, i, buf);
  if (!f || !fv) return negative + i;
  buf += i;
  *buf++ = '.';
  return negative + i + 1 + Base10_print_frac_truncate(fv, f, f, buf);
}
template <typename T> static unsigned ftoa_fixed(T v, unsigned f, char *buf) {
  using FP = ZuFP<T>;
  if (__builtin_expect(!!(FP::nan(v)), 0)) {
    *buf++ = 'n', *buf++ = 'a', *buf = 'n';
    return 3U;
  }
  bool negative = 0;
  if (v < 0) negative = 1, v = -v, *buf++ = '-';
  if (__builtin_expect(!!(v > ftoa_max<T>()), 0)) {
    *buf++ = 'i', *buf++ = 'n', *buf = 'f';
    return negative + 3U;
  }
  uint64_t iv = (uint64_t)v;
  unsigned i = Log10<8>::log(iv);
  uint64_t fv = frac(v, iv, i, f);
  Base10_print(iv, i, buf);
  if (!f) return negative + i;
  buf += i;
  *buf++ = '.';
  Base10_print(fv, f, buf);
  return negative + i + 1 + f;
}

template <char Comma, int NDP, char Trim, bool Fixed = NDP >= 0> struct FPrint {
  template <typename T> static unsigned ftoa(T v, char *buf) {
    using FP = ZuFP<T>;
    if (__builtin_expect(!!(FP::nan(v)), 0)) {
      *buf++ = 'n', *buf++ = 'a', *buf = 'n';
      return 3U;
    }
    bool negative = 0;
    if (__builtin_expect(!!(v < 0), 0)) negative = 1, v = -v, *buf++ = '-';
    if (__builtin_expect(!!(v > Zu_ntoa::ftoa_max<T>()), 0)) {
      *buf++ = 'i', *buf++ = 'n', *buf = 'f';
      return negative + 3U;
    }
    uint64_t iv = (uint64_t)v;
    int f = NDP;
    unsigned i;
    if constexpr (!Fixed) {
      i = Log10FP::log<FP::Bits>(iv);
      unsigned j = i & 0xffU;
      if ((unsigned)(f = -f) > j) f = j;
      i >>= 8U;
    } else
      i = Log10<8>::log(iv);
    uint64_t fv = frac(v, iv, i, f);
    if constexpr (!Comma) {
      Base10_print(iv, i, buf);
    } else {
      i += ((i - 1U) / 3U);
      Base10_print_comma(iv, i, buf, Comma);
    }
    if (!f || (!fv && !Fixed)) return negative + i;
    buf += i;
    *buf++ = '.';
    if constexpr (Fixed) {
      Base10_print(fv, f, buf);
      return negative + i + 1 + f;
    }
    if constexpr (!Trim)
      return negative + i + 1 + Base10_print_frac_truncate(fv, f, f, buf);
    Base10_print_frac(fv, f, f, Trim, buf);
    return negative + i + 1 + f;
  }
};
template <int NDP> struct FPrint<'\0', NDP, '\0', 0> {
  template <typename T> inline static unsigned ftoa(T v, char *buf) {
    return ftoa_variable(v, -NDP, buf);
  }
};
template <int NDP> struct FPrint<'\0', NDP, '\0', 1> {
  template <typename T> inline static unsigned ftoa(T v, char *buf) {
    return ftoa_fixed(v, NDP, buf);
  }
};
} // namespace Zu_ntoa

template <
  class Fmt = ZuFmt::Default,
  bool Frac = Fmt::Justification_ == ZuFmt::Just::Frac>
struct Zu_nprint {
  struct NFmt : public Fmt {
    enum { Negative_ = 1 };
  };
  template <bool Negative, typename T>
  using MaxLen = Zu_ntoa::MaxLen<
    Fmt::Hex_, Fmt::Comma_, Fmt::Alt_, Fmt::Justification_, Fmt::Width_,
    Fmt::NDP_, Negative, Zu_ntoa::LogN_MaxLog<sizeof(T), Fmt::Hex_>::N>;

  template <bool Negative>
  using Print_ = Zu_ntoa::Print<
    Fmt::Hex_, Fmt::Comma_, Fmt::Upper_, Fmt::Alt_, Fmt::Justification_,
    Fmt::Width_, Fmt::Pad_, Negative>;
  using Print = Print_<0>;
  using NPrint = Print_<1>;

  template <typename T> using Log = Zu_ntoa::LogN<Fmt::Hex_, sizeof(T)>;

  template <typename T> static constexpr unsigned ulen() {
    return MaxLen<0, T>::N;
  }
  template <typename T> static constexpr unsigned ulen(T) {
    return MaxLen<0, T>::N;
  }
  template <typename T> static unsigned utoa(T v_, char *buf) {
    typename Zu_ntoa::Unsigned<T> v = v_;
    return Print::print(v, Log<T>::log(v), buf);
  }

  template <typename T> static constexpr unsigned ilen() {
    return MaxLen<1, T>::N;
  }
  template <typename T> static constexpr unsigned ilen(T) {
    return MaxLen<1, T>::N;
  }
  template <typename T> static unsigned itoa(T v_, char *buf) {
    unsigned n;
    typename Zu_ntoa::Unsigned<T> v = v_;
    if (__builtin_expect(!!(v_ < 0), 0)) {
      v = ~v + 1;
      n = NPrint::print(v, Log<T>::log(v), buf);
    } else {
      n = Print::print(v, Log<T>::log(v), buf);
    }
    return n;
  }

  using FPrint = Zu_ntoa::FPrint<Fmt::Comma_, Fmt::NDP_, Fmt::Trim_>;

  template <typename T> static constexpr unsigned flen() {
    return 29U + (Fmt::Trim_ ? (Fmt::NDP_ > 1 ? (Fmt::NDP_ - 1) : 0) : 0);
  }
  template <typename T> static constexpr unsigned flen(T) { return flen<T>(); }
  template <typename T> inline static unsigned ftoa(T v, char *buf) {
    return FPrint::ftoa(v, buf);
  }
};
template <unsigned NDP> struct Zu_nprint_frac_ {
  template <typename T> static constexpr unsigned ulen() { return NDP; }
  template <typename T> static constexpr unsigned ulen(T) { return NDP; }
  template <typename T> static constexpr unsigned ilen() { return NDP; }
  template <typename T> static constexpr unsigned ilen(T) { return NDP; }
};
template <unsigned Width, unsigned NDP, char Trim>
struct Zu_nprint_frac : public Zu_nprint_frac_<NDP> {
  template <typename T> static unsigned utoa(T v, char *buf) {
    Zu_ntoa::Base10_print_frac(v, Width, NDP, Trim, buf);
    return NDP;
  }
  template <typename T> static unsigned itoa(T v_, char *buf) {
    typename Zu_ntoa::Unsigned<T> v = v_;
    if (__builtin_expect(!!(v_ < 0), 0)) v = ~v + 1;
    Zu_ntoa::Base10_print_frac(v, Width, NDP, Trim, buf);
    return NDP;
  }
};
template <unsigned Width, unsigned NDP>
struct Zu_nprint_frac<Width, NDP, '\0'> : public Zu_nprint_frac_<NDP> {
  template <typename T> static unsigned utoa(T v, char *buf) {
    return Zu_ntoa::Base10_print_frac_truncate(v, Width, NDP, buf);
  }
  template <typename T> static unsigned itoa(T v_, char *buf) {
    typename Zu_ntoa::Unsigned<T> v = v_;
    if (__builtin_expect(!!(v_ < 0), 0)) v = ~v + 1;
    return Zu_ntoa::Base10_print_frac_truncate(v, Width, NDP, buf);
  }
};
template <unsigned Width, unsigned NDP>
struct Zu_nprint_frac<Width, NDP, '0'> : public Zu_nprint_frac_<NDP> {
  template <typename T> static unsigned utoa(T v, char *buf) {
    Zu_ntoa::Base10_print(v, NDP, buf);
    return NDP;
  }
  template <typename T> static unsigned itoa(T v_, char *buf) {
    typename Zu_ntoa::Unsigned<T> v = v_;
    if (__builtin_expect(!!(v_ < 0), 0)) v = ~v + 1;
    Zu_ntoa::Base10_print(v, NDP, buf);
    return NDP;
  }
};
template <class Fmt>
struct Zu_nprint<Fmt, true> :
  public Zu_nprint_frac<Fmt::Width_, Fmt::NDP_, Fmt::Trim_> { };

template <typename T> inline constexpr unsigned Zu_ulen() {
  return Zu_nprint<>::ulen<T>();
}
template <typename T> inline constexpr unsigned Zu_ulen(T v) {
  return Zu_nprint<>::ulen(v);
}
template <typename T> inline unsigned Zu_utoa(T v, char *buf) {
  return Zu_nprint<>::utoa(v, buf);
}

template <typename T> inline constexpr unsigned Zu_ilen() {
  return Zu_nprint<>::ilen<T>();
}
template <typename T> inline constexpr unsigned Zu_ilen(T v) {
  return Zu_nprint<>::ilen(v);
}
template <typename T> inline unsigned Zu_itoa(T v, char *buf) {
  return Zu_nprint<>::itoa(v, buf);
}

template <typename T> inline constexpr unsigned Zu_flen() {
  return Zu_nprint<>::flen<T>();
}
template <typename T> inline constexpr unsigned Zu_flen(T) {
  return Zu_nprint<>::flen<T>();
}
template <typename T> inline unsigned Zu_ftoa(T v, char *buf) {
  return Zu_nprint<>::ftoa(v, buf);
}

struct Zu_vprint {
  template <typename T> static unsigned ulen(const ZuVFmt &fmt) {
    switch (fmt.justification()) {
    default:
      break;
    case ZuFmt::Just::Left:
    case ZuFmt::Just::Right:
      return fmt.width();
    case ZuFmt::Just::Frac:
      return fmt.ndp();
    }
    if (fmt.hex())
      return Zu_ntoa::Log16_MaxLog<sizeof(T)>::N + (fmt.alt() << 1U);
    unsigned i = Zu_ntoa::Log10_MaxLog<sizeof(T)>::N;
    if (fmt.comma()) i += ((i - 1U) / 3U);
    return i;
  }
  template <typename T> inline static unsigned ulen(const ZuVFmt &fmt, T) {
    return ulen<T>(fmt);
  }
  template <typename T>
  static unsigned utoa_hex(const ZuVFmt &fmt, T v, char *buf) {
    unsigned n = Zu_ntoa::Log16<sizeof(T)>::log(v);
    unsigned a = ((unsigned)fmt.alt()) << 1U;
    if (__builtin_expect(!!(fmt.justification() == ZuFmt::Just::None), 1)) {
      if (a) *buf++ = '0', *buf++ = 'x';
      if (!fmt.upper())
	Zu_ntoa::Base16_print(v, n, buf);
      else
	Zu_ntoa::Base16_print_upper(v, n, buf);
      return n + a;
    }
    int w = (int)fmt.width() - a;
    if (w < (int)n) return 0U;
    char pad = fmt.pad();
    if (__builtin_expect(!!(fmt.justification() == ZuFmt::Just::Right), 1)) {
      if (a && pad == '0') *buf++ = '0', *buf++ = 'x';
      if ((unsigned)w > n) memset(buf, pad, (unsigned)w - n);
      buf += (unsigned)w - n;
      if (a && pad != '0') *buf++ = '0', *buf++ = 'x';
      if (!fmt.upper())
	Zu_ntoa::Base16_print(v, n, buf);
      else
	Zu_ntoa::Base16_print_upper(v, n, buf);
      return (unsigned)w + a;
    }
    if (__builtin_expect(!!(fmt.justification() == ZuFmt::Just::Left), 1)) {
      if (a) { *buf++ = '0', *buf++ = 'x'; }
      if (!fmt.upper())
	Zu_ntoa::Base16_print(v, n, buf);
      else
	Zu_ntoa::Base16_print_upper(v, n, buf);
      if ((unsigned)w > n) memset(buf + n, pad, (unsigned)w - n);
      return (unsigned)w + a;
    }
    return 0;
  }
  template <typename T>
  static unsigned utoa(const ZuVFmt &fmt, T v, char *buf) {
    if (__builtin_expect(!!(fmt.hex()), 0)) return utoa_hex(fmt, v, buf);
    if (__builtin_expect(!!(fmt.justification() == ZuFmt::Just::Frac), 0)) {
      unsigned w = fmt.width();
      unsigned n = fmt.ndp();
      char trim = fmt.trim();
      if (__builtin_expect(!!(!trim), 1))
	return Zu_ntoa::Base10_print_frac_truncate(v, w, n, buf);
      if (__builtin_expect(!!(trim == '0'), 0)) {
	Zu_ntoa::Base10_print(v, n, buf);
	return n;
      }
      Zu_ntoa::Base10_print_frac(v, w, n, trim, buf);
      return n;
    }
    unsigned n = Zu_ntoa::Log10<sizeof(T)>::log(v);
    char comma = fmt.comma();
    if (comma) n += ((n - 1U) / 3U);
    if (__builtin_expect(!!(fmt.justification() == ZuFmt::Just::None), 1)) {
      if (__builtin_expect(!!(!comma), 1))
	Zu_ntoa::Base10_print(v, n, buf);
      else
	Zu_ntoa::Base10_print_comma(v, n, buf, comma);
      return n;
    }
    unsigned w = fmt.width();
    if (w < n) return 0U;
    if (__builtin_expect(!!(fmt.justification() == ZuFmt::Just::Right), 1)) {
      if (w > n) {
	memset(buf, fmt.pad(), w - n);
	buf += w - n;
      }
      if (__builtin_expect(!!(!comma), 1))
	Zu_ntoa::Base10_print(v, n, buf);
      else
	Zu_ntoa::Base10_print_comma(v, n, buf, comma);
      return w;
    }
    if (__builtin_expect(!!(fmt.justification() == ZuFmt::Just::Left), 1)) {
      if (__builtin_expect(!!(!comma), 1))
	Zu_ntoa::Base10_print(v, n, buf);
      else
	Zu_ntoa::Base10_print_comma(v, n, buf, comma);
      if (w > n) memset(buf + n, fmt.pad(), w - n);
      return w;
    }
    return 0;
  }
  template <typename T> inline static unsigned ilen(const ZuVFmt &fmt) {
    return ulen<T>(fmt) + 1;
  }
  template <typename T> inline static unsigned ilen(const ZuVFmt &fmt, T) {
    return ulen<T>(fmt) + 1;
  }
  template <typename T>
  static unsigned itoa_hex(const ZuVFmt &fmt, T v_, char *buf) {
    bool m = v_ < 0;
    typename Zu_ntoa::Unsigned<T> v = v_;
    if (__builtin_expect(!!(m), 0)) v = ~v + 1;
    unsigned n = Zu_ntoa::Log16<sizeof(T)>::log(v);
    unsigned a = ((unsigned)fmt.alt()) << 1U;
    if (__builtin_expect(!!(fmt.justification() == ZuFmt::Just::None), 1)) {
      if (m) *buf++ = '-';
      if (a) *buf++ = '0', *buf++ = 'x';
      if (!fmt.upper())
	Zu_ntoa::Base16_print(v, n, buf);
      else
	Zu_ntoa::Base16_print_upper(v, n, buf);
      return n + a + m;
    }
    int w = (int)fmt.width() - (a + m);
    if (w < (int)n) return 0U;
    char pad = fmt.pad();
    if (__builtin_expect(!!(fmt.justification() == ZuFmt::Just::Right), 1)) {
      if (m && pad == '0') *buf++ = '-';
      if (a && pad == '0') *buf++ = '0', *buf++ = 'x';
      if ((unsigned)w > n) {
	memset(buf, pad, (unsigned)w - n);
	buf += (unsigned)w - n;
      }
      if (m && pad != '0') *buf++ = '-';
      if (a && pad != '0') *buf++ = '0', *buf++ = 'x';
      if (!fmt.upper())
	Zu_ntoa::Base16_print(v, n, buf);
      else
	Zu_ntoa::Base16_print_upper(v, n, buf);
      return (unsigned)w + a + m;
    }
    if (__builtin_expect(!!(fmt.justification() == ZuFmt::Just::Left), 1)) {
      if (m) *buf++ = '-';
      if (a) *buf++ = '0', *buf++ = 'x';
      if (!fmt.upper())
	Zu_ntoa::Base16_print(v, n, buf);
      else
	Zu_ntoa::Base16_print_upper(v, n, buf);
      if ((unsigned)w > n) memset(buf + n, pad, (unsigned)w - n);
      return (unsigned)w + a + m;
    }
    return 0;
  }
  template <typename T>
  static unsigned itoa(const ZuVFmt &fmt, T v_, char *buf) {
    if (__builtin_expect(!!(fmt.hex()), 0)) return itoa_hex(fmt, v_, buf);
    if (__builtin_expect(!!(fmt.justification() == ZuFmt::Just::Frac), 0)) {
      unsigned w = fmt.width();
      unsigned n = fmt.ndp();
      typename Zu_ntoa::Unsigned<T> v = v_;
      if (__builtin_expect(!!(v_ < 0), 0)) v = ~v + 1;
      char trim = fmt.trim();
      if (__builtin_expect(!!(!trim), 1))
	return Zu_ntoa::Base10_print_frac_truncate(v, w, n, buf);
      if (__builtin_expect(!!(trim == '0'), 0)) {
	Zu_ntoa::Base10_print(v, n, buf);
	return n;
      }
      Zu_ntoa::Base10_print_frac(v, w, n, trim, buf);
      return n;
    }
    bool m = v_ < 0;
    typename Zu_ntoa::Unsigned<T> v = v_;
    if (__builtin_expect(!!(m), 0)) v = ~v + 1;
    unsigned n = Zu_ntoa::Log10<sizeof(T)>::log(v);
    char comma = fmt.comma();
    if (comma) n += ((n - 1U) / 3U);
    if (__builtin_expect(!!(fmt.justification() == ZuFmt::Just::None), 1)) {
      if (m) *buf++ = '-';
      if (__builtin_expect(!!(!comma), 1))
	Zu_ntoa::Base10_print(v, n, buf);
      else
	Zu_ntoa::Base10_print_comma(v, n, buf, comma);
      return n + m;
    }
    int w = (int)fmt.width() - m;
    if (w < (int)n) return 0U;
    char pad = fmt.pad();
    if (__builtin_expect(!!(fmt.justification() == ZuFmt::Just::Right), 1)) {
      if (m && pad == '0') *buf++ = '-';
      if ((unsigned)w > n) {
	memset(buf, pad, (unsigned)w - n);
	buf += (unsigned)w - n;
      }
      if (m && pad != '0') *buf++ = '-';
      if (__builtin_expect(!!(!comma), 1))
	Zu_ntoa::Base10_print(v, n, buf);
      else
	Zu_ntoa::Base10_print_comma(v, n, buf, comma);
      return (unsigned)w + m;
    }
    if (__builtin_expect(!!(fmt.justification() == ZuFmt::Just::Left), 1)) {
      if (m) *buf++ = '-';
      if (__builtin_expect(!!(!comma), 1))
	Zu_ntoa::Base10_print(v, n, buf);
      else
	Zu_ntoa::Base10_print_comma(v, n, buf, comma);
      if ((unsigned)w > n) memset(buf + n, pad, (unsigned)w - n);
      return (unsigned)w + m;
    }
    return 0;
  }
  template <typename T> static unsigned flen(const ZuVFmt &fmt) {
    return 29U + (fmt.trim() ? (fmt.ndp() > 1 ? (fmt.ndp() - 1) : 0) : 0);
  }
  template <typename T> static unsigned flen(const ZuVFmt &fmt, T) {
    return flen<T>(fmt);
  }
  template <typename T>
  static unsigned ftoa(const ZuVFmt &fmt, T v, char *buf) {
    using FP = ZuFP<T>;
    if (__builtin_expect(!!(FP::nan(v)), 0)) {
      *buf++ = 'n', *buf++ = 'a', *buf = 'n';
      return 3U;
    }
    bool negative = 0;
    if (v < 0) negative = 1, v = -v, *buf++ = '-';
    if (__builtin_expect(!!(v > (T)(~0ULL)), 0)) {
      *buf++ = 'i', *buf++ = 'n', *buf = 'f';
      return negative + 3U;
    }
    uint64_t iv = (uint64_t)v;
    int f = fmt.ndp();
    bool fixed = f >= 0;
    unsigned i;
    if (!fixed) {
      i = Zu_ntoa::Log10FP::log<FP::Bits>(iv);
      unsigned j = i & 0xffU;
      if ((unsigned)(f = -f) > j) f = j;
      i >>= 8U;
    } else
      i = Zu_ntoa::Log10<8>::log(iv);
    uint64_t fv = Zu_ntoa::frac(v, iv, i, f);
    {
      char comma = fmt.comma();
      if (__builtin_expect(!!(!comma), 1)) {
	Zu_ntoa::Base10_print(iv, i, buf);
      } else {
	i += ((i - 1U) / 3U);
	Zu_ntoa::Base10_print_comma(iv, i, buf, comma);
      }
    }
    if (!f || (!fv && !fixed)) return negative + i;
    buf += i;
    *buf++ = '.';
    if (fixed) {
      Zu_ntoa::Base10_print(fv, f, buf);
      return negative + i + 1 + f;
    }
    char trim = fmt.trim();
    if (!trim)
      return negative + i + 1 +
	Zu_ntoa::Base10_print_frac_truncate(fv, f, f, buf);
    Zu_ntoa::Base10_print_frac(fv, f, f, trim, buf);
    return negative + i + 1 + f;
  }
};

namespace Zu_aton {
using namespace ZuFmt;

template <typename T_, unsigned Size = sizeof(T_)> struct Unsigned {
  using T = uint64_t;
};
template <typename T_> struct Unsigned<T_, 16> {
  using T = uint128_t;
};

template <
  class Fmt, char Skip = Fmt::Comma_, int Justification = Fmt::Justification_>
struct Base10 {
  template <typename T>
  static unsigned scan(T &v_, int c, const char *buf, unsigned n) {
    T v;
    if (__builtin_expect(!!(c >= '0' && c <= '9'), 1))
      v = c - '0';
    else if (__builtin_expect(!!(c == Skip), 1))
      v = 0;
    else
      return 0;
    unsigned o = 1;
    if (n > Fmt::Width_) n = Fmt::Width_;
    while (__builtin_expect(!!(o < n), 1)) {
      if (__builtin_expect(!!((c = buf[o]) >= '0' && c <= '9'), 1))
	v = v * 10U + (c - '0');
      else if (__builtin_expect(!!(c != Skip), 0))
	break;
      ++o;
    }
    v_ = v;
    return o;
  }
};
template <class Fmt, int Justification>
struct Base10<Fmt, '\0', Justification> {
  template <typename T>
  static unsigned scan(T &v_, int c, const char *buf, unsigned n) {
    if (__builtin_expect(!!(c < '0' || c > '9'), 0)) return 0;
    T v = c - '0';
    unsigned o = 1;
    if (n > Fmt::Width_) n = Fmt::Width_;
    while (__builtin_expect(!!(o < n && (c = buf[o]) >= '0' && c <= '9'), 1)) {
      v = v * 10U + (c - '0');
      ++o;
    }
    v_ = v;
    return o;
  }
};
template <class Fmt, char Skip> struct Base10<Fmt, Skip, Just::None> {
  template <typename T>
  static unsigned scan(T &v_, int c, const char *buf, unsigned n) {
    T v;
    if (__builtin_expect(!!(c >= '0' && c <= '9'), 1))
      v = c - '0';
    else if (__builtin_expect(!!(c == Skip), 1))
      v = 0;
    else
      return 0;
    unsigned o = 1;
    while (__builtin_expect(!!(o < n), 1)) {
      if (__builtin_expect(!!((c = buf[o]) >= '0' && c <= '9'), 1))
	v = v * 10U + (c - '0');
      else if (__builtin_expect(!!(c != Skip), 0))
	break;
      ++o;
    }
    v_ = v;
    return o;
  }
};
template <class Fmt> struct Base10<Fmt, '\0', Just::None> {
  template <typename T>
  static unsigned scan(T &v_, int c, const char *buf, unsigned n) {
    if (__builtin_expect(!!(c < '0' || c > '9'), 0)) return 0;
    T v = c - '0';
    unsigned o = 1;
    while (__builtin_expect(!!(o < n && (c = buf[o]) >= '0' && c <= '9'), 1)) {
      v = v * 10U + (c - '0');
      ++o;
    }
    v_ = v;
    return o;
  }
};
template <class Fmt> struct Base10<Fmt, '\0', Just::Frac> {
  template <typename T>
  static unsigned scan(T &v_, int c, const char *buf, unsigned n) {
    if (__builtin_expect(!!(c < '0' || c > '9'), 0)) return 0;
    T v = c - '0';
    unsigned o = 1;
    if (n > Fmt::NDP_) n = Fmt::NDP_;
    while (__builtin_expect(!!(o < n && (c = buf[o]) >= '0' && c <= '9'), 1)) {
      v = v * 10U + (c - '0');
      ++o;
    }
    unsigned r = o;
    while (__builtin_expect(!!(o < Fmt::NDP_), 1)) {
      v = v * 10U;
      ++o;
    }
    v_ = v;
    return r;
  }
};

template <class Fmt> struct Base16 {
  inline static int hexDigit(char c) {
    if (__builtin_expect(!!(c >= '0' && c <= '9'), 1)) return c - '0';
    if (__builtin_expect(!!(c >= 'a' && c <= 'f'), 1)) return c - 'a' + 10;
    if (__builtin_expect(!!(c >= 'A' && c <= 'F'), 1)) return c - 'A' + 10;
    return -1;
  }

  template <typename T>
  static unsigned scan(T &v_, int i, const char *buf, unsigned n) {
    i = hexDigit(i);
    if (__builtin_expect(!!(i < 0), 0)) return 0;
    T v = i;
    if (__builtin_expect(!!(n == 1), 0)) {
      v_ = v;
      return 1;
    }
    unsigned o = 1;
    i = buf[1];
    if (!v && i == 'x') {
      if (__builtin_expect(!!(n == 2), 0)) {
	v_ = 0;
	return 2;
      }
      i = buf[++o];
    }
    while (__builtin_expect(!!(o < n && (i = hexDigit(i)) >= 0), 1)) {
      v = (v << 4U) + i;
      i = buf[++o];
    }
    v_ = v;
    return o;
  }
};

template <class Fmt, bool Hex = Fmt::Hex_>
struct BaseN : public Base10<Fmt> { };
template <class Fmt> struct BaseN<Fmt, 1> : public Base16<Fmt> { };
} // namespace Zu_aton

template <class Fmt> struct Zu_nscan_ {
  template <bool Constrain, unsigned Width> struct Len_ {
    static constexpr unsigned len(unsigned n) { return n > Width ? Width : n; }
  };
  template <unsigned Width> struct Len_<0, Width> {
    static constexpr unsigned len(unsigned n) { return n; }
  };
  using Len = Len_<
    Fmt::Justification_ != ZuFmt::Just::None,
    Fmt::Justification_ != ZuFmt::Just::Frac ? Fmt::Width_ : Fmt::NDP_>;

  template <typename T>
  static unsigned atou_(T &v, const char *buf, unsigned n) {
    using namespace Zu_aton;
    return BaseN<Fmt>::scan(v, *buf, buf, n);
  }
  template <typename T>
  static unsigned atou(T &v, const char *buf, unsigned n) {
    n = Len::len(n);
    if (__builtin_expect(!!(!buf || !n), 0)) return 0;
    return atou_(v, buf, n);
  }

  template <typename T>
  static unsigned atoi_(T &v_, const char *buf, unsigned n) {
    using namespace Zu_aton;
    typename Unsigned<T>::T v = 0;
    unsigned o;
    int c = *buf;
    if (c == '-') {
      if (__builtin_expect(!!(n == 1), 0)) {
	v_ = 0;
	return 1;
      }
      o = BaseN<Fmt>::scan(v, buf[1], buf + 1, n - 1);
      if (__builtin_expect(!!(!o), 0)) return 0;
      v_ = -((T)v);
      return o + 1;
    }
    o = BaseN<Fmt>::scan(v, c, buf, n);
    v_ = v;
    return o;
  }
  template <typename T>
  static unsigned atoi(T &v_, const char *buf, unsigned n) {
    n = Len::len(n);
    if (__builtin_expect(!!(!buf || !n), 0)) return 0;
    return atoi_(v_, buf, n);
  }

  template <class Fmt_> struct FPIntFmt_ : public Fmt_ {
    enum { Justification_ = ZuFmt::Just::None };
    enum { Hex_ = 0 };
  };

  template <class Fmt_> struct FPFracFmt_ : public Fmt_ {
    enum { Justification_ = ZuFmt::Just::None };
    enum { Hex_ = 0 };
    enum { Comma_ = 0 };
    enum { Pad_ = 0 };
  };
  template <typename T>
  static unsigned atof_(T &v_, const char *buf, unsigned n) {
    using namespace Zu_aton;
    using FP = ZuFP<T>;
    uint64_t iv;
    unsigned o = 0;
    int c = *buf;
    bool negative = c == '-';
    if (negative) {
      if (__builtin_expect(!!(n == 1), 0)) return 0;
      c = buf[++o];
    }
    if (__builtin_expect(!!(c == '.'), 0)) {
      iv = 0;
      goto frac;
    }
    if (__builtin_expect(!!(n - o >= 3), 1)) {
      if (__builtin_expect(
	    !!(c == 'n' && buf[o + 1] == 'a' && buf[o + 2] == 'n'), 0
	  )) {
	v_ = FP::nan();
	return 3 + negative;
      }
      if (__builtin_expect(
	    !!(c == 'i' && buf[o + 1] == 'n' && buf[o + 2] == 'f'), 0
	  )) {
	v_ = negative ? -FP::inf() : FP::inf();
	return 3 + negative;
      }
    }
    {
      unsigned i = Base10<FPIntFmt_<Fmt>>::scan(iv, c, buf + o, n - o);
      if (__builtin_expect(!!(!i), 0)) return 0;
      o += i;
    }
    if (o >= n - 1 || (c = buf[o]) != '.') {
      v_ = (T)iv;
      if (negative) v_ = -v_;
      return o;
    }
frac: {
  ++o;
  unsigned l = n - o;
  if (l >= FP::MaxDigits) l = FP::MaxDigits - 1;
  uint64_t fv;
  unsigned i = Base10<FPFracFmt_<Fmt>>::scan(fv, buf[o], buf + o, l);
  if (__builtin_expect(!!(!i), 0)) {
    v_ = (T)iv;
    if (negative) v_ = -v_;
    return o;
  }
  o += i;
  T v = (T)(fv * ZuDecimalFn::pow10_64(FP::MaxDigits - 1 - i));
  if (o < n && (c = buf[o]) >= '0' && c <= '9') {
    ++o;
    v += (T)0.1 * (T)(c - '0');
  }
  v_ = (T)iv + v / (T)ZuDecimalFn::Pow10<FP::MaxDigits - 1>{};
  if (negative) v_ = -v_;
  return o;
}
  }
  template <typename T>
  static unsigned atof(T &v_, const char *buf, unsigned n) {
    n = Len::len(n);
    if (__builtin_expect(!!(!buf || !n), 0)) return 0;
    return atof_(v_, buf, n);
  }
};
template <
  class Fmt = ZuFmt::Default,
  int Skip = (Fmt::Justification_ == ZuFmt::Just::Right && Fmt::Pad_ != '0') ?
    Fmt::Pad_ :
    -1>
struct Zu_nscan : public Zu_nscan_<Fmt> {
  using Len = typename Zu_nscan_<Fmt>::Len;
  static unsigned skip(const char *buf, unsigned n) {
    unsigned o = 0;
    while (__builtin_expect(!!(o < n && buf[o] == Skip), 1)) ++o;
    return o;
  }
  template <typename T>
  static unsigned atou(T &v, const char *buf, unsigned n) {
    n = Len::len(n);
    if (__builtin_expect(!!(!buf || !n), 0)) return 0;
    unsigned o = skip(buf, n);
    if (__builtin_expect(!!(o >= n), 0)) return 0;
    return Zu_nscan_<Fmt>::atou_(v, buf + o, n - o) + o;
  }
  template <typename T>
  static unsigned atoi(T &v, const char *buf, unsigned n) {
    n = Len::len(n);
    if (__builtin_expect(!!(!buf || !n), 0)) return 0;
    unsigned o = skip(buf, n);
    if (__builtin_expect(!!(o >= n), 0)) return 0;
    return Zu_nscan_<Fmt>::atoi_(v, buf + o, n - o) + o;
  }
  template <typename T>
  static unsigned atof(T &v, const char *buf, unsigned n) {
    n = Len::len(n);
    if (__builtin_expect(!!(!buf || !n), 0)) return 0;
    unsigned o = skip(buf, n);
    if (__builtin_expect(!!(o >= n), 0)) return 0;
    return Zu_nscan_<Fmt>::atof_(v, buf + o, n - o) + o;
  }
};
template <class Fmt> struct Zu_nscan<Fmt, -1> : public Zu_nscan_<Fmt> { };

template <typename T>
inline unsigned Zu_atou(T &v, const char *buf, unsigned n) {
  return Zu_nscan<>::atou(v, buf, n);
}
template <typename T>
inline unsigned Zu_atoi(T &v, const char *buf, unsigned n) {
  return Zu_nscan<>::atoi(v, buf, n);
}
template <typename T>
inline unsigned Zu_atof(T &v, const char *buf, unsigned n) {
  return Zu_nscan<>::atof(v, buf, n);
}

template <typename T, typename NTP> class ZuBox;
template <typename> struct ZuIsBoxed : public ZuFalse { };
template <typename T, typename NTP>
struct ZuIsBoxed<ZuBox<T, NTP>> : public ZuTrue { };

template <typename U, typename R = void>
using ZuMatchBoxed = ZuIfT<ZuIsBoxed<U>{}, R>;
template <typename U, typename R = void>
using ZuNotBoxed = ZuIfT<!ZuIsBoxed<U>{}, R>;

inline constexpr auto ZuBox_NullAsIs() {
  return []() -> ZuCSpan { return {}; };
};
inline constexpr auto ZuBox_NullString() {
  return []() -> ZuCSpan { return {}; };
};

template <
  typename T, typename Fmt, auto IsNull, auto NullString,
  bool Signed = ZuTraits<T>::IsSigned,
  bool FloatingPoint = Signed && ZuTraits<T>::IsFloatingPoint>
struct ZuBox_Print;
template <typename T, typename Fmt, auto IsNull>
struct ZuBox_Print<T, Fmt, IsNull, ZuBox_NullAsIs(), 0, 0> {
  static unsigned length(T v) { return Zu_nprint<Fmt>::ulen(v); }
  static unsigned print(T v, char *buf) { return Zu_nprint<Fmt>::utoa(v, buf); }
};
template <typename T, typename Fmt, auto IsNull>
struct ZuBox_Print<T, Fmt, IsNull, ZuBox_NullAsIs(), 1, 0> {
  static unsigned length(T v) { return Zu_nprint<Fmt>::ilen(v); }
  static unsigned print(T v, char *buf) { return Zu_nprint<Fmt>::itoa(v, buf); }
};
template <typename T, typename Fmt, auto IsNull>
struct ZuBox_Print<T, Fmt, IsNull, ZuBox_NullAsIs(), 1, 1> {
  static unsigned length(T v) { return Zu_nprint<Fmt>::flen(v); }
  static unsigned print(T v, char *buf) { return Zu_nprint<Fmt>::ftoa(v, buf); }
};
template <typename T, typename Fmt, auto IsNull, auto NullString>
struct ZuBox_Print<T, Fmt, IsNull, NullString, 0, 0> {
  static unsigned length(T v) {
    if (__builtin_expect(!!(IsNull(v)), 0)) return NullString().length();
    return Zu_nprint<Fmt>::ulen(v);
  }
  static unsigned print(T v, char *buf) {
    if (__builtin_expect(!!(IsNull(v)), 0)) {
      auto s = NullString();
      memcpy(buf, s.data(), s.length());
      return s.length();
    }
    return Zu_nprint<Fmt>::utoa(v, buf);
  }
};
template <typename T, typename Fmt, auto IsNull, auto NullString>
struct ZuBox_Print<T, Fmt, IsNull, NullString, 1, 0> {
  static unsigned length(T v) {
    if (__builtin_expect(!!(IsNull(v)), 0)) return NullString().length();
    return Zu_nprint<Fmt>::ilen(v);
  }
  static unsigned print(T v, char *buf) {
    if (__builtin_expect(!!(IsNull(v)), 0)) {
      auto s = NullString();
      memcpy(buf, s.data(), s.length());
      return s.length();
    }
    return Zu_nprint<Fmt>::itoa(v, buf);
  }
};
template <typename T, typename Fmt, auto IsNull, auto NullString>
struct ZuBox_Print<T, Fmt, IsNull, NullString, 1, 1> {
  static unsigned length(T v) {
    if (__builtin_expect(!!(IsNull(v)), 0)) return NullString().length();
    return Zu_nprint<Fmt>::flen(v);
  }
  static unsigned print(T v, char *buf) {
    if (__builtin_expect(!!(IsNull(v)), 0)) {
      auto s = NullString();
      memcpy(buf, s.data(), s.length());
      return s.length();
    }
    return Zu_nprint<Fmt>::ftoa(v, buf);
  }
};

template <
  typename T, auto IsNull, auto NullString, bool Signed = ZuTraits<T>::IsSigned,
  bool FloatingPoint = Signed && ZuTraits<T>::IsFloatingPoint>
struct ZuBox_VPrint;
template <typename T, auto IsNull>
struct ZuBox_VPrint<T, IsNull, ZuBox_NullAsIs(), 0, 0> {
  static unsigned length(const ZuVFmt &fmt, T v) {
    return Zu_vprint::ulen(fmt, v);
  }
  static unsigned print(const ZuVFmt &fmt, T v, char *buf) {
    return Zu_vprint::utoa(fmt, v, buf);
  }
};
template <typename T, auto IsNull>
struct ZuBox_VPrint<T, IsNull, ZuBox_NullAsIs(), 1, 0> {
  static unsigned length(const ZuVFmt &fmt, T v) {
    return Zu_vprint::ilen(fmt, v);
  }
  static unsigned print(const ZuVFmt &fmt, T v, char *buf) {
    return Zu_vprint::itoa(fmt, v, buf);
  }
};
template <typename T, auto IsNull>
struct ZuBox_VPrint<T, IsNull, ZuBox_NullAsIs(), 1, 1> {
  static unsigned length(const ZuVFmt &fmt, T v) {
    return Zu_vprint::flen(fmt, v);
  }
  static unsigned print(const ZuVFmt &fmt, T v, char *buf) {
    return Zu_vprint::ftoa(fmt, v, buf);
  }
};
template <typename T, auto IsNull, auto NullString>
struct ZuBox_VPrint<T, IsNull, NullString, 0, 0> {
  static unsigned length(const ZuVFmt &fmt, T v) {
    if (__builtin_expect(!!(IsNull(v)), 0)) return NullString().length();
    return Zu_vprint::ulen(fmt, v);
  }
  static unsigned print(const ZuVFmt &fmt, T v, char *buf) {
    if (__builtin_expect(!!(IsNull(v)), 0)) {
      auto s = NullString();
      memcpy(buf, s.data(), s.length());
      return s.length();
    }
    return Zu_vprint::utoa(fmt, v, buf);
  }
};
template <typename T, auto IsNull, auto NullString>
struct ZuBox_VPrint<T, IsNull, NullString, 1, 0> {
  static unsigned length(const ZuVFmt &fmt, T v) {
    if (__builtin_expect(!!(IsNull(v)), 0)) return NullString().length();
    return Zu_vprint::ilen(fmt, v);
  }
  static unsigned print(const ZuVFmt &fmt, T v, char *buf) {
    if (__builtin_expect(!!(IsNull(v)), 0)) {
      auto s = NullString();
      memcpy(buf, s.data(), s.length());
      return s.length();
    }
    return Zu_vprint::itoa(fmt, v, buf);
  }
};
template <typename T, auto IsNull, auto NullString>
struct ZuBox_VPrint<T, IsNull, NullString, 1, 1> {
  static unsigned length(const ZuVFmt &fmt, T v) {
    if (__builtin_expect(!!(IsNull(v)), 0)) return NullString().length();
    return Zu_vprint::flen(fmt, v);
  }
  static unsigned print(const ZuVFmt &fmt, T v, char *buf) {
    if (__builtin_expect(!!(IsNull(v)), 0)) {
      auto s = NullString();
      memcpy(buf, s.data(), s.length());
      return s.length();
    }
    return Zu_vprint::ftoa(fmt, v, buf);
  }
};

template <
  typename T, typename Fmt, auto Null, auto NullString,
  bool Signed = ZuTraits<T>::IsSigned,
  bool FloatingPoint = Signed && ZuTraits<T>::IsFloatingPoint>
struct ZuBox_Scan;
template <typename T_, typename Fmt, auto Null>
struct ZuBox_Scan<T_, Fmt, Null, ZuBox_NullAsIs(), 0, 0> {
  using T = uint64_t;
  static unsigned scan(T &v, const char *buf, unsigned n) {
    return Zu_nscan<Fmt>::atou(v, buf, n);
  }
};
template <typename T_, typename Fmt, auto Null>
struct ZuBox_Scan<T_, Fmt, Null, ZuBox_NullAsIs(), 1, 0> {
  using T = int64_t;
  static unsigned scan(T &v, const char *buf, unsigned n) {
    return Zu_nscan<Fmt>::atoi(v, buf, n);
  }
};
template <typename T_, typename Fmt, auto Null>
struct ZuBox_Scan<T_, Fmt, Null, ZuBox_NullAsIs(), 1, 1> {
  using T = T_;
  static unsigned scan(T &v, const char *buf, unsigned n) {
    return Zu_nscan<Fmt>::atof(v, buf, n);
  }
};
template <typename T_, typename Fmt, auto Null, auto NullString>
struct ZuBox_Scan<T_, Fmt, Null, NullString, 0, 0> {
  using T = uint64_t;
  static unsigned scan(T &v, const char *buf, unsigned n) {
    unsigned o = Zu_nscan<Fmt>::atou(v, buf, n);
    if (__builtin_expect(!!(o), 1)) return o;
    auto null = NullString();
    o = null.length();
    if (n >= o && !memcmp(null.data(), buf, o)) {
      v = Null();
      return o;
    }
    return 0;
  }
};
template <typename T_, typename Fmt, auto Null, auto NullString>
struct ZuBox_Scan<T_, Fmt, Null, NullString, 1, 0> {
  using T = int64_t;
  static unsigned scan(T &v, const char *buf, unsigned n) {
    unsigned o = Zu_nscan<Fmt>::atoi(v, buf, n);
    if (__builtin_expect(!!(o), 1)) return o;
    auto null = NullString();
    o = null.length();
    if (n >= o && !memcmp(null.data(), buf, o)) {
      v = Null();
      return o;
    }
    return 0;
  }
};
template <typename T_, typename Fmt, auto Null, auto NullString>
struct ZuBox_Scan<T_, Fmt, Null, NullString, 1, 1> {
  using T = T_;
  static unsigned scan(T &v, const char *buf, unsigned n) {
    unsigned o = Zu_nscan<Fmt>::atof(v, buf, n);
    if (__builtin_expect(!!(o), 1)) return o;
    auto null = NullString();
    o = null.length();
    if (n >= o && !memcmp(null.data(), buf, o)) {
      v = Null();
      return o;
    }
    return 0;
  }
};

template <typename B> struct ZuBoxPrint : public ZuPrintBuffer {
  static unsigned length(const B &b) { return b.length(); }
  static unsigned print(char *buf, unsigned, const B &b) {
    return b.print(buf);
  }
};

template <typename Boxed, typename Fmt> class ZuBoxFmt {
  template <typename, typename> friend class ZuBox;

  using Print =
    ZuBox_Print<typename Boxed::T, Fmt, Boxed::isNull, Boxed::NullString>;

  ZuBoxFmt(const Boxed &ref) : m_ref(ref) { }

public:
  unsigned length() const { return Print::length(m_ref); }
  unsigned print(char *buf) const { return Print::print(m_ref, buf); }

  friend ZuBoxPrint<ZuBoxFmt> ZuPrintType(ZuBoxFmt *);

private:
  const Boxed &m_ref;
};

template <typename Boxed>
class ZuBoxVFmt : public ZuVFmtWrapper<ZuBoxVFmt<Boxed>> {
  template <typename, typename> friend class ZuBox;

  using Print =
    ZuBox_VPrint<typename Boxed::T, Boxed::isNull, Boxed::NullString>;

public:
  ZuBoxVFmt(const Boxed &v) : m_value(v) { }
  template <typename VFmt>
  ZuBoxVFmt(const Boxed &v, VFmt &&fmt) :
    ZuVFmtWrapper<ZuBoxVFmt>{ZuFwd<VFmt>(fmt)}, m_value{v} { }

  unsigned length() const { return Print::length(this->fmt, m_value); }
  unsigned print(char *buf) const {
    return Print::print(this->fmt, m_value, buf);
  }
  friend ZuBoxPrint<ZuBoxVFmt> ZuPrintType(ZuBoxVFmt *);

private:
  const Boxed &m_value;
};

template <typename U, typename T, typename R = void>
using ZuBox_MatchReal = ZuIfT<
  !ZuIsBoxed<U>{} && !ZuTraits<U>::IsString &&
    (ZuTraits<U>::IsReal || ZuInspect<U, T>::Converts ||
     ZuInspect<U, int>::Converts),
  R>;
template <typename Traits, typename R, bool IsPointer, bool IsArray>
struct ZuBox_MatchCharPtr_ { };
template <typename Traits, typename R>
struct ZuBox_MatchCharPtr_<Traits, R, true, false> :
  public ZuIfT_<ZuInspect<typename Traits::Elem, char>::Same, R> { };
template <typename Traits, typename R>
struct ZuBox_MatchCharPtr_<Traits, R, false, true> :
  public ZuIfT_<ZuInspect<typename Traits::Elem, char>::Same, R> { };
template <typename S, typename R = void>
using ZuBox_MatchCharPtr = typename ZuBox_MatchCharPtr_<
  ZuTraits<S>, R, ZuTraits<S>::IsPointer, ZuTraits<S>::IsArray>::T;

struct ZuBox_Defaults {
  template <typename T> using CmpT = ZuCmp<T>;
  static constexpr auto NullString = ZuBox_NullAsIs();
};

template <template <typename> typename Cmp_, typename NTP = ZuBox_Defaults>
struct ZuBoxCmp : public NTP {
  template <typename T> using CmpT = Cmp_<T>;
};

template <auto NullString_, typename NTP = ZuBox_Defaults>
struct ZuBoxNullString : public NTP {
  static constexpr auto NullString = NullString_;
};

template <typename T_, typename NTP = ZuBox_Defaults> class ZuBox {
  template <typename, typename> friend class ZuBox;
  template <typename, typename> friend class ZuBoxFmt;
  template <typename> friend class ZuBoxVFmt;

public:
  using T = ZuUnder<T_>;
  using Cmp = typename NTP::template CmpT<T>;
  static constexpr auto NullString = NTP::NullString;

  static T null() { return Cmp::null(); }
  static bool isNull(T v) { return Cmp::null(v); }

private:
  template <typename Fmt = ZuFmt::Default>
  using Scan = ZuBox_Scan<T, Fmt, null, NullString>;

  template <typename Fmt = ZuFmt::Default>
  using Print = ZuBox_Print<T, Fmt, isNull, NullString>;

  static_assert(
    (ZuTraits<T>::IsPrimitive && ZuTraits<T>::IsReal),
    "ZuTraits<T>::IsPrimitive && ZuTraits<T>::IsReal"
  );

public:
  ZuBox() : m_val(Cmp::null()) { }

  ZuBox(const ZuBox &b) : m_val(b.m_val) { }
  ZuBox &operator=(const ZuBox &b) {
    m_val = b.m_val;
    return *this;
  }

  template <typename R, decltype(ZuBox_MatchReal<R, T>(), int()) = 0>
  ZuBox(R r) : m_val(r) { }

  template <typename B, decltype(ZuMatchBoxed<B>(), int()) = 0>
  ZuBox(B b) :
    m_val(!*b ? static_cast<T>(Cmp::null()) : static_cast<T>(b.m_val)) { }

  template <typename S, decltype(ZuMatchCharString<S>(), int()) = 0>
  ZuBox(S &&s_) : m_val(Cmp::null()) {
    ZuCSpan s(ZuFwd<S>(s_));
    typename Scan<>::T val = 0;
    if (__builtin_expect(!!(s && Scan<>::scan(val, s.data(), s.length())), 1))
      m_val = val;
  }
  template <
    typename Fmt, typename S, decltype(ZuMatchCharString<S>(), int()) = 0>
  ZuBox(Fmt, S &&s_) : m_val(Cmp::null()) {
    ZuCSpan s(ZuFwd<S>(s_));
    typename Scan<Fmt>::T val = 0;
    if (__builtin_expect(
	  !!(s && Scan<Fmt>::scan(val, s.data(), s.length())), 1
	))
      m_val = val;
  }

  template <typename S, decltype(ZuBox_MatchCharPtr<S>(), int()) = 0>
  ZuBox(S s, unsigned len) : m_val(Cmp::null()) {
    typename Scan<>::T val = 0;
    if (__builtin_expect(!!(s && Scan<>::scan(val, s, len)), 1)) m_val = val;
  }
  template <
    typename Fmt, typename S, decltype(ZuBox_MatchCharPtr<S>(), int()) = 0>
  ZuBox(Fmt, S s, unsigned len) : m_val(Cmp::null()) {
    typename Scan<Fmt>::T val = 0;
    if (__builtin_expect(!!(s && Scan<Fmt>::scan(val, s, len)), 1)) m_val = val;
  }

  T val() const { return m_val; }

private:
  template <typename R> ZuBox_MatchReal<R, T> assign(R r) { m_val = r; }

  template <typename B> ZuMatchBoxed<B> assign(const B &b) {
    m_val = !*b ? (T)Cmp::null() : (T)b.m_val;
  }

  template <typename S> ZuMatchCharString<S> assign(S &&s_) {
    ZuCSpan s(ZuFwd<S>(s_));
    typename Scan<>::T val = 0;
    if (__builtin_expect(!!(!s || !Scan<>::scan(val, s.data(), s.length())), 0))
      m_val = Cmp::null();
    else
      m_val = val;
  }

public:
  template <typename T> ZuBox &operator=(T &&t) {
    assign(ZuFwd<T>(t));
    return *this;
  }

  template <typename T>
  static ZuMatchFloatingPoint<T, bool> equals_(T t1, T t2) {
    if (Cmp::null(t2)) return Cmp::null(t1);
    if (Cmp::null(t1)) return false;
    return t1 == t2;
  }
  template <typename T> static ZuNotFloatingPoint<T, bool> equals_(T t1, T t2) {
    return t1 == t2;
  }
  bool equals(const ZuBox &b) const { return equals_(m_val, b.m_val); }

  template <typename Cmp__ = Cmp>
  ZuIfT<!ZuInspect<Cmp__, ZuCmp0<T>>::Same, int> cmp_(const ZuBox &b) const {
    if (Cmp::null(b.m_val)) return Cmp::null(m_val) ? 0 : 1;
    if (Cmp::null(m_val)) return -1;
    return Cmp::cmp(m_val, b.m_val);
  }
  template <typename Cmp__ = Cmp>
  ZuIfT<ZuInspect<Cmp__, ZuCmp0<T>>::Same, int> cmp_(const ZuBox &b) const {
    return Cmp::cmp(m_val, b.m_val);
  }
  int cmp(const ZuBox &b) const { return cmp_<>(b.m_val); }
  template <typename L, typename R>
  friend inline ZuIfT<ZuInspect<ZuBox, L>::Is, bool>
  operator==(const L &l, const R &r) {
    return l.equals(r);
  }
  template <typename L, typename R>
  friend inline ZuIfT<ZuInspect<ZuBox, L>::Is, int>
  operator<=>(const L &l, const R &r) {
    return l.cmp(r);
  }

  bool operator!() const { return !m_val; }

  bool operator*() const { return !Cmp::null(m_val); }

  uint32_t hash() const { return ZuHash<T>::hash(m_val); }

  operator T() const { return m_val; }
  operator T &() & { return m_val; }

  template <typename Fmt = ZuFmt::Default> ZuBoxFmt<ZuBox, Fmt> fmt() const {
    return ZuBoxFmt<ZuBox, Fmt>{*this};
  }
  template <bool Upper = false, typename Fmt = ZuFmt::Default>
  ZuBoxFmt<ZuBox, ZuFmt::Hex<Upper, Fmt>> hex() const {
    return ZuBoxFmt<ZuBox, ZuFmt::Hex<Upper, Fmt>>{*this};
  }
  template <
    int NDP = -ZuFmt::Default::NDP_, char Trim = '\0',
    typename Fmt = ZuFmt::Default>
  ZuBoxFmt<ZuBox, ZuFmt::FP<NDP, Trim, Fmt>> fp() const {
    return ZuBoxFmt<ZuBox, ZuFmt::FP<NDP, Trim, Fmt>>{*this};
  }

  ZuBoxVFmt<ZuBox> vfmt() const { return ZuBoxVFmt<ZuBox>{*this}; }
  template <typename VFmt> ZuBoxVFmt<ZuBox> vfmt(VFmt &&fmt) const {
    return ZuBoxVFmt<ZuBox>{*this, ZuFwd<VFmt>(fmt)};
  }

  template <typename Fmt = ZuFmt::Default, typename S>
  ZuMatchCharString<S, unsigned> scan(S &&s_) {
    ZuCSpan s(ZuFwd<S>(s_));
    typename Scan<>::T val = 0;
    unsigned n = Scan<Fmt>::scan(val, s.data(), s.length());
    if (__builtin_expect(!!(!n), 0)) {
      m_val = Cmp::null();
      return 0;
    }
    m_val = val;
    return n;
  }
  template <typename Fmt = ZuFmt::Default, typename S>
  ZuBox_MatchCharPtr<S, unsigned> scan(S s, unsigned len) {
    typename Scan<Fmt>::T val = 0;
    unsigned n = Scan<Fmt>::scan(val, s, len);
    if (__builtin_expect(!!(!n), 0)) {
      m_val = Cmp::null();
      return 0;
    }
    m_val = val;
    return n;
  }

  unsigned length() const { return Print<>::length(m_val); }
  unsigned print(char *buf) const { return Print<>::print(m_val, buf); }

  ZuBox operator-() { return -m_val; }

  template <typename R> ZuBox operator+(const R &r) const { return m_val + r; }
  template <typename R> ZuBox operator-(const R &r) const { return m_val - r; }
  template <typename R> ZuBox operator*(const R &r) const { return m_val * r; }
  template <typename R> ZuBox operator/(const R &r) const { return m_val / r; }
  template <typename R> ZuBox operator%(const R &r) const { return m_val % r; }
  template <typename R> ZuBox operator|(const R &r) const { return m_val | r; }
  template <typename R> ZuBox operator&(const R &r) const { return m_val & r; }
  template <typename R> ZuBox operator^(const R &r) const { return m_val ^ r; }

  ZuBox operator++(int) { return m_val++; }
  ZuBox &operator++() {
    ++m_val;
    return *this;
  }
  ZuBox operator--(int) { return m_val--; }
  ZuBox &operator--() {
    --m_val;
    return *this;
  }

  template <typename R> ZuBox &operator+=(const R &r) {
    m_val += r;
    return *this;
  }
  template <typename R> ZuBox &operator-=(const R &r) {
    m_val -= r;
    return *this;
  }
  template <typename R> ZuBox &operator*=(const R &r) {
    m_val *= r;
    return *this;
  }
  template <typename R> ZuBox &operator/=(const R &r) {
    m_val /= r;
    return *this;
  }
  template <typename R> ZuBox &operator%=(const R &r) {
    m_val %= r;
    return *this;
  }
  template <typename R> ZuBox &operator|=(const R &r) {
    m_val |= r;
    return *this;
  }
  template <typename R> ZuBox &operator&=(const R &r) {
    m_val &= r;
    return *this;
  }
  template <typename R> ZuBox &operator^=(const R &r) {
    m_val ^= r;
    return *this;
  }

  ZuBox &update(const ZuBox &u) {
    if (!Cmp::null(u)) m_val = u.m_val;
    return *this;
  }

  ZuBox &update(const ZuBox &u, const ZuBox &reset) {
    if (!Cmp::null(u)) {
      if (u == reset)
	m_val = Cmp::null();
      else
	m_val = u.m_val;
    }
    return *this;
  }

  static ZuBox inf() { return ZuBox{Cmp::inf()}; }

  ZuBox epsilon() const { return ZuBox{Cmp::epsilon(m_val)}; }

  bool feq(T r) const {
    if (Cmp::null(m_val)) return Cmp::null(r);
    if (Cmp::null(r)) return false;
    return feq_(r);
  }
  bool feq_(T r) const {
    if (__builtin_expect(!!(m_val == r), 1)) return true;
    if (__builtin_expect(!!(m_val >= 0.0), 1)) {
      if (r < 0.0) return false;
      if (m_val > r) return m_val - r < Cmp::epsilon(m_val);
      return r - m_val < Cmp::epsilon(r);
    }
    if (r > 0.0) return false;
    T val = -m_val;
    r = -r;
    if (val > r) return val - r < Cmp::epsilon(val);
    return r - val < Cmp::epsilon(r);
  }

  bool fne(T r) const { return !feq(r); }
  bool fge(T r) const {
    if (Cmp::null(m_val)) return Cmp::null(r);
    if (Cmp::null(r)) return false;
    return m_val > r || feq_(r);
  }
  bool fle(T r) const {
    if (Cmp::null(m_val)) return Cmp::null(r);
    if (Cmp::null(r)) return false;
    return m_val < r || feq_(r);
  }
  bool fgt(T r) const { return !fle(r); }
  bool flt(T r) const { return !fge(r); }

  int fcmp(T r) const {
    if (Cmp::null(r)) return Cmp::null(m_val) ? 0 : 1;
    if (Cmp::null(m_val)) return -1;
    if (feq_(r)) return 0;
    return m_val > r ? 1 : -1;
  }

  struct Traits : public ZuTraits<T> {
    enum { IsPrimitive = 0 };
  };
  friend Traits ZuTraitsType(ZuBox *);

  friend ZuBoxPrint<ZuBox> ZuPrintType(ZuBox *);

  friend T ZuUnderType(ZuBox *);

private:
  T m_val;
};

template <auto N> struct ZuBox_CmpN {
  template <typename T> using Cmp = ZuCmpN<T, N>;
};

template <typename T_, typename NTP>
struct ZuCmp<ZuBox<T_, NTP>> : public ZuCmp<T_> {
  using T = ZuBox<T_, NTP>;
  static int cmp(const T &t1, const T &t2) { return t1.cmp(t2); }
  static bool less(const T &t1, const T &t2) { return t1 < t2; }
  static bool equals(const T &t1, const T &t2) { return t1 == t2; }
  static bool null(const T &t) { return !*t; }
  static const T &null() {
    static const T v;
    return v;
  }
};

template <typename T> const ZuMatchBoxed<T, T> &ZuBoxed(const T &v) {
  return v;
}
template <typename T> ZuMatchBoxed<T, T> &ZuBoxed(T &v) { return v; }
template <typename T> const ZuNotBoxed<T, ZuBox<T>> &ZuBoxed(const T &v) {
  const ZuBox<T> *__attribute__((__may_alias__)) v_ =
    reinterpret_cast<const ZuBox<T> *>(&v);
  return *v_;
}
template <typename T> ZuNotBoxed<T, ZuBox<T>> &ZuBoxed(T &v) {
  ZuBox<T> *__attribute__((__may_alias__)) v_ =
    reinterpret_cast<ZuBox<T> *>(&v);
  return *v_;
}

template <typename T, typename NTP = ZuBox_Defaults>
using ZuNBox = ZuBox<T, ZuBoxNullString<ZuBox_NullString(), NTP>>;

template <typename T> const ZuMatchBoxed<T, T> &ZuNBoxed(const T &v) {
  return v;
}
template <typename T> ZuMatchBoxed<T, T> &ZuNBoxed(T &v) { return v; }
template <typename T> const ZuNotBoxed<T, ZuNBox<T>> &ZuNBoxed(const T &v) {
  const ZuNBox<T> *__attribute__((__may_alias__)) v_ =
    reinterpret_cast<const ZuNBox<T> *>(&v);
  return *v_;
}
template <typename T> ZuNotBoxed<T, ZuNBox<T>> &ZuNBoxed(T &v) {
  ZuNBox<T> *__attribute__((__may_alias__)) v_ =
    reinterpret_cast<ZuNBox<T> *>(&v);
  return *v_;
}

namespace Zu {

inline unsigned strlen_(const char *s) { return strlen(s); }
inline unsigned strlen_(const wchar_t *w) { return wcslen(w); }

inline int strcmp_(const char *s1, const char *s2) { return strcmp(s1, s2); }
inline int strcmp_(const wchar_t *w1, const wchar_t *w2) {
  return wcscmp(w1, w2);
}
inline int strcmp_(const char *s1, const char *s2, unsigned n) {
  return strncmp(s1, s2, n);
}
inline int strcmp_(const wchar_t *w1, const wchar_t *w2, unsigned n) {
  return wcsncmp(w1, w2, n);
}

inline int stricmp_(const char *s1, const char *s2) {
  return strcasecmp(s1, s2);
}

inline int stricmp_(const wchar_t *w1, const wchar_t *w2) {
  return wcscasecmp(w1, w2);
}

inline int stricmp_(const char *s1, const char *s2, unsigned n) {
  return strncasecmp(s1, s2, n);
}

inline int stricmp_(const wchar_t *w1, const wchar_t *w2, unsigned n) {
  return wcsncasecmp(w1, w2, n);
}

inline void strpad(char *s, unsigned n) { memset(s, ' ', n); }
inline void strpad(wchar_t *w, unsigned n) { wmemset(w, L' ', n); }

extern int vsnprintf(char *s, unsigned n, const char *format, va_list ap_);
extern int
vsnprintf(wchar_t *w, unsigned n, const wchar_t *format, va_list ap_);

inline const wchar_t *nullWString() {
  static wchar_t s[1] = {0};

  return s;
}
} // namespace Zu

template <typename T> struct ZuICmp : public ZuCmp<T> {
public:
  static int cmp(ZuCSpan s1, ZuCSpan s2) {
    int l1 = s1.length(), l2 = s2.length();
    if (!l1) return l2 ? -1 : 0;
    if (!l2) return 1;
    int i = Zu::stricmp_(s1.data(), s2.data(), l1 > l2 ? l2 : l1);
    if (i) return i;
    return l1 - l2;
  }
  static bool less(ZuCSpan s1, ZuCSpan s2) {
    int l1 = s1.length(), l2 = s2.length();
    if (!l1) return l2;
    if (!l2) return false;
    int i = Zu::stricmp_(s1.data(), s2.data(), l1 > l2 ? l2 : l1);
    if (i) return i < 0;
    return l1 < l2;
  }
  static int equals(ZuCSpan s1, ZuCSpan s2) {
    int l1 = s1.length(), l2 = s2.length();
    if (l1 != l2) return false;
    return !Zu::stricmp_(s1.data(), s2.data(), l1);
  }
};

using ZuBytes = ZuSpan<const uint8_t>;

namespace cppcodec { namespace data {

template <typename T>
inline __attribute__((always_inline)) size_t size(const T &t) {
  return t.size();
}

template <typename T, size_t N>
inline __attribute__((always_inline)) constexpr size_t
size(const T (&t)[N]) noexcept {
  return (void)t, N * sizeof(t[0]);
}

class general_t { };
class specific_t : public general_t { };

class empty_result_state {
  template <typename Result>
  inline __attribute__((always_inline)) void size(const Result &result) {
    return size(result);
  }
};

template <typename Result>
inline __attribute__((always_inline)) empty_result_state create_state(
  Result &, general_t
) {
  return empty_result_state();
}

template <typename Result>
inline __attribute__((always_inline)) void
init(Result &result, empty_result_state &, size_t capacity) {
  result.resize(0);
  result.reserve(capacity);
}

template <typename Result>
inline __attribute__((always_inline)) void
finish(Result &, empty_result_state &) { }

namespace fallback {
struct flag {
  char c[2];
};
flag put_uint8(...);

int operator,(flag, flag);
template <typename T> void operator,(flag, T &);
char operator,(int, flag);
}

template <typename Result> inline void put_uint8(Result &result, uint8_t c) {
  result.push_back(c);
}

template <bool> struct put_impl;
template <> struct put_impl<true> {
  template <typename Result>
  inline static __attribute__((always_inline)) void
  put(Result &result, uint8_t c) {
    put_uint8(result, c);
  }
};
template <> struct put_impl<false> {
  template <typename Result>
  inline static __attribute__((always_inline)) void
  put(Result &result, uint8_t c) {
    result.push_back(static_cast<char>(c));
  }
};

template <typename Result>
inline __attribute__((always_inline)) void
put(Result &result, empty_result_state &, uint8_t c) {
  using namespace fallback;
  put_impl<
    sizeof(fallback::flag(), put_uint8(result, c), fallback::flag()) !=
    1>::put(result, c);
}

template <typename T>
constexpr auto
data_is_mutable(T *t) -> decltype(t->data()[size_t(0)] = 'x', bool()) {
  return (void)t, true;
}
constexpr bool data_is_mutable(...) { return false; }

template <typename Result> class direct_data_access_result_state {
public:
  inline __attribute__((always_inline)) void
  init(Result &result, size_t capacity) {
    result.resize(capacity);

    m_buffer = result.data();
  }
  inline __attribute__((always_inline)) void put(Result &, char c) {
    m_buffer[m_offset++] = c;
  }
  inline __attribute__((always_inline)) void finish(Result &result) {
    result.resize(m_offset);
  }
  inline __attribute__((always_inline)) size_t size(const Result &) {
    return m_offset;
  }

private:
  typename std::remove_reference<
    decltype(std::declval<Result>().data()[size_t(0)] = 'x')>::type *m_buffer;
  size_t m_offset = 0;
};

template <
  typename Result,
  typename = typename std::enable_if<
    data_is_mutable(static_cast<Result *>(nullptr))>::type>
inline __attribute__((always_inline)) direct_data_access_result_state<Result>
create_state(Result &, specific_t) {
  return direct_data_access_result_state<Result>();
}

static_assert(
  std::is_same<
    decltype(create_state(
      *static_cast<std::vector<uint8_t> *>(nullptr), specific_t()
    )),
    direct_data_access_result_state<std::vector<uint8_t>>>::value,
  "std::vector<uint8_t> must be handled by direct_data_access_result_state"
);

template <typename Result>
inline __attribute__((always_inline)) void init(
  Result &result, direct_data_access_result_state<Result> &state,
  size_t capacity
) {
  state.init(result, capacity);
}

template <typename Result>
inline __attribute__((always_inline)) void
put(Result &result, direct_data_access_result_state<Result> &state, char c) {
  state.put(result, c);
}

template <typename Result>
inline __attribute__((always_inline)) void
finish(Result &result, direct_data_access_result_state<Result> &state) {
  state.finish(result);
}

template <typename T>
constexpr auto
array_access_is_mutable(T *t) -> decltype((*t)[size_t(0)] = 'x', bool()) {
  return (void)t, true;
}
constexpr bool array_access_is_mutable(...) { return false; }

template <typename Result> class array_access_result_state {
public:
  inline __attribute__((always_inline)) void
  init(Result &result, size_t capacity) {
    result.resize(capacity);
  }
  inline __attribute__((always_inline)) void put(Result &result, char c) {
    result[m_offset++] = c;
  }
  inline __attribute__((always_inline)) void finish(Result &result) {
    result.resize(m_offset);
  }
  inline __attribute__((always_inline)) size_t size(const Result &) {
    return m_offset;
  }

private:
  size_t m_offset = 0;
};

template <
  typename Result,
  typename = typename std::enable_if<
    !data_is_mutable(static_cast<Result *>(nullptr)) &&
    array_access_is_mutable(static_cast<Result *>(nullptr))>::type>
inline __attribute__((always_inline)) array_access_result_state<Result>
create_state(Result &, specific_t) {
  return array_access_result_state<Result>();
}

static_assert(
  std::is_same<
    decltype(create_state(*static_cast<std::string *>(nullptr), specific_t())),
    direct_data_access_result_state<std::string>>::value,
  "std::string (C++17 and later) must be handled by "
  "direct_data_access_result_state"
);

template <typename Result>
inline __attribute__((always_inline)) void init(
  Result &result, array_access_result_state<Result> &state, size_t capacity
) {
  state.init(result, capacity);
}

template <typename Result>
inline __attribute__((always_inline)) void
put(Result &result, array_access_result_state<Result> &state, char c) {
  state.put(result, c);
}

template <typename Result>
inline __attribute__((always_inline)) void
finish(Result &result, array_access_result_state<Result> &state) {
  state.finish(result);
}

template <typename T> inline const char *char_data(const T &t) {
  return reinterpret_cast<const char *>(t.data());
}
template <typename T, size_t N>
inline const char *char_data(const T (&t)[N]) noexcept {
  return reinterpret_cast<const char *>(&(t[0]));
}

template <typename T> inline const uint8_t *uchar_data(const T &t) {
  return reinterpret_cast<const uint8_t *>(char_data(t));
}

}} // namespace cppcodec::data

namespace cppcodec { namespace data {

class raw_result_buffer {
public:
  raw_result_buffer(char *data, size_t capacity) :
    m_ptr(data + capacity), m_begin(data) { }

  char last() const { return *(m_ptr - 1); }
  void push_back(char c) {
    *m_ptr = c;
    ++m_ptr;
  }
  size_t size() const { return m_ptr - m_begin; }
  void resize(size_t size) { m_ptr = m_begin + size; }

private:
  char *m_ptr;
  char *m_begin;
};

template <>
inline void init<raw_result_buffer>(
  raw_result_buffer &result, empty_result_state &, size_t capacity
) {
  if (capacity > result.size()) { abort(); }
  result.resize(0);
}
template <>
inline void
finish<raw_result_buffer>(raw_result_buffer &, empty_result_state &) { }

}} // namespace cppcodec::data

namespace cppcodec { namespace detail {

template <typename T>
struct non_numeric : std::enable_if<!std::is_arithmetic<T>::value> { };

template <typename CodecImpl> class codec {
public:
  static std::string encode(const uint8_t *binary, size_t binary_size);
  static std::string encode(const char *binary, size_t binary_size);

  template <typename Result>
  static Result encode(const uint8_t *binary, size_t binary_size);
  template <typename Result>
  static Result encode(const char *binary, size_t binary_size);
  template <typename Result = std::string, typename T = std::vector<uint8_t>>
  static Result encode(const T &binary);

  template <typename Result>
  static void
  encode(Result &encoded_result, const uint8_t *binary, size_t binary_size);
  template <typename Result>
  static void
  encode(Result &encoded_result, const char *binary, size_t binary_size);
  template <
    typename Result, typename T, typename non_numeric<T>::type * = nullptr>
  static void encode(Result &encoded_result, const T &binary);

  static size_t encode(
    char *encoded_result, size_t encoded_buffer_size, const uint8_t *binary,
    size_t binary_size
  ) noexcept;
  static size_t encode(
    char *encoded_result, size_t encoded_buffer_size, const char *binary,
    size_t binary_size
  ) noexcept;
  template <typename T>
  static size_t encode(
    char *encoded_result, size_t encoded_buffer_size, const T &binary
  ) noexcept;

  static constexpr size_t encoded_size(size_t binary_size) noexcept;

  static std::vector<uint8_t> decode(const char *encoded, size_t encoded_size);

  template <typename Result>
  static Result decode(const char *encoded, size_t encoded_size);
  template <typename Result = std::vector<uint8_t>, typename T = std::string>
  static Result decode(const T &encoded);

  template <typename Result>
  static void
  decode(Result &binary_result, const char *encoded, size_t encoded_size);
  template <
    typename Result, typename T, typename non_numeric<T>::type * = nullptr>
  static void decode(Result &binary_result, const T &encoded);

  static size_t decode(
    uint8_t *binary_result, size_t binary_buffer_size, const char *encoded,
    size_t encoded_size
  );
  static size_t decode(
    char *binary_result, size_t binary_buffer_size, const char *encoded,
    size_t encoded_size
  );
  template <typename T>
  static size_t
  decode(uint8_t *binary_result, size_t binary_buffer_size, const T &encoded);
  template <typename T>
  static size_t
  decode(char *binary_result, size_t binary_buffer_size, const T &encoded);

  static constexpr size_t decoded_max_size(size_t encoded_size) noexcept;
};

template <typename CodecImpl>
inline std::string
codec<CodecImpl>::encode(const uint8_t *binary, size_t binary_size) {
  return encode<std::string>(binary, binary_size);
}

template <typename CodecImpl>
inline std::string
codec<CodecImpl>::encode(const char *binary, size_t binary_size) {
  return encode<std::string>(
    reinterpret_cast<const uint8_t *>(binary), binary_size
  );
}

template <typename CodecImpl>
template <typename Result>
inline Result
codec<CodecImpl>::encode(const uint8_t *binary, size_t binary_size) {
  Result encoded_result;
  encode(encoded_result, binary, binary_size);
  return encoded_result;
}

template <typename CodecImpl>
template <typename Result>
inline Result codec<CodecImpl>::encode(const char *binary, size_t binary_size) {
  return encode<Result>(reinterpret_cast<const uint8_t *>(binary), binary_size);
}

template <typename CodecImpl>
template <typename Result, typename T>
inline Result codec<CodecImpl>::encode(const T &binary) {
  return encode<Result>(data::uchar_data(binary), data::size(binary));
}

template <typename CodecImpl>
template <typename Result>
inline void codec<CodecImpl>::encode(
  Result &encoded_result, const uint8_t *binary, size_t binary_size
) {
  size_t encoded_buffer_size = encoded_size(binary_size);
  auto state = data::create_state(encoded_result, data::specific_t());
  data::init(encoded_result, state, encoded_buffer_size);

  CodecImpl::encode(encoded_result, state, binary, binary_size);
  data::finish(encoded_result, state);
  (static_cast<bool>(data::size(encoded_result) == encoded_buffer_size) ?
     void(0) :
     __assert_fail(
       "data::size(encoded_result) == encoded_buffer_size", __builtin_FILE(),
       __builtin_LINE(), __extension__ __PRETTY_FUNCTION__
     ));
}

template <typename CodecImpl>
template <typename Result>
inline void codec<CodecImpl>::encode(
  Result &encoded_result, const char *binary, size_t binary_size
) {
  encode(
    encoded_result, reinterpret_cast<const uint8_t *>(binary), binary_size
  );
}

template <typename CodecImpl>
template <typename Result, typename T, typename non_numeric<T>::type *>
inline void codec<CodecImpl>::encode(Result &encoded_result, const T &binary) {
  encode(encoded_result, data::uchar_data(binary), data::size(binary));
}

template <typename CodecImpl>
inline size_t codec<CodecImpl>::encode(
  char *encoded_result, size_t encoded_buffer_size, const uint8_t *binary,
  size_t binary_size
) noexcept {
  data::raw_result_buffer encoded(encoded_result, encoded_buffer_size);
  encode(encoded, binary, binary_size);

  size_t encoded_size = data::size(encoded);
  if (encoded_size < encoded_buffer_size) {
    encoded_result[encoded_size] = '\0';
  }
  return encoded_size;
}

template <typename CodecImpl>
inline size_t codec<CodecImpl>::encode(
  char *encoded_result, size_t encoded_buffer_size, const char *binary,
  size_t binary_size
) noexcept {
  return encode(
    encoded_result, encoded_buffer_size,
    reinterpret_cast<const uint8_t *>(binary), binary_size
  );
}

template <typename CodecImpl>
template <typename T>
inline size_t codec<CodecImpl>::encode(
  char *encoded_result, size_t encoded_buffer_size, const T &binary
) noexcept {
  return encode(
    encoded_result, encoded_buffer_size, data::uchar_data(binary),
    data::size(binary)
  );
}

template <typename CodecImpl>
inline constexpr size_t
codec<CodecImpl>::encoded_size(size_t binary_size) noexcept {
  return CodecImpl::encoded_size(binary_size);
}

template <typename CodecImpl>
inline std::vector<uint8_t>
codec<CodecImpl>::decode(const char *encoded, size_t encoded_size) {
  return decode<std::vector<uint8_t>>(encoded, encoded_size);
}

template <typename CodecImpl>
template <typename Result>
inline Result
codec<CodecImpl>::decode(const char *encoded, size_t encoded_size) {
  Result result;
  decode(result, encoded, encoded_size);
  return result;
}

template <typename CodecImpl>
template <typename Result, typename T>
inline Result codec<CodecImpl>::decode(const T &encoded) {
  return decode<Result>(data::char_data(encoded), data::size(encoded));
}

template <typename CodecImpl>
template <typename Result>
inline void codec<CodecImpl>::decode(
  Result &binary_result, const char *encoded, size_t encoded_size
) {
  size_t binary_buffer_size = decoded_max_size(encoded_size);
  auto state = data::create_state(binary_result, data::specific_t());
  data::init(binary_result, state, binary_buffer_size);

  CodecImpl::decode(binary_result, state, encoded, encoded_size);
  data::finish(binary_result, state);
  (static_cast<bool>(data::size(binary_result) <= binary_buffer_size) ?
     void(0) :
     __assert_fail(
       "data::size(binary_result) <= binary_buffer_size", __builtin_FILE(),
       __builtin_LINE(), __extension__ __PRETTY_FUNCTION__
     ));
}

template <typename CodecImpl>
template <typename Result, typename T, typename non_numeric<T>::type *>
inline void codec<CodecImpl>::decode(Result &binary_result, const T &encoded) {
  decode(binary_result, data::char_data(encoded), data::size(encoded));
}

template <typename CodecImpl>
inline size_t codec<CodecImpl>::decode(
  uint8_t *binary_result, size_t binary_buffer_size, const char *encoded,
  size_t encoded_size
) {
  return decode(
    reinterpret_cast<char *>(binary_result), binary_buffer_size, encoded,
    encoded_size
  );
}

template <typename CodecImpl>
inline size_t codec<CodecImpl>::decode(
  char *binary_result, size_t binary_buffer_size, const char *encoded,
  size_t encoded_size
) {
  data::raw_result_buffer binary(binary_result, binary_buffer_size);
  decode(binary, encoded, encoded_size);
  return data::size(binary);
}

template <typename CodecImpl>
template <typename T>
inline size_t codec<CodecImpl>::decode(
  uint8_t *binary_result, size_t binary_buffer_size, const T &encoded
) {
  return decode(
    reinterpret_cast<char *>(binary_result), binary_buffer_size, encoded
  );
}

template <typename CodecImpl>
template <typename T>
inline size_t codec<CodecImpl>::decode(
  char *binary_result, size_t binary_buffer_size, const T &encoded
) {
  return decode(
    binary_result, binary_buffer_size, data::char_data(encoded),
    data::size(encoded)
  );
}

template <typename CodecImpl>
inline constexpr size_t
codec<CodecImpl>::decoded_max_size(size_t encoded_size) noexcept {
  return CodecImpl::decoded_max_size(encoded_size);
}

}} // namespace cppcodec::detail

namespace cppcodec {

namespace detail {

template <int N> static void uctoa(unsigned char n, char (&s)[N]) {
  static_assert(
    N >= 4, "need at least 4 bytes to convert an unsigned char to string safely"
  );
  int i = sizeof(s) - 1;
  int num_chars = 1;
  s[i--] = '\0';
  do {
    s[i--] = n % 10 + '0';
    ++num_chars;
  } while ((n /= 10) > 0);

  if (num_chars == sizeof(s)) { return; }
  for (i = 0; i < num_chars; ++i) { s[i] = s[i + (sizeof(s) - num_chars)]; }
}
} // namespace detail

class parse_error : public std::domain_error {
public:
  using std::domain_error::domain_error;
};

class symbol_error : public parse_error {
public:
  symbol_error(char c) :
    parse_error(symbol_error::make_error_message(c)), m_symbol(c) { }

  symbol_error(const symbol_error &) = default;

  char symbol() const noexcept { return m_symbol; }

private:
  static std::string make_error_message(char c) {
    char s[4];
    detail::uctoa(*reinterpret_cast<unsigned char *>(&c), s);
    return std::string("parse error: character [") + &(s[0]) + " '" + c +
      "'] out of bounds";
  }

private:
  char m_symbol;
};

class invalid_input_length : public parse_error {
public:
  using parse_error::parse_error;
};

class padding_error : public invalid_input_length {
public:
  padding_error() :
    invalid_input_length(
      "parse error: codec expects padded input string but padding was invalid"
    ) { }

  padding_error(const padding_error &) = default;
};

} // namespace cppcodec

namespace cppcodec { namespace detail {

using alphabet_index_t = uint_fast16_t;

template <typename Codec, typename CodecVariant> class stream_codec {
public:
  template <typename Result, typename ResultState>
  static void encode(
    Result &encoded_result, ResultState &, const uint8_t *binary,
    size_t binary_size
  );

  template <typename Result, typename ResultState>
  static void decode(
    Result &binary_result, ResultState &, const char *encoded,
    size_t encoded_size
  );

  static constexpr size_t encoded_size(size_t binary_size) noexcept;
  static constexpr size_t decoded_max_size(size_t encoded_size) noexcept;
};

template <bool GeneratesPadding> struct padder {
  template <
    typename CodecVariant, typename Result, typename ResultState,
    typename EncodedBlockSizeT>
  inline __attribute__((always_inline)) void
  operator()(Result &, ResultState &, EncodedBlockSizeT) { }
};

template <> struct padder<true> {
  template <
    typename CodecVariant, typename Result, typename ResultState,
    typename EncodedBlockSizeT>
  inline __attribute__((always_inline)) void operator()(
    Result &encoded, ResultState &state,
    EncodedBlockSizeT num_padding_characters
  ) {
    for (EncodedBlockSizeT i = 0; i < num_padding_characters; ++i) {
      data::put(encoded, state, CodecVariant::padding_symbol());
    }
  }
};

template <size_t I> struct enc {
  template <
    typename Codec, typename CodecVariant, typename Result,
    typename ResultState>
  inline static __attribute__((always_inline)) void
  block(Result &encoded, ResultState &state, const uint8_t *src) {
    using EncodedBlockSizeT = decltype(Codec::encoded_block_size());
    static constexpr const EncodedBlockSizeT SymbolIndex =
      static_cast<EncodedBlockSizeT>(I - 1);

    enc<I - 1>().template block<Codec, CodecVariant>(encoded, state, src);
    data::put(
      encoded, state,
      CodecVariant::symbol(Codec::template index<SymbolIndex>(src))
    );
  }

  template <
    typename Codec, typename CodecVariant, typename Result,
    typename ResultState,
    typename EncodedBlockSizeT = decltype(Codec::encoded_block_size())>
  inline static __attribute__((always_inline)) void tail(
    Result &encoded, ResultState &state, const uint8_t *src,
    EncodedBlockSizeT num_symbols
  ) {
    static constexpr const EncodedBlockSizeT SymbolIndex =
      Codec::encoded_block_size() - I;
    static constexpr const EncodedBlockSizeT NumSymbols =
      SymbolIndex + static_cast<EncodedBlockSizeT>(1);

    if (num_symbols == NumSymbols) {
      data::put(
	encoded, state,
	CodecVariant::symbol(Codec::template index_last<SymbolIndex>(src))
      );
      padder<CodecVariant::generates_padding()> pad;

      pad.template operator(
      )<CodecVariant>(encoded, state, Codec::encoded_block_size() - NumSymbols);

      return;
    }
    data::put(
      encoded, state,
      CodecVariant::symbol(Codec::template index<SymbolIndex>(src))
    );
    enc<I - 1>().template tail<Codec, CodecVariant>(
      encoded, state, src, num_symbols
    );
  }
};

template <> struct enc<0> {
  template <
    typename Codec, typename CodecVariant, typename Result,
    typename ResultState>
  inline static __attribute__((always_inline)) void
  block(Result &, ResultState &, const uint8_t *) { }

  template <
    typename Codec, typename CodecVariant, typename Result,
    typename ResultState,
    typename EncodedBlockSizeT = decltype(Codec::encoded_block_size())>
  inline static __attribute__((always_inline)) void
  tail(Result &, ResultState &, const uint8_t *, EncodedBlockSizeT) {
    abort();
  }
};

template <typename Codec, typename CodecVariant>
template <typename Result, typename ResultState>
inline void stream_codec<Codec, CodecVariant>::encode(
  Result &encoded_result, ResultState &state, const uint8_t *src,
  size_t src_size
) {
  using encoder = enc<Codec::encoded_block_size()>;

  const uint8_t *src_end = src + src_size;

  if (src_size >= Codec::binary_block_size()) {
    src_end -= Codec::binary_block_size();

    for (; src <= src_end; src += Codec::binary_block_size()) {
      encoder::template block<Codec, CodecVariant>(encoded_result, state, src);
    }
    src_end += Codec::binary_block_size();
  }

  if (src_end > src) {
    auto remaining_src_len = src_end - src;
    if (!remaining_src_len || remaining_src_len >= Codec::binary_block_size()) {
      abort();
      return;
    }
    auto num_symbols =
      Codec::num_encoded_tail_symbols(static_cast<uint8_t>(remaining_src_len));
    encoder::template tail<Codec, CodecVariant>(
      encoded_result, state, src, num_symbols
    );
  }
}

template <unsigned... Is> struct seq { };

template <unsigned N, unsigned... Is>
struct gen_seq : gen_seq<N - 4, N - 4, N - 3, N - 2, N - 1, Is...> {
  static_assert(N % 4 == 0, "I must be divisible by 4 to eventually end at 0");
};
template <unsigned... Is> struct gen_seq<0, Is...> : seq<Is...> { };

template <size_t N> struct lookup_table_t {
  alphabet_index_t lookup[N];
  static constexpr size_t size = N;
};

template <typename LambdaType, unsigned... Is>
constexpr lookup_table_t<sizeof...(Is)>
make_lookup_table(seq<Is...>, LambdaType value_for_index) {
  return {{value_for_index(Is)...}};
}

template <unsigned N, typename LambdaType>
constexpr lookup_table_t<N> make_lookup_table(LambdaType evalFunc) {
  return make_lookup_table(gen_seq<N>(), evalFunc);
}

template <typename T>
inline static __attribute__((always_inline)) constexpr size_t
num_possible_values() {
  return static_cast<size_t>(
    static_cast<intmax_t>(std::numeric_limits<T>::max()) -
    static_cast<intmax_t>(std::numeric_limits<T>::min()) + 1
  );
}

template <typename CodecVariant, alphabet_index_t InvalidIdx, size_t I>
struct index_if_in_alphabet {
  inline static __attribute__((always_inline)) constexpr alphabet_index_t
  for_symbol(char symbol) {
    return (CodecVariant::symbol(
	      static_cast<alphabet_index_t>(CodecVariant::alphabet_size() - I)
	    ) == symbol) ?
      static_cast<alphabet_index_t>(CodecVariant::alphabet_size() - I) :
      index_if_in_alphabet<CodecVariant, InvalidIdx, I - 1>::for_symbol(symbol);
  }
};
template <typename CodecVariant, alphabet_index_t InvalidIdx>
struct index_if_in_alphabet<CodecVariant, InvalidIdx, 0> {
  inline static __attribute__((always_inline)) constexpr alphabet_index_t
  for_symbol(char) {
    return InvalidIdx;
  }
};

template <typename CodecVariant, size_t I> struct padding_searcher {
  inline static __attribute__((always_inline)) constexpr bool
  exists_padding_symbol() {
    static_assert(
      I % 4 == 0, "I must be divisible by 4 to eventually end at 0"
    );

    return CodecVariant::is_padding_symbol(
	     static_cast<char>(num_possible_values<char>() - I - 4)
	   ) ||
      CodecVariant::is_padding_symbol(
	     static_cast<char>(num_possible_values<char>() - I - 3)
      ) ||
      CodecVariant::is_padding_symbol(
	     static_cast<char>(num_possible_values<char>() - I - 2)
      ) ||
      CodecVariant::is_padding_symbol(
	     static_cast<char>(num_possible_values<char>() - I - 1)
      ) ||
      padding_searcher<CodecVariant, I - 4>::exists_padding_symbol();
  }
};
template <typename CodecVariant> struct padding_searcher<CodecVariant, 0> {
  inline static __attribute__((always_inline)) constexpr bool
  exists_padding_symbol() {
    return false;
  }
};

template <typename CodecVariant> struct alphabet_index_info {
  static constexpr const size_t num_possible_symbols =
    num_possible_values<char>();

  static constexpr const alphabet_index_t padding_idx = 1 << 8;
  static constexpr const alphabet_index_t invalid_idx = 1 << 9;
  static constexpr const alphabet_index_t eof_idx = 1 << 10;
  static constexpr const alphabet_index_t stop_character_mask =
    static_cast<alphabet_index_t>(~0xFFu);

  static constexpr const bool padding_allowed =
    padding_searcher<CodecVariant, num_possible_symbols>::exists_padding_symbol(
    );

  inline static __attribute__((always_inline)) constexpr bool allows_padding() {
    return padding_allowed;
  }
  inline static __attribute__((always_inline)) constexpr bool
  is_padding(alphabet_index_t idx) {
    return allows_padding() ? (idx == padding_idx) : false;
  }
  inline static __attribute__((always_inline)) constexpr bool
  is_invalid(alphabet_index_t idx) {
    return idx == invalid_idx;
  }
  inline static __attribute__((always_inline)) constexpr bool
  is_eof(alphabet_index_t idx) {
    return idx == eof_idx;
  }
  inline static __attribute__((always_inline)) constexpr bool
  is_stop_character(alphabet_index_t idx) {
    return (idx & stop_character_mask) != 0;
  }

private:
  inline static __attribute__((always_inline)) constexpr alphabet_index_t
  valid_index_or(alphabet_index_t a, alphabet_index_t b) {
    return a == invalid_idx ? b : a;
  }

  using idx_if_in_alphabet = index_if_in_alphabet<
    CodecVariant, invalid_idx, CodecVariant::alphabet_size()>;

  inline static __attribute__((always_inline)) constexpr alphabet_index_t
  index_of(char symbol) {
    return valid_index_or(
      idx_if_in_alphabet::for_symbol(symbol),
      CodecVariant::is_eof_symbol(symbol)       ? eof_idx :
	CodecVariant::is_padding_symbol(symbol) ? padding_idx :
						  invalid_idx
    );
  }

  inline static __attribute__((always_inline)) constexpr alphabet_index_t
  index_at(size_t symbol) {
    return index_of(CodecVariant::normalized_symbol(static_cast<char>(symbol)));
  }

public:
  struct lookup {
    inline static __attribute__((always_inline)) alphabet_index_t for_symbol(
      char symbol
    ) {
      static constexpr const auto t =
	make_lookup_table<num_possible_symbols>(&index_at);

      static_assert(
	t.size == num_possible_symbols,
	"lookup table must cover each possible (character) symbol"
      );
      return t.lookup[static_cast<uint8_t>(symbol)];
    }
  };
};

template <typename Codec, typename CodecVariant>
template <typename Result, typename ResultState>
inline void stream_codec<Codec, CodecVariant>::decode(
  Result &binary_result, ResultState &state, const char *src_encoded,
  size_t src_size
) {
  using alphabet_index_lookup =
    typename alphabet_index_info<CodecVariant>::lookup;
  const char *src = src_encoded;
  const char *src_end = src + src_size;

  alphabet_index_t alphabet_indexes[Codec::encoded_block_size()] = {};
  alphabet_indexes[0] = alphabet_index_info<CodecVariant>::eof_idx;

  alphabet_index_t *const alphabet_index_start = &alphabet_indexes[0];
  alphabet_index_t *const alphabet_index_end =
    &alphabet_indexes[Codec::encoded_block_size()];
  alphabet_index_t *alphabet_index_ptr = &alphabet_indexes[0];

  while (src < src_end) {
    if (CodecVariant::should_ignore(*src)) {
      ++src;
      continue;
    }
    *alphabet_index_ptr = alphabet_index_lookup::for_symbol(*src);
    if (alphabet_index_info<CodecVariant>::is_stop_character(*alphabet_index_ptr
	)) {
      break;
    }
    ++src;
    ++alphabet_index_ptr;

    if (alphabet_index_ptr == alphabet_index_end) {
      Codec::decode_block(binary_result, state, alphabet_indexes);
      alphabet_index_ptr = alphabet_index_start;
    }
  }

  if (alphabet_index_info<CodecVariant>::is_invalid(*alphabet_index_ptr)) {
    throw symbol_error(*src);
  }
  ++src;

  alphabet_index_t *last_index_ptr = alphabet_index_ptr;
  if (alphabet_index_info<CodecVariant>::is_padding(*last_index_ptr)) {
    if (last_index_ptr == alphabet_index_start) { throw padding_error(); }

    ++last_index_ptr;
    while (src < src_end) {
      *alphabet_index_ptr = alphabet_index_lookup::for_symbol(*(src++));

      if (alphabet_index_info<CodecVariant>::is_eof(*alphabet_index_ptr)) {
	*alphabet_index_ptr = alphabet_index_info<CodecVariant>::padding_idx;
	break;
      }
      if (!alphabet_index_info<CodecVariant>::is_padding(*alphabet_index_ptr)) {
	throw padding_error();
      }

      ++last_index_ptr;
      if (last_index_ptr > alphabet_index_end) { throw padding_error(); }
    }
  }

  if (last_index_ptr != alphabet_index_start) {
    if ((CodecVariant::requires_padding() ||
	 alphabet_index_info<CodecVariant>::is_padding(*alphabet_index_ptr)) &&
	last_index_ptr != alphabet_index_end) {
      throw padding_error();
    }
    if (alphabet_index_ptr >= alphabet_index_end) {
      abort();
      return;
    }
    Codec::decode_tail(
      binary_result, state, alphabet_indexes,
      static_cast<size_t>(alphabet_index_ptr - alphabet_index_start)
    );
  }
}

template <typename Codec, typename CodecVariant>
inline constexpr size_t
stream_codec<Codec, CodecVariant>::encoded_size(size_t binary_size) noexcept {
  using C = Codec;

  return CodecVariant::generates_padding()

    ?
    (binary_size + (C::binary_block_size() - 1) -
     ((binary_size + (C::binary_block_size() - 1)) % C::binary_block_size())) *
      C::encoded_block_size() / C::binary_block_size()

    :
    (binary_size * C::encoded_block_size() / C::binary_block_size()) +
      (((binary_size * C::encoded_block_size()) % C::binary_block_size()) ? 1 :
									    0);
}

template <typename Codec, typename CodecVariant>
inline constexpr size_t
stream_codec<Codec, CodecVariant>::decoded_max_size(size_t encoded_size
) noexcept {
  using C = Codec;

  return CodecVariant::requires_padding() ?
    (encoded_size / C::encoded_block_size() * C::binary_block_size()) :
    (encoded_size / C::encoded_block_size() * C::binary_block_size()) +
      ((encoded_size % C::encoded_block_size()) * C::binary_block_size() /
       C::encoded_block_size());
}

}} // namespace cppcodec::detail

namespace cppcodec { namespace detail {

template <typename CodecVariant>
class base64 : public CodecVariant::template codec_impl<base64<CodecVariant>> {
public:
  inline static constexpr uint8_t binary_block_size() { return 3; }
  inline static constexpr uint8_t encoded_block_size() { return 4; }

  inline static __attribute__((always_inline)) constexpr uint8_t
  num_encoded_tail_symbols(uint8_t num_bytes) {
    return (num_bytes == 1) ?
      2 :
      (num_bytes == 2) ?
      3 :
      throw std::domain_error("invalid number of bytes in a tail block");
  }

  template <uint8_t I>
  inline static __attribute__((always_inline)) constexpr uint8_t
  index(const uint8_t *b) noexcept {
    static_assert(
      I >= 0 && I < encoded_block_size(),
      "invalid encoding symbol index in a block"
    );

    return (I == 0) ? (b[0] >> 2) :
      (I == 1)      ? (((b[0] & 0x3) << 4) | (b[1] >> 4)) :
      (I == 2)      ? (((b[1] & 0xF) << 2) | (b[2] >> 6)) :
		      (b[2] & 0x3F);
  }

  template <bool B> using uint8_if = typename std::enable_if<B, uint8_t>::type;

  template <uint8_t I>
  inline static
    __attribute__((always_inline)) constexpr uint8_if<I == 1 || I == 2>
    index_last(const uint8_t *b) noexcept {
    return (I == 1) ? ((b[0] & 0x3) << 4) : ((b[1] & 0xF) << 2);
  }

  template <uint8_t I>
  inline static __attribute__((always_inline)) uint8_if<I != 1 && I != 2>
  index_last(const uint8_t *) {
    throw std::domain_error("invalid last encoding symbol index in a tail");
  }

  template <typename Result, typename ResultState>
  inline static __attribute__((always_inline)) void
  decode_block(Result &decoded, ResultState &, const alphabet_index_t *idx);

  template <typename Result, typename ResultState>
  inline static __attribute__((always_inline)) void decode_tail(
    Result &decoded, ResultState &, const alphabet_index_t *idx, size_t idx_len
  );
};

template <typename CodecVariant>
template <typename Result, typename ResultState>
inline __attribute__((always_inline)) void base64<CodecVariant>::decode_block(
  Result &decoded, ResultState &state, const alphabet_index_t *idx
) {
  uint_fast32_t dec = (idx[0] << 18) | (idx[1] << 12) | (idx[2] << 6) | idx[3];
  data::put(decoded, state, static_cast<uint8_t>(dec >> 16));
  data::put(decoded, state, static_cast<uint8_t>((dec >> 8) & 0xFF));
  data::put(decoded, state, static_cast<uint8_t>(dec & 0xFF));
}

template <typename CodecVariant>
template <typename Result, typename ResultState>
inline __attribute__((always_inline)) void base64<CodecVariant>::decode_tail(
  Result &decoded, ResultState &state, const alphabet_index_t *idx,
  size_t idx_len
) {
  if (idx_len == 1) {
    throw invalid_input_length(
      "invalid number of symbols in last base64 block: found 1, expected 2 or 3"
    );
  }

  data::put(
    decoded, state, static_cast<uint8_t>((idx[0] << 2) + ((idx[1] & 0x30) >> 4))
  );
  if (idx_len == 2) { return; }

  data::put(
    decoded, state,
    static_cast<uint8_t>(((idx[1] & 0xF) << 4) + ((idx[2] & 0x3C) >> 2))
  );
}

}} // namespace cppcodec::detail

namespace cppcodec {

namespace detail {

static constexpr const char base64_rfc4648_alphabet[] = {
  'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
  'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
  'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
  'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
  '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'
};

class base64_rfc4648 {
public:
  template <typename Codec>
  using codec_impl = stream_codec<Codec, base64_rfc4648>;

  inline static __attribute__((always_inline)) constexpr size_t
  alphabet_size() {
    static_assert(
      sizeof(base64_rfc4648_alphabet) == 64,
      "base64 alphabet must have 64 values"
    );
    return sizeof(base64_rfc4648_alphabet);
  }
  inline static __attribute__((always_inline)) constexpr char
  symbol(alphabet_index_t idx) {
    return base64_rfc4648_alphabet[idx];
  }
  inline static __attribute__((always_inline)) constexpr char
  normalized_symbol(char c) {
    return c;
  }

  inline static __attribute__((always_inline)) constexpr bool
  generates_padding() {
    return true;
  }
  inline static __attribute__((always_inline)) constexpr bool
  requires_padding() {
    return true;
  }
  inline static __attribute__((always_inline)) constexpr char padding_symbol() {
    return '=';
  }
  inline static __attribute__((always_inline)) constexpr bool
  is_padding_symbol(char c) {
    return c == '=';
  }
  inline static __attribute__((always_inline)) constexpr bool
  is_eof_symbol(char c) {
    return c == '\0';
  }

  inline static __attribute__((always_inline)) constexpr bool
  should_ignore(char) {
    return false;
  }
};

} // namespace detail

using base64_rfc4648 = detail::codec<detail::base64<detail::base64_rfc4648>>;

} // namespace cppcodec

namespace ZuBase64 {

inline constexpr bool is(char c) {
  return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') ||
    (c >= '0' && c <= '9') || c == '+' || c == '/' || c == '=';
}

inline constexpr unsigned enclen(unsigned slen) {
  return ((slen + 2) / 3) << 2;
}
inline unsigned encode(ZuSpan<uint8_t> dst, ZuBytes src) {
  using base64 = cppcodec::base64_rfc4648;
  try {
    return base64::encode(
      reinterpret_cast<char *>(dst.data()), dst.length(), src.data(),
      src.length()
    );
  } catch (...) { return 0; }
}

inline constexpr unsigned declen(unsigned slen) {
  return ((slen + 3) >> 2) * 3;
}
inline unsigned decode(ZuSpan<uint8_t> dst, ZuBytes src) {
  using base64 = cppcodec::base64_rfc4648;
  try {
    return base64::decode(
      dst.data(), dst.length(), reinterpret_cast<const char *>(src.data()),
      src.length()
    );
  } catch (...) { return 0; }
}

} // namespace ZuBase64

template <typename Int, int Size> struct ZmAtomicOps;

template <typename Int32> struct ZmAtomicOps<Int32, 4> {
  using S = int32_t;
  using U = uint32_t;

  static Int32 load_(const Int32 *ptr) { return __atomic_load_n(ptr, 0); }
  static Int32 load(const Int32 *ptr) {
    Int32 i = __atomic_load_n(ptr, 0);
    __atomic_thread_fence(2);
    return i;
  }
  static void store_(Int32 *ptr, Int32 value) {
    __atomic_store_n(ptr, value, 0);
  }
  static void store(Int32 *ptr, Int32 value) {
    __atomic_thread_fence(3);
    __atomic_store_n(ptr, value, 0);
  }

  static Int32 atomicXch(volatile Int32 *ptr, Int32 value) {
    return __sync_lock_test_and_set(ptr, value);
  }

  static Int32 atomicXchAdd(volatile Int32 *ptr, Int32 value) {
    return __sync_fetch_and_add(ptr, value);
  }

  static Int32 atomicCmpXch(volatile Int32 *ptr, Int32 value, Int32 cmp) {
    return __sync_val_compare_and_swap(ptr, cmp, value);
  }
};

template <typename Int64> struct ZmAtomicOps<Int64, 8> {
  using S = int64_t;
  using U = uint64_t;

  static Int64 load_(const Int64 *ptr) { return __atomic_load_n(ptr, 0); }
  static Int64 load(const Int64 *ptr) {
    Int64 i = __atomic_load_n(ptr, 0);
    __atomic_thread_fence(2);
    return i;
  }
  static void store_(Int64 *ptr, Int64 value) {
    __atomic_store_n(ptr, value, 0);
  }
  static void store(Int64 *ptr, Int64 value) {
    __atomic_thread_fence(3);
    __atomic_store_n(ptr, value, 0);
  }

  static Int64 atomicXch(volatile Int64 *ptr, Int64 value) {
    return __sync_lock_test_and_set(ptr, value);
  }

  static Int64 atomicXchAdd(volatile Int64 *ptr, Int64 value) {
    return __sync_fetch_and_add(ptr, value);
  }

  static Int64 atomicCmpXch(volatile Int64 *ptr, Int64 value, Int64 cmp) {
    return __sync_val_compare_and_swap(ptr, cmp, value);
  }
};

template <typename Int128> struct ZmAtomicOps<Int128, 16> {
  using S = int128_t;
  using U = uint128_t;

  static Int128 load_(const Int128 *ptr) { return __atomic_load_n(ptr, 0); }
  static Int128 load(const Int128 *ptr) {
    Int128 i = __atomic_load_n(ptr, 0);
    __atomic_thread_fence(2);
    return i;
  }
  static void store_(Int128 *ptr, Int128 value) {
    __atomic_store_n(ptr, value, 0);
  }
  static void store(Int128 *ptr, Int128 value) {
    __atomic_thread_fence(3);
    __atomic_store_n(ptr, value, 0);
  }

  static Int128 atomicXch(volatile Int128 *ptr, Int128 value) {
    return __sync_lock_test_and_set(ptr, value);
  }

  static Int128 atomicXchAdd(volatile Int128 *ptr, Int128 value) {
    return __sync_fetch_and_add(ptr, value);
  }

  static Int128 atomicCmpXch(volatile Int128 *ptr, Int128 value, Int128 cmp) {
    return __sync_val_compare_and_swap(ptr, cmp, value);
  }
};

template <typename T> class ZmAtomic {
  static_assert(
    (ZuTraits<T>::IsPrimitive && ZuTraits<T>::IsIntegral),
    "ZuTraits<T>::IsPrimitive && ZuTraits<T>::IsIntegral"
  );

public:
  using Ops = ZmAtomicOps<T, sizeof(T)>;

private:
  using S = typename Ops::S;
  using U = typename Ops::U;

public:
  ZmAtomic() : m_val{0} {};

  ZmAtomic(const ZmAtomic &a) { Ops::store_(&m_val, Ops::load(&a.m_val)); };
  ZmAtomic(T val) { Ops::store_(&m_val, val); };

  ZmAtomic &operator=(const ZmAtomic &a) {
    Ops::store(&m_val, Ops::load(&a.m_val));
    return *this;
  }
  ZmAtomic &operator=(T val) {
    Ops::store(&m_val, val);
    return *this;
  }

  void store_(T val) { Ops::store_(&m_val, val); }

  operator T() const { return Ops::load(&m_val); }

  T load_() const { return Ops::load_(&m_val); }

  T xch(T val) { return Ops::atomicXch(&m_val, val); }
  T xchAdd(T val) { return Ops::atomicXchAdd(&m_val, val); }
  T xchSub(T val) { return Ops::atomicXchAdd(&m_val, -val); }
  T cmpXch(T val, T cmp) { return Ops::atomicCmpXch(&m_val, val, cmp); }

  T operator++() { return Ops::atomicXchAdd(&m_val, 1) + 1; }
  T operator--() { return Ops::atomicXchAdd(&m_val, -1) - 1; }

  T operator++(int) { return Ops::atomicXchAdd(&m_val, 1); }
  T operator--(int) { return Ops::atomicXchAdd(&m_val, -1); }

  T operator+=(S val) { return Ops::atomicXchAdd(&m_val, val) + val; }
  T operator-=(S val) { return Ops::atomicXchAdd(&m_val, -val) - val; }

  T xchOr(T val) {
    T old;
    do {
      if (((old = m_val) & val) == val) return old;
    } while (Ops::atomicCmpXch(&m_val, old | val, old) != old);
    return old;
  }
  T xchAnd(T val) {
    T old;
    do {
      if (!((old = m_val) & ~val)) return old;
    } while (Ops::atomicCmpXch(&m_val, old & val, old) != old);
    return old;
  }

  T operator|=(T val) { return xchOr(val) | val; }
  T operator&=(T val) { return xchAnd(val) & val; }

  T minimum(T val) {
    T old;
    do {
      if ((old = m_val) <= val) return old;
    } while (Ops::atomicCmpXch(&m_val, val, old) != old);
    return val;
  }
  T maximum(T val) {
    T old;
    do {
      if ((old = m_val) >= val) return old;
    } while (Ops::atomicCmpXch(&m_val, val, old) != old);
    return val;
  }

private:
  T m_val;
};

template <typename T> class ZmAtomic<T *> {
public:
  using Ops = ZmAtomicOps<uintptr_t, sizeof(T *)>;

private:
  using S = typename Ops::S;
  using U = typename Ops::U;

public:
  ZmAtomic() : m_val{0} { }

  ZmAtomic(const ZmAtomic &a) { Ops::store_(&m_val, Ops::load(&a.m_val)); }
  ZmAtomic(T *val) { Ops::store_(&m_val, reinterpret_cast<uintptr_t>(val)); }

  ZmAtomic &operator=(const ZmAtomic &a) {
    Ops::store(&m_val, Ops::load(&a.m_val));
    return *this;
  }
  ZmAtomic &operator=(T *val) {
    Ops::store(&m_val, reinterpret_cast<uintptr_t>(val));
    return *this;
  }

  void store_(T *val) { Ops::store_(&m_val, reinterpret_cast<U>(val)); }

  operator T *() const { return reinterpret_cast<T *>(Ops::load(&m_val)); }
  T *operator->() const { return reinterpret_cast<T *>(Ops::load(&m_val)); }

  T *load_() const { return reinterpret_cast<T *>(Ops::load_(&m_val)); }

  T *xch(T *val) {
    return reinterpret_cast<T *>(
      Ops::atomicXch(&m_val, reinterpret_cast<U>(val))
    );
  }
  T *xchAdd(S val) {
    return reinterpret_cast<T *>(Ops::atomicXchAdd(&m_val, val));
  }
  T *cmpXch(T *val, T *cmp) {
    return reinterpret_cast<T *>(Ops::atomicCmpXch(
      &m_val, reinterpret_cast<U>(val), reinterpret_cast<U>(cmp)
    ));
  }

  T *operator++() {
    return reinterpret_cast<T *>(Ops::atomicXchAdd(&m_val, sizeof(T))) +
      sizeof(T);
  }
  T *operator--() {
    return reinterpret_cast<T *>(Ops::atomicXchAdd(&m_val, -sizeof(T))) -
      sizeof(T);
  }

  T *operator++(int) {
    return reinterpret_cast<T *>(Ops::atomicXchAdd(&m_val, sizeof(T)));
  }
  T *operator--(int) {
    return reinterpret_cast<T *>(Ops::atomicXchAdd(&m_val, -sizeof(T)));
  }

  T *operator+=(S val) {
    val *= sizeof(T);
    return reinterpret_cast<T *>(Ops::atomicXchAdd(&m_val, val)) + val;
  }
  T *operator-=(S val) {
    val *= sizeof(T);
    return reinterpret_cast<T *>(Ops::atomicXchAdd(&m_val, -val)) - val;
  }

private:
  uintptr_t m_val;
};

template <typename T_> struct ZuTraits<ZmAtomic<T_>> : public ZuTraits<T_> {
  enum { IsPrimitive = 0 };
};

struct ZmBackTrace_Print;

class ZmBackTrace {
public:
  ZmBackTrace() { memset(m_frames, 0, sizeof(void *) * 64); }
  ZmBackTrace(unsigned skip) {
    memset(m_frames, 0, sizeof(void *) * 64);
    capture(skip + 1);
  }

  ZmBackTrace(const ZmBackTrace &t) {
    memcpy(m_frames, t.m_frames, sizeof(void *) * 64);
  }
  ZmBackTrace &operator=(const ZmBackTrace &t) {
    if (this != &t) memcpy(m_frames, t.m_frames, sizeof(void *) * 64);
    return *this;
  }

  bool equals(const ZmBackTrace &t) const {
    return !memcmp(m_frames, t.m_frames, sizeof(void *) * 64);
  }

  bool operator!() const { return !m_frames[0]; }

  void capture() { capture(1); }
  void capture(unsigned skip);

  void *const *frames() const { return m_frames; }

  friend ZmBackTrace_Print ZuPrintType(ZmBackTrace *);

private:
  void *m_frames[64];
};

inline bool operator==(const ZmBackTrace &l, const ZmBackTrace &r) {
  return l.equals(r);
}

class ZmObjectDebug;

extern "C" {
  extern void ZmObject_ref(const ZmObjectDebug *, const void *);
  extern void ZmObject_deref(const ZmObjectDebug *, const void *);
}

class ZmObjectDebug {
  friend void ZmObject_ref(const ZmObjectDebug *, const void *);
  friend void ZmObject_deref(const ZmObjectDebug *, const void *);

public:
  ZmObjectDebug() : m_debug(0) { }
  ~ZmObjectDebug() { ::free(m_debug); }

  void debug() const;

  typedef void (*DumpFn)(void *, const void *, const ZmBackTrace *);
  void dump(void *context, DumpFn fn) const;

protected:
  bool debugging_() const { return m_debug.load_(); }

  mutable ZmAtomic<void *> m_debug;
};

class ZmObject

  :
  public ZmObjectDebug

{
  ZmObject(const ZmObject &) = delete;
  ZmObject &operator=(const ZmObject &) = delete;
  ZmObject(ZmObject &&) = delete;
  ZmObject &operator=(ZmObject &&) = delete;

  friend ZmObject ZuObjectType(ZmObject *);

public:
  inline ZmObject() : m_refCount{0} { }

  inline ~ZmObject() { this->del_(); }

  inline int refCount() const { return m_refCount.load_(); }

  void ref(const void *referrer = 0) const

  {
    if (__builtin_expect(!!(this->deleted_()), 0)) return;
    if (__builtin_expect(!!(this->debugging_()), 0))
      ZmObject_ref(this, referrer);

    this->ref_();
  }

  bool deref(const void *referrer = 0) const

  {
    if (__builtin_expect(!!(this->deleted_()), 0)) return false;
    if (__builtin_expect(!!(this->debugging_()), 0))
      ZmObject_deref(this, referrer);

    return this->deref_();
  }

  void mvref(const void *prev, const void *next) const {
    if (__builtin_expect(!!(this->debugging_()), 0)) {
      ZmObject_ref(this, next);
      ZmObject_deref(this, prev);
    }
  }

  inline void ref_() const { ++m_refCount; }
  inline void ref2_() const { m_refCount += 2; }
  inline bool deref_() const { return !--m_refCount; }

private:
  inline bool deleted_() const { return m_refCount.load_() < 0; }
  inline void del_() const { m_refCount.store_(-1); }

  mutable ZmAtomic<int> m_refCount;
};

void ZuRefType(...);

template <typename T_> class ZuRef {
  template <typename> friend class ZuRef;
  friend T_ ZuRefType(ZuRef *);

public:
  using T = T_;

private:
  enum Acquire_ { Acquire };
  ZuRef(T *o, Acquire_ _) : m_object{o} { }

  template <typename V>
  struct IsOtherRef_ :
    public ZuBool<ZuInspect<T, V>::Base || ZuInspect<V, T>::Base> { };
  template <typename U>
  struct IsOtherRef :
    public IsOtherRef_<decltype(ZuRefType(ZuDeclVal<U *>()))> { };
  template <typename U, typename = void, bool = IsOtherRef<U>{}>
  struct MatchOtherRef_ { };
  template <typename U, typename R> struct MatchOtherRef_<U, R, true> {
    using T = R;
  };
  template <typename U, typename R = void>
  using MatchOtherRef = typename MatchOtherRef_<U, R>::T;

  template <typename V>
  struct IsRef_ : public ZuBool<ZuInspect<T, V>::Is || ZuInspect<V, T>::Is> { };
  template <typename U>
  struct IsRef : public IsRef_<decltype(ZuRefType(ZuDeclVal<U *>()))> { };
  template <typename U, typename = void, bool = IsRef<U>{}>
  struct MatchRef_ { };
  template <typename U, typename R> struct MatchRef_<U, R, true> {
    using T = R;
  };
  template <typename U, typename R = void>
  using MatchRef = typename MatchRef_<U, R>::T;

  template <typename U>
  struct IsPtr :
    public ZuBool<(ZuInspect<T, U>::Is || ZuInspect<U, T>::Is)> { };
  template <typename U, typename R = void>
  using MatchPtr = ZuIfT<IsPtr<U>{}, R>;

public:
  ZuRef() : m_object{0} { }
  ZuRef(const ZuRef &r) : m_object{r.m_object} {
    if (T *o = m_object) o->ref();
  }
  ZuRef(ZuRef &&r) noexcept : m_object{r.m_object} { r.m_object = 0; }
  template <typename R, decltype(MatchOtherRef<ZuDeref<R>>(), int()) = 0>
  ZuRef(R &&r) noexcept :
    m_object{static_cast<T *>(const_cast<ZuDeref<R> *>(r.m_object))} {
    ZuBind<R>::mvcp(ZuFwd<R>(r), [](auto &&r) {
      r.m_object = 0;
    }, [this](const auto &) {
      if (T *o = m_object) o->ref();
    });
  }
  ZuRef(T *o) : m_object{o} {
    if (o) o->ref();
  }
  template <typename O, decltype(MatchPtr<O>(), int()) = 0>
  ZuRef(O *o) : m_object{static_cast<T *>(o)} {
    if (o) o->ref();
  }
  ~ZuRef() {
    if (T *o = m_object)
      if (o->deref()) delete o;
  }

  template <typename R> MatchRef<R> swap(R &r) noexcept {
    T *o = m_object;
    m_object = static_cast<T *>(r.m_object);
    r.m_object = static_cast<typename R::T *>(o);
  }

  template <typename R> friend MatchRef<R> swap(ZuRef &r1, R &r2) noexcept {
    r1.swap(r2);
  }

  ZuRef &operator=(ZuRef r) noexcept {
    swap(r);
    return *this;
  }
  template <typename R> MatchOtherRef<R, ZuRef &> operator=(R r) noexcept {
    swap(r);
    return *this;
  }

  template <typename O> MatchPtr<O, ZuRef &> operator=(O *n) {
    if (n) n->ref();
    T *o = m_object;
    m_object = n;
    if (o && o->deref()) delete o;
    return *this;
  }

  operator T *() const { return m_object; }
  T *operator->() const { return m_object; }

  template <typename O = T> MatchRef<ZuRef<O>, O *> ptr() const {
    return static_cast<O *>(m_object);
  }
  T *ptr_() const { return m_object; }

  static ZuRef acquire(T *o) { return ZuRef{o, Acquire}; }
  template <typename O = T> MatchRef<ZuRef<O>, O *> release() && {
    T *o = m_object;
    m_object = nullptr;
    return static_cast<O *>(o);
  }

  const T *constPtr() const { return const_cast<const T *>(m_object); }
  ZuRef<const T> constRef() const & { return {constPtr()}; }
  ZuRef<const T> constRef() && {
    return ZuRef<const T>::acquire(const_cast<const T *>(ZuMv(*this).release())
    );
  }
  ZuStrip<T> *mutablePtr() const { return const_cast<ZuStrip<T> *>(m_object); }
  ZuRef<ZuStrip<T>> mutableRef() const & { return {mutablePtr()}; }
  ZuRef<ZuStrip<T>> mutableRef() && {
    return ZuRef<ZuStrip<T>>::acquire(
      const_cast<ZuStrip<T> *>(ZuMv(*this).release())
    );
  }

  bool operator!() const { return !m_object; }

  struct Traits : public ZuTraits<T *> {
    enum { IsPrimitive = 0, IsPOD = 0 };
  };
  friend Traits ZuTraitsType(ZuRef *);

protected:
  T *m_object;
};

template <typename T> struct ZuCmp;
template <typename T> struct ZuCmp<ZuRef<T>> : public ZuCmp<T *> {
  static bool null(const ZuRef<T> &r) { return !r; }
  static const ZuRef<T> &null() {
    static const ZuRef<T> v;
    return v;
  }
};

template <typename T> struct ZuHash;
template <typename T> struct ZuHash<ZuRef<T>> : public ZuHash<T *> { };

template <typename T> ZuRef<T> ZuMkRef(T *p) { return ZuRef<T>{p}; }

void ZuObjectType(...);

template <
  typename U, typename O = decltype(ZuObjectType(ZuDeclVal<ZuDecay<U> *>()))>
struct ZuObjectTraits {
  using T = O;
  enum { IsObject = 1 };
};
template <typename U> struct ZuObjectTraits<U, void> {
  enum { IsObject = 0 };
};
template <typename U> using ZuIsObject = ZuBool<ZuObjectTraits<U>::IsObject>;
template <typename U, typename R = void>
using ZuMatchObject = ZuIfT<ZuObjectTraits<U>::IsObject, R>;
template <typename U, typename R = void>
using ZuNotObject = ZuIfT<!ZuObjectTraits<U>::IsObject, R>;

void ZmRefType(...);

template <typename> class ZmRef;

struct ZmRef__ {
  template <typename O>
  static ZuIs<ZmObjectDebug, O> ZmREF_(const O *o, const void *p) {
    o->ref(p);
  }
  template <typename O>
  static ZuIs<ZmObjectDebug, O> ZmREF_(const ZmRef<O> &o, const void *p) {
    o->ref(p);
  }
  template <typename O>
  static ZuIs<ZmObjectDebug, O> ZmDEREF_(const O *o, const void *p) {
    if (o->deref(p)) delete o;
  }
  template <typename O>
  static ZuIs<ZmObjectDebug, O> ZmDEREF_(const ZmRef<O> &o, const void *p) {
    if (o->deref(p)) delete o.ptr();
  }
  template <typename O>
  static ZuIs<ZmObjectDebug, O>
  ZmMVREF_(const O *o, const void *p, const void *n) {
    o->mvref(p, n);
  }
  template <typename O>
  static void ZmMVREF_(const ZmRef<O> &o, const void *p, const void *n) {
    o->mvref(p, n);
  }
  template <typename O>
  static ZuIsNot<ZmObjectDebug, O> ZmREF_(const O *o, const void *) {
    o->ref();
  }
  template <typename O>
  static ZuIsNot<ZmObjectDebug, O> ZmREF_(const ZmRef<O> &o, const void *) {
    o->ref();
  }
  template <typename O>
  static ZuIsNot<ZmObjectDebug, O> ZmDEREF_(const O *o, const void *) {
    if (o->deref()) delete o;
  }
  template <typename O>
  static ZuIsNot<ZmObjectDebug, O> ZmDEREF_(const ZmRef<O> &o, const void *) {
    if (o->deref()) delete o.ptr();
  }
  template <typename O>
  static ZuIsNot<ZmObjectDebug, O>
  ZmMVREF_(const O *, const void *, const void *) { }
  template <typename O>
  static ZuIsNot<ZmObjectDebug, O>
  ZmMVREF_(const ZmRef<O> &, const void *, const void *) { }
};

template <typename T_> class ZmRef {
  template <typename> friend class ZmRef;
  friend T_ ZmRefType(ZmRef *);

public:
  using T = T_;

private:
  enum Acquire_ { Acquire };
  ZmRef(T *o, Acquire_ _) : m_object{o} { }

  template <typename V>
  struct IsOtherRef_ :
    public ZuBool<ZuInspect<T, V>::Base || ZuInspect<V, T>::Base> { };
  template <typename U>
  struct IsOtherRef :
    public IsOtherRef_<decltype(ZmRefType(ZuDeclVal<U *>()))> { };
  template <typename U, typename = void, bool = IsOtherRef<U>{}>
  struct MatchOtherRef_ { };
  template <typename U, typename R> struct MatchOtherRef_<U, R, true> {
    using T = R;
  };
  template <typename U, typename R = void>
  using MatchOtherRef = typename MatchOtherRef_<U, R>::T;

  template <typename V>
  struct IsRef_ : public ZuBool<ZuInspect<T, V>::Is || ZuInspect<V, T>::Is> { };
  template <typename U>
  struct IsRef : public IsRef_<decltype(ZmRefType(ZuDeclVal<U *>()))> { };
  template <typename U, typename = void, bool = IsRef<U>{}>
  struct MatchRef_ { };
  template <typename U, typename R> struct MatchRef_<U, R, true> {
    using T = R;
  };
  template <typename U, typename R = void>
  using MatchRef = typename MatchRef_<U, R>::T;

  template <typename U>
  struct IsPtr :
    public ZuBool<(ZuInspect<T, U>::Is || ZuInspect<U, T>::Is)> { };
  template <typename U, typename R = void>
  using MatchPtr = ZuIfT<IsPtr<U>{}, R>;

public:
  ZmRef() = default;
  ZmRef(const ZmRef &r) : m_object{r.m_object} {
    if (T *o = m_object) ZmRef__::ZmREF_((o), this);
  }
  ZmRef(ZmRef &&r) noexcept : m_object{r.m_object} {
    r.m_object = nullptr;

    if (T *o = m_object) ZmRef__::ZmMVREF_((o), (&r), (this));
  }
  template <typename R, decltype(MatchOtherRef<ZuDeref<R>>(), int()) = 0>
  ZmRef(R &&r) :
    m_object{static_cast<T *>(const_cast<typename ZuDeref<R>::T *>(r.m_object))
    } {
    ZuBind<R>::mvcp(
      ZuFwd<R>(r),

      [this](auto &&r) {
      r.m_object = nullptr;
      if (T *o = m_object) ZmRef__::ZmMVREF_((o), (&r), (this));
    }

      ,
      [this](const auto &) {
      if (T *o = m_object) ZmRef__::ZmREF_((o), this);
    }
    );
  }
  ZmRef(T *o) : m_object{o} {
    if (o) ZmRef__::ZmREF_((o), this);
  }
  template <typename O, decltype(MatchPtr<O>(), int()) = 0>
  ZmRef(O *o) : m_object{static_cast<T *>(o)} {
    if (o) ZmRef__::ZmREF_((o), this);
  }
  ~ZmRef() {
    if (T *o = m_object) ZmRef__::ZmDEREF_((o), this);
  }

  template <typename R> MatchRef<R> swap(R &r) noexcept {
    T *o = m_object;
    m_object = static_cast<T *>(r.m_object);
    r.m_object = static_cast<typename R::T *>(o);

    if (o) ZmRef__::ZmMVREF_((o), (this), (&r));
    if (m_object) ZmRef__::ZmMVREF_((m_object), (&r), (this));
  }

  template <typename R> friend MatchRef<R> swap(ZmRef &r1, R &r2) noexcept {
    r1.swap(r2);
  }

  ZmRef &operator=(ZmRef r) noexcept {
    swap(r);
    return *this;
  }
  template <typename R> MatchOtherRef<R, ZmRef &> operator=(R r) noexcept {
    swap(r);
    return *this;
  }

  template <typename O> MatchPtr<O, ZmRef &> operator=(O *n) {
    if (m_object != n) {
      if (n) ZmRef__::ZmREF_((n), this);
      T *o = m_object;
      m_object = n;
      if (o) ZmRef__::ZmDEREF_((o), this);
    }
    return *this;
  }

  operator T *() const { return m_object; }
  T *operator->() const { return m_object; }

  template <typename O = T> MatchRef<ZmRef<O>, O *> ptr() const {
    return static_cast<O *>(m_object);
  }
  T *ptr_() const { return m_object; }

  static ZmRef acquire(T *o) { return ZmRef{o, Acquire}; }
  template <typename O = T> MatchRef<ZmRef<O>, O *> release() && {
    T *o = m_object;
    m_object = nullptr;
    return static_cast<O *>(o);
  }

  const T *constPtr() const { return const_cast<const T *>(m_object); }
  ZmRef<const T> constRef() const & { return {constPtr()}; }
  ZmRef<const T> constRef() && {
    return ZmRef<const T>::acquire(const_cast<const T *>(ZuMv(*this).release())
    );
  }
  ZuStrip<T> *mutablePtr() const { return const_cast<ZuStrip<T> *>(m_object); }
  ZmRef<ZuStrip<T>> mutableRef() const & { return {mutablePtr()}; }
  ZmRef<ZuStrip<T>> mutableRef() && {
    return ZmRef<ZuStrip<T>>::acquire(
      const_cast<ZuStrip<T> *>(ZuMv(*this).release())
    );
  }

  bool operator!() const { return !m_object; }

  struct Traits : public ZuTraits<T *> {
    enum { IsPrimitive = 0, IsPOD = 0 };
  };
  friend Traits ZuTraitsType(ZmRef *);

protected:
  T *m_object = nullptr;
};

template <typename T> struct ZuCmp;
template <typename T> struct ZuCmp<ZmRef<T>> : public ZuCmp<T *> {
  static bool null(const ZmRef<T> &r) { return !r; }
  static const ZmRef<T> &null() {
    static const ZmRef<T> v;
    return v;
  }
};

template <typename T> struct ZuHash;
template <typename T> struct ZuHash<ZmRef<T>> : public ZuHash<T *> { };

template <typename T> ZmRef<T> ZmMkRef(T *p) { return ZmRef<T>{p}; }

class ZuObject {
  ZuObject(const ZuObject &) = delete;
  ZuObject &operator=(const ZuObject &) = delete;
  ZuObject(ZuObject &&) = delete;
  ZuObject &operator=(ZuObject &&) = delete;

  friend ZuObject ZuObjectType(ZuObject *);

public:
  ZuObject() = default;

  inline void ref() const { ++m_refCount; }
  inline bool deref() const { return !--m_refCount; }
  inline int refCount() const { return m_refCount; }

  inline void ref_() const { ++m_refCount; }
  inline void ref2_() const { m_refCount += 2; }
  inline bool deref_() const { return !--m_refCount; }

private:
  mutable int m_refCount = 0;
};

template <class Lock_> struct ZmGenericLockTraits {
  using Lock = Lock_;
  enum { CanTry = 1, Recursive = 1, RWLock = 0 };
  inline static void lock(Lock &l) { l.lock(); }
  inline static int trylock(Lock &l) { return l.trylock(); }
  inline static void unlock(Lock &l) { l.unlock(); }
  inline static void readlock(Lock &l) { l.lock(); }
  inline static int readtrylock(Lock &l) { return l.trylock(); }
  inline static void readunlock(Lock &l) { l.unlock(); }
};

template <class Lock>
struct ZmLockTraits : public ZmGenericLockTraits<Lock> { };

class ZmNoLock {
  ZmNoLock(const ZmNoLock &);
  ZmNoLock &operator=(const ZmNoLock &);

public:
  inline ZmNoLock() { }

  inline void lock() { }
  inline int trylock() { return 0; }
  inline void unlock() { }

  struct Wait { };
  Wait wait() { return {}; }
  inline void lock_() {};
  inline void unlock_() {};
};

template <>
struct ZmLockTraits<ZmNoLock> : public ZmGenericLockTraits<ZmNoLock> {
  inline static void lock(ZmNoLock &l) { }
  inline static int trylock(ZmNoLock &l) { return 0; }
  inline static void unlock(ZmNoLock &l) { }
  inline static void readlock(ZmNoLock &l) { }
  inline static int readtrylock(ZmNoLock &l) { return 0; }
  inline static void readunlock(ZmNoLock &l) { }
};

template <class Lock> class ZmGuard;
template <class Lock> class ZmReadGuard;
template <> class ZmGuard<ZmNoLock> {
public:
  inline ZmGuard() { }
  inline ZmGuard(ZmNoLock &) { }
  inline ZmGuard(const ZmGuard &guard) { }
  inline ~ZmGuard() { }

  inline void unlock() { }

  inline ZmGuard &operator=(const ZmGuard &guard) { return *this; }
};

template <> class ZmReadGuard<ZmNoLock> {
public:
  inline ZmReadGuard() { }
  inline ZmReadGuard(const ZmNoLock &) { }
  inline ZmReadGuard(const ZmReadGuard &guard) { }
  inline ~ZmReadGuard() { }

  inline void unlock() { }

  inline ZmReadGuard &operator=(const ZmReadGuard &guard) { return *this; }
};

template <class Lock> class ZmGuard : private ZmLockTraits<Lock> {
  using Traits = ZmLockTraits<Lock>;

public:
  struct Try { };

  ZmGuard() : m_lock{nullptr} { }

  ZmGuard(Lock &l) : m_lock(&l) { this->lock(l); }

  explicit ZmGuard(Lock &l, Try) : m_lock(&l) {
    if (this->trylock(l)) m_lock = nullptr;
  }
  explicit ZmGuard(Lock &l, Try, int &r) : m_lock(&l) {
    if (r = this->trylock(l)) m_lock = nullptr;
  }

  ZmGuard(ZmGuard &&guard) : m_lock(guard.m_lock) { guard.m_lock = nullptr; }
  ZmGuard &operator=(ZmGuard &&guard) {
    if (__builtin_expect(!!(this != &guard), 1)) {
      if (m_lock) Traits::unlock(*m_lock);
      m_lock = guard.m_lock;
      guard.m_lock = nullptr;
    }
    return *this;
  }

  ~ZmGuard() {
    if (m_lock) Traits::unlock(*m_lock);
  }

  bool locked() const { return m_lock; }

  void unlock() {
    if (m_lock) {
      Traits::unlock(*m_lock);
      m_lock = nullptr;
    }
  }

private:
  Lock *m_lock;
};

template <typename Lock> ZmGuard(Lock &) -> ZmGuard<Lock>;

template <class Lock> class ZmReadGuard : private ZmLockTraits<Lock> {
  using Traits = ZmLockTraits<Lock>;

public:
  struct Try { };

  ZmReadGuard(const Lock &l) : m_lock(&(const_cast<Lock &>(l))) {
    this->readlock(const_cast<Lock &>(l));
  }
  explicit ZmReadGuard(const Lock &l, Try) : m_lock(&(const_cast<Lock &>(l))) {
    if (this->tryreadlock(const_cast<Lock &>(l))) m_lock = nullptr;
  }
  explicit ZmReadGuard(const Lock &l, Try, int &r) :
    m_lock(&(const_cast<Lock &>(l))) {
    if (r = this->tryreadlock(const_cast<Lock &>(l))) m_lock = nullptr;
  }
  ZmReadGuard(ZmReadGuard &&guard) : m_lock(guard.m_lock) {
    guard.m_lock = nullptr;
  }
  ~ZmReadGuard() {
    if (m_lock) Traits::readunlock(*m_lock);
  }

  void unlock() {
    if (m_lock) {
      Traits::readunlock(*m_lock);
      m_lock = nullptr;
    }
  }

  ZmReadGuard &operator=(ZmReadGuard &&guard) {
    if (__builtin_expect(!!(this != &guard), 1)) {
      if (m_lock) Traits::readunlock(*m_lock);
      m_lock = guard.m_lock;
      guard.m_lock = nullptr;
    }
    return *this;
  }

private:
  Lock *m_lock;
};

extern "C" {
  extern void ZmAssert_fail(
    const char *expr, const char *file, unsigned line, const char *fn
  );
  extern void ZmAssert_failed();
}

template <typename... Ts> struct ZuTypeList {
  enum { N = sizeof...(Ts) };
  template <typename... Ts_> struct Unshift_ {
    using T = ZuTypeList<Ts_..., Ts...>;
  };
  template <typename... Ts_> struct Unshift_<ZuTypeList<Ts_...>> {
    using T = ZuTypeList<Ts_..., Ts...>;
  };
  template <typename... Ts_> using Unshift = typename Unshift_<Ts_...>::T;

  template <typename... Ts_> struct Push_ {
    using T = ZuTypeList<Ts..., Ts_...>;
  };
  template <typename... Ts_> struct Push_<ZuTypeList<Ts_...>> {
    using T = ZuTypeList<Ts..., Ts_...>;
  };
  template <typename... Ts_> using Push = typename Push_<Ts_...>::T;
};

template <unsigned N, typename List, typename E> struct ZuTypeRepeat__ {
  using T =
    typename ZuTypeRepeat__<N - 1, typename List::template Push<E>, E>::T;
};
template <typename List, typename E> struct ZuTypeRepeat__<0, List, E> {
  using T = List;
};
template <unsigned N, typename E>
struct ZuTypeRepeat_ : public ZuTypeRepeat__<N, ZuTypeList<>, E> { };
template <unsigned N, typename E>
using ZuTypeRepeat = typename ZuTypeRepeat_<N, E>::T;

template <typename... Ts> struct ZuTypeRev_;
template <typename... Ts> struct ZuTypeRev__;
template <typename T0, typename... Ts> struct ZuTypeRev__<T0, Ts...> {
  using T = typename ZuTypeRev__<Ts...>::T::template Push<T0>;
};
template <typename T0> struct ZuTypeRev__<T0> {
  using T = ZuTypeList<T0>;
};
template <> struct ZuTypeRev__<> {
  using T = ZuTypeList<>;
};
template <typename... Ts> struct ZuTypeRev_ {
  using T = typename ZuTypeRev__<Ts...>::T;
};
template <typename... Ts> struct ZuTypeRev_<ZuTypeList<Ts...>> {
  using T = typename ZuTypeRev__<Ts...>::T;
};
template <typename... Ts> using ZuTypeRev = typename ZuTypeRev_<Ts...>::T;

template <unsigned, typename...> struct ZuType_;
template <unsigned I, typename T0, typename... Ts> struct ZuType__ {
  using T = typename ZuType_<I - 1, Ts...>::T;
};
template <typename T0, typename... Ts> struct ZuType__<0, T0, Ts...> {
  using T = T0;
};
template <unsigned I, typename... Ts>
struct ZuType_ : public ZuType__<I, Ts...> { };
template <unsigned I, typename... Ts>
struct ZuType_<I, ZuTypeList<Ts...>> : public ZuType_<I, Ts...> { };
template <unsigned I, typename... Ts>
using ZuType = typename ZuType_<I, Ts...>::T;

template <typename, typename...> struct ZuTypeIndex;
template <typename T, typename... Ts>
struct ZuTypeIndex<T, T, Ts...> : public ZuUnsigned<0> { };
template <typename T, typename O, typename... Ts>
struct ZuTypeIndex<T, O, Ts...> :
  public ZuUnsigned<1 + ZuTypeIndex<T, Ts...>{}> { };
template <typename T, typename... Ts>
struct ZuTypeIndex<T, ZuTypeList<Ts...>> : public ZuTypeIndex<T, Ts...> { };

template <template <typename> class, typename...> struct ZuTypeMap_;
template <template <typename> class Map> struct ZuTypeMap_<Map> {
  using T = ZuTypeList<>;
};
template <template <typename> class Map, typename T0>
struct ZuTypeMap_<Map, T0> {
  using T = ZuTypeList<Map<T0>>;
};
template <template <typename> class Map, typename T0, typename... Ts>
struct ZuTypeMap_<Map, T0, Ts...> {
  using T = typename ZuTypeList<Map<T0>>::template Push<
    typename ZuTypeMap_<Map, Ts...>::T>;
};
template <template <typename> class Map, typename... Ts>
struct ZuTypeMap_<Map, ZuTypeList<Ts...>> : public ZuTypeMap_<Map, Ts...> { };
template <template <typename> class Map, typename... Ts>
using ZuTypeMap = typename ZuTypeMap_<Map, Ts...>::T;

template <typename T0, bool> struct ZuTypeGrep__ {
  using T = ZuTypeList<T0>;
};
template <typename T0> struct ZuTypeGrep__<T0, false> {
  using T = ZuTypeList<>;
};
template <template <typename> class, typename...> struct ZuTypeGrep_ {
  using T = ZuTypeList<>;
};
template <template <typename> class Filter, typename T0>
struct ZuTypeGrep_<Filter, T0> {
  using T = typename ZuTypeGrep__<T0, Filter<T0>{}>::T;
};
template <template <typename> class Filter, typename T0, typename... Ts>
struct ZuTypeGrep_<Filter, T0, Ts...> {
  using T = typename ZuTypeGrep__<T0, Filter<T0>{}>::T::template Push<
    typename ZuTypeGrep_<Filter, Ts...>::T>;
};
template <template <typename> class Filter, typename... Ts>
struct ZuTypeGrep_<Filter, ZuTypeList<Ts...>> :
  public ZuTypeGrep_<Filter, Ts...> { };
template <template <typename> class Filter, typename... Ts>
using ZuTypeGrep = typename ZuTypeGrep_<Filter, Ts...>::T;

template <typename, typename...> struct ZuTypeIn : public ZuFalse { };
template <typename U> struct ZuTypeIn<U, U> : public ZuTrue { };
template <typename U, typename... Ts>
struct ZuTypeIn<U, U, Ts...> : public ZuTrue { };
template <typename U, typename T0, typename... Ts>
struct ZuTypeIn<U, T0, Ts...> : public ZuTypeIn<U, Ts...> { };
template <typename U, typename... Ts>
struct ZuTypeIn<U, ZuTypeList<Ts...>> : public ZuTypeIn<U, Ts...> { };

template <template <typename...> class, typename...> struct ZuTypeReduce_;
template <template <typename...> class Reduce> struct ZuTypeReduce_<Reduce> {
  using T = Reduce<>;
};
template <template <typename...> class Reduce, typename T0>
struct ZuTypeReduce_<Reduce, T0> {
  using T = Reduce<T0>;
};
template <template <typename...> class Reduce, typename T0, typename T1>
struct ZuTypeReduce_<Reduce, T0, T1> {
  using T = Reduce<T0, T1>;
};
template <
  template <typename...> class Reduce, typename T0, typename T1, typename... Ts>
struct ZuTypeReduce_<Reduce, T0, T1, Ts...> {
  using T = Reduce<T0, typename ZuTypeReduce_<Reduce, T1, Ts...>::T>;
};
template <template <typename...> class Reduce, typename... Ts>
struct ZuTypeReduce_<Reduce, ZuTypeList<Ts...>> :
  public ZuTypeReduce_<Reduce, Ts...> { };
template <template <typename...> class Reduce, typename... Ts>
using ZuTypeReduce = typename ZuTypeReduce_<Reduce, Ts...>::T;

template <unsigned N, typename... Ts> struct ZuTypeHead__;
template <unsigned N, typename T0, typename... Ts>
struct ZuTypeHead__<N, T0, Ts...> {
  using T = typename ZuTypeHead__<N - 1, Ts...>::T::template Unshift<T0>;
};
template <typename T0, typename... Ts> struct ZuTypeHead__<0, T0, Ts...> {
  using T = ZuTypeList<>;
};
template <typename... Ts> struct ZuTypeHead__<0, Ts...> {
  using T = ZuTypeList<>;
};
template <unsigned N, typename... Ts>
struct ZuTypeHead_ : public ZuTypeHead__<N, Ts...> { };
template <unsigned N, typename... Ts>
struct ZuTypeHead_<N, ZuTypeList<Ts...>> : public ZuTypeHead__<N, Ts...> { };
template <unsigned N, typename... Ts>
using ZuTypeHead = typename ZuTypeHead_<N, Ts...>::T;

template <unsigned N, typename... Ts> struct ZuTypeTail__;
template <unsigned N, typename T0, typename... Ts>
struct ZuTypeTail__<N, T0, Ts...> {
  using T = typename ZuTypeTail__<N - 1, Ts...>::T;
};
template <typename T0, typename... Ts> struct ZuTypeTail__<0, T0, Ts...> {
  using T = ZuTypeList<T0, Ts...>;
};
template <typename... Ts> struct ZuTypeTail__<0, Ts...> {
  using T = ZuTypeList<Ts...>;
};
template <unsigned N, typename... Ts>
struct ZuTypeTail_ : public ZuTypeTail__<N, Ts...> { };
template <unsigned N, typename... Ts>
struct ZuTypeTail_<N, ZuTypeList<Ts...>> : public ZuTypeTail__<N, Ts...> { };
template <unsigned N, typename... Ts>
using ZuTypeTail = typename ZuTypeTail_<N, Ts...>::T;

template <template <typename> class Index, typename Left, typename Right>
struct ZuTypeMerge_;
template <template <typename> class, typename, typename, bool>
struct ZuTypeMerge__;
template <
  template <typename> class Index, typename LeftT0, typename... LeftTs,
  typename RightT0, typename... RightTs>
struct ZuTypeMerge__<
  Index, ZuTypeList<LeftT0, LeftTs...>, ZuTypeList<RightT0, RightTs...>,
  false> {
  using T = typename ZuTypeMerge_<
    Index, ZuTypeList<LeftTs...>,
    ZuTypeList<RightT0, RightTs...>>::T::template Unshift<LeftT0>;
};
template <
  template <typename> class Index, typename LeftT0, typename... LeftTs,
  typename RightT0, typename... RightTs>
struct ZuTypeMerge__<
  Index, ZuTypeList<LeftT0, LeftTs...>, ZuTypeList<RightT0, RightTs...>, true> {
  using T = typename ZuTypeMerge_<
    Index, ZuTypeList<LeftT0, LeftTs...>,
    ZuTypeList<RightTs...>>::T::template Unshift<RightT0>;
};
template <
  template <typename> class Index, typename LeftT0, typename... LeftTs,
  typename RightT0, typename... RightTs>
struct ZuTypeMerge_<
  Index, ZuTypeList<LeftT0, LeftTs...>, ZuTypeList<RightT0, RightTs...>> :
  public ZuTypeMerge__<
    Index, ZuTypeList<LeftT0, LeftTs...>, ZuTypeList<RightT0, RightTs...>,
    (Index<LeftT0>{} > Index<RightT0>{})> { };
template <template <typename> class Index, typename... Ts>
struct ZuTypeMerge_<Index, ZuTypeList<>, ZuTypeList<Ts...>> {
  using T = ZuTypeList<Ts...>;
};
template <template <typename> class Index, typename... Ts>
struct ZuTypeMerge_<Index, ZuTypeList<Ts...>, ZuTypeList<>> {
  using T = ZuTypeList<Ts...>;
};
template <template <typename> class Index>
struct ZuTypeMerge_<Index, ZuTypeList<>, ZuTypeList<>> {
  using T = ZuTypeList<>;
};
template <template <typename> class Index, typename Left, typename Right>
using ZuTypeMerge = typename ZuTypeMerge_<Index, Left, Right>::T;
template <template <typename> class Index, typename... Ts> struct ZuTypeSort_ {
  enum { N = sizeof...(Ts) };
  using T = ZuTypeMerge<
    Index, typename ZuTypeSort_<Index, ZuTypeHead<(N >> 1), Ts...>>::T,
    typename ZuTypeSort_<Index, ZuTypeTail<(N >> 1), Ts...>>::T>;
};
template <template <typename> class Index, typename T0>
struct ZuTypeSort_<Index, T0> {
  using T = ZuTypeList<T0>;
};
template <template <typename> class Index> struct ZuTypeSort_<Index> {
  using T = ZuTypeList<>;
};
template <template <typename> class Index, typename... Ts>
struct ZuTypeSort_<Index, ZuTypeList<Ts...>> :
  public ZuTypeSort_<Index, Ts...> { };
template <template <typename> class Index, typename... Ts>
using ZuTypeSort = typename ZuTypeSort_<Index, Ts...>::T;

template <template <typename...> class Type, typename... Ts>
struct ZuTypeApply_ {
  using T = Type<Ts...>;
};
template <template <typename...> class Type, typename... Ts>
struct ZuTypeApply_<Type, ZuTypeList<Ts...>> :
  public ZuTypeApply_<Type, Ts...> { };
template <template <typename...> class Type, typename... Ts>
using ZuTypeApply = typename ZuTypeApply_<Type, Ts...>::T;

template <typename... Ts> struct ZuLargest_;
template <typename T0> struct ZuLargest_<T0> {
  using T = T0;
};
template <typename T0, typename... Ts> struct ZuLargest_<T0, Ts...> {
  using T = ZuIf<
    (unsigned(ZuSize<T0>{}) >= unsigned(ZuSize<typename ZuLargest_<Ts...>::T>{})
    ),
    T0, typename ZuLargest_<Ts...>::T>;
};
template <typename... Ts> struct ZuLargest_<void, Ts...> {
  using T = typename ZuLargest_<Ts...>::T;
};
template <typename... Ts>
struct ZuLargest_<ZuTypeList<Ts...>> : public ZuLargest_<Ts...> { };
template <typename... Ts> using ZuLargest = typename ZuLargest_<Ts...>::T;

template <typename Ts, typename Us> struct ZuTLConverts : public ZuFalse { };
template <typename, typename, unsigned, bool>
struct ZuTLConverts_ : public ZuFalse { };
template <>
struct ZuTLConverts_<ZuTypeList<>, ZuTypeList<>, 0, true> : public ZuTrue { };
template <typename T0, typename... Ts, typename U0, typename... Us, unsigned N>
struct ZuTLConverts_<ZuTypeList<T0, Ts...>, ZuTypeList<U0, Us...>, N, true> :
  public ZuTLConverts_<
    ZuTypeList<Ts...>, ZuTypeList<Us...>, N - 1, ZuInspect<T0, U0>::Converts> {
};
template <typename... Ts, typename... Us>
struct ZuTLConverts<ZuTypeList<Ts...>, ZuTypeList<Us...>> :
  public ZuTLConverts_<
    ZuTypeList<Ts...>, ZuTypeList<Us...>, sizeof...(Us),
    sizeof...(Ts) == sizeof...(Us)> { };

template <typename Ts, typename Us> struct ZuTLConstructs : public ZuFalse { };
template <typename, typename, unsigned, bool>
struct ZuTLConstructs_ : public ZuFalse { };
template <>
struct ZuTLConstructs_<ZuTypeList<>, ZuTypeList<>, 0, true> : public ZuTrue { };
template <typename T0, typename... Ts, typename U0, typename... Us, unsigned N>
struct ZuTLConstructs_<ZuTypeList<T0, Ts...>, ZuTypeList<U0, Us...>, N, true> :
  public ZuTLConstructs_<
    ZuTypeList<Ts...>, ZuTypeList<Us...>, N - 1,
    ZuInspect<T0, U0>::Constructs> { };
template <typename... Ts, typename... Us>
struct ZuTLConstructs<ZuTypeList<Ts...>, ZuTypeList<Us...>> :
  public ZuTLConstructs_<
    ZuTypeList<Ts...>, ZuTypeList<Us...>, sizeof...(Us),
    sizeof...(Ts) == sizeof...(Us)> { };

template <unsigned... I> struct ZuSeq {
  enum { N = sizeof...(I) };
};

template <typename T_, unsigned, bool> struct ZuPushSeq_ {
  using T = T_;
};
template <unsigned... I, unsigned N> struct ZuPushSeq_<ZuSeq<I...>, N, true> {
  enum { J = sizeof...(I) };
  using T = typename ZuPushSeq_<ZuSeq<I..., J>, N, (J < N - 1)>::T;
};
template <unsigned N> struct ZuMkSeq_ {
  using T = typename ZuPushSeq_<ZuSeq<>, N, (N > 0)>::T;
};
template <unsigned N> using ZuMkSeq = typename ZuMkSeq_<N>::T;

template <typename> struct ZuSeqBitmap_;
template <> struct ZuSeqBitmap_<ZuSeq<>> {
  static constexpr uint64_t bits() { return 0; }
};
template <unsigned I> struct ZuSeqBitmap_<ZuSeq<I>> {
  static constexpr uint64_t bits() { return uint64_t(1) << I; }
};
template <unsigned I, unsigned... Seq> struct ZuSeqBitmap_<ZuSeq<I, Seq...>> {
  static constexpr uint64_t bits() {
    return (uint64_t(1) << I) | ZuSeqBitmap_<ZuSeq<Seq...>>::bits();
  }
};
template <typename Seq> constexpr uint64_t ZuSeqBitmap() {
  return ZuSeqBitmap_<Seq>::bits();
}

template <typename, unsigned Bit, uint64_t V, bool = (V & (uint64_t(1) << Bit))>
struct ZuBitmapSeq_;
template <typename Seq, unsigned Bit>
struct ZuBitmapSeq_<Seq, Bit, uint64_t(0), false> {
  using T = Seq;
};
template <typename Seq, unsigned Bit, uint64_t V>
struct ZuBitmapSeq_<Seq, Bit, V, false> {
  using T = typename ZuBitmapSeq_<Seq, Bit + 1, V & ~(uint64_t(1) << Bit)>::T;
};
template <unsigned... Seq, unsigned Bit, uint64_t V>
struct ZuBitmapSeq_<ZuSeq<Seq...>, Bit, V, true> {
  using T = typename ZuBitmapSeq_<
    ZuSeq<Seq..., Bit>, Bit + 1, V & ~(uint64_t(1) << Bit)>::T;
};
template <typename Seq, uint64_t V>
using ZuBitmapSeq = typename ZuBitmapSeq_<Seq, 0, V>::T;

template <typename> struct ZuSeqTL_;
template <> struct ZuSeqTL_<ZuSeq<>> {
  using T = ZuTypeList<>;
};
template <unsigned I> struct ZuSeqTL_<ZuSeq<I>> {
  using T = ZuTypeList<ZuUnsigned<I>>;
};
template <unsigned I, unsigned... Seq> struct ZuSeqTL_<ZuSeq<I, Seq...>> {
  using T = ZuTypeList<ZuUnsigned<I>>::template Push<
    typename ZuSeqTL_<ZuSeq<Seq...>>::T>;
};
template <typename Seq> using ZuSeqTL = typename ZuSeqTL_<Seq>::T;

template <typename... Seq> struct ZuTLSeq_ {
  using T = ZuSeq<Seq{}...>;
};
template <typename... Seq>
struct ZuTLSeq_<ZuTypeList<Seq...>> : public ZuTLSeq_<Seq...> { };
template <typename... Seq> using ZuTLSeq = typename ZuTLSeq_<Seq...>::T;

template <typename> struct ZuMin;
template <>
struct ZuMin<ZuSeq<>> :
  public ZuUnsigned<

    (0x7fffffff * 2U + 1U)

    > { };
template <unsigned I> struct ZuMin<ZuSeq<I>> : public ZuUnsigned<I> { };
template <unsigned I, unsigned J>
struct ZuMin<ZuSeq<I, J>> : public ZuUnsigned<(I < J) ? I : J> { };
template <unsigned I, unsigned J, unsigned... Seq>
struct ZuMin<ZuSeq<I, J, Seq...>> :
  public ZuMin<ZuSeq<((I < J) ? I : J), Seq...>> { };

template <typename> struct ZuMax;
template <> struct ZuMax<ZuSeq<>> : public ZuUnsigned<0> { };
template <unsigned I> struct ZuMax<ZuSeq<I>> : public ZuUnsigned<I> { };
template <unsigned I, unsigned J>
struct ZuMax<ZuSeq<I, J>> : public ZuUnsigned<(I > J) ? I : J> { };
template <unsigned I, unsigned J, unsigned... Seq>
struct ZuMax<ZuSeq<I, J, Seq...>> :
  public ZuMax<ZuSeq<((I > J) ? I : J), Seq...>> { };

template <auto Axor, typename Seq, typename T> struct ZuSeqCall_;
template <auto Axor, unsigned... I, typename T>
struct ZuSeqCall_<Axor, ZuSeq<I...>, T> {
  template <typename L> static decltype(auto) fn(const T &v, L l) {
    return l(Axor.template operator()<I>(v)...);
  }
  template <typename L> static decltype(auto) fn(T &v, L l) {
    return l(Axor.template operator()<I>(v)...);
  }
  template <typename L> static decltype(auto) fn(T &&v, L l) {
    return l(Axor.template operator()<I>(ZuMv(v))...);
  }
};
template <unsigned N, auto Axor = ZuDefaultAxor(), typename T, typename L>
inline decltype(auto) ZuSeqCall(T &&v, L l) {
  return ZuSeqCall_<Axor, ZuMkSeq<N>, ZuDecay<T>>::fn(ZuFwd<T>(v), ZuMv(l));
}

namespace ZuSwitch {

template <typename R, typename Seq> struct Dispatch;
template <unsigned... I> struct Dispatch<void, ZuSeq<I...>> {
  template <typename L> static constexpr void fn(unsigned i, L l) {
    std::initializer_list<int>{(i == I ? l(ZuUnsigned<I>{}), 0 : 0)...};
  }
};
template <typename R, unsigned... I> struct Dispatch<R, ZuSeq<I...>> {
  template <typename L> static constexpr R fn(unsigned i, L l) {
    R r = {};
    std::initializer_list<int>{(i == I ? (r = l(ZuUnsigned<I>{})), 0 : 0)...};
    return r;
  }
};

template <unsigned N, typename L>
constexpr decltype(auto) dispatch(unsigned i, L l) {
  using R = ZuDecay<decltype(l(ZuUnsigned<0>{}))>;
  return Dispatch<R, ZuMkSeq<N>>::fn(i, ZuMv(l));
}

template <unsigned N, typename L, typename D>
constexpr decltype(auto) dispatch(unsigned i, L l, D d) {
  using R = ZuDecay<decltype(l(ZuUnsigned<0>{}))>;
  if (__builtin_expect(!!(i >= N), 0)) return d();
  return Dispatch<R, ZuMkSeq<N>>::fn(i, ZuMv(l));
}

} // namespace ZuSwitch

namespace ZuUnroll {

template <typename, typename> struct All;

template <typename R, unsigned... I> struct All<R, ZuSeq<I...>> {
  template <typename L> static constexpr R fn(L l) {
    R r;
    std::initializer_list<int>{((r = l(ZuUnsigned<I>{})), 0)...};
    return r;
  }

  template <typename L> static constexpr R fn(R r, L l) {
    std::initializer_list<int>{((r = l(ZuUnsigned<I>{}, r)), 0)...};
    return r;
  }
};

template <typename R, typename... Ts> struct All<R, ZuTypeList<Ts...>> {
  template <typename L> static constexpr R fn(L l) {
    R r;
    std::initializer_list<int> {((r = l.template operator()<Ts>()), 0)... };
    return r;
  }

  template <typename L> static constexpr R fn(R r, L l) {
    std::initializer_list<int> {((r = l.template operator()<Ts>(r)), 0)... };
    return r;
  }
};

template <unsigned... I> struct All<void, ZuSeq<I...>> {
  template <typename L> static constexpr void fn(L l) {
    std::initializer_list<int>{(l(ZuUnsigned<I>{}), 0)...};
  }
};

template <typename... Ts> struct All<void, ZuTypeList<Ts...>> {
  template <typename L> static constexpr void fn(L l) {
    std::initializer_list<int> {(l.template operator()<Ts>(), 0)... };
  }
};

template <> struct All<void, ZuSeq<>> {
  template <typename L> static constexpr void fn(L) { }
};

template <> struct All<void, ZuTypeList<>> {
  template <typename L> static constexpr void fn(L) { }
};

template <typename R> struct All<R, ZuSeq<>> {
  template <typename L> static constexpr R fn(L) { return {}; }
};

template <typename R> struct All<R, ZuTypeList<>> {
  template <typename L> static constexpr R fn(L) { return {}; }
};

template <typename, typename> struct Deduce;
template <typename L> struct Deduce<ZuSeq<>, L> {
  using R = void;
};
template <unsigned... I, typename L> struct Deduce<ZuSeq<I...>, L> {
  using R = ZuDecay<decltype(ZuDeclVal<L>()(ZuUnsigned<0>{}))>;
};
template <typename L> struct Deduce<ZuTypeList<>, L> {
  using R = void;
};
template <typename... Ts, typename L> struct Deduce<ZuTypeList<Ts...>, L> {
  using R =
    ZuDecay<decltype(ZuDeclVal<L>().template operator()<ZuType<0, Ts...>>())>;
};

template <typename List, typename L> constexpr decltype(auto) all(L l) {
  return All<typename Deduce<List, L>::R, List>::fn(ZuMv(l));
}
template <unsigned N, typename L> constexpr decltype(auto) all(L l) {
  return all<ZuMkSeq<N>>(ZuMv(l));
}

template <typename List, typename R, typename L>
constexpr decltype(auto) all(R r, L l) {
  return All<R, List>::fn(ZuMv(r), ZuMv(l));
}
template <unsigned N, typename R, typename L>
constexpr decltype(auto) all(R r, L l) {
  return all<ZuMkSeq<N>>(ZuMv(r), ZuMv(l));
}

} // namespace ZuUnroll

namespace std {
template <typename...> class tuple;
template <typename, typename> struct pair;
template <typename, size_t> class array;
}

namespace Zu_ {

template <typename... Ts> class Tuple;

template <typename, typename> class Tuple_;

void TupleType(...);
template <typename... Ts> std::tuple<Ts...> TupleType(std::tuple<Ts...> *);
template <typename L, typename R> std::pair<L, R> TupleType(std::pair<L, R> *);
template <typename E, size_t N> std::array<E, N> TupleType(std::array<E, N> *);

template <typename T>
using TupleT = ZuDecay<decltype(TupleType(ZuDeclVal<ZuDecay<T> *>()))>;

template <typename> struct IsTuple_ : public ZuFalse { };
template <typename... Ts> struct IsTuple_<Tuple<Ts...>> : public ZuTrue { };
template <typename... Ts>
struct IsTuple_<std::tuple<Ts...>> : public ZuTrue { };
template <typename L, typename R>
struct IsTuple_<std::pair<L, R>> : public ZuTrue { };
template <typename E, size_t N>
struct IsTuple_<std::array<E, N>> : public ZuTrue { };
template <typename T> struct IsTuple : public IsTuple_<TupleT<T>> { };
template <typename T, typename R = void>
using MatchTuple = ZuIfT<IsTuple<T>{}, R>;

struct Tuple_RDecayer {
  template <typename> struct Decay_;
  template <typename... Ts> struct Decay_<Tuple<Ts...>> {
    using T = ZuTypeApply<Tuple, ZuTypeMap<ZuRDecay, Ts...>>;
  };
  template <typename T> using Decay = Decay_<TupleT<T>>;
};

template <unsigned I_, typename T_> struct Tuple_Elem {
  enum { I = I_ };
  using T = T_;
  T v;
};

template <typename... Elems_, typename... StoredElems_>
class Tuple_<ZuTypeList<Elems_...>, ZuTypeList<StoredElems_...>> :
  public StoredElems_... {
  template <typename, typename> friend class Tuple_;

protected:
  using Elems = ZuTypeList<Elems_...>;
  using StoredElems = ZuTypeList<StoredElems_...>;

  template <unsigned J, typename U>
  static Tuple_Elem<J, U> *elem_(const Tuple_Elem<J, U> &);

  template <unsigned J> struct Elem_ {
    using T = ZuDeref<decltype(*elem_<J>(ZuDeclVal<const Tuple_ &>()))>;
  };
  template <unsigned J> using Elem = typename Elem_<J>::T;

  template <unsigned J> using P = Elem<J>::T;
  template <unsigned J> using U = ZuDeref<P<J>>;

public:
  using Indices = ZuSeq<Elems_::I...>;
  using Types = ZuTypeList<typename Elems_::T...>;
  template <unsigned J> using Type = Elem<J>::T;
  enum { N = sizeof...(Elems_) };
  template <typename T> using Index = ZuTypeIndex<T, Types>;

private:
  template <
    unsigned J, typename V, typename R = typename V::template Elem<J>::T,
    bool = ZuTraits<R>::IsReference>
  struct Bind {
    using E = typename V::template Elem<J>;
    static const auto &p(const V &v) { return static_cast<const E &>(v).v; }
    static auto &p(V &v) { return static_cast<E &>(v).v; }
    static decltype(auto) p(V &&v) { return ZuMv(static_cast<E &&>(v).v); }
  };
  template <unsigned J, typename V, typename R> struct Bind<J, V, R, true> {
    using E = typename V::template Elem<J>;
    static const auto &p(const V &v) { return static_cast<const E &>(v).v; }
    static auto &p(V &v) { return static_cast<E &>(v).v; }
  };

  template <
    unsigned J, typename V,
    typename R =
      ZuDecay<decltype(std::get<J>(ZuDeclVal<const ZuDecay<V> &>()))>,
    bool = ZuTraits<R>::IsReference>
  struct StdBind {
    static decltype(auto) p(const V &v) { return std::get<J>(v); }
    static decltype(auto) p(V &v) { return std::get<J>(v); }
    static decltype(auto) p(V &&v) { return std::get<J>(ZuMv(v)); }
  };
  template <unsigned J, typename V, typename R> struct StdBind<J, V, R, true> {
    static decltype(auto) p(const V &v) { return std::get<J>(v); }
    static decltype(auto) p(V &v) { return std::get<J>(v); }
  };

protected:
  template <typename V> struct IsConTuple_ : public ZuFalse { };
  template <typename... Ts>
  struct IsConTuple_<Tuple<Ts...>> :
    public ZuTLConstructs<ZuTypeList<Ts...>, Types> { };
  template <typename V> using IsConTuple = IsConTuple_<TupleT<V>>;
  template <typename V, typename R = void>
  using ConTuple = ZuIfT<IsConTuple<V>{}, R>;

  template <typename V> struct IsCvtTuple_ : public ZuFalse { };
  template <typename... Ts>
  struct IsCvtTuple_<Tuple<Ts...>> :
    public ZuTLConverts<ZuTypeList<Ts...>, Types> { };

public:
  template <typename V> using IsCvtTuple = IsCvtTuple_<TupleT<V>>;

protected:
  template <typename V, typename R = void>
  using CvtTuple = ZuIfT<IsCvtTuple<V>{}, R>;

  template <typename V> struct IsConStdTuple_ : public ZuFalse { };
  template <typename... Ts>
  struct IsConStdTuple_<std::tuple<Ts...>> :
    public ZuTLConstructs<ZuTypeList<Ts...>, Types> { };
  template <typename L, typename R>
  struct IsConStdTuple_<std::pair<L, R>> :
    public ZuTLConstructs<ZuTypeList<L, R>, Types> { };
  template <typename E, size_t N>
  struct IsConStdTuple_<std::array<E, N>> :
    public ZuTLConstructs<ZuTypeRepeat<N, E>, Types> { };
  template <typename V> using IsConStdTuple = IsConStdTuple_<TupleT<V>>;
  template <typename V, typename R = void>
  using ConStdTuple = ZuIfT<IsConStdTuple<V>{}, R>;

  template <typename V> struct IsCvtStdTuple_ : public ZuFalse { };
  template <typename... Ts>
  struct IsCvtStdTuple_<std::tuple<Ts...>> :
    public ZuTLConverts<ZuTypeList<Ts...>, Types> { };
  template <typename L, typename R>
  struct IsCvtStdTuple_<std::pair<L, R>> :
    public ZuTLConverts<ZuTypeList<L, R>, Types> { };
  template <typename E, size_t N>
  struct IsCvtStdTuple_<std::array<E, N>> :
    public ZuTLConverts<ZuTypeRepeat<N, E>, Types> { };
  template <typename V> using IsCvtStdTuple = IsCvtStdTuple_<TupleT<V>>;
  template <typename V, typename R = void>
  using CvtStdTuple = ZuIfT<IsCvtStdTuple<V>{}, R>;

  template <typename V>
  using IsConAnyTuple = ZuBool<IsConTuple<V>{} || IsConStdTuple<V>{}>;
  template <typename V, typename R = void>
  using ConAnyTuple = ZuIfT<IsConAnyTuple<V>{}, R>;

  template <typename V>
  using IsCvtAnyTuple = ZuBool<IsCvtTuple<V>{} || IsCvtStdTuple<V>{}>;
  template <typename V, typename R = void>
  using CvtAnyTuple = ZuIfT<IsCvtAnyTuple<V>{}, R>;

  template <typename V, unsigned N_ = N> struct IsCvtFirstElem_ {
    using T =
      ZuBool<!IsCvtAnyTuple<V>{} && ZuInspect<V, ZuType<0, Types>>::Converts>;
  };
  template <typename V> struct IsCvtFirstElem_<V, 0> {
    using T = ZuFalse;
  };
  template <typename V> using IsCvtFirstElem = typename IsCvtFirstElem_<V>::T;
  template <typename V, typename R = void>
  using CvtFirstElem = ZuIfT<IsCvtFirstElem<V>{}, R>;

public:
  template <typename V, unsigned N_ = N> struct IsCvtElem_ {
    using T = ZuBool<
      !IsCvtAnyTuple<V>{} && ZuInspect<V, ZuType<0, Types>>::Converts &&
      N_ == 1>;
  };
  template <typename V> struct IsCvtElem_<V, 0> {
    using T = ZuFalse;
  };
  template <typename V> using IsCvtElem = typename IsCvtElem_<V>::T;

protected:
  template <typename V, typename R = void>
  using CvtElem = ZuIfT<IsCvtElem<V>{}, R>;

  template <typename V, ConTuple<V, int> = 0>
  Tuple_(V &&v) :
    StoredElems_{Bind<StoredElems_::I, ZuDecay<V>>::p(ZuFwd<V>(v))}... { }

  template <typename V, ConStdTuple<V, int> = 0>
  Tuple_(V &&v) :
    StoredElems_{StdBind<StoredElems_::I, ZuDecay<V>>::p(ZuFwd<V>(v))}... { }

  template <typename V> CvtTuple<V, Tuple_ &> operator=(V &&v) {
    ZuUnroll::all<Indices>([this, &v](auto J) {
      this->p<J>(Bind<J, ZuDecay<V>>::p(ZuFwd<V>(v)));
    });
    return *this;
  }

  template <typename V> CvtStdTuple<V, Tuple_ &> operator=(V &&v) {
    ZuUnroll::all<Indices>([this, &v](auto J) {
      this->p<J>(StdBind<J, ZuDecay<V>>::p(ZuFwd<V>(v)));
    });
    return *this;
  }

  template <typename V> CvtFirstElem<V, Tuple_ &> operator=(V &&v) {
    this->p<0>(ZuFwd<V>(v));
    return *this;
  }

  template <
    typename... HeadElems, typename... TailElems, typename... Vs,
    ZuIfT<
      ZuTLConstructs<ZuTypeList<Vs...>, ZuTypeList<typename HeadElems::T...>>{},
      int> = 0>
  Tuple_(ZuTypeList<HeadElems...>, ZuTypeList<TailElems...>, Vs &&...v) :
    HeadElems(ZuFwd<Vs>(v))..., TailElems{}... { }

  Tuple_() = default;
  Tuple_(const Tuple_ &) = default;
  Tuple_(Tuple_ &&) = default;
  Tuple_ &operator=(const Tuple_ &) = default;
  Tuple_ &operator=(Tuple_ &&) = default;
  ~Tuple_() = default;

public:
  template <unsigned J> const U<J> &p() const & {
    static_assert((J < N), "J < N");
    return static_cast<const Elem<J> &>(*this).v;
  }
  template <unsigned J> U<J> &p() & {
    static_assert((J < N), "J < N");
    return static_cast<Elem<J> &>(*this).v;
  }
  template <unsigned J> ZuNotReference<P<J>, U<J> &&> p() && {
    static_assert((J < N), "J < N");
    return ZuMv(static_cast<Elem<J> &&>(*this).v);
  }
  template <unsigned J, typename V> void p(V &&v) {
    static_assert((J < N), "J < N");
    static_cast<Elem<J> &>(*this).v = ZuFwd<V>(v);
  }

  template <typename T> const auto &p() const & {
    return static_cast<const Elem<ZuTypeIndex<T, Types>{}> &>(*this).v;
  }
  template <typename T> auto &p() & {
    return static_cast<Elem<ZuTypeIndex<T, Types>{}> &>(*this).v;
  }
  template <typename T>
  ZuNotReference<P<ZuTypeIndex<T, Types>{}>, U<ZuTypeIndex<T, Types>{}> &&>
  p() && {
    return ZuMv(static_cast<Elem<ZuTypeIndex<T, Types>{}> &&>(*this).v);
  }
  template <typename T, typename V> void p(V &&v) && {
    static_cast<Elem<ZuTypeIndex<T, Types>{}> &>(*this).v = ZuFwd<V>(v);
  }

  template <typename L> decltype(auto) all(L l) const & {
    return ZuUnroll::all<Indices>(
      [this, l = ZuMv(l)](auto J) mutable -> decltype(auto) {
      return l(static_cast<const Tuple_ &>(*this).template p<J>());
    }
    );
  }
  template <typename L> decltype(auto) all(L l) & {
    return ZuUnroll::all<Indices>(
      [this, l = ZuMv(l)](auto J) mutable -> decltype(auto) {
      return l(static_cast<Tuple_ &>(*this).template p<J>());
    }
    );
  }
  template <typename L> decltype(auto) all(L l) && {
    return ZuUnroll::all<Indices>(
      [this, l = ZuMv(l)](auto J) mutable -> decltype(auto) {
      return l(ZuMv(*this).template p<J>());
    }
    );
  }

public:
  template <typename V> CvtTuple<V, bool> equals(const V &v) const {
    return ZuUnroll::all<Indices, bool>(true, [this, &v](auto J, bool b) {
      return b && this->p<J>() == v.template p<J>();
    });
  }
  template <typename V> CvtTuple<V, int> cmp(const V &v) const {
    return ZuUnroll::all<Indices, int>(0, [this, &v](auto J, int i) {
      if (i) return i;
      return ZuCmp<Type<J>>::cmp(this->p<J>(), v.template p<J>());
    });
  }

  template <typename V> CvtElem<V, bool> equals(const V &v) const {
    return this->p<0>() == v;
  }
  template <typename V> CvtElem<V, int> cmp(const V &v) const {
    return ZuCmp<Type<0>>::cmp(this->p<0>(), v);
  }

  bool operator!() const {
    return ZuUnroll::all<Indices, bool>(true, [this](auto J, bool b) {
      return b && !this->p<J>();
    });
  }
  operator const void *() const {
    return !*this ? reinterpret_cast<const void *>(0) :
		    static_cast<const void *>(this);
  }

  uint32_t hash() const {
    return ZuUnroll::all<Indices, uint32_t>(0, [this](auto J, uint32_t v) {
      return v ^ ZuHash<Type<J>>::hash(this->p<J>());
    });
  }

  struct Print {
    const Tuple_ &tuple;
    ZuCSpan delim;

    template <typename S> void print(S &s) const {
      s << '{';
      ZuUnroll::all<Indices>([this, &s](auto J) {
	if (J) s << delim;
	if constexpr (Zu_::IsTuple<Type<J>>{})
	  s << tuple.p<J>().fmt(delim);
	else
	  s << tuple.p<J>();
      });
      s << '}';
    }

    friend ZuPrintFn ZuPrintType(Print *);
  };
  Print fmt(ZuCSpan delim) const { return Print{*this, delim}; }
  template <typename S> void print(S &s) const { s << fmt(","); }
  friend ZuPrintFn ZuPrintType(Tuple_ *);

  template <typename L> auto dispatch(unsigned i, L l) {
    return ZuSwitch::dispatch<N>(i, [this, l = ZuMv(l)](auto I) mutable {
      return l(I, this->p<I>());
    });
  }
  template <typename L> auto cdispatch(unsigned i, L l) const {
    return ZuSwitch::dispatch<N>(i, [this, l = ZuMv(l)](auto I) mutable {
      return l(I, this->p<I>());
    });
  }

  struct Traits : public ZuBaseTraits<Tuple_> {
    template <typename T> using NotPOD = ZuBool<!ZuTraits<T>::IsPOD>;
    enum { IsPOD = !ZuTypeGrep<NotPOD, Types>::N };
  };
  friend Traits ZuTraitsType(Tuple_ *) { return {}; }

  friend Tuple_RDecayer ZuRDecayer(Tuple_ *);
};

template <typename Elem>
using TupleSort = ZuInt<-int(ZuSize<typename Elem::T>{})>;

template <typename, typename> struct TupleBaseT_;
template <unsigned... I, typename... Ts>
struct TupleBaseT_<ZuSeq<I...>, ZuTypeList<Ts...>> {
  using Elems = ZuTypeList<Tuple_Elem<I, Ts>...>;
  using StoredElems = ZuTypeSort<TupleSort, Elems>;
  using T = Tuple_<Elems, StoredElems>;
};
template <typename I, typename Ts>
using TupleBaseT = typename TupleBaseT_<I, Ts>::T;

template <typename... Ts>
class Tuple : public TupleBaseT<ZuMkSeq<sizeof...(Ts)>, ZuTypeList<Ts...>> {
  using Base = TupleBaseT<ZuMkSeq<sizeof...(Ts)>, ZuTypeList<Ts...>>;
  using Elems = typename Base::Elems;
  template <typename V> using IsConAnyTuple = Base::template IsConAnyTuple<V>;
  template <typename V, typename R = void>
  using ConAnyTuple = Base::template ConAnyTuple<V, R>;
  template <typename V, typename R = void>
  using CvtAnyTuple = Base::template CvtAnyTuple<V, R>;
  template <typename V, typename R = void>
  using CvtFirstElem = Base::template CvtFirstElem<V, R>;

public:
  using Types = typename Base::Types;
  enum { N = Base::N };

  Tuple() = default;
  Tuple(const Tuple &) = default;
  Tuple &operator=(const Tuple &) = default;
  Tuple(Tuple &&) = default;
  Tuple &operator=(Tuple &&) = default;
  ~Tuple() = default;

  template <typename V, ConAnyTuple<V, int> = 0>
  Tuple(V &&v) : Base{ZuFwd<V>(v)} { }

  template <
    typename V0, typename... Vs,
    ZuIfT<
      (sizeof...(Vs) + 1 <= N) && (sizeof...(Vs) > 0 || !IsConAnyTuple<V0>{}),
      int> = 0>
  Tuple(V0 &&v0, Vs &&...v) :
    Base{
      ZuTypeHead<sizeof...(Vs) + 1, Elems>{},
      ZuTypeTail<sizeof...(Vs) + 1, Elems>{}, ZuFwd<V0>(v0), ZuFwd<Vs>(v)...
    } { }

  template <typename V> CvtAnyTuple<V, Tuple &> operator=(V &&v) {
    Base::operator=(ZuFwd<V>(v));
    return *this;
  }

  template <typename V> CvtFirstElem<V, Tuple &> operator=(V &&v) {
    Base::operator=(ZuFwd<V>(v));
    return *this;
  }

  friend Tuple TupleType(Tuple *);
};

template <typename L, typename R> struct TupleCanCmp_ : public ZuFalse { };
template <typename... L, typename... R>
struct TupleCanCmp_<Tuple<L...>, Tuple<R...>> :
  public ZuBool<
    typename Tuple<L...>::template IsCvtTuple<Tuple<R...>>{} ||
    typename Tuple<R...>::template IsCvtTuple<Tuple<L...>>{}> { };
template <typename L, typename R>
struct TupleCanCmp :
  public TupleCanCmp_<
    decltype(TupleType(ZuDeclVal<ZuDecay<L> *>())),
    decltype(TupleType(ZuDeclVal<ZuDecay<R> *>()))> { };

template <typename L, typename R>
inline ZuIfT<TupleCanCmp<L, R>{}, bool> operator==(const L &l, const R &r) {
  return l.equals(r);
}
template <typename L, typename R>
inline ZuIfT<TupleCanCmp<L, R>{}, int> operator<=>(const L &l, const R &r) {
  return l.cmp(r);
}

template <typename L, typename R> struct TupleCanCmpElem_ : public ZuFalse { };
template <typename... L, typename R>
struct TupleCanCmpElem_<Tuple<L...>, R> :
  public Tuple<L...>::template IsCvtElem<R> { };
template <typename L, typename R>
struct TupleCanCmpElem :
  public TupleCanCmpElem_<
    decltype(TupleType(ZuDeclVal<ZuDecay<L> *>())), ZuDecay<R>> { };

template <typename L, typename R>
inline ZuIfT<TupleCanCmpElem<L, R>{}, bool> operator==(const L &l, const R &r) {
  return l.equals(r);
}
template <typename L, typename R>
inline ZuIfT<TupleCanCmpElem<L, R>{}, int> operator<=>(const L &l, const R &r) {
  return l.cmp(r);
}

} // namespace Zu_

template <typename... Ts> using ZuTuple = Zu_::Tuple<Ts...>;

template <typename T> using ZuIsTuple = Zu_::IsTuple<T>;
template <typename T, typename R = void>
using ZuMatchTuple = Zu_::MatchTuple<T, R>;

template <typename... Ts> inline auto ZuFwdTuple(Ts &&...args) {
  return ZuTuple<Ts &&...>{ZuFwd<Ts>(args)...};
}

template <typename... Ts> inline auto ZuMvTuple(Ts... args) {
  return ZuTuple<Ts...>{ZuMv(args)...};
}

template <
  typename P, unsigned I,
  bool = ZuTraits<typename P::template Type<I>>::IsReference>
struct ZuTupleAxor_Bind {
  static decltype(auto) get(const P &v) { return v.template p<I>(); }
  static decltype(auto) get(P &v) { return v.template p<I>(); }
  static decltype(auto) get(P &&v) { return ZuMv(v).template p<I>(); }
};
template <typename P, unsigned I> struct ZuTupleAxor_Bind<P, I, true> {
  static decltype(auto) get(const P &v) { return v.template p<I>(); }
  static decltype(auto) get(P &v) { return v.template p<I>(); }
};
template <unsigned I = 0> inline constexpr auto ZuTupleAxor() {
  return []<unsigned I_ = I, typename P>(P &&v) -> decltype(auto) {
    return ZuTupleAxor_Bind<ZuDecay<P>, I_>::get(ZuFwd<P>(v));
  };
}

template <typename P, typename L> decltype(auto) ZuTupleCall(P &&v, L l) {
  return ZuSeqCall<ZuDecay<P>::N, ZuTupleAxor()>(ZuFwd<P>(v), ZuMv(l));
}

namespace std {

template <class> struct tuple_size;
template <typename... Ts>
struct tuple_size<ZuTuple<Ts...>> :
  public integral_constant<size_t, sizeof...(Ts)> { };

template <size_t, typename> struct tuple_element;
template <size_t I, typename... Ts> struct tuple_element<I, ZuTuple<Ts...>> {
  using type = typename ZuTuple<Ts...>::template Type<I>;
};

}

namespace Zu_ {

using size_t = std::size_t;
namespace {
template <size_t I, typename T>
using tuple_element_t = typename std::tuple_element<I, T>::type;
}
template <size_t I, typename... Ts>
constexpr tuple_element_t<I, Tuple<Ts...>> &get(Tuple<Ts...> &p) noexcept {
  return p.template p<I>();
}
template <size_t I, typename... Ts>
constexpr const tuple_element_t<I, Tuple<Ts...>> &
get(const Tuple<Ts...> &p) noexcept {
  return p.template p<I>();
}
template <size_t I, typename... Ts>
constexpr tuple_element_t<I, Tuple<Ts...>> &&get(Tuple<Ts...> &&p) noexcept {
  return static_cast<tuple_element_t<I, Tuple<Ts...>> &&>(p.template p<I>());
}
template <size_t I, typename... Ts>
constexpr const tuple_element_t<I, Tuple<Ts...>> &&
get(const Tuple<Ts...> &&p) noexcept {
  return static_cast<const tuple_element_t<I, Tuple<Ts...>> &&>(p.template p<I>(
  ));
}

template <typename T, typename... Ts>
constexpr T &get(Tuple<Ts...> &p) noexcept {
  return p.template p<T>();
}
template <typename T, typename... Ts>
constexpr const T &get(const Tuple<Ts...> &p) noexcept {
  return p.template p<T>();
}
template <typename T, typename... Ts>
constexpr T &&get(Tuple<Ts...> &&p) noexcept {
  return static_cast<T &&>(p.template p<T>());
}
template <typename T, typename... Ts>
constexpr const T &&get(const Tuple<Ts...> &&p) noexcept {
  return static_cast<const T &&>(p.template p<T>());
}

} // namespace Zu_

struct ZuUTF8 {
  using Elem = uint8_t;

  static bool initial(uint8_t c) { return c < 0x80 || c >= 0xc0; }

  static unsigned in(uint8_t c) {
    if (__builtin_expect(!!(c < 0x80), 1)) return 1;
    if (__builtin_expect(!!((c >> 5) == 0x6), 1)) return 2;
    if (__builtin_expect(!!((c >> 4) == 0xe), 1)) return 3;
    if (__builtin_expect(!!((c >> 3U) == 0x1e), 1)) return 4;
    return 0;
  }

  static unsigned in(const uint8_t *s, unsigned n) {
    if (__builtin_expect(!!(n < 1), 0)) return 0;
    uint8_t c = *s;
    if (__builtin_expect(!!(c < 0x80), 1)) return 1;
    if (__builtin_expect(!!(n < 2), 0)) return 0;
    if (__builtin_expect(!!((c >> 5) == 0x6), 1)) return 2;
    if (__builtin_expect(!!(n < 3), 0)) return 0;
    if (__builtin_expect(!!((c >> 4) == 0xe), 1)) return 3;
    if (__builtin_expect(!!(n < 4), 0)) return 0;
    if (__builtin_expect(!!((c >> 3U) == 0x1e), 1)) return 4;
    return 0;
  }

  static unsigned in(const uint8_t *s, unsigned n, uint32_t &u_) {
    if (__builtin_expect(!!(n < 1), 0)) return 0;
    uint8_t c = *s;
    if (__builtin_expect(!!(c < 0x80), 1)) {
      u_ = c;
      return 1;
    }
    if (__builtin_expect(!!(n < 2), 0)) return 0;
    uint32_t u = c;
    if (__builtin_expect(!!((c >> 5) == 0x6), 1)) {
      c = *++s;
      u_ = ((u << 6) & 0x7ff) + (c & 0x3f);
      return 2;
    }
    if (__builtin_expect(!!(n < 3), 0)) return 0;
    if (__builtin_expect(!!((c >> 4) == 0xe), 1)) {
      c = *++s;
      u = ((u << 12) & 0xf000) + ((static_cast<uint32_t>(c) << 6) & 0xfc0);
      c = *++s;
      u_ = u + (c & 0x3f);
      return 3;
    }
    if (__builtin_expect(!!(n < 4), 0)) return 0;
    if (__builtin_expect(!!((c >> 3U) == 0x1e), 1)) {
      c = *++s;
      u = ((u << 18) & 0x1c0000) + ((static_cast<uint32_t>(c) << 12) & 0x3f000);
      c = *++s;
      u += ((static_cast<uint32_t>(c) << 6) & 0xfc0);
      c = *++s;
      u_ = u + (c & 0x3f);
      return 4;
    }
    return 0;
  }

  static unsigned out(uint32_t u) {
    if (__builtin_expect(!!(u < 0x80), 1)) return 1;
    if (__builtin_expect(!!(u < 0x800), 1)) return 2;
    if (__builtin_expect(!!(u < 0x10000), 1)) return 3;
    return 4;
  }

  static unsigned out(uint8_t *s, unsigned n, uint32_t u) {
    if (__builtin_expect(!!(n < 1), 0)) return 0;
    if (__builtin_expect(!!(u < 0x80), 1)) {
      *s = u;
      return 1;
    }
    if (__builtin_expect(!!(n < 2), 0)) return 0;
    if (__builtin_expect(!!(u < 0x800), 1)) {
      *s++ = (u >> 6) | 0xc0;
      *s = (u & 0x3f) | 0x80;
      return 2;
    }
    if (__builtin_expect(!!(n < 3), 0)) return 0;
    if (__builtin_expect(!!(u < 0x10000), 1)) {
      *s++ = (u >> 12) | 0xe0;
      *s++ = ((u >> 6) & 0x3f) | 0x80;
      *s = (u & 0x3f) | 0x80;
      return 3;
    }
    if (__builtin_expect(!!(n < 4), 0)) return 0;
    *s++ = (u >> 18) | 0xf0;
    *s++ = ((u >> 12) & 0x3f) | 0x80;
    *s++ = ((u >> 6) & 0x3f) | 0x80;
    *s = (u & 0x3f) | 0x80;
    return 4;
  }
};

struct ZuUTF16 {
  using Elem = uint16_t;

  static bool initial(uint16_t c) { return c < 0xdc00 || c >= 0xe000; }

  static unsigned in(uint16_t c) {
    if (__builtin_expect(!!(c < 0xd800 || c >= 0xe000), 1)) return 1;
    if (__builtin_expect(!!(c >= 0xdc00), 0)) return 0;
    return 2;
  }

  static unsigned in(const uint16_t *s, unsigned n) {
    uint16_t c = *s;
    if (__builtin_expect(!!(n < 1), 0)) return 0;
    if (__builtin_expect(!!(c < 0xd800 || c >= 0xe000), 1)) return 1;
    if (__builtin_expect(!!(n < 2 || c >= 0xdc00), 0)) return 0;
    c = *++s;
    if (__builtin_expect(!!(c < 0xdc00 || c >= 0xe000), 0)) return 0;
    return 2;
  }

  static unsigned in(const uint16_t *s, unsigned n, uint32_t &u_) {
    uint16_t c = *s;
    if (__builtin_expect(!!(n < 1), 0)) return 0;
    if (__builtin_expect(!!(c < 0xd800 || c >= 0xe000), 1)) {
      u_ = c;
      return 1;
    }
    if (__builtin_expect(!!(n < 2 || c >= 0xdc00), 0)) return 0;
    uint32_t u = c;
    c = *++s;
    if (__builtin_expect(!!(c < 0xdc00 || c >= 0xe000), 0)) return 0;
    u_ =
      (((u - 0xd800) << 10) | 0x10000) + ((static_cast<uint32_t>(c)) - 0xdc00);
    return 2;
  }

  static unsigned out(uint32_t u) {
    if (__builtin_expect(!!(u < 0xd800 || (u >= 0xe000 && u < 0x10000)), 1))
      return 1;
    return 2;
  }

  static unsigned out(uint16_t *s, unsigned n, uint32_t u) {
    if (__builtin_expect(!!(n < 1), 0)) return 0;
    if (__builtin_expect(!!(u < 0xd800 || (u >= 0xe000 && u < 0x10000)), 1)) {
      *s = u;
      return 1;
    }
    if (__builtin_expect(!!(n < 2), 0)) return 0;
    *s++ = ((u & 0xffff) >> 10) + 0xd800;
    *s = (u & 0x3ff) + 0xdc00;
    return 2;
  }
};

struct ZuUTF32 {
  using Elem = uint32_t;

  static unsigned in(const uint32_t *s, unsigned n, uint32_t &u) {
    if (__builtin_expect(!!(n < 1), 0)) return 0;
    u = *s;
    return 1;
  }

  static constexpr unsigned out(uint32_t) { return 1; }

  static unsigned out(uint32_t *s, unsigned n, uint32_t u) {
    if (__builtin_expect(!!(n < 1), 0)) return 0;
    *s = u;
    return 1;
  }

  static unsigned width(uint32_t);
};

template <unsigned> struct ZuUTF_;
template <> struct ZuUTF_<1> {
  using T = ZuUTF8;
};
template <> struct ZuUTF_<2> {
  using T = ZuUTF16;
};
template <> struct ZuUTF_<4> {
  using T = ZuUTF32;
};

class ZuUTFSpan {
  static constexpr unsigned shift() { return 21; }
  static constexpr unsigned mask() { return ((1 << shift()) - 1); }

public:
  ZuUTFSpan() = default;
  ZuUTFSpan(const ZuUTFSpan &) = default;
  ZuUTFSpan &operator=(const ZuUTFSpan &) = default;
  ZuUTFSpan(ZuUTFSpan &&) = default;
  ZuUTFSpan &operator=(ZuUTFSpan &&) = default;
  ~ZuUTFSpan() = default;

  ZuUTFSpan(uint64_t inLen, uint64_t outLen, uint64_t width) :
    m_value{inLen | (outLen << shift()) | (width << (shift() << 1))} { }

private:
  explicit ZuUTFSpan(uint64_t value) : m_value{value} { }

public:
  unsigned inLen() const { return m_value & mask(); }
  unsigned outLen() const { return (m_value >> shift()) & mask(); }
  unsigned width() const { return m_value >> (shift() << 1); }

  bool operator!() const { return !m_value; }
  operator const void *() const {
    return !*this ? reinterpret_cast<const void *>(0) :
		    static_cast<const void *>(this);
  }

  ZuUTFSpan operator+(const ZuUTFSpan &o) {
    return ZuUTFSpan{m_value + o.m_value};
  }
  ZuUTFSpan &operator+=(const ZuUTFSpan &o) {
    m_value += o.m_value;
    return *this;
  }
  ZuUTFSpan operator-(const ZuUTFSpan &o) {
    if (m_value <= o.m_value) return ZuUTFSpan{};
    return ZuUTFSpan{m_value - o.m_value};
  }
  ZuUTFSpan &operator-=(const ZuUTFSpan &o) {
    if (m_value <= o.m_value)
      m_value = 0;
    else
      m_value -= o.m_value;
    return *this;
  }

  ZuUTFSpan &operator++() {
    m_value += ZuUTFSpan{1, 1, 1}.m_value;
    return *this;
  }

private:
  uint64_t m_value = 0;
};

template <typename OutChar, typename InChar> struct ZuUTF {
  using OutUTF = typename ZuUTF_<sizeof(OutChar)>::T;
  using OutElem = typename OutUTF::Elem;
  using InUTF = typename ZuUTF_<sizeof(InChar)>::T;
  using InElem = typename InUTF::Elem;

  using Span = ZuUTFSpan;

  static Span span(ZuSpan<const InChar> s_) {
    auto s = reinterpret_cast<const InElem *>(s_.data());
    unsigned n = s_.length();
    uint32_t u;
    unsigned l = 0;
    unsigned w = 0;
    unsigned i = n;
    while (i) {
      unsigned j = InUTF::in(s, i, u);
      if (__builtin_expect(!!(!j || j > i), 0)) break;
      s += j, i -= j;
      l += OutUTF::out(u);
      w += ZuUTF32::width(u);
    }
    return Span{n - i, l, w};
  }

  static Span nspan(ZuSpan<const InChar> s_, unsigned nglyphs) {
    auto s = reinterpret_cast<const InElem *>(s_.data());
    unsigned n = s_.length();
    uint32_t u;
    unsigned l = 0;
    unsigned w = 0;
    unsigned i = n;
    while (i && nglyphs) {
      unsigned j = InUTF::in(s, i, u);
      if (__builtin_expect(!!(!j || j > i), 0)) break;
      s += j, i -= j;
      l += OutUTF::out(u);
      w += ZuUTF32::width(u);
      --nglyphs;
    }
    return Span{n - i, l, w};
  }

  static Span gspan(ZuSpan<const InChar> s_) {
    auto s = reinterpret_cast<const InElem *>(s_.data());
    unsigned n = s_.length();
    uint32_t u;
    if (__builtin_expect(!!(!n), 0)) return Span{};
    unsigned j = InUTF::in(s, n, u);
    if (__builtin_expect(!!(!j || j > n), 0)) return Span{};
    return Span{j, OutUTF::out(u), ZuUTF32::width(u)};
  }

  static unsigned len(ZuSpan<const InChar> s_) {
    auto s = reinterpret_cast<const InElem *>(s_.data());
    unsigned n = s_.length();
    uint32_t u;
    unsigned l = 0;
    for (unsigned i = n; i;) {
      unsigned j = InUTF::in(s, i, u);
      if (__builtin_expect(!!(!j || j > i), 0)) break;
      s += j, i -= j;
      l += OutUTF::out(u);
    }
    return l;
  }

  static unsigned cvt(ZuSpan<OutChar> o_, ZuSpan<const InChar> s_) {
    auto o = reinterpret_cast<OutElem *>(o_.data());
    unsigned l = o_.length();
    auto s = reinterpret_cast<const InElem *>(s_.data());
    unsigned n = s_.length();
    uint32_t u;
    for (unsigned i = n; i;) {
      unsigned j = InUTF::in(s, i, u);
      if (__builtin_expect(!!(!j || j > i), 0)) break;
      s += j, i -= j;
      j = OutUTF::out(o, l, u);
      if (!j) break;
      o += j, l -= j;
    }
    return o_.length() - l;
  }
};

template <typename T_> struct ZuCArray_Char2;
template <> struct ZuCArray_Char2<char> {
  using T = wchar_t;
};
template <> struct ZuCArray_Char2<wchar_t> {
  using T = char;
};

template <typename Char_, unsigned N, typename StringN> class ZuCArray_ {
  template <typename, typename> friend struct ZuInspect_::Convertible;

  ZuCArray_(const ZuCArray_ &);
  ZuCArray_ &operator=(const ZuCArray_ &);

  static_assert((N >= 1 && N < 65536), "N >= 1 && N < 65536");
  enum { M = N - 1 };

public:
  using Char = Char_;
  using Char2 = typename ZuCArray_Char2<Char>::T;

  struct Nop { };

protected:
  template <typename U, typename V = Char>
  struct IsString :
    public ZuBool<
      (ZuTraits<U>::IsArray || ZuTraits<U>::IsString) &&
      bool{ZuEquiv<typename ZuTraits<U>::Elem, V>{}}> { };
  template <typename U, typename R = void>
  using MatchString = ZuIfT<IsString<U>{}, R>;

  template <typename U, typename V = Char>
  struct IsChar : public ZuEquiv<U, V> { };
  template <typename U, typename R = void>
  using MatchChar = ZuIfT<IsChar<U>{}, R>;

  template <typename U, typename V = Char2>
  struct IsChar2String :
    public ZuBool<
      (ZuTraits<U>::IsArray || ZuTraits<U>::IsString) &&
      bool{ZuEquiv<typename ZuTraits<U>::Elem, V>{}}> { };
  template <typename U, typename R = void>
  using MatchChar2String = ZuIfT<IsChar2String<U>{}, R>;

  template <typename U, typename V = Char2>
  struct IsChar2 :
    public ZuBool<bool{ZuEquiv<U, V>{}} && !bool{ZuEquiv<U, wchar_t>{}}> { };
  template <typename U, typename R = void>
  using MatchChar2 = ZuIfT<IsChar2<U>{}, R>;

  template <typename U, typename V = Char>
  struct IsPDelegate :
    public ZuBool<bool{ZuEquiv<char, V>{}} && ZuPrint<U>::Delegate> { };
  template <typename U, typename R = void>
  using MatchPDelegate = ZuIfT<IsPDelegate<U>{}, R>;
  template <typename U, typename V = Char>
  struct IsPBuffer :
    public ZuBool<bool{ZuEquiv<char, V>{}} && ZuPrint<U>::Buffer> { };
  template <typename U, typename R = void>
  using MatchPBuffer = ZuIfT<IsPBuffer<U>{}, R>;

  template <typename U, typename V = Char>
  struct IsReal :
    public ZuBool<
      bool{ZuEquiv<char, V>{}} && !bool{ZuEquiv<U, V>{}} &&
      ZuTraits<U>::IsReal && ZuTraits<U>::IsPrimitive &&
      !ZuTraits<U>::IsArray> { };
  template <typename U, typename R = void>
  using MatchReal = ZuIfT<IsReal<U>{}, R>;

  template <typename U, typename V = Char>
  struct IsPtr :
    public ZuBool<
      bool{ZuEquiv<char, V>{}} && ZuTraits<U>::IsPointer &&
      ZuTraits<U>::IsPrimitive && !ZuTraits<U>::IsArray &&
      !ZuTraits<U>::IsString> { };
  template <typename U, typename R = void>
  using MatchPtr = ZuIfT<IsPtr<U>{}, R>;

  template <typename U>
  struct IsStreamable :
    public ZuBool<
      bool{IsString<U>{}} || bool{IsChar<U>{}} || bool{IsChar2String<U>{}} ||
      bool{IsChar2<U>{}} || bool{IsPDelegate<U>{}} || bool{IsPBuffer<U>{}} ||
      bool{IsReal<U>{}} || bool{IsPtr<U>{}}> { };
  template <typename U, typename R = void>
  using MatchStreamable = ZuIfT<IsStreamable<U>{}, R>;

  ZuCArray_() : m_length(0) { data()[0] = 0; }

  ZuCArray_(Nop) { }

  ZuCArray_(unsigned length) : m_length(length) {
    if (m_length >= N) m_length = M;
    data()[m_length] = 0;
  }

  void init(const Char *s) {
    if (!s) {
      null();
      return;
    }
    unsigned i;
    for (i = 0; i < M; i++)
      if (!(data()[i] = *s++)) break;
    if (i == M) data()[i] = 0;
    m_length = i;
  }

  void init(const Char *s, unsigned length) {
    if (__builtin_expect(!!(length >= N), 0)) length = M;
    if (__builtin_expect(!!(s && length), 1))
      memcpy(data(), s, length * sizeof(Char));
    memset(data() + (m_length = length), 0, (N - length) * sizeof(Char));
  }

  template <typename S> MatchString<S> init(S &&s_) {
    ZuSpan<const Char> s(s_);
    init(s.data(), s.length());
  }

  template <typename C> MatchChar<C> init(C c) {
    auto data = this->data();
    data[0] = c;
    data[m_length = 1] = 0;
  }

  template <typename S> MatchChar2String<S> init(S &&s) {
    data()[m_length = ZuUTF<Char, Char2>::cvt({data(), M}, s)] = 0;
  }
  template <typename C> MatchChar2<C> init(C c) {
    data()[m_length = ZuUTF<Char, Char2>::cvt({data(), M}, {&c, 1})] = 0;
  }

  template <typename P> MatchPDelegate<P> init(const P &p) {
    m_length = 0;
    ZuPrint<P>::print(*static_cast<StringN *>(this), p);
  }
  template <typename P> MatchPBuffer<P> init(const P &p) {
    unsigned length = ZuPrint<P>::length(p);
    if (length >= N)
      data()[m_length = 0] = 0;
    else
      data()[m_length = ZuPrint<P>::print(data(), length, p)] = 0;
  }

  template <typename V> MatchReal<V> init(V v) { init(ZuBoxed(v)); }
  template <typename V> MatchPtr<V> init(V v) {
    init((ZuBox<uintptr_t, ZuBoxCmp<ZuCmp0>>{reinterpret_cast<uintptr_t>(v)})
	   .hex<false, ZuFmt::Alt<>>());
  }

  void append(const Char *s, unsigned length) {
    if (m_length + length >= N) {
      if (m_length >= M) return;
      length = M - m_length;
    }
    if (s && length) memcpy(data() + m_length, s, length * sizeof(Char));
    data()[m_length += length] = 0;
  }

  template <typename S> MatchString<S> append_(S &&s_) {
    ZuSpan<const Char> s(s_);
    append(s.data(), s.length());
  }

  template <typename C> MatchChar<C> append_(C c) {
    if (m_length >= M) return;
    auto data = this->data();
    data[m_length++] = c;
    data[m_length] = 0;
  }

  template <typename S> MatchChar2String<S> append_(S &&s) {
    if (m_length < M)
      data(
      )[m_length = ZuUTF<Char, Char2>::cvt(
	  {data() + m_length, unsigned(M - m_length)}, s
	)] = 0;
  }

  template <typename C> MatchChar2<C> append_(C c) {
    if (m_length < M)
      data(
      )[m_length += ZuUTF<Char, Char2>::cvt(
	  {data() + m_length, unsigned(M - m_length)}, {&c, 1}
	)] = 0;
  }

  template <typename P> MatchPDelegate<P> append_(const P &p) {
    ZuPrint<P>::print(*static_cast<StringN *>(this), p);
  }
  template <typename P> MatchPBuffer<P> append_(const P &p) {
    unsigned length = ZuPrint<P>::length(p);
    if (m_length + length >= N) return;
    data()[m_length += ZuPrint<P>::print(data() + m_length, length, p)] = 0;
  }

  template <typename V> MatchReal<V> append_(V v) { append_(ZuBoxed(v)); }
  template <typename V> MatchPtr<V> append_(V v) {
    append_((ZuBox<uintptr_t, ZuBoxCmp<ZuCmp0>>{reinterpret_cast<uintptr_t>(v)})
	      .hex<false, ZuFmt::Alt<>>());
  }

public:
  Char &operator[](unsigned i) { return data()[i]; }
  const Char &operator[](unsigned i) const { return data()[i]; }

  operator Char *() {
    return !m_length ? static_cast<Char *>(nullptr) : data();
  }
  operator const Char *() const {
    return !m_length ? static_cast<const Char *>(nullptr) : data();
  }

  Char *data() { return reinterpret_cast<Char *>(&this[1]); }
  const Char *data() const { return reinterpret_cast<const Char *>(&this[1]); }
  unsigned length() const { return m_length; }
  static constexpr unsigned size() { return N; }

private:
  auto matchS() {
    return
      [](int c) { return c == ' ' || c == '\t' || c == '\n' || c == '\t'; };
  }

public:
  template <typename Match> void chomp(Match match) {
    int o = m_length;
    if (!o) return;
    while (--o >= 0 && match(data()[0]));
    data()[m_length = o + 1] = 0;
  }
  void chomp() { return chomp(matchS()); }

  template <typename Match> void trim(Match match) {
    int o;
    for (o = 0; o < (int)m_length && match(data()[0]); o++);
    if (!o) return;
    if (!(m_length -= o)) {
      null();
      return;
    }
    memmove(data(), data() + o, m_length * sizeof(Char));
    data()[m_length] = 0;
  }
  void trim() { return trim(matchS()); }

  template <typename Match> void strip(Match match) {
    int o = m_length;
    if (!o) return;
    while (--o >= 0 && match(data()[o]));
    if (o < 0) {
      null();
      return;
    }
    m_length = o + 1;
    for (o = 0; o < (int)m_length && match(data()[0]); o++);
    if (!o) {
      data()[m_length] = 0;
      return;
    }
    if (!(m_length -= o)) {
      null();
      return;
    }
    memmove(data(), data() + o, m_length * sizeof(Char));
    data()[m_length] = 0;
  }
  void strip() { return strip(matchS()); }

  StringN &sprintf(const Char *format, ...) {
    va_list args;

    __builtin_va_start(

      args

      ,

      format

    );
    vsnprintf(format, args);

    __builtin_va_end(

      args

    );
    return *static_cast<StringN *>(this);
  }
  StringN &vsprintf(const Char *format, va_list args) {
    vsnprintf(format, args);
    return *static_cast<StringN *>(this);
  }

private:
  void vsnprintf(const Char *format, va_list args) {
    if (N <= m_length + 2) return;
    int n = Zu::vsnprintf(data() + m_length, N - m_length, format, args);
    if (n < 0) {
      calcLength();
      return;
    }
    n += m_length;
    if (n == (int)N || n == (int)M) {
      data()[m_length = M] = 0;
      return;
    }
    m_length = n;
  }

public:
  void clear() { null(); }
  void null() { data()[m_length = 0] = 0; }

  void length(unsigned length) {
    if (length >= N) length = M;
    data()[m_length = length] = 0;
  }

  void calcLength() {
    data()[M] = 0;
    m_length = Zu::strlen_(data());
  }

  auto buf() { return ZuSpan{data(), M}; }
  auto cbuf() const { return ZuSpan{data(), m_length}; }

  bool operator!() const { return !m_length; }

protected:
  bool same(const StringN &s) const {
    return static_cast<const StringN *>(this) == &s;
  }
  template <typename S> bool same(const S &s) const { return false; }

public:
  template <typename S> bool equals(const S &s) const {
    return same(s) ||
      ZuCmp<StringN>::equals(*static_cast<const StringN *>(this), s);
  }
  template <typename S> int cmp(const S &s) const {
    if (same(s)) return 0;
    return ZuCmp<StringN>::cmp(*static_cast<const StringN *>(this), s);
  }
  template <typename L, typename R>
  friend inline ZuIfT<ZuInspect<StringN, L>::Is, bool>
  operator==(const L &l, const R &r) {
    return l.equals(r);
  }
  template <typename L, typename R>
  friend inline ZuIfT<ZuInspect<StringN, L>::Is, int>
  operator<=>(const L &l, const R &r) {
    return l.cmp(r);
  }

  uint32_t hash() const {
    return ZuHash<StringN>::hash(*static_cast<const StringN *>(this));
  }

  struct Traits : public ZuBaseTraits<ZuCArray_> {
    using Elem = Char;
    enum {
      IsPOD = 1,
      IsCString = 1,
      IsString = 1,
      IsStream = 1,
      IsWString = bool{ZuEquiv<wchar_t, Char>{}}
    };
    static Elem *data(ZuCArray_ &s) { return s.data(); }
    static const Elem *data(const ZuCArray_ &s) { return s.data(); }
    static unsigned length(const ZuCArray_ &s) { return s.length(); }
  };
  friend Traits ZuTraitsType(ZuCArray_ *);

protected:
  uint16_t m_length;
};

template <unsigned N_>
class ZuCArray : public ZuCArray_<char, N_, ZuCArray<N_>> {
  static_assert((N_ > 1), "N_ > 1");

public:
  using Char = char;
  using Char2 = wchar_t;
  using Base = ZuCArray_<char, N_, ZuCArray<N_>>;
  enum { N = N_ };

  using Nop = Base::Nop;

private:
  template <typename U, typename V = Char>
  struct IsCtorLength :
    public ZuBool<
      ZuTraits<U>::IsIntegral &&
      (sizeof(U) > 2 || !ZuIsExact<ZuNormChar<V>, ZuNormChar<U>>{})> { };
  template <typename U, typename R = void>
  using MatchCtorLength = ZuIfT<IsCtorLength<U>{}, R>;

  template <typename U>
  struct IsCtorArg :
    public ZuBool<!IsCtorLength<U>{} && !ZuInspect<Base, U>::Base> { };
  template <typename U, typename R = void>
  using MatchCtorArg = ZuIfT<IsCtorArg<U>{}, R>;

public:
  ZuCArray() { }

  ZuCArray(const ZuCArray &s) : Base{Nop{}} {
    this->init(s.data(), s.length());
  }
  ZuCArray &operator=(const ZuCArray &s) {
    if (__builtin_expect(!!(this != &s), 1)) this->init(s.data(), s.length());
    return *this;
  }

  ZuCArray &update(ZuCSpan s) {
    if (s.length()) this->init(s.data(), s.length());
    return *this;
  }

  ZuCArray(const char *s) : Base{Nop{}} { this->init(s); }
  ZuCArray(const char *s, unsigned length) : Base{Nop{}} {
    this->init(s, length);
  }
  ZuCArray &operator=(const char *s) {
    this->init(s);
    return *this;
  }
  ZuCArray &operator<<(const char *s_) {
    ZuCSpan s{s_};
    this->append(s.data(), s.length());
    return *this;
  }
  ZuCArray &update(const char *s) {
    if (s) this->init(s);
    return *this;
  }

  template <typename S, decltype(MatchCtorArg<S>(), int()) = 0>
  ZuCArray(S &&s) : Base{Nop{}} {
    this->init(ZuFwd<S>(s));
  }
  template <typename S> ZuCArray &operator=(S &&s) {
    this->init(ZuFwd<S>(s));
    return *this;
  }
  template <typename U> ZuCArray &operator+=(U &&v) {
    return *this << ZuFwd<U>(v);
  }

  template <typename U>
  Base::template MatchStreamable<U, ZuCArray &> operator<<(U &&v) {
    this->append_(ZuFwd<U>(v));
    return *this;
  }

  template <typename V, decltype(MatchCtorLength<V>(), int()) = 0>
  ZuCArray(V n) : Base{unsigned(n)} { }

  friend typename Base::Traits ZuTraitsType(ZuCArray *);

  friend ZuPrintString ZuPrintType(ZuCArray *);

private:
  char m_data[N];
};

template <unsigned N_>
class ZuWArray : public ZuCArray_<wchar_t, N_, ZuWArray<N_>> {
  static_assert((N_ > 1), "N_ > 1");

public:
  using Char = wchar_t;
  using Char2 = char;
  using Base = ZuCArray_<wchar_t, N_, ZuWArray<N_>>;
  enum { N = N_ };

  using Nop = Base::Nop;

private:
  template <typename U, typename V = Char>
  struct IsCtorLength :
    public ZuBool<
      ZuTraits<U>::IsIntegral &&
      (sizeof(U) > 2 || !ZuIsExact<ZuNormChar<V>, ZuNormChar<U>>{})> { };
  template <typename U, typename R = void>
  using MatchCtorLength = ZuIfT<IsCtorLength<U>{}, R>;

  template <typename U>
  struct IsCtorArg :
    public ZuBool<!IsCtorLength<U>{} && !ZuInspect<Base, U>::Base> { };
  template <typename U, typename R = void>
  using MatchCtorArg = ZuIfT<IsCtorArg<U>{}, R>;

public:
  ZuWArray() { }

  ZuWArray(const ZuWArray &s) : Base{Nop{}} {
    this->init(s.data(), s.length());
  }
  ZuWArray &operator=(const ZuWArray &s) {
    if (__builtin_expect(!!(this != &s), 1)) init(s.data(), s.length());
    return *this;
  }

  template <typename S> ZuWArray &update(S &&s_) {
    ZuWSpan s{s_};
    if (s.length()) this->init(s.data(), s.length());
    return *this;
  }

  ZuWArray(const wchar_t *s) : Base{Nop{}} { this->init(s); }
  ZuWArray(const wchar_t *s, unsigned length) : Base{Nop{}} {
    this->init(s, length);
  }
  ZuWArray &operator=(const wchar_t *s) {
    this->init(s);
    return *this;
  }
  ZuWArray &operator<<(const wchar_t *s_) {
    ZuWSpan s{s_};
    this->append(s.data(), s.length());
    return *this;
  }
  ZuWArray &update(const wchar_t *s) {
    if (s) this->init(s);
    return *this;
  }

  template <typename S, decltype(MatchCtorArg<S>(), int()) = 0>
  ZuWArray(S &&s) : Base{Nop{}} {
    this->init(ZuFwd<S>(s));
  }
  template <typename S> ZuWArray &operator=(S &&s) {
    this->init(ZuFwd<S>(s));
    return *this;
  }
  template <typename U>
  Base::template MatchStreamable<U, ZuWArray &> operator<<(U &&v) {
    this->append_(ZuFwd<U>(v));
    return *this;
  }
  template <typename U> ZuWArray &operator+=(U &&v) {
    return *this << ZuFwd<U>(v);
  }

  template <typename V, decltype(MatchCtorLength<V>(), int()) = 0>
  ZuWArray(V n) : Base{unsigned(n)} { }

  friend typename Base::Traits ZuTraitsType(ZuWArray *);

private:
  wchar_t m_data[N];
};

using ZmIDString = ZuCArray<60>;

namespace Zm {

enum { CacheLineSize = 64 };

using ProcessID = pid_t;

using ThreadID = pid_t;

inline ProcessID getPID() { return getpid(); }

inline ThreadID getTID() {
  unsigned tid;
  __asm__("mov %%fs:0x2d0, %0" : "=r"(tid));
  return tid;
}

inline unsigned getncpu() {
  int n = sysconf(

    _SC_NPROCESSORS_ONLN

  );
  return n < 1 ? 1 : n;
}

inline void yield() { sched_yield(); }

inline void exit(int code) { ::_exit(code); }

template <unsigned Align_> inline void *alignedAlloc(unsigned size) {
  enum { Align = Align_ < sizeof(void *) ? sizeof(void *) : Align_ };
  void *ptr;
  if (posix_memalign(&ptr, Align, size)) ptr = nullptr;
  return ptr;
}
inline void alignedFree(const void *ptr) { ::free(const_cast<void *>(ptr)); }

} // namespace Zm

typedef uint64_t hwloc_uint64_t;

extern "C" { }

extern "C" {

  extern void __assert_fail(
    const char *__assertion, const char *__file, unsigned int __line,
    const char *__function
  ) noexcept(true) __attribute__((__noreturn__));

  extern void __assert_perror_fail(
    int __errnum, const char *__file, unsigned int __line,
    const char *__function
  ) noexcept(true) __attribute__((__noreturn__));

  extern void __assert(
    const char *__assertion, const char *__file, int __line
  ) noexcept(true) __attribute__((__noreturn__));
}

extern "C" {

  typedef struct hwloc_bitmap_s *hwloc_bitmap_t;

  typedef const struct hwloc_bitmap_s *hwloc_const_bitmap_t;

  hwloc_bitmap_t hwloc_bitmap_alloc(void) __attribute__((__malloc__));

  hwloc_bitmap_t hwloc_bitmap_alloc_full(void) __attribute__((__malloc__));

  void hwloc_bitmap_free(hwloc_bitmap_t bitmap);

  hwloc_bitmap_t hwloc_bitmap_dup(hwloc_const_bitmap_t bitmap)
    __attribute__((__malloc__));

  int hwloc_bitmap_copy(hwloc_bitmap_t dst, hwloc_const_bitmap_t src);

  int hwloc_bitmap_snprintf(
    char *__restrict buf, size_t buflen, hwloc_const_bitmap_t bitmap
  );

  int hwloc_bitmap_asprintf(char **strp, hwloc_const_bitmap_t bitmap);

  int hwloc_bitmap_sscanf(hwloc_bitmap_t bitmap, const char *__restrict string);

  int hwloc_bitmap_list_snprintf(
    char *__restrict buf, size_t buflen, hwloc_const_bitmap_t bitmap
  );

  int hwloc_bitmap_list_asprintf(char **strp, hwloc_const_bitmap_t bitmap);

  int hwloc_bitmap_list_sscanf(
    hwloc_bitmap_t bitmap, const char *__restrict string
  );

  int hwloc_bitmap_taskset_snprintf(
    char *__restrict buf, size_t buflen, hwloc_const_bitmap_t bitmap
  );

  int hwloc_bitmap_taskset_asprintf(char **strp, hwloc_const_bitmap_t bitmap);

  int hwloc_bitmap_taskset_sscanf(
    hwloc_bitmap_t bitmap, const char *__restrict string
  );

  void hwloc_bitmap_zero(hwloc_bitmap_t bitmap);

  void hwloc_bitmap_fill(hwloc_bitmap_t bitmap);

  int hwloc_bitmap_only(hwloc_bitmap_t bitmap, unsigned id);

  int hwloc_bitmap_allbut(hwloc_bitmap_t bitmap, unsigned id);

  int hwloc_bitmap_from_ulong(hwloc_bitmap_t bitmap, unsigned long mask);

  int hwloc_bitmap_from_ith_ulong(
    hwloc_bitmap_t bitmap, unsigned i, unsigned long mask
  );

  int hwloc_bitmap_from_ulongs(
    hwloc_bitmap_t bitmap, unsigned nr, const unsigned long *masks
  );

  int hwloc_bitmap_set(hwloc_bitmap_t bitmap, unsigned id);

  int hwloc_bitmap_set_range(hwloc_bitmap_t bitmap, unsigned begin, int end);

  int hwloc_bitmap_set_ith_ulong(
    hwloc_bitmap_t bitmap, unsigned i, unsigned long mask
  );

  int hwloc_bitmap_clr(hwloc_bitmap_t bitmap, unsigned id);

  int hwloc_bitmap_clr_range(hwloc_bitmap_t bitmap, unsigned begin, int end);

  int hwloc_bitmap_singlify(hwloc_bitmap_t bitmap);

  unsigned long hwloc_bitmap_to_ulong(hwloc_const_bitmap_t bitmap)
    __attribute__((__pure__));

  unsigned long
  hwloc_bitmap_to_ith_ulong(hwloc_const_bitmap_t bitmap, unsigned i)
    __attribute__((__pure__));

  int hwloc_bitmap_to_ulongs(
    hwloc_const_bitmap_t bitmap, unsigned nr, unsigned long *masks
  );

  int hwloc_bitmap_nr_ulongs(hwloc_const_bitmap_t bitmap)
    __attribute__((__pure__));

  int hwloc_bitmap_isset(hwloc_const_bitmap_t bitmap, unsigned id)
    __attribute__((__pure__));

  int hwloc_bitmap_iszero(hwloc_const_bitmap_t bitmap)
    __attribute__((__pure__));

  int hwloc_bitmap_isfull(hwloc_const_bitmap_t bitmap)
    __attribute__((__pure__));

  int hwloc_bitmap_first(hwloc_const_bitmap_t bitmap) __attribute__((__pure__));

  int hwloc_bitmap_next(hwloc_const_bitmap_t bitmap, int prev)
    __attribute__((__pure__));

  int hwloc_bitmap_last(hwloc_const_bitmap_t bitmap) __attribute__((__pure__));

  int hwloc_bitmap_weight(hwloc_const_bitmap_t bitmap)
    __attribute__((__pure__));

  int hwloc_bitmap_first_unset(hwloc_const_bitmap_t bitmap)
    __attribute__((__pure__));

  int hwloc_bitmap_next_unset(hwloc_const_bitmap_t bitmap, int prev)
    __attribute__((__pure__));

  int hwloc_bitmap_last_unset(hwloc_const_bitmap_t bitmap)
    __attribute__((__pure__));

  int hwloc_bitmap_or(
    hwloc_bitmap_t res, hwloc_const_bitmap_t bitmap1,
    hwloc_const_bitmap_t bitmap2
  );

  int hwloc_bitmap_and(
    hwloc_bitmap_t res, hwloc_const_bitmap_t bitmap1,
    hwloc_const_bitmap_t bitmap2
  );

  int hwloc_bitmap_andnot(
    hwloc_bitmap_t res, hwloc_const_bitmap_t bitmap1,
    hwloc_const_bitmap_t bitmap2
  );

  int hwloc_bitmap_xor(
    hwloc_bitmap_t res, hwloc_const_bitmap_t bitmap1,
    hwloc_const_bitmap_t bitmap2
  );

  int hwloc_bitmap_not(hwloc_bitmap_t res, hwloc_const_bitmap_t bitmap);

  int hwloc_bitmap_intersects(
    hwloc_const_bitmap_t bitmap1, hwloc_const_bitmap_t bitmap2
  ) __attribute__((__pure__));

  int hwloc_bitmap_isincluded(
    hwloc_const_bitmap_t sub_bitmap, hwloc_const_bitmap_t super_bitmap
  ) __attribute__((__pure__));

  int hwloc_bitmap_isequal(
    hwloc_const_bitmap_t bitmap1, hwloc_const_bitmap_t bitmap2
  ) __attribute__((__pure__));

  int hwloc_bitmap_compare_first(
    hwloc_const_bitmap_t bitmap1, hwloc_const_bitmap_t bitmap2
  ) __attribute__((__pure__));

  int hwloc_bitmap_compare(
    hwloc_const_bitmap_t bitmap1, hwloc_const_bitmap_t bitmap2
  ) __attribute__((__pure__));
}

extern "C" {

  unsigned hwloc_get_api_version(void);

  typedef hwloc_bitmap_t hwloc_cpuset_t;

  typedef hwloc_const_bitmap_t hwloc_const_cpuset_t;

  typedef hwloc_bitmap_t hwloc_nodeset_t;

  typedef hwloc_const_bitmap_t hwloc_const_nodeset_t;

  typedef enum {

    HWLOC_OBJ_MACHINE,

    HWLOC_OBJ_PACKAGE,

    HWLOC_OBJ_CORE,

    HWLOC_OBJ_PU,

    HWLOC_OBJ_L1CACHE,
    HWLOC_OBJ_L2CACHE,
    HWLOC_OBJ_L3CACHE,
    HWLOC_OBJ_L4CACHE,
    HWLOC_OBJ_L5CACHE,

    HWLOC_OBJ_L1ICACHE,
    HWLOC_OBJ_L2ICACHE,
    HWLOC_OBJ_L3ICACHE,

    HWLOC_OBJ_GROUP,

    HWLOC_OBJ_NUMANODE,

    HWLOC_OBJ_BRIDGE,

    HWLOC_OBJ_PCI_DEVICE,

    HWLOC_OBJ_OS_DEVICE,

    HWLOC_OBJ_MISC,

    HWLOC_OBJ_MEMCACHE,

    HWLOC_OBJ_DIE,

    HWLOC_OBJ_TYPE_MAX
  } hwloc_obj_type_t;

  typedef enum hwloc_obj_cache_type_e {
    HWLOC_OBJ_CACHE_UNIFIED,
    HWLOC_OBJ_CACHE_DATA,
    HWLOC_OBJ_CACHE_INSTRUCTION
  } hwloc_obj_cache_type_t;

  typedef enum hwloc_obj_bridge_type_e {
    HWLOC_OBJ_BRIDGE_HOST,
    HWLOC_OBJ_BRIDGE_PCI
  } hwloc_obj_bridge_type_t;

  typedef enum hwloc_obj_osdev_type_e {
    HWLOC_OBJ_OSDEV_BLOCK,

    HWLOC_OBJ_OSDEV_GPU,

    HWLOC_OBJ_OSDEV_NETWORK,

    HWLOC_OBJ_OSDEV_OPENFABRICS,

    HWLOC_OBJ_OSDEV_DMA,

    HWLOC_OBJ_OSDEV_COPROC

  } hwloc_obj_osdev_type_t;

  int hwloc_compare_types(hwloc_obj_type_t type1, hwloc_obj_type_t type2)
    __attribute__((__const__));

  union hwloc_obj_attr_u;

  struct hwloc_obj {
    hwloc_obj_type_t type;
    char *subtype;

    unsigned os_index;

    char *name;

    hwloc_uint64_t total_memory;

    union hwloc_obj_attr_u *attr;

    int depth;

    unsigned logical_index;

    struct hwloc_obj *next_cousin;
    struct hwloc_obj *prev_cousin;

    struct hwloc_obj *parent;
    unsigned sibling_rank;
    struct hwloc_obj *next_sibling;
    struct hwloc_obj *prev_sibling;

    unsigned arity;

    struct hwloc_obj **children;
    struct hwloc_obj *first_child;
    struct hwloc_obj *last_child;

    int symmetric_subtree;

    unsigned memory_arity;

    struct hwloc_obj *memory_first_child;

    unsigned io_arity;

    struct hwloc_obj *io_first_child;

    unsigned misc_arity;

    struct hwloc_obj *misc_first_child;

    hwloc_cpuset_t cpuset;

    hwloc_cpuset_t complete_cpuset;

    hwloc_nodeset_t nodeset;

    hwloc_nodeset_t complete_nodeset;

    struct hwloc_info_s *infos;
    unsigned infos_count;

    void *userdata;

    hwloc_uint64_t gp_index;
  };

  typedef struct hwloc_obj *hwloc_obj_t;

  union hwloc_obj_attr_u {
    struct hwloc_numanode_attr_s {
      hwloc_uint64_t local_memory;
      unsigned page_types_len;

      struct hwloc_memory_page_type_s {
	hwloc_uint64_t size;
	hwloc_uint64_t count;
      } *page_types;
    } numanode;

    struct hwloc_cache_attr_s {
      hwloc_uint64_t size;
      unsigned depth;
      unsigned linesize;
      int associativity;

      hwloc_obj_cache_type_t type;
    } cache;

    struct hwloc_group_attr_s {
      unsigned depth;

      unsigned kind;
      unsigned subkind;
      unsigned char dont_merge;
    } group;

    struct hwloc_pcidev_attr_s {
      unsigned short domain;

      unsigned char bus;
      unsigned char dev;
      unsigned char func;
      unsigned short class_id;
      unsigned short vendor_id;
      unsigned short device_id;
      unsigned short subvendor_id;
      unsigned short subdevice_id;
      unsigned char revision;
      float linkspeed;

    } pcidev;

    struct hwloc_bridge_attr_s {
      union {
	struct hwloc_pcidev_attr_s pci;
      } upstream;
      hwloc_obj_bridge_type_t upstream_type;
      union {
	struct {
	  unsigned short domain;

	  unsigned char secondary_bus;
	  unsigned char subordinate_bus;
	} pci;
      } downstream;
      hwloc_obj_bridge_type_t downstream_type;
      unsigned depth;
    } bridge;

    struct hwloc_osdev_attr_s {
      hwloc_obj_osdev_type_t type;
    } osdev;
  };

  struct hwloc_info_s {
    char *name;
    char *value;
  };

  struct hwloc_topology;

  typedef struct hwloc_topology *hwloc_topology_t;

  int hwloc_topology_init(hwloc_topology_t *topologyp);

  int hwloc_topology_load(hwloc_topology_t topology);

  void hwloc_topology_destroy(hwloc_topology_t topology);

  int hwloc_topology_dup(
    hwloc_topology_t *newtopology, hwloc_topology_t oldtopology
  );

  int hwloc_topology_abi_check(hwloc_topology_t topology);

  void hwloc_topology_check(hwloc_topology_t topology);

  int hwloc_topology_get_depth(hwloc_topology_t __restrict topology)
    __attribute__((__pure__));

  int hwloc_get_type_depth(hwloc_topology_t topology, hwloc_obj_type_t type);

  enum hwloc_get_type_depth_e {
    HWLOC_TYPE_DEPTH_UNKNOWN = -1,
    HWLOC_TYPE_DEPTH_MULTIPLE = -2,
    HWLOC_TYPE_DEPTH_NUMANODE = -3,
    HWLOC_TYPE_DEPTH_BRIDGE = -4,
    HWLOC_TYPE_DEPTH_PCI_DEVICE = -5,
    HWLOC_TYPE_DEPTH_OS_DEVICE = -6,
    HWLOC_TYPE_DEPTH_MISC = -7,
    HWLOC_TYPE_DEPTH_MEMCACHE = -8
  };

  int hwloc_get_memory_parents_depth(hwloc_topology_t topology);

  inline static int hwloc_get_type_or_below_depth(
    hwloc_topology_t topology, hwloc_obj_type_t type
  ) __attribute__((__pure__));

  inline static int hwloc_get_type_or_above_depth(
    hwloc_topology_t topology, hwloc_obj_type_t type
  ) __attribute__((__pure__));

  hwloc_obj_type_t hwloc_get_depth_type(hwloc_topology_t topology, int depth)
    __attribute__((__pure__));

  unsigned hwloc_get_nbobjs_by_depth(hwloc_topology_t topology, int depth)
    __attribute__((__pure__));

  inline static int
  hwloc_get_nbobjs_by_type(hwloc_topology_t topology, hwloc_obj_type_t type)
    __attribute__((__pure__));

  inline static hwloc_obj_t hwloc_get_root_obj(hwloc_topology_t topology)
    __attribute__((__pure__));

  hwloc_obj_t
  hwloc_get_obj_by_depth(hwloc_topology_t topology, int depth, unsigned idx)
    __attribute__((__pure__));

  inline static hwloc_obj_t hwloc_get_obj_by_type(
    hwloc_topology_t topology, hwloc_obj_type_t type, unsigned idx
  ) __attribute__((__pure__));

  inline static hwloc_obj_t hwloc_get_next_obj_by_depth(
    hwloc_topology_t topology, int depth, hwloc_obj_t prev
  );

  inline static hwloc_obj_t hwloc_get_next_obj_by_type(
    hwloc_topology_t topology, hwloc_obj_type_t type, hwloc_obj_t prev
  );

  const char *hwloc_obj_type_string(hwloc_obj_type_t type)
    __attribute__((__const__));

  int hwloc_obj_type_snprintf(
    char *__restrict string, size_t size, hwloc_obj_t obj, int verbose
  );

  int hwloc_obj_attr_snprintf(
    char *__restrict string, size_t size, hwloc_obj_t obj,
    const char *__restrict separator, int verbose
  );

  int hwloc_type_sscanf(
    const char *string, hwloc_obj_type_t *typep, union hwloc_obj_attr_u *attrp,
    size_t attrsize
  );

  int hwloc_type_sscanf_as_depth(
    const char *string, hwloc_obj_type_t *typep, hwloc_topology_t topology,
    int *depthp
  );

  inline static const char *
  hwloc_obj_get_info_by_name(hwloc_obj_t obj, const char *name)
    __attribute__((__pure__));

  int hwloc_obj_add_info(hwloc_obj_t obj, const char *name, const char *value);

  int hwloc_obj_set_subtype(
    hwloc_topology_t topology, hwloc_obj_t obj, const char *subtype
  );

  typedef enum {

    HWLOC_CPUBIND_PROCESS = (1 << 0),

    HWLOC_CPUBIND_THREAD = (1 << 1),

    HWLOC_CPUBIND_STRICT = (1 << 2),

    HWLOC_CPUBIND_NOMEMBIND = (1 << 3)
  } hwloc_cpubind_flags_t;

  int hwloc_set_cpubind(
    hwloc_topology_t topology, hwloc_const_cpuset_t set, int flags
  );

  int hwloc_get_cpubind(
    hwloc_topology_t topology, hwloc_cpuset_t set, int flags
  );

  int hwloc_set_proc_cpubind(
    hwloc_topology_t topology, pid_t pid, hwloc_const_cpuset_t set, int flags
  );

  int hwloc_get_proc_cpubind(
    hwloc_topology_t topology, pid_t pid, hwloc_cpuset_t set, int flags
  );

  int hwloc_set_thread_cpubind(
    hwloc_topology_t topology, pthread_t thread, hwloc_const_cpuset_t set,
    int flags
  );

  int hwloc_get_thread_cpubind(
    hwloc_topology_t topology, pthread_t thread, hwloc_cpuset_t set, int flags
  );

  int hwloc_get_last_cpu_location(
    hwloc_topology_t topology, hwloc_cpuset_t set, int flags
  );

  int hwloc_get_proc_last_cpu_location(
    hwloc_topology_t topology, pid_t pid, hwloc_cpuset_t set, int flags
  );

  typedef enum {

    HWLOC_MEMBIND_DEFAULT = 0,

    HWLOC_MEMBIND_FIRSTTOUCH = 1,

    HWLOC_MEMBIND_BIND = 2,

    HWLOC_MEMBIND_INTERLEAVE = 3,

    HWLOC_MEMBIND_WEIGHTED_INTERLEAVE = 5,

    HWLOC_MEMBIND_NEXTTOUCH = 4,

    HWLOC_MEMBIND_MIXED = -1
  } hwloc_membind_policy_t;

  typedef enum {

    HWLOC_MEMBIND_PROCESS = (1 << 0),

    HWLOC_MEMBIND_THREAD = (1 << 1),

    HWLOC_MEMBIND_STRICT = (1 << 2),

    HWLOC_MEMBIND_MIGRATE = (1 << 3),

    HWLOC_MEMBIND_NOCPUBIND = (1 << 4),

    HWLOC_MEMBIND_BYNODESET = (1 << 5)
  } hwloc_membind_flags_t;

  int hwloc_set_membind(
    hwloc_topology_t topology, hwloc_const_bitmap_t set,
    hwloc_membind_policy_t policy, int flags
  );

  int hwloc_get_membind(
    hwloc_topology_t topology, hwloc_bitmap_t set,
    hwloc_membind_policy_t *policy, int flags
  );

  int hwloc_set_proc_membind(
    hwloc_topology_t topology, pid_t pid, hwloc_const_bitmap_t set,
    hwloc_membind_policy_t policy, int flags
  );

  int hwloc_get_proc_membind(
    hwloc_topology_t topology, pid_t pid, hwloc_bitmap_t set,
    hwloc_membind_policy_t *policy, int flags
  );

  int hwloc_set_area_membind(
    hwloc_topology_t topology, const void *addr, size_t len,
    hwloc_const_bitmap_t set, hwloc_membind_policy_t policy, int flags
  );

  int hwloc_get_area_membind(
    hwloc_topology_t topology, const void *addr, size_t len, hwloc_bitmap_t set,
    hwloc_membind_policy_t *policy, int flags
  );

  int hwloc_get_area_memlocation(
    hwloc_topology_t topology, const void *addr, size_t len, hwloc_bitmap_t set,
    int flags
  );

  void *hwloc_alloc(hwloc_topology_t topology, size_t len);

  void *hwloc_alloc_membind(
    hwloc_topology_t topology, size_t len, hwloc_const_bitmap_t set,
    hwloc_membind_policy_t policy, int flags
  ) __attribute__((__malloc__));

  inline static void *hwloc_alloc_membind_policy(
    hwloc_topology_t topology, size_t len, hwloc_const_bitmap_t set,
    hwloc_membind_policy_t policy, int flags
  ) __attribute__((__malloc__));

  int hwloc_free(hwloc_topology_t topology, void *addr, size_t len);

  int hwloc_topology_set_pid(hwloc_topology_t __restrict topology, pid_t pid);

  int hwloc_topology_set_synthetic(
    hwloc_topology_t __restrict topology, const char *__restrict description
  );

  int hwloc_topology_set_xml(
    hwloc_topology_t __restrict topology, const char *__restrict xmlpath
  );

  int hwloc_topology_set_xmlbuffer(
    hwloc_topology_t __restrict topology, const char *__restrict buffer,
    int size
  );

  enum hwloc_topology_components_flag_e {

    HWLOC_TOPOLOGY_COMPONENTS_FLAG_BLACKLIST = (1UL << 0)
  };

  int hwloc_topology_set_components(
    hwloc_topology_t __restrict topology, unsigned long flags,
    const char *__restrict name
  );

  enum hwloc_topology_flags_e {

    HWLOC_TOPOLOGY_FLAG_INCLUDE_DISALLOWED = (1UL << 0),

    HWLOC_TOPOLOGY_FLAG_IS_THISSYSTEM = (1UL << 1),

    HWLOC_TOPOLOGY_FLAG_THISSYSTEM_ALLOWED_RESOURCES = (1UL << 2),

    HWLOC_TOPOLOGY_FLAG_IMPORT_SUPPORT = (1UL << 3),

    HWLOC_TOPOLOGY_FLAG_RESTRICT_TO_CPUBINDING = (1UL << 4),

    HWLOC_TOPOLOGY_FLAG_RESTRICT_TO_MEMBINDING = (1UL << 5),

    HWLOC_TOPOLOGY_FLAG_DONT_CHANGE_BINDING = (1UL << 6),

    HWLOC_TOPOLOGY_FLAG_NO_DISTANCES = (1UL << 7),

    HWLOC_TOPOLOGY_FLAG_NO_MEMATTRS = (1UL << 8),

    HWLOC_TOPOLOGY_FLAG_NO_CPUKINDS = (1UL << 9)
  };

  int hwloc_topology_set_flags(hwloc_topology_t topology, unsigned long flags);

  unsigned long hwloc_topology_get_flags(hwloc_topology_t topology);

  int hwloc_topology_is_thissystem(hwloc_topology_t __restrict topology)
    __attribute__((__pure__));

  struct hwloc_topology_discovery_support {
    unsigned char pu;

    unsigned char numa;

    unsigned char numa_memory;

    unsigned char disallowed_pu;

    unsigned char disallowed_numa;

    unsigned char cpukind_efficiency;
  };

  struct hwloc_topology_cpubind_support {
    unsigned char set_thisproc_cpubind;

    unsigned char get_thisproc_cpubind;

    unsigned char set_proc_cpubind;

    unsigned char get_proc_cpubind;

    unsigned char set_thisthread_cpubind;

    unsigned char get_thisthread_cpubind;

    unsigned char set_thread_cpubind;

    unsigned char get_thread_cpubind;

    unsigned char get_thisproc_last_cpu_location;

    unsigned char get_proc_last_cpu_location;

    unsigned char get_thisthread_last_cpu_location;
  };

  struct hwloc_topology_membind_support {
    unsigned char set_thisproc_membind;

    unsigned char get_thisproc_membind;

    unsigned char set_proc_membind;

    unsigned char get_proc_membind;

    unsigned char set_thisthread_membind;

    unsigned char get_thisthread_membind;

    unsigned char set_area_membind;

    unsigned char get_area_membind;

    unsigned char alloc_membind;

    unsigned char firsttouch_membind;

    unsigned char bind_membind;

    unsigned char interleave_membind;

    unsigned char nexttouch_membind;

    unsigned char migrate_membind;

    unsigned char get_area_memlocation;

    unsigned char weighted_interleave_membind;
  };

  struct hwloc_topology_misc_support {
    unsigned char imported_support;
  };

  struct hwloc_topology_support {
    struct hwloc_topology_discovery_support *discovery;
    struct hwloc_topology_cpubind_support *cpubind;
    struct hwloc_topology_membind_support *membind;
    struct hwloc_topology_misc_support *misc;
  };

  const struct hwloc_topology_support *
    hwloc_topology_get_support(hwloc_topology_t __restrict topology);

  enum hwloc_type_filter_e {

    HWLOC_TYPE_FILTER_KEEP_ALL = 0,

    HWLOC_TYPE_FILTER_KEEP_NONE = 1,

    HWLOC_TYPE_FILTER_KEEP_STRUCTURE = 2,

    HWLOC_TYPE_FILTER_KEEP_IMPORTANT = 3
  };

  int hwloc_topology_set_type_filter(
    hwloc_topology_t topology, hwloc_obj_type_t type,
    enum hwloc_type_filter_e filter
  );

  int hwloc_topology_get_type_filter(
    hwloc_topology_t topology, hwloc_obj_type_t type,
    enum hwloc_type_filter_e *filter
  );

  int hwloc_topology_set_all_types_filter(
    hwloc_topology_t topology, enum hwloc_type_filter_e filter
  );

  int hwloc_topology_set_cache_types_filter(
    hwloc_topology_t topology, enum hwloc_type_filter_e filter
  );

  int hwloc_topology_set_icache_types_filter(
    hwloc_topology_t topology, enum hwloc_type_filter_e filter
  );

  int hwloc_topology_set_io_types_filter(
    hwloc_topology_t topology, enum hwloc_type_filter_e filter
  );

  void
  hwloc_topology_set_userdata(hwloc_topology_t topology, const void *userdata);

  void *hwloc_topology_get_userdata(hwloc_topology_t topology);

  enum hwloc_restrict_flags_e {

    HWLOC_RESTRICT_FLAG_REMOVE_CPULESS = (1UL << 0),

    HWLOC_RESTRICT_FLAG_BYNODESET = (1UL << 3),

    HWLOC_RESTRICT_FLAG_REMOVE_MEMLESS = (1UL << 4),

    HWLOC_RESTRICT_FLAG_ADAPT_MISC = (1UL << 1),

    HWLOC_RESTRICT_FLAG_ADAPT_IO = (1UL << 2)
  };

  int hwloc_topology_restrict(
    hwloc_topology_t __restrict topology, hwloc_const_bitmap_t set,
    unsigned long flags
  );

  enum hwloc_allow_flags_e {

    HWLOC_ALLOW_FLAG_ALL = (1UL << 0),

    HWLOC_ALLOW_FLAG_LOCAL_RESTRICTIONS = (1UL << 1),

    HWLOC_ALLOW_FLAG_CUSTOM = (1UL << 2)
  };

  int hwloc_topology_allow(
    hwloc_topology_t __restrict topology, hwloc_const_cpuset_t cpuset,
    hwloc_const_nodeset_t nodeset, unsigned long flags
  );

  hwloc_obj_t hwloc_topology_insert_misc_object(
    hwloc_topology_t topology, hwloc_obj_t parent, const char *name
  );

  hwloc_obj_t hwloc_topology_alloc_group_object(hwloc_topology_t topology);

  int hwloc_topology_free_group_object(
    hwloc_topology_t topology, hwloc_obj_t group
  );

  hwloc_obj_t hwloc_topology_insert_group_object(
    hwloc_topology_t topology, hwloc_obj_t group
  );

  int hwloc_obj_add_other_obj_sets(hwloc_obj_t dst, hwloc_obj_t src);

  int hwloc_topology_refresh(hwloc_topology_t topology);
}

extern "C" {

  int hwloc_obj_type_is_normal(hwloc_obj_type_t type);

  int hwloc_obj_type_is_io(hwloc_obj_type_t type);

  int hwloc_obj_type_is_memory(hwloc_obj_type_t type);

  int hwloc_obj_type_is_cache(hwloc_obj_type_t type);

  int hwloc_obj_type_is_dcache(hwloc_obj_type_t type);

  int hwloc_obj_type_is_icache(hwloc_obj_type_t type);

  inline static hwloc_obj_t hwloc_get_first_largest_obj_inside_cpuset(
    hwloc_topology_t topology, hwloc_const_cpuset_t set
  ) {
    hwloc_obj_t obj = hwloc_get_root_obj(topology);
    if (!hwloc_bitmap_intersects(obj->cpuset, set)) return __null;
    while (!hwloc_bitmap_isincluded(obj->cpuset, set)) {
      hwloc_obj_t child = obj->first_child;
      while (child) {
	if (hwloc_bitmap_intersects(child->cpuset, set)) break;
	child = child->next_sibling;
      }
      if (!child) return obj;

      obj = child;
    }

    return obj;
  }

  int hwloc_get_largest_objs_inside_cpuset(
    hwloc_topology_t topology, hwloc_const_cpuset_t set,
    hwloc_obj_t *__restrict objs, int max
  );

  inline static hwloc_obj_t hwloc_get_next_obj_inside_cpuset_by_depth(
    hwloc_topology_t topology, hwloc_const_cpuset_t set, int depth,
    hwloc_obj_t prev
  ) {
    hwloc_obj_t next = hwloc_get_next_obj_by_depth(topology, depth, prev);
    if (!next) return __null;
    while (next &&
	   (hwloc_bitmap_iszero(next->cpuset) ||
	    !hwloc_bitmap_isincluded(next->cpuset, set)))
      next = next->next_cousin;
    return next;
  }

  inline static hwloc_obj_t hwloc_get_next_obj_inside_cpuset_by_type(
    hwloc_topology_t topology, hwloc_const_cpuset_t set, hwloc_obj_type_t type,
    hwloc_obj_t prev
  ) {
    int depth = hwloc_get_type_depth(topology, type);
    if (depth == HWLOC_TYPE_DEPTH_UNKNOWN || depth == HWLOC_TYPE_DEPTH_MULTIPLE)
      return __null;
    return hwloc_get_next_obj_inside_cpuset_by_depth(
      topology, set, depth, prev
    );
  }

  inline static hwloc_obj_t hwloc_get_obj_inside_cpuset_by_depth(
    hwloc_topology_t topology, hwloc_const_cpuset_t set, int depth, unsigned idx
  ) __attribute__((__pure__));
  inline static hwloc_obj_t hwloc_get_obj_inside_cpuset_by_depth(
    hwloc_topology_t topology, hwloc_const_cpuset_t set, int depth, unsigned idx
  ) {
    hwloc_obj_t obj = hwloc_get_obj_by_depth(topology, depth, 0);
    unsigned count = 0;
    if (!obj) return __null;
    while (obj) {
      if (!hwloc_bitmap_iszero(obj->cpuset) &&
	  hwloc_bitmap_isincluded(obj->cpuset, set)) {
	if (count == idx) return obj;
	count++;
      }
      obj = obj->next_cousin;
    }
    return __null;
  }

  inline static hwloc_obj_t hwloc_get_obj_inside_cpuset_by_type(
    hwloc_topology_t topology, hwloc_const_cpuset_t set, hwloc_obj_type_t type,
    unsigned idx
  ) __attribute__((__pure__));
  inline static hwloc_obj_t hwloc_get_obj_inside_cpuset_by_type(
    hwloc_topology_t topology, hwloc_const_cpuset_t set, hwloc_obj_type_t type,
    unsigned idx
  ) {
    int depth = hwloc_get_type_depth(topology, type);
    if (depth == HWLOC_TYPE_DEPTH_UNKNOWN || depth == HWLOC_TYPE_DEPTH_MULTIPLE)
      return __null;
    return hwloc_get_obj_inside_cpuset_by_depth(topology, set, depth, idx);
  }

  inline static unsigned hwloc_get_nbobjs_inside_cpuset_by_depth(
    hwloc_topology_t topology, hwloc_const_cpuset_t set, int depth
  ) __attribute__((__pure__));
  inline static unsigned hwloc_get_nbobjs_inside_cpuset_by_depth(
    hwloc_topology_t topology, hwloc_const_cpuset_t set, int depth
  ) {
    hwloc_obj_t obj = hwloc_get_obj_by_depth(topology, depth, 0);
    unsigned count = 0;
    if (!obj) return 0;
    while (obj) {
      if (!hwloc_bitmap_iszero(obj->cpuset) &&
	  hwloc_bitmap_isincluded(obj->cpuset, set))
	count++;
      obj = obj->next_cousin;
    }
    return count;
  }

  inline static int hwloc_get_nbobjs_inside_cpuset_by_type(
    hwloc_topology_t topology, hwloc_const_cpuset_t set, hwloc_obj_type_t type
  ) __attribute__((__pure__));
  inline static int hwloc_get_nbobjs_inside_cpuset_by_type(
    hwloc_topology_t topology, hwloc_const_cpuset_t set, hwloc_obj_type_t type
  ) {
    int depth = hwloc_get_type_depth(topology, type);
    if (depth == HWLOC_TYPE_DEPTH_UNKNOWN) return 0;
    if (depth == HWLOC_TYPE_DEPTH_MULTIPLE) return -1;
    return (int)hwloc_get_nbobjs_inside_cpuset_by_depth(topology, set, depth);
  }

  inline static int hwloc_get_obj_index_inside_cpuset(
    hwloc_topology_t topology __attribute__((__unused__)),
    hwloc_const_cpuset_t set, hwloc_obj_t obj
  ) __attribute__((__pure__));
  inline static int hwloc_get_obj_index_inside_cpuset(
    hwloc_topology_t topology __attribute__((__unused__)),
    hwloc_const_cpuset_t set, hwloc_obj_t obj
  ) {
    int idx = 0;
    if (!hwloc_bitmap_isincluded(obj->cpuset, set)) return -1;

    while ((obj = obj->prev_cousin) != __null)
      if (!hwloc_bitmap_iszero(obj->cpuset) &&
	  hwloc_bitmap_isincluded(obj->cpuset, set))
	idx++;
    return idx;
  }

  inline static hwloc_obj_t hwloc_get_child_covering_cpuset(
    hwloc_topology_t topology __attribute__((__unused__)),
    hwloc_const_cpuset_t set, hwloc_obj_t parent
  ) __attribute__((__pure__));
  inline static hwloc_obj_t hwloc_get_child_covering_cpuset(
    hwloc_topology_t topology __attribute__((__unused__)),
    hwloc_const_cpuset_t set, hwloc_obj_t parent
  ) {
    hwloc_obj_t child;
    if (hwloc_bitmap_iszero(set)) return __null;
    child = parent->first_child;
    while (child) {
      if (child->cpuset && hwloc_bitmap_isincluded(set, child->cpuset))
	return child;
      child = child->next_sibling;
    }
    return __null;
  }

  inline static hwloc_obj_t hwloc_get_obj_covering_cpuset(
    hwloc_topology_t topology, hwloc_const_cpuset_t set
  ) __attribute__((__pure__));
  inline static hwloc_obj_t hwloc_get_obj_covering_cpuset(
    hwloc_topology_t topology, hwloc_const_cpuset_t set
  ) {
    struct hwloc_obj *current = hwloc_get_root_obj(topology);
    if (hwloc_bitmap_iszero(set) ||
	!hwloc_bitmap_isincluded(set, current->cpuset))
      return __null;
    while (1) {
      hwloc_obj_t child =
	hwloc_get_child_covering_cpuset(topology, set, current);
      if (!child) return current;
      current = child;
    }
  }

  inline static hwloc_obj_t hwloc_get_next_obj_covering_cpuset_by_depth(
    hwloc_topology_t topology, hwloc_const_cpuset_t set, int depth,
    hwloc_obj_t prev
  ) {
    hwloc_obj_t next = hwloc_get_next_obj_by_depth(topology, depth, prev);
    if (!next) return __null;
    while (next && !hwloc_bitmap_intersects(set, next->cpuset))
      next = next->next_cousin;
    return next;
  }

  inline static hwloc_obj_t hwloc_get_next_obj_covering_cpuset_by_type(
    hwloc_topology_t topology, hwloc_const_cpuset_t set, hwloc_obj_type_t type,
    hwloc_obj_t prev
  ) {
    int depth = hwloc_get_type_depth(topology, type);
    if (depth == HWLOC_TYPE_DEPTH_UNKNOWN || depth == HWLOC_TYPE_DEPTH_MULTIPLE)
      return __null;
    return hwloc_get_next_obj_covering_cpuset_by_depth(
      topology, set, depth, prev
    );
  }

  inline static hwloc_obj_t hwloc_get_ancestor_obj_by_depth(
    hwloc_topology_t topology __attribute__((__unused__)), int depth,
    hwloc_obj_t obj
  ) __attribute__((__pure__));
  inline static hwloc_obj_t hwloc_get_ancestor_obj_by_depth(
    hwloc_topology_t topology __attribute__((__unused__)), int depth,
    hwloc_obj_t obj
  ) {
    hwloc_obj_t ancestor = obj;
    if (obj->depth < depth) return __null;
    while (ancestor && ancestor->depth > depth) ancestor = ancestor->parent;
    return ancestor;
  }

  inline static hwloc_obj_t hwloc_get_ancestor_obj_by_type(
    hwloc_topology_t topology __attribute__((__unused__)),
    hwloc_obj_type_t type, hwloc_obj_t obj
  ) __attribute__((__pure__));
  inline static hwloc_obj_t hwloc_get_ancestor_obj_by_type(
    hwloc_topology_t topology __attribute__((__unused__)),
    hwloc_obj_type_t type, hwloc_obj_t obj
  ) {
    hwloc_obj_t ancestor = obj->parent;
    while (ancestor && ancestor->type != type) ancestor = ancestor->parent;
    return ancestor;
  }

  inline static hwloc_obj_t hwloc_get_common_ancestor_obj(
    hwloc_topology_t topology __attribute__((__unused__)), hwloc_obj_t obj1,
    hwloc_obj_t obj2
  ) __attribute__((__pure__));
  inline static hwloc_obj_t hwloc_get_common_ancestor_obj(
    hwloc_topology_t topology __attribute__((__unused__)), hwloc_obj_t obj1,
    hwloc_obj_t obj2
  ) {
    while (obj1 != obj2) {
      while (obj1->depth > obj2->depth) obj1 = obj1->parent;
      while (obj2->depth > obj1->depth) obj2 = obj2->parent;
      if (obj1 != obj2 && obj1->depth == obj2->depth) {
	obj1 = obj1->parent;
	obj2 = obj2->parent;
      }
    }
    return obj1;
  }

  inline static int hwloc_obj_is_in_subtree(
    hwloc_topology_t topology __attribute__((__unused__)), hwloc_obj_t obj,
    hwloc_obj_t subtree_root
  ) __attribute__((__pure__));
  inline static int hwloc_obj_is_in_subtree(
    hwloc_topology_t topology __attribute__((__unused__)), hwloc_obj_t obj,
    hwloc_obj_t subtree_root
  ) {
    return obj->cpuset && subtree_root->cpuset &&
      hwloc_bitmap_isincluded(obj->cpuset, subtree_root->cpuset);
  }

  inline static hwloc_obj_t hwloc_get_next_child(
    hwloc_topology_t topology __attribute__((__unused__)), hwloc_obj_t parent,
    hwloc_obj_t prev
  ) {
    hwloc_obj_t obj;
    int state = 0;
    if (prev) {
      if (prev->type == HWLOC_OBJ_MISC)
	state = 3;
      else if (hwloc_obj_type_is_io(prev->type))
	state = 2;
      else if (hwloc_obj_type_is_memory(prev->type))
	state = 1;
      obj = prev->next_sibling;
    } else {
      obj = parent->first_child;
    }
    if (!obj && state == 0) {
      obj = parent->memory_first_child;
      state = 1;
    }
    if (!obj && state == 1) {
      obj = parent->io_first_child;
      state = 2;
    }
    if (!obj && state == 2) {
      obj = parent->misc_first_child;
      state = 3;
    }
    return obj;
  }

  inline static int hwloc_get_cache_type_depth(
    hwloc_topology_t topology, unsigned cachelevel,
    hwloc_obj_cache_type_t cachetype
  ) {
    int depth;
    int found = HWLOC_TYPE_DEPTH_UNKNOWN;
    for (depth = 0;; depth++) {
      hwloc_obj_t obj = hwloc_get_obj_by_depth(topology, depth, 0);
      if (!obj) break;
      if (!hwloc_obj_type_is_dcache(obj->type) ||
	  obj->attr->cache.depth != cachelevel)

	continue;
      if (cachetype == (hwloc_obj_cache_type_t)-1) {
	if (found != HWLOC_TYPE_DEPTH_UNKNOWN) {
	  return HWLOC_TYPE_DEPTH_MULTIPLE;
	}

	found = depth;
	continue;
      }
      if (obj->attr->cache.type == cachetype ||
	  obj->attr->cache.type == HWLOC_OBJ_CACHE_UNIFIED)

	return depth;
    }

    return found;
  }

  inline static hwloc_obj_t hwloc_get_cache_covering_cpuset(
    hwloc_topology_t topology, hwloc_const_cpuset_t set
  ) __attribute__((__pure__));
  inline static hwloc_obj_t hwloc_get_cache_covering_cpuset(
    hwloc_topology_t topology, hwloc_const_cpuset_t set
  ) {
    hwloc_obj_t current = hwloc_get_obj_covering_cpuset(topology, set);
    while (current) {
      if (hwloc_obj_type_is_dcache(current->type)) return current;
      current = current->parent;
    }
    return __null;
  }

  inline static hwloc_obj_t hwloc_get_shared_cache_covering_obj(
    hwloc_topology_t topology __attribute__((__unused__)), hwloc_obj_t obj
  ) __attribute__((__pure__));
  inline static hwloc_obj_t hwloc_get_shared_cache_covering_obj(
    hwloc_topology_t topology __attribute__((__unused__)), hwloc_obj_t obj
  ) {
    hwloc_obj_t current = obj->parent;
    if (!obj->cpuset) return __null;
    while (current) {
      if (!hwloc_bitmap_isequal(current->cpuset, obj->cpuset) &&
	  hwloc_obj_type_is_dcache(current->type))
	return current;
      current = current->parent;
    }
    return __null;
  }

  int hwloc_bitmap_singlify_per_core(
    hwloc_topology_t topology, hwloc_bitmap_t cpuset, unsigned which
  );

  inline static hwloc_obj_t
  hwloc_get_pu_obj_by_os_index(hwloc_topology_t topology, unsigned os_index)
    __attribute__((__pure__));
  inline static hwloc_obj_t
  hwloc_get_pu_obj_by_os_index(hwloc_topology_t topology, unsigned os_index) {
    hwloc_obj_t obj = __null;
    while ((obj = hwloc_get_next_obj_by_type(topology, HWLOC_OBJ_PU, obj)) !=
	   __null)
      if (obj->os_index == os_index) return obj;
    return __null;
  }

  inline static hwloc_obj_t hwloc_get_numanode_obj_by_os_index(
    hwloc_topology_t topology, unsigned os_index
  ) __attribute__((__pure__));
  inline static hwloc_obj_t hwloc_get_numanode_obj_by_os_index(
    hwloc_topology_t topology, unsigned os_index
  ) {
    hwloc_obj_t obj = __null;
    while ((obj = hwloc_get_next_obj_by_type(topology, HWLOC_OBJ_NUMANODE, obj)
	   ) != __null)
      if (obj->os_index == os_index) return obj;
    return __null;
  }

  unsigned hwloc_get_closest_objs(
    hwloc_topology_t topology, hwloc_obj_t src, hwloc_obj_t *__restrict objs,
    unsigned max
  );

  inline static hwloc_obj_t hwloc_get_obj_below_by_type(
    hwloc_topology_t topology, hwloc_obj_type_t type1, unsigned idx1,
    hwloc_obj_type_t type2, unsigned idx2
  ) __attribute__((__pure__));
  inline static hwloc_obj_t hwloc_get_obj_below_by_type(
    hwloc_topology_t topology, hwloc_obj_type_t type1, unsigned idx1,
    hwloc_obj_type_t type2, unsigned idx2
  ) {
    hwloc_obj_t obj;
    obj = hwloc_get_obj_by_type(topology, type1, idx1);
    if (!obj) return __null;
    return hwloc_get_obj_inside_cpuset_by_type(
      topology, obj->cpuset, type2, idx2
    );
  }

  inline static hwloc_obj_t hwloc_get_obj_below_array_by_type(
    hwloc_topology_t topology, int nr, hwloc_obj_type_t *typev, unsigned *idxv
  ) __attribute__((__pure__));
  inline static hwloc_obj_t hwloc_get_obj_below_array_by_type(
    hwloc_topology_t topology, int nr, hwloc_obj_type_t *typev, unsigned *idxv
  ) {
    hwloc_obj_t obj = hwloc_get_root_obj(topology);
    int i;
    for (i = 0; i < nr; i++) {
      if (!obj) return __null;
      obj = hwloc_get_obj_inside_cpuset_by_type(
	topology, obj->cpuset, typev[i], idxv[i]
      );
    }
    return obj;
  }

  hwloc_obj_t hwloc_get_obj_with_same_locality(
    hwloc_topology_t topology, hwloc_obj_t src, hwloc_obj_type_t type,
    const char *subtype, const char *nameprefix, unsigned long flags
  );

  enum hwloc_distrib_flags_e {

    HWLOC_DISTRIB_FLAG_REVERSE = (1UL << 0)
  };

  inline static int hwloc_distrib(
    hwloc_topology_t topology, hwloc_obj_t *roots, unsigned n_roots,
    hwloc_cpuset_t *set, unsigned n, int until, unsigned long flags
  ) {
    unsigned i;
    unsigned tot_weight;
    unsigned given, givenweight;
    hwloc_cpuset_t *cpusetp = set;

    if (flags & ~HWLOC_DISTRIB_FLAG_REVERSE) {
      (*__errno_location()) = 22;
      return -1;
    }

    tot_weight = 0;
    for (i = 0; i < n_roots; i++)
      tot_weight += (unsigned)hwloc_bitmap_weight(roots[i]->cpuset);

    for (i = 0, given = 0, givenweight = 0; i < n_roots; i++) {
      unsigned chunk, weight;
      hwloc_obj_t root =
	roots[flags & HWLOC_DISTRIB_FLAG_REVERSE ? n_roots - 1 - i : i];
      hwloc_cpuset_t cpuset = root->cpuset;
      while (!hwloc_obj_type_is_normal(root->type)) root = root->parent;
      weight = (unsigned)hwloc_bitmap_weight(cpuset);
      if (!weight) continue;

      chunk = (((givenweight + weight) * n + tot_weight - 1) / tot_weight) -
	((givenweight * n + tot_weight - 1) / tot_weight);
      if (!root->arity || chunk <= 1 || root->depth >= until) {
	if (chunk) {
	  unsigned j;
	  for (j = 0; j < chunk; j++) cpusetp[j] = hwloc_bitmap_dup(cpuset);
	} else {
	  (static_cast<bool>(given) ?
	     void(0) :
	     __assert_fail(
	       "given", __builtin_FILE(), __builtin_LINE(),
	       __extension__ __PRETTY_FUNCTION__
	     ));
	  hwloc_bitmap_or(cpusetp[-1], cpusetp[-1], cpuset);
	}
      } else {
	hwloc_distrib(
	  topology, root->children, root->arity, cpusetp, chunk, until, flags
	);
      }
      cpusetp += chunk;
      given += chunk;
      givenweight += weight;
    }

    return 0;
  }

  hwloc_const_cpuset_t
  hwloc_topology_get_complete_cpuset(hwloc_topology_t topology)
    __attribute__((__pure__));

  hwloc_const_cpuset_t
  hwloc_topology_get_topology_cpuset(hwloc_topology_t topology)
    __attribute__((__pure__));

  hwloc_const_cpuset_t
  hwloc_topology_get_allowed_cpuset(hwloc_topology_t topology)
    __attribute__((__pure__));

  hwloc_const_nodeset_t
  hwloc_topology_get_complete_nodeset(hwloc_topology_t topology)
    __attribute__((__pure__));

  hwloc_const_nodeset_t
  hwloc_topology_get_topology_nodeset(hwloc_topology_t topology)
    __attribute__((__pure__));

  hwloc_const_nodeset_t
  hwloc_topology_get_allowed_nodeset(hwloc_topology_t topology)
    __attribute__((__pure__));

  inline static int hwloc_cpuset_to_nodeset(
    hwloc_topology_t topology, hwloc_const_cpuset_t _cpuset,
    hwloc_nodeset_t nodeset
  ) {
    int depth = hwloc_get_type_depth(topology, HWLOC_OBJ_NUMANODE);
    hwloc_obj_t obj = __null;
    (static_cast<bool>(depth != HWLOC_TYPE_DEPTH_UNKNOWN) ?
       void(0) :
       __assert_fail(
	 "depth != HWLOC_TYPE_DEPTH_UNKNOWN", __builtin_FILE(),
	 __builtin_LINE(), __extension__ __PRETTY_FUNCTION__
       ));
    hwloc_bitmap_zero(nodeset);
    while ((obj = hwloc_get_next_obj_covering_cpuset_by_depth(
	      topology, _cpuset, depth, obj
	    )) != __null)
      if (hwloc_bitmap_set(nodeset, obj->os_index) < 0) return -1;
    return 0;
  }

  inline static int hwloc_cpuset_from_nodeset(
    hwloc_topology_t topology, hwloc_cpuset_t _cpuset,
    hwloc_const_nodeset_t nodeset
  ) {
    int depth = hwloc_get_type_depth(topology, HWLOC_OBJ_NUMANODE);
    hwloc_obj_t obj = __null;
    (static_cast<bool>(depth != HWLOC_TYPE_DEPTH_UNKNOWN) ?
       void(0) :
       __assert_fail(
	 "depth != HWLOC_TYPE_DEPTH_UNKNOWN", __builtin_FILE(),
	 __builtin_LINE(), __extension__ __PRETTY_FUNCTION__
       ));
    hwloc_bitmap_zero(_cpuset);
    while ((obj = hwloc_get_next_obj_by_depth(topology, depth, obj)) != __null
    ) {
      if (hwloc_bitmap_isset(nodeset, obj->os_index))

	if (hwloc_bitmap_or(_cpuset, _cpuset, obj->cpuset) < 0) return -1;
    }
    return 0;
  }

  inline static hwloc_obj_t hwloc_get_non_io_ancestor_obj(
    hwloc_topology_t topology __attribute__((__unused__)), hwloc_obj_t ioobj
  ) {
    hwloc_obj_t obj = ioobj;
    while (obj && !obj->cpuset) { obj = obj->parent; }
    return obj;
  }

  inline static hwloc_obj_t
  hwloc_get_next_pcidev(hwloc_topology_t topology, hwloc_obj_t prev) {
    return hwloc_get_next_obj_by_type(topology, HWLOC_OBJ_PCI_DEVICE, prev);
  }

  inline static hwloc_obj_t hwloc_get_pcidev_by_busid(
    hwloc_topology_t topology, unsigned domain, unsigned bus, unsigned dev,
    unsigned func
  ) {
    hwloc_obj_t obj = __null;
    while ((obj = hwloc_get_next_pcidev(topology, obj)) != __null) {
      if (obj->attr->pcidev.domain == domain && obj->attr->pcidev.bus == bus &&
	  obj->attr->pcidev.dev == dev && obj->attr->pcidev.func == func)
	return obj;
    }
    return __null;
  }

  inline static hwloc_obj_t hwloc_get_pcidev_by_busidstring(
    hwloc_topology_t topology, const char *busid
  ) {
    unsigned domain = 0;
    unsigned bus, dev, func;

    if (sscanf(busid, "%x:%x.%x", &bus, &dev, &func) != 3 &&
	sscanf(busid, "%x:%x:%x.%x", &domain, &bus, &dev, &func) != 4) {
      (*__errno_location()) = 22;
      return __null;
    }

    return hwloc_get_pcidev_by_busid(topology, domain, bus, dev, func);
  }

  inline static hwloc_obj_t
  hwloc_get_next_osdev(hwloc_topology_t topology, hwloc_obj_t prev) {
    return hwloc_get_next_obj_by_type(topology, HWLOC_OBJ_OS_DEVICE, prev);
  }

  inline static hwloc_obj_t
  hwloc_get_next_bridge(hwloc_topology_t topology, hwloc_obj_t prev) {
    return hwloc_get_next_obj_by_type(topology, HWLOC_OBJ_BRIDGE, prev);
  }

  inline static int hwloc_bridge_covers_pcibus(
    hwloc_obj_t bridge, unsigned domain, unsigned bus
  ) {
    return bridge->type == HWLOC_OBJ_BRIDGE &&
      bridge->attr->bridge.downstream_type == HWLOC_OBJ_BRIDGE_PCI &&
      bridge->attr->bridge.downstream.pci.domain == domain &&
      bridge->attr->bridge.downstream.pci.secondary_bus <= bus &&
      bridge->attr->bridge.downstream.pci.subordinate_bus >= bus;
  }
}

extern "C" {

  inline static int hwloc_get_type_or_below_depth(
    hwloc_topology_t topology, hwloc_obj_type_t type
  ) {
    int depth = hwloc_get_type_depth(topology, type);

    if (depth != HWLOC_TYPE_DEPTH_UNKNOWN) return depth;

    for (depth = hwloc_get_type_depth(topology, HWLOC_OBJ_PU);; depth--)
      if (hwloc_compare_types(hwloc_get_depth_type(topology, depth), type) < 0)
	return depth + 1;
  }

  inline static int hwloc_get_type_or_above_depth(
    hwloc_topology_t topology, hwloc_obj_type_t type
  ) {
    int depth = hwloc_get_type_depth(topology, type);

    if (depth != HWLOC_TYPE_DEPTH_UNKNOWN) return depth;

    for (depth = 0;; depth++)
      if (hwloc_compare_types(hwloc_get_depth_type(topology, depth), type) > 0)
	return depth - 1;
  }

  inline static int
  hwloc_get_nbobjs_by_type(hwloc_topology_t topology, hwloc_obj_type_t type) {
    int depth = hwloc_get_type_depth(topology, type);
    if (depth == HWLOC_TYPE_DEPTH_UNKNOWN) return 0;
    if (depth == HWLOC_TYPE_DEPTH_MULTIPLE) return -1;
    return (int)hwloc_get_nbobjs_by_depth(topology, depth);
  }

  inline static hwloc_obj_t hwloc_get_obj_by_type(
    hwloc_topology_t topology, hwloc_obj_type_t type, unsigned idx
  ) {
    int depth = hwloc_get_type_depth(topology, type);
    if (depth == HWLOC_TYPE_DEPTH_UNKNOWN) return __null;
    if (depth == HWLOC_TYPE_DEPTH_MULTIPLE) return __null;
    return hwloc_get_obj_by_depth(topology, depth, idx);
  }

  inline static hwloc_obj_t hwloc_get_next_obj_by_depth(
    hwloc_topology_t topology, int depth, hwloc_obj_t prev
  ) {
    if (!prev) return hwloc_get_obj_by_depth(topology, depth, 0);
    if (prev->depth != depth) return __null;
    return prev->next_cousin;
  }

  inline static hwloc_obj_t hwloc_get_next_obj_by_type(
    hwloc_topology_t topology, hwloc_obj_type_t type, hwloc_obj_t prev
  ) {
    int depth = hwloc_get_type_depth(topology, type);
    if (depth == HWLOC_TYPE_DEPTH_UNKNOWN || depth == HWLOC_TYPE_DEPTH_MULTIPLE)
      return __null;
    return hwloc_get_next_obj_by_depth(topology, depth, prev);
  }

  inline static hwloc_obj_t hwloc_get_root_obj(hwloc_topology_t topology) {
    return hwloc_get_obj_by_depth(topology, 0, 0);
  }

  inline static const char *
  hwloc_obj_get_info_by_name(hwloc_obj_t obj, const char *name) {
    unsigned i;
    for (i = 0; i < obj->infos_count; i++) {
      struct hwloc_info_s *info = &obj->infos[i];
      if (!strcmp(info->name, name)) return info->value;
    }
    return __null;
  }

  inline static void *hwloc_alloc_membind_policy(
    hwloc_topology_t topology, size_t len, hwloc_const_cpuset_t set,
    hwloc_membind_policy_t policy, int flags
  ) {
    void *p = hwloc_alloc_membind(topology, len, set, policy, flags);
    if (p) return p;

    if (hwloc_set_membind(topology, set, policy, flags) < 0) return __null;

    p = hwloc_alloc(topology, len);
    if (p && policy != HWLOC_MEMBIND_FIRSTTOUCH) memset(p, 0, len);
    return p;
  }
}

extern "C" {

  enum hwloc_memattr_id_e {

    HWLOC_MEMATTR_ID_CAPACITY = 0,

    HWLOC_MEMATTR_ID_LOCALITY = 1,

    HWLOC_MEMATTR_ID_BANDWIDTH = 2,

    HWLOC_MEMATTR_ID_READ_BANDWIDTH = 4,

    HWLOC_MEMATTR_ID_WRITE_BANDWIDTH = 5,

    HWLOC_MEMATTR_ID_LATENCY = 3,

    HWLOC_MEMATTR_ID_READ_LATENCY = 6,

    HWLOC_MEMATTR_ID_WRITE_LATENCY = 7,

    HWLOC_MEMATTR_ID_MAX
  };

  typedef unsigned hwloc_memattr_id_t;

  int hwloc_memattr_get_by_name(
    hwloc_topology_t topology, const char *name, hwloc_memattr_id_t *id
  );

  enum hwloc_location_type_e {

    HWLOC_LOCATION_TYPE_CPUSET = 1,

    HWLOC_LOCATION_TYPE_OBJECT = 0
  };

  struct hwloc_location {
    enum hwloc_location_type_e type;

    union hwloc_location_u {
      hwloc_cpuset_t cpuset;

      hwloc_obj_t object;
    } location;
  };

  enum hwloc_local_numanode_flag_e {

    HWLOC_LOCAL_NUMANODE_FLAG_LARGER_LOCALITY = (1UL << 0),

    HWLOC_LOCAL_NUMANODE_FLAG_SMALLER_LOCALITY = (1UL << 1),

    HWLOC_LOCAL_NUMANODE_FLAG_ALL = (1UL << 2)
  };

  int hwloc_get_local_numanode_objs(
    hwloc_topology_t topology, struct hwloc_location *location, unsigned *nr,
    hwloc_obj_t *nodes, unsigned long flags
  );

  int hwloc_memattr_get_value(
    hwloc_topology_t topology, hwloc_memattr_id_t attribute,
    hwloc_obj_t target_node, struct hwloc_location *initiator,
    unsigned long flags, hwloc_uint64_t *value
  );

  int hwloc_memattr_get_best_target(
    hwloc_topology_t topology, hwloc_memattr_id_t attribute,
    struct hwloc_location *initiator, unsigned long flags,
    hwloc_obj_t *best_target, hwloc_uint64_t *value
  );

  int hwloc_memattr_get_best_initiator(
    hwloc_topology_t topology, hwloc_memattr_id_t attribute, hwloc_obj_t target,
    unsigned long flags, struct hwloc_location *best_initiator,
    hwloc_uint64_t *value
  );

  int hwloc_memattr_get_name(
    hwloc_topology_t topology, hwloc_memattr_id_t attribute, const char **name
  );

  int hwloc_memattr_get_flags(
    hwloc_topology_t topology, hwloc_memattr_id_t attribute,
    unsigned long *flags
  );

  enum hwloc_memattr_flag_e {

    HWLOC_MEMATTR_FLAG_HIGHER_FIRST = (1UL << 0),

    HWLOC_MEMATTR_FLAG_LOWER_FIRST = (1UL << 1),

    HWLOC_MEMATTR_FLAG_NEED_INITIATOR = (1UL << 2)
  };

  int hwloc_memattr_register(
    hwloc_topology_t topology, const char *name, unsigned long flags,
    hwloc_memattr_id_t *id
  );

  int hwloc_memattr_set_value(
    hwloc_topology_t topology, hwloc_memattr_id_t attribute,
    hwloc_obj_t target_node, struct hwloc_location *initiator,
    unsigned long flags, hwloc_uint64_t value
  );

  int hwloc_memattr_get_targets(
    hwloc_topology_t topology, hwloc_memattr_id_t attribute,
    struct hwloc_location *initiator, unsigned long flags, unsigned *nr,
    hwloc_obj_t *targets, hwloc_uint64_t *values
  );

  int hwloc_memattr_get_initiators(
    hwloc_topology_t topology, hwloc_memattr_id_t attribute,
    hwloc_obj_t target_node, unsigned long flags, unsigned *nr,
    struct hwloc_location *initiators, hwloc_uint64_t *values
  );
}

extern "C" {

  int hwloc_cpukinds_get_nr(hwloc_topology_t topology, unsigned long flags);

  int hwloc_cpukinds_get_by_cpuset(
    hwloc_topology_t topology, hwloc_const_bitmap_t cpuset, unsigned long flags
  );

  int hwloc_cpukinds_get_info(
    hwloc_topology_t topology, unsigned kind_index, hwloc_bitmap_t cpuset,
    int *efficiency, unsigned *nr_infos, struct hwloc_info_s **infos,
    unsigned long flags
  );

  int hwloc_cpukinds_register(
    hwloc_topology_t topology, hwloc_bitmap_t cpuset, int forced_efficiency,
    unsigned nr_infos, struct hwloc_info_s *infos, unsigned long flags
  );
}

extern "C" {

  enum hwloc_topology_export_xml_flags_e {

    HWLOC_TOPOLOGY_EXPORT_XML_FLAG_V1 = (1UL << 0)
  };

  int hwloc_topology_export_xml(
    hwloc_topology_t topology, const char *xmlpath, unsigned long flags
  );

  int hwloc_topology_export_xmlbuffer(
    hwloc_topology_t topology, char **xmlbuffer, int *buflen,
    unsigned long flags
  );

  void hwloc_free_xmlbuffer(hwloc_topology_t topology, char *xmlbuffer);

  void hwloc_topology_set_userdata_export_callback(
    hwloc_topology_t topology,
    void (*export_cb)(
      void *reserved, hwloc_topology_t topology, hwloc_obj_t obj
    )
  );

  int hwloc_export_obj_userdata(
    void *reserved, hwloc_topology_t topology, hwloc_obj_t obj,
    const char *name, const void *buffer, size_t length
  );

  int hwloc_export_obj_userdata_base64(
    void *reserved, hwloc_topology_t topology, hwloc_obj_t obj,
    const char *name, const void *buffer, size_t length
  );

  void hwloc_topology_set_userdata_import_callback(
    hwloc_topology_t topology,
    void (*import_cb)(
      hwloc_topology_t topology, hwloc_obj_t obj, const char *name,
      const void *buffer, size_t length
    )
  );

  enum hwloc_topology_export_synthetic_flags_e {

    HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_NO_EXTENDED_TYPES = (1UL << 0),

    HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_NO_ATTRS = (1UL << 1),

    HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_V1 = (1UL << 2),

    HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_IGNORE_MEMORY = (1UL << 3)
  };

  int hwloc_topology_export_synthetic(
    hwloc_topology_t topology, char *buffer, size_t buflen, unsigned long flags
  );
}

extern "C" {

  struct hwloc_distances_s {
    unsigned nbobjs;
    hwloc_obj_t *objs;

    unsigned long kind;
    hwloc_uint64_t *values;
  };

  enum hwloc_distances_kind_e {

    HWLOC_DISTANCES_KIND_FROM_OS = (1UL << 0),

    HWLOC_DISTANCES_KIND_FROM_USER = (1UL << 1),

    HWLOC_DISTANCES_KIND_MEANS_LATENCY = (1UL << 2),

    HWLOC_DISTANCES_KIND_MEANS_BANDWIDTH = (1UL << 3),

    HWLOC_DISTANCES_KIND_HETEROGENEOUS_TYPES = (1UL << 4)
  };

  int hwloc_distances_get(
    hwloc_topology_t topology, unsigned *nr,
    struct hwloc_distances_s **distances, unsigned long kind,
    unsigned long flags
  );

  int hwloc_distances_get_by_depth(
    hwloc_topology_t topology, int depth, unsigned *nr,
    struct hwloc_distances_s **distances, unsigned long kind,
    unsigned long flags
  );

  int hwloc_distances_get_by_type(
    hwloc_topology_t topology, hwloc_obj_type_t type, unsigned *nr,
    struct hwloc_distances_s **distances, unsigned long kind,
    unsigned long flags
  );

  int hwloc_distances_get_by_name(
    hwloc_topology_t topology, const char *name, unsigned *nr,
    struct hwloc_distances_s **distances, unsigned long flags
  );

  const char *hwloc_distances_get_name(
    hwloc_topology_t topology, struct hwloc_distances_s *distances
  );

  void hwloc_distances_release(
    hwloc_topology_t topology, struct hwloc_distances_s *distances
  );

  enum hwloc_distances_transform_e {

    HWLOC_DISTANCES_TRANSFORM_REMOVE_NULL = 0,

    HWLOC_DISTANCES_TRANSFORM_LINKS = 1,

    HWLOC_DISTANCES_TRANSFORM_MERGE_SWITCH_PORTS = 2,

    HWLOC_DISTANCES_TRANSFORM_TRANSITIVE_CLOSURE = 3
  };

  int hwloc_distances_transform(
    hwloc_topology_t topology, struct hwloc_distances_s *distances,
    enum hwloc_distances_transform_e transform, void *transform_attr,
    unsigned long flags
  );

  inline static int hwloc_distances_obj_index(
    struct hwloc_distances_s *distances, hwloc_obj_t obj
  ) {
    unsigned i;
    for (i = 0; i < distances->nbobjs; i++)
      if (distances->objs[i] == obj) return (int)i;
    return -1;
  }

  inline static int hwloc_distances_obj_pair_values(
    struct hwloc_distances_s *distances, hwloc_obj_t obj1, hwloc_obj_t obj2,
    hwloc_uint64_t *value1to2, hwloc_uint64_t *value2to1
  ) {
    int i1 = hwloc_distances_obj_index(distances, obj1);
    int i2 = hwloc_distances_obj_index(distances, obj2);
    if (i1 < 0 || i2 < 0) return -1;
    *value1to2 = distances->values[i1 * distances->nbobjs + i2];
    *value2to1 = distances->values[i2 * distances->nbobjs + i1];
    return 0;
  }

  typedef void *hwloc_distances_add_handle_t;

  hwloc_distances_add_handle_t hwloc_distances_add_create(
    hwloc_topology_t topology, const char *name, unsigned long kind,
    unsigned long flags
  );

  int hwloc_distances_add_values(
    hwloc_topology_t topology, hwloc_distances_add_handle_t handle,
    unsigned nbobjs, hwloc_obj_t *objs, hwloc_uint64_t *values,
    unsigned long flags
  );

  enum hwloc_distances_add_flag_e {

    HWLOC_DISTANCES_ADD_FLAG_GROUP = (1UL << 0),

    HWLOC_DISTANCES_ADD_FLAG_GROUP_INACCURATE = (1UL << 1)
  };

  int hwloc_distances_add_commit(
    hwloc_topology_t topology, hwloc_distances_add_handle_t handle,
    unsigned long flags
  );

  int hwloc_distances_remove(hwloc_topology_t topology);

  int hwloc_distances_remove_by_depth(hwloc_topology_t topology, int depth);

  inline static int hwloc_distances_remove_by_type(
    hwloc_topology_t topology, hwloc_obj_type_t type
  ) {
    int depth = hwloc_get_type_depth(topology, type);
    if (depth == HWLOC_TYPE_DEPTH_UNKNOWN || depth == HWLOC_TYPE_DEPTH_MULTIPLE)
      return 0;
    return hwloc_distances_remove_by_depth(topology, depth);
  }

  int hwloc_distances_release_remove(
    hwloc_topology_t topology, struct hwloc_distances_s *distances
  );
}

extern "C" {

  typedef enum hwloc_topology_diff_obj_attr_type_e {

    HWLOC_TOPOLOGY_DIFF_OBJ_ATTR_SIZE,

    HWLOC_TOPOLOGY_DIFF_OBJ_ATTR_NAME,

    HWLOC_TOPOLOGY_DIFF_OBJ_ATTR_INFO
  } hwloc_topology_diff_obj_attr_type_t;

  union hwloc_topology_diff_obj_attr_u {
    struct hwloc_topology_diff_obj_attr_generic_s {
      hwloc_topology_diff_obj_attr_type_t type;
    } generic;

    struct hwloc_topology_diff_obj_attr_uint64_s {
      hwloc_topology_diff_obj_attr_type_t type;
      hwloc_uint64_t index;
      hwloc_uint64_t oldvalue;
      hwloc_uint64_t newvalue;
    } uint64;

    struct hwloc_topology_diff_obj_attr_string_s {
      hwloc_topology_diff_obj_attr_type_t type;
      char *name;
      char *oldvalue;
      char *newvalue;
    } string;
  };

  typedef enum hwloc_topology_diff_type_e {

    HWLOC_TOPOLOGY_DIFF_OBJ_ATTR,

    HWLOC_TOPOLOGY_DIFF_TOO_COMPLEX
  } hwloc_topology_diff_type_t;

  typedef union hwloc_topology_diff_u {
    struct hwloc_topology_diff_generic_s {
      hwloc_topology_diff_type_t type;
      union hwloc_topology_diff_u *next;
    } generic;

    struct hwloc_topology_diff_obj_attr_s {
      hwloc_topology_diff_type_t type;
      union hwloc_topology_diff_u *next;

      int obj_depth;
      unsigned obj_index;
      union hwloc_topology_diff_obj_attr_u diff;
    } obj_attr;

    struct hwloc_topology_diff_too_complex_s {
      hwloc_topology_diff_type_t type;
      union hwloc_topology_diff_u *next;

      int obj_depth;
      unsigned obj_index;
    } too_complex;
  } *hwloc_topology_diff_t;

  int hwloc_topology_diff_build(
    hwloc_topology_t topology, hwloc_topology_t newtopology,
    unsigned long flags, hwloc_topology_diff_t *diff
  );

  enum hwloc_topology_diff_apply_flags_e {

    HWLOC_TOPOLOGY_DIFF_APPLY_REVERSE = (1UL << 0)
  };

  int hwloc_topology_diff_apply(
    hwloc_topology_t topology, hwloc_topology_diff_t diff, unsigned long flags
  );

  int hwloc_topology_diff_destroy(hwloc_topology_diff_t diff);

  int hwloc_topology_diff_load_xml(
    const char *xmlpath, hwloc_topology_diff_t *diff, char **refname
  );

  int hwloc_topology_diff_export_xml(
    hwloc_topology_diff_t diff, const char *refname, const char *xmlpath
  );

  int hwloc_topology_diff_load_xmlbuffer(
    const char *xmlbuffer, int buflen, hwloc_topology_diff_t *diff,
    char **refname
  );

  int hwloc_topology_diff_export_xmlbuffer(
    hwloc_topology_diff_t diff, const char *refname, char **xmlbuffer,
    int *buflen
  );
}

extern "C" {

  int hwloc_distances_add(
    hwloc_topology_t topology, unsigned nbobjs, hwloc_obj_t *objs,
    hwloc_uint64_t *values, unsigned long kind, unsigned long flags
  ) __attribute__((__deprecated__));

  inline static hwloc_obj_t hwloc_topology_insert_misc_object_by_parent(
    hwloc_topology_t topology, hwloc_obj_t parent, const char *name
  ) __attribute__((__deprecated__));
  inline static hwloc_obj_t hwloc_topology_insert_misc_object_by_parent(
    hwloc_topology_t topology, hwloc_obj_t parent, const char *name
  ) {
    return hwloc_topology_insert_misc_object(topology, parent, name);
  }

  inline static int hwloc_obj_cpuset_snprintf(
    char *str, size_t size, size_t nobj, struct hwloc_obj *const *objs
  ) __attribute__((__deprecated__));
  inline static int hwloc_obj_cpuset_snprintf(
    char *str, size_t size, size_t nobj, struct hwloc_obj *const *objs
  ) {
    hwloc_bitmap_t set = hwloc_bitmap_alloc();
    int res;
    unsigned i;

    hwloc_bitmap_zero(set);
    for (i = 0; i < nobj; i++)
      if (objs[i]->cpuset) hwloc_bitmap_or(set, set, objs[i]->cpuset);

    res = hwloc_bitmap_snprintf(str, size, set);
    hwloc_bitmap_free(set);
    return res;
  }

  inline static int hwloc_obj_type_sscanf(
    const char *string, hwloc_obj_type_t *typep, int *depthattrp,
    void *typeattrp, size_t typeattrsize
  ) __attribute__((__deprecated__));
  inline static int hwloc_obj_type_sscanf(
    const char *string, hwloc_obj_type_t *typep, int *depthattrp,
    void *typeattrp, size_t typeattrsize
  ) {
    union hwloc_obj_attr_u attr;
    int err = hwloc_type_sscanf(string, typep, &attr, sizeof(attr));
    if (err < 0) return err;
    if (hwloc_obj_type_is_cache(*typep)) {
      if (depthattrp) *depthattrp = (int)attr.cache.depth;
      if (typeattrp && typeattrsize >= sizeof(hwloc_obj_cache_type_t))
	memcpy(typeattrp, &attr.cache.type, sizeof(hwloc_obj_cache_type_t));
    } else if (*typep == HWLOC_OBJ_GROUP) {
      if (depthattrp) *depthattrp = (int)attr.group.depth;
    }
    return 0;
  }

  inline static int hwloc_set_membind_nodeset(
    hwloc_topology_t topology, hwloc_const_nodeset_t nodeset,
    hwloc_membind_policy_t policy, int flags
  ) __attribute__((__deprecated__));
  inline static int hwloc_set_membind_nodeset(
    hwloc_topology_t topology, hwloc_const_nodeset_t nodeset,
    hwloc_membind_policy_t policy, int flags
  ) {
    return hwloc_set_membind(
      topology, nodeset, policy, flags | HWLOC_MEMBIND_BYNODESET
    );
  }

  inline static int hwloc_get_membind_nodeset(
    hwloc_topology_t topology, hwloc_nodeset_t nodeset,
    hwloc_membind_policy_t *policy, int flags
  ) __attribute__((__deprecated__));
  inline static int hwloc_get_membind_nodeset(
    hwloc_topology_t topology, hwloc_nodeset_t nodeset,
    hwloc_membind_policy_t *policy, int flags
  ) {
    return hwloc_get_membind(
      topology, nodeset, policy, flags | HWLOC_MEMBIND_BYNODESET
    );
  }

  inline static int hwloc_set_proc_membind_nodeset(
    hwloc_topology_t topology, pid_t pid, hwloc_const_nodeset_t nodeset,
    hwloc_membind_policy_t policy, int flags
  ) __attribute__((__deprecated__));
  inline static int hwloc_set_proc_membind_nodeset(
    hwloc_topology_t topology, pid_t pid, hwloc_const_nodeset_t nodeset,
    hwloc_membind_policy_t policy, int flags
  ) {
    return hwloc_set_proc_membind(
      topology, pid, nodeset, policy, flags | HWLOC_MEMBIND_BYNODESET
    );
  }

  inline static int hwloc_get_proc_membind_nodeset(
    hwloc_topology_t topology, pid_t pid, hwloc_nodeset_t nodeset,
    hwloc_membind_policy_t *policy, int flags
  ) __attribute__((__deprecated__));
  inline static int hwloc_get_proc_membind_nodeset(
    hwloc_topology_t topology, pid_t pid, hwloc_nodeset_t nodeset,
    hwloc_membind_policy_t *policy, int flags
  ) {
    return hwloc_get_proc_membind(
      topology, pid, nodeset, policy, flags | HWLOC_MEMBIND_BYNODESET
    );
  }

  inline static int hwloc_set_area_membind_nodeset(
    hwloc_topology_t topology, const void *addr, size_t len,
    hwloc_const_nodeset_t nodeset, hwloc_membind_policy_t policy, int flags
  ) __attribute__((__deprecated__));
  inline static int hwloc_set_area_membind_nodeset(
    hwloc_topology_t topology, const void *addr, size_t len,
    hwloc_const_nodeset_t nodeset, hwloc_membind_policy_t policy, int flags
  ) {
    return hwloc_set_area_membind(
      topology, addr, len, nodeset, policy, flags | HWLOC_MEMBIND_BYNODESET
    );
  }

  inline static int hwloc_get_area_membind_nodeset(
    hwloc_topology_t topology, const void *addr, size_t len,
    hwloc_nodeset_t nodeset, hwloc_membind_policy_t *policy, int flags
  ) __attribute__((__deprecated__));
  inline static int hwloc_get_area_membind_nodeset(
    hwloc_topology_t topology, const void *addr, size_t len,
    hwloc_nodeset_t nodeset, hwloc_membind_policy_t *policy, int flags
  ) {
    return hwloc_get_area_membind(
      topology, addr, len, nodeset, policy, flags | HWLOC_MEMBIND_BYNODESET
    );
  }

  inline static void *hwloc_alloc_membind_nodeset(
    hwloc_topology_t topology, size_t len, hwloc_const_nodeset_t nodeset,
    hwloc_membind_policy_t policy, int flags
  ) __attribute__((__malloc__)) __attribute__((__deprecated__));
  inline static void *hwloc_alloc_membind_nodeset(
    hwloc_topology_t topology, size_t len, hwloc_const_nodeset_t nodeset,
    hwloc_membind_policy_t policy, int flags
  ) {
    return hwloc_alloc_membind(
      topology, len, nodeset, policy, flags | HWLOC_MEMBIND_BYNODESET
    );
  }

  inline static void *hwloc_alloc_membind_policy_nodeset(
    hwloc_topology_t topology, size_t len, hwloc_const_nodeset_t nodeset,
    hwloc_membind_policy_t policy, int flags
  ) __attribute__((__malloc__)) __attribute__((__deprecated__));
  inline static void *hwloc_alloc_membind_policy_nodeset(
    hwloc_topology_t topology, size_t len, hwloc_const_nodeset_t nodeset,
    hwloc_membind_policy_t policy, int flags
  ) {
    return hwloc_alloc_membind_policy(
      topology, len, nodeset, policy, flags | HWLOC_MEMBIND_BYNODESET
    );
  }

  inline static void hwloc_cpuset_to_nodeset_strict(
    hwloc_topology_t topology, hwloc_const_cpuset_t _cpuset,
    hwloc_nodeset_t nodeset
  ) __attribute__((__deprecated__));
  inline static void hwloc_cpuset_to_nodeset_strict(
    hwloc_topology_t topology, hwloc_const_cpuset_t _cpuset,
    hwloc_nodeset_t nodeset
  ) {
    hwloc_cpuset_to_nodeset(topology, _cpuset, nodeset);
  }

  inline static void hwloc_cpuset_from_nodeset_strict(
    hwloc_topology_t topology, hwloc_cpuset_t _cpuset,
    hwloc_const_nodeset_t nodeset
  ) __attribute__((__deprecated__));
  inline static void hwloc_cpuset_from_nodeset_strict(
    hwloc_topology_t topology, hwloc_cpuset_t _cpuset,
    hwloc_const_nodeset_t nodeset
  ) {
    hwloc_cpuset_from_nodeset(topology, _cpuset, nodeset);
  }
}

template <typename Impl_, typename Container_, typename Elem_>
class ZuIterator {
public:
  using Impl = Impl_;
  using Container = Container_;
  using Elem = Elem_;

  auto impl() const { return static_cast<const Impl *>(this); }
  auto impl() { return static_cast<Impl *>(this); }

  using iterator_category = std::bidirectional_iterator_tag;
  using value_type = Elem;
  using difference_type = ptrdiff_t;
  using pointer = Elem *;
  using reference = Elem &;

  ZuIterator() = delete;
  ZuIterator(Container &container_, unsigned i) :
    container{container_}, i{i} { }
  ZuIterator(const ZuIterator &) = default;
  ZuIterator &operator=(const ZuIterator &) = default;
  ZuIterator(ZuIterator &&) = default;
  ZuIterator &operator=(ZuIterator &&) = default;

  Impl &operator++() {
    ++i;
    return *impl();
  }
  Impl operator++(int) {
    Impl _ = *impl();
    ++(*impl());
    return _;
  }
  Impl &operator--() {
    --i;
    return *impl();
  }
  Impl operator--(int) {
    Impl _ = *impl();
    --(*impl());
    return _;
  }

  bool operator==(const ZuIterator &r) const {
    return &container == &r.container && i == r.i;
  }

  friend ptrdiff_t operator-(const ZuIterator &l, const ZuIterator &r) {
    return ptrdiff_t(l.i) - ptrdiff_t(r.i);
  }

protected:
  Container &container;
  unsigned i;
};

namespace ZuBitmap_ {

template <typename Bitmap_, typename Bit_>
class Iterator : public ZuIterator<Iterator<Bitmap_, Bit_>, Bitmap_, Bit_> {
  using Base = ZuIterator<Iterator<Bitmap_, Bit_>, Bitmap_, Bit_>;

public:
  using Bitmap = Bitmap_;
  using Bit = Bit_;
  using Base::Base;
  using Base::operator=;
  using Base::container;
  using Base::i;

  Bit operator*() const { return container[i]; }
};

template <typename Bitmap_> class Bit {
public:
  using Bitmap = Bitmap_;

  Bit() = delete;
  Bit(Bitmap &bitmap_, unsigned i_) : bitmap{bitmap_}, i{i_} { }
  Bit(const Bit &) = default;
  Bit &operator=(const Bit &) = default;
  Bit(Bit &&) = default;
  Bit &operator=(Bit &&) = default;

  bool get() const;
  void set();
  void clr();

  operator bool() const { return get(); }
  bool operator!() const { return !get(); }

  Bit &operator=(bool v) {
    v ? set() : clr();
    return *this;
  }

  bool equals(const Bit &r) const { return get() == r.get(); }
  int cmp(const Bit &r) const { return ZuCmp<bool>::cmp(get(), r.get()); }
  friend inline bool operator==(const Bit &l, const Bit &r) {
    return l.equals(r);
  }
  friend inline int operator<=>(const Bit &l, const Bit &r) { return l.cmp(r); }

  struct Traits : public ZuTraits<bool> {
    enum { IsPrimitive = 0, IsPOD = 0 };
    using Elem = Bit;
  };
  friend Traits ZuTraitsType(Bit *);

  friend bool ZuUnderType(Bit *);

private:
  Bitmap &bitmap;
  unsigned i;
};

template <typename Bitmap_> struct PrintScan {
  using Bitmap = Bitmap_;

  auto impl() const { return static_cast<const Bitmap *>(this); }
  auto impl() { return static_cast<Bitmap *>(this); }

  static int scanLast(ZuCSpan s) {
    const char *data = s.data();
    unsigned length = s.length(), offset = 0;
    int last = -1;
    ZuBox<unsigned> begin, end;
    int j;
    while (offset < length) {
      if (data[offset] == ',') {
	++offset;
	continue;
      }
      if ((j = begin.scan(data + offset, length - offset)) <= 0) break;
      offset += j;
      if (offset < length && data[offset] == '-') {
	if ((j = end.scan(data + offset + 1, length - offset - 1)) > 0) {
	  ++end;
	  offset += j + 1;
	} else {
	  end = begin + 1;
	  ++offset;
	}
      } else
	end = begin + 1;
      if (int(end.val()) > last) last = end;
    }
    return last;
  }
  unsigned scan(ZuCSpan s) {
    const char *data = s.data();
    unsigned length = s.length(), offset = 0;
    if (!length) return 0;
    ZuBox<unsigned> begin, end;
    int j;
    while (offset < length) {
      if (data[offset] == ',') {
	++offset;
	continue;
      }
      if ((j = begin.scan(data + offset, length - offset)) <= 0) break;
      offset += j;
      if (offset < length && data[offset] == '-') {
	if ((j = end.scan(data + offset + 1, length - offset - 1)) > 0) {
	  ++end;
	  offset += j + 1;
	} else {
	  end = impl()->length();
	  ++offset;
	}
      } else
	end = begin + 1;
      impl()->set(begin, end);
    }
    return offset;
  }
  unsigned printLen() const {
    using Log = Zu_ntoa::Log10<4>;
    if (!*impl()) return 0;
    unsigned len = 0;
    int begin = impl()->first(), end;
    bool first = true;
    while (begin >= 0) {
      if (!first)
	++len;
      else
	first = false;
      end = begin;
      int next;
      while ((next = impl()->next(end)) == end + 1) end = next;
      if (end == begin)
	len += Log::log(begin);
      else if (end == impl()->length() - 1)
	len += Log::log(begin) + 1;
      else
	len += Log::log(begin) + 1 + Log::log(end);
      begin = next;
    }
    len = (len - Log::log(end)) + Zu_ntoa::Log10_MaxLog<4>::N;
    return len;
  }
  template <typename S> void print(S &s) const {
    if (!*impl()) return;
    int begin = impl()->first();
    bool first = true;
    while (begin >= 0) {
      if (!first)
	s << ',';
      else
	first = false;
      int end = begin, next;
      while ((next = impl()->next(end)) == end + 1) end = next;
      if (end == begin)
	s << ZuBox<unsigned>{begin};
      else if (end == impl()->length() - 1)
	s << ZuBox<unsigned>{begin} << '-';
      else
	s << ZuBox<unsigned>{begin} << '-' << ZuBox<unsigned>{end};
      begin = next;
    }
  }
};

template <typename Data_>
class Bitmap_ : public Data_, public PrintScan<Bitmap_<Data_>> {
public:
  using Bit = ZuBitmap_::Bit<Bitmap_>;

  using Data = Data_;
  using Data::length;
  using Data::data;

  using PrintScan<Bitmap_>::scan;
  using PrintScan<Bitmap_>::print;

  enum { ByteShift = 3 };
  enum { BitShift = 6 };
  enum { Mask = ((1U << BitShift) - 1) };

  Bitmap_() = default;
  Bitmap_(const Bitmap_ &) = default;
  Bitmap_ &operator=(const Bitmap_ &) = default;
  Bitmap_(Bitmap_ &&) = default;
  Bitmap_ &operator=(Bitmap_ &&) = default;
  ~Bitmap_() = default;

  template <typename _ = Data, decltype(_{ZuDeclVal<unsigned>()}, int()) = 0>
  Bitmap_(unsigned n) : Data{n} { }
  template <typename _ = Data, decltype(ZuIfT<!_::Fixed>(), int()) = 0>
  Bitmap_(ZuCSpan s) : Data{1U + this->scanLast(s)} {
    this->scan(s);
  }
  template <typename _ = Data, decltype(_{ZuDeclVal<unsigned>()}, int()) = 0>
  Bitmap_(ZuCSpan s, unsigned n) : Data{n} {
    this->scan(s);
  }
  template <typename _ = Data, decltype(ZuIfT<_::Fixed>(), int()) = 0>
  Bitmap_(ZuCSpan s) {
    this->scan(s);
  }

  Bitmap_ &zero() {
    memset(&data[0], 0, length() >> ByteShift);
    return *this;
  }
  Bitmap_ &fill() {
    memset(&data[0], 0xff, length() >> ByteShift);
    return *this;
  }

  bool get(unsigned i) const {
    if (__builtin_expect(!!(i >= length()), 0)) return 0;
    return data[i >> BitShift] & (uint64_t(1) << (i & Mask));
  }
  Bitmap_ &set(unsigned i) {
    if (__builtin_expect(!!(i >= length()), 1)) {
      if constexpr (Data::Fixed)
	return *this;
      else
	length(i + 1);
    }
    data[i >> BitShift] |= (uint64_t(1) << (i & Mask));
    return *this;
  }
  Bitmap_ &clr(unsigned i) {
    if (__builtin_expect(!!(i < length()), 1))
      data[i >> BitShift] &= ~(uint64_t(1) << (i & Mask));
    return *this;
  }

  const Bit operator[](unsigned i) const {
    return {const_cast<Bitmap_ &>(*this), i};
  }
  Bit operator[](unsigned i) { return {*this, i}; }

  void flip() {
    unsigned n = length() >> BitShift;
    for (unsigned i = 0; i < n; i++) data[i] = ~data[i];
  }

  Bitmap_ &operator|=(const Bitmap_ &b) {
    unsigned n = Data::combine(b);
    for (unsigned i = 0; i < n; i++) data[i] |= b.data[i];
    return *this;
  }
  Bitmap_ &operator&=(const Bitmap_ &b) {
    unsigned n = Data::combine(b);
    for (unsigned i = 0; i < n; i++) data[i] &= b.data[i];
    return *this;
  }
  Bitmap_ &operator^=(const Bitmap_ &b) {
    unsigned n = Data::combine(b);
    for (unsigned i = 0; i < n; i++) data[i] ^= b.data[i];
    return *this;
  }

  Bitmap_ &set(unsigned begin, unsigned end) {
    if (__builtin_expect(!!(end > length()), 1)) {
      if constexpr (Data::Fixed) {
	end = length();
	if (begin >= end) return *this;
      } else
	length(end);
    } else {
      if (begin >= end) return *this;
    }
    {
      unsigned i = (begin >> BitShift);
      uint64_t mask = ~static_cast<uint64_t>(0);
      if (i == (end >> BitShift)) mask >>= (64 - (end - begin));
      if (uint64_t begin_ = (begin & Mask)) {
	mask <<= begin_;
	begin -= begin_;
      }
      data[i] |= mask;
      begin += 64;
    }
    {
      unsigned i = (begin >> BitShift);
      unsigned j = (end >> BitShift);
      if (i < j) {
	memset(&data[i], 0xff, (j - i) << (BitShift - ByteShift));
	begin = end & ~Mask;
      }
    }
    if (begin < end) {
      uint64_t mask = (~static_cast<uint64_t>(0)) >> (63 - (end - begin));
      data[begin >> BitShift] |= mask;
    }
    return *this;
  }
  Bitmap_ &clr(unsigned begin, unsigned end) {
    if (end > length()) end = length();
    if (begin >= end) return *this;
    {
      unsigned i = (begin >> BitShift);
      uint64_t mask = ~static_cast<uint64_t>(0);
      if (i == (end >> BitShift)) mask >>= (64 - (end - begin));
      if (uint64_t begin_ = (begin & Mask)) {
	mask <<= begin_;
	begin -= begin_;
      }
      data[i] &= ~mask;
      begin += 64;
    }
    {
      unsigned i = (begin >> BitShift);
      unsigned j = (end >> BitShift);
      if (i < j) {
	memset(&data[i], 0, (j - i) << (BitShift - ByteShift));
	begin = end & ~Mask;
      }
    }
    if (begin < end) {
      uint64_t mask = (~static_cast<uint64_t>(0)) >> (63 - (end - begin));
      data[begin >> BitShift] &= ~mask;
    }
    return *this;
  }

  auto buf() { return ZuSpan{&data[0], length() >> BitShift}; }
  auto cbuf() const { return ZuSpan{&data[0], length() >> BitShift}; }

  bool operator!() const {
    unsigned n = length() >> BitShift;
    for (unsigned i = 0; i < n; i++)
      if (data[i]) return false;
    return true;
  }
  operator const void *() const {
    return !*this ? reinterpret_cast<const void *>(0) :
		    static_cast<const void *>(this);
  };

protected:
  bool same(const Bitmap_ &r) const { return this == &r; }

public:
  bool equals(const Bitmap_ &r) const {
    return same(r) || cbuf().equals(r.cbuf());
  }
  int cmp(const Bitmap_ &r) const {
    if (same(r)) return 0;
    return cbuf().cmp(r.cbuf());
  }
  friend inline bool operator==(const Bitmap_ &l, const Bitmap_ &r) {
    return l.equals(r);
  }
  friend inline int operator<=>(const Bitmap_ &l, const Bitmap_ &r) {
    return l.cmp(r);
  }

  uint32_t hash() const { return cbuf().hash(); }

  int first() const {
    unsigned n = length() >> BitShift;
    for (unsigned i = 0; i < n; i++)
      if (uint64_t w = data[i]) return (i << BitShift) + ZuIntrin::ctz(w);
    return -1;
  }
  int last() const {
    unsigned n = length() >> BitShift;
    for (int i = n; --i >= 0;)
      if (uint64_t w = data[i])
	return (i << BitShift) + (63 - ZuIntrin::clz(w));
    return -1;
  }
  int next(int i) const {
    unsigned n = length();
    if (__builtin_expect(!!(i == -1), 0)) return first();
    do {
      if (++i >= n) return -1;
    } while (!get(i));
    return i;
  }
  int prev(int i) const {
    if (__builtin_expect(!!(i == -1), 0)) return last();
    do {
      if (--i < 0) return -1;
    } while (!get(i));
    return i;
  }

  friend ZuPrintFn ZuPrintType(Bitmap_ *);

  using iterator = Iterator<Bitmap_, Bit>;
  using const_iterator = Iterator<const Bitmap_, const Bit>;
  const_iterator begin() const { return const_iterator{*this, 0}; }
  const_iterator end() const { return const_iterator{*this, length()}; }
  const_iterator cbegin() const { return const_iterator{*this, 0}; }
  const_iterator cend() const { return const_iterator{*this, length()}; }
  iterator begin() { return iterator{*this, 0}; }
  iterator end() { return iterator{*this, length()}; }
};

template <unsigned Bits_> struct Data {
  enum { Fixed = 1 };

  enum { Bits = ((Bits_ + 63) & ~63) };
  enum { Words = (Bits >> 6) };

  static constexpr unsigned length() { return Bits; }

private:
  void copy(const Data &b) { memcpy(&data[0], &b.data[0], sizeof(data)); }

public:
  Data() { memset(&data[0], 0, sizeof(data)); }
  Data(const Data &b) { copy(b); }
  Data &operator=(const Data &b) {
    copy(b);
    return *this;
  }
  Data(Data &&b) { copy(b); }
  Data &operator=(Data &&b) {
    copy(b);
    return *this;
  }

  static constexpr unsigned combine(const Data &) { return Words; }

  uint64_t data[Words];
};

template <unsigned Bits_> struct Bitmap : public Bitmap_<Data<Bits_>> {
  using Base = Bitmap_<Data<Bits_>>;
  using Base::Base;
  using Base::operator=;
};

template <typename Bitmap> inline bool Bit<Bitmap>::get() const {
  return bitmap.get(i);
}

template <typename Bitmap> inline void Bit<Bitmap>::set() { bitmap.set(i); }

template <typename Bitmap> inline void Bit<Bitmap>::clr() { bitmap.clr(i); }

} // namespace ZuBitmap_

template <unsigned Bits> using ZuBitmap = ZuBitmap_::Bitmap<Bits>;

namespace ZmBitmap_ {

template <typename Bitmap_, typename Bit_> class Iterator {
public:
  using Bitmap = Bitmap_;
  using Bit = Bit_;
  using iterator_category = std::bidirectional_iterator_tag;
  using value_type = Bit;
  using difference_type = ptrdiff_t;
  using pointer = Bit *;
  using reference = Bit &;

  Iterator() = delete;
  Iterator(Bitmap &bitmap_, int i) : bitmap{bitmap_}, i{i} { }
  Iterator(const Iterator &) = default;
  Iterator &operator=(const Iterator &) = default;
  Iterator(Iterator &&) = default;
  Iterator &operator=(Iterator &&) = default;

  bool operator*() const;

  Iterator &operator++() {
    ++i;
    return *this;
  }
  Iterator operator++(int) {
    Iterator _ = *this;
    ++(*this);
    return _;
  }
  Iterator &operator--() {
    --i;
    return *this;
  }
  Iterator operator--(int) {
    Iterator _ = *this;
    --(*this);
    return _;
  }

  bool operator==(const Iterator &r) const {
    return &bitmap == &r.bitmap && i == r.i;
  }

  friend ptrdiff_t operator-(const Iterator &l, const Iterator &r) {
    if (l.i < 0)
      return r.i < 0 ? 0 :

		       (9223372036854775807L);
    if (r.i < 0)
      return

	(-9223372036854775807L - 1);
    return ptrdiff_t(l.i) - ptrdiff_t(r.i);
  }

protected:
  Bitmap &bitmap;
  int i;
};

class Bitmap {
public:
  using Bit = ZuBitmap_::Bit<Bitmap>;

  Bitmap() : m_map{static_cast<hwloc_bitmap_t>(nullptr)} { }
  Bitmap(const Bitmap &b) :
    m_map{
      b.m_map ? hwloc_bitmap_dup(b.m_map) : static_cast<hwloc_bitmap_t>(nullptr)
    } { }
  Bitmap(Bitmap &&b) : m_map{b.m_map} { b.m_map = 0; }
  Bitmap &operator=(const Bitmap &b) {
    if (this == &b) return *this;
    if (!b.m_map) {
      if (m_map) hwloc_bitmap_free(m_map);
      m_map = 0;
      return *this;
    }
    if (!m_map) m_map = hwloc_bitmap_alloc();
    hwloc_bitmap_copy(m_map, b.m_map);
    return *this;
  }
  Bitmap &operator=(Bitmap &&b) {
    m_map = b.m_map;
    b.m_map = 0;
    return *this;
  }
  ~Bitmap() {
    if (m_map) hwloc_bitmap_free(m_map);
  }

private:
  void lazy() const {
    if (__builtin_expect(!!(!m_map), 0))
      const_cast<Bitmap *>(this)->m_map = hwloc_bitmap_alloc();
  }

public:
  bool get(unsigned i) const {
    if (!m_map) return false;
    return hwloc_bitmap_isset(m_map, i);
  }
  Bitmap &set(unsigned i) {
    lazy();
    hwloc_bitmap_set(m_map, i);
    return *this;
  }
  Bitmap &clr(unsigned i) {
    lazy();
    hwloc_bitmap_clr(m_map, i);
    return *this;
  }

  const Bit operator[](unsigned i) const {
    return {*const_cast<Bitmap *>(this), i};
  }
  Bit operator[](unsigned i) { return {*this, i}; }

  bool equals(const Bitmap &b) const {
    if (this == &b || m_map == b.m_map) return true;
    if (!m_map || !b.m_map) return false;
    return hwloc_bitmap_isequal(m_map, b.m_map);
  }
  int cmp(const Bitmap &b) const {
    if (this == &b || m_map == b.m_map) return 0;
    if (!m_map) return -1;
    if (!b.m_map) return 1;
    return hwloc_bitmap_compare(m_map, b.m_map);
  }
  friend inline bool operator==(const Bitmap &l, const Bitmap &r) {
    return l.equals(r);
  }
  friend inline int operator<=>(const Bitmap &l, const Bitmap &r) {
    return l.cmp(r);
  }

  using Range = ZuTuple<unsigned, unsigned>;

  template <typename T> ZuSame<Range, T, Bitmap &> set(const T &v) {
    lazy();
    hwloc_bitmap_set_range(m_map, v.p1(), v.p2());
    return *this;
  }
  template <typename T> ZuSame<Range, T, Bitmap &> clr(const T &v) {
    lazy();
    hwloc_bitmap_clr_range(m_map, v.p1(), v.p2());
    return *this;
  }

  bool operator&&(const Bitmap &b) const {
    if (!m_map) return !b.m_map;
    return hwloc_bitmap_isincluded(b.m_map, m_map);
  }
  bool operator||(const Bitmap &b) const {
    if (!m_map) return false;
    return hwloc_bitmap_intersects(b.m_map, m_map);
  }

  Bitmap operator|(const Bitmap &b) const {
    lazy();
    b.lazy();
    Bitmap r;
    hwloc_bitmap_or(r.m_map, m_map, b.m_map);
    return r;
  }
  Bitmap operator&(const Bitmap &b) const {
    lazy();
    b.lazy();
    Bitmap r;
    hwloc_bitmap_and(r.m_map, m_map, b.m_map);
    return r;
  }
  Bitmap operator^(const Bitmap &b) const {
    lazy();
    b.lazy();
    Bitmap r;
    hwloc_bitmap_xor(r.m_map, m_map, b.m_map);
    return r;
  }
  Bitmap operator~() const {
    lazy();
    Bitmap r;
    hwloc_bitmap_not(r.m_map, m_map);
    return r;
  }

  Bitmap &operator|=(const Bitmap &b) {
    lazy();
    b.lazy();
    hwloc_bitmap_or(m_map, m_map, b.m_map);
    return *this;
  }
  Bitmap &operator&=(const Bitmap &b) {
    lazy();
    b.lazy();
    hwloc_bitmap_and(m_map, m_map, b.m_map);
    return *this;
  }
  Bitmap &operator^=(const Bitmap &b) {
    lazy();
    b.lazy();
    hwloc_bitmap_xor(m_map, m_map, b.m_map);
    return *this;
  }

  void set(unsigned begin, int end) {
    hwloc_bitmap_set_range(m_map, begin, end);
  }

  Bitmap &zero() {
    lazy();
    hwloc_bitmap_zero(m_map);
    return *this;
  }
  Bitmap &fill() {
    lazy();
    hwloc_bitmap_fill(m_map);
    return *this;
  }

  bool operator!() const { return !m_map || hwloc_bitmap_iszero(m_map); }

  bool full() const { return m_map ? hwloc_bitmap_isfull(m_map) : false; }

  int first() const { return !m_map ? -1 : hwloc_bitmap_first(m_map); }
  int last() const { return !m_map ? -1 : hwloc_bitmap_last(m_map); }
  int next(int i) const { return !m_map ? -1 : hwloc_bitmap_next(m_map, i); }
  int count() const { return !m_map ? 0 : hwloc_bitmap_weight(m_map); }

  operator hwloc_bitmap_t() {
    lazy();
    return m_map;
  }
  operator const hwloc_bitmap_t() const {
    return const_cast<Bitmap *>(this)->operator hwloc_bitmap_t();
  }

  Bitmap(uint64_t v) : m_map{hwloc_bitmap_alloc()} {
    hwloc_bitmap_from_ulong(m_map, v);
  }
  uint64_t uint64() const {
    if (__builtin_expect(!!(!m_map), 1)) return 0;
    return hwloc_bitmap_to_ulong(m_map);
  }
  Bitmap(uint128_t v) : m_map{hwloc_bitmap_alloc()} {
    hwloc_bitmap_from_ith_ulong(m_map, 0, (uint64_t)v);
    hwloc_bitmap_from_ith_ulong(m_map, 1, (uint64_t)(v >> 64U));
  }
  uint128_t uint128() const {
    if (__builtin_expect(!!(!m_map), 1)) return 0;
    return (uint128_t)hwloc_bitmap_to_ith_ulong(m_map, 0) |
      ((uint128_t)hwloc_bitmap_to_ith_ulong(m_map, 1) << 64U);
  }
  template <typename S, decltype(ZuMatchCharString<S>(), int()) = 0>
  Bitmap(const S &s) : m_map{hwloc_bitmap_alloc()} {
    scan(s);
  }
  template <typename S> ZuMatchCharString<S, Bitmap &> operator=(const S &s) {
    if (m_map) hwloc_bitmap_zero(m_map);
    scan(s);
    return *this;
  }

  unsigned scan(ZuCSpan s) {
    lazy();
    const char *data = s.data();
    unsigned length = s.length(), offset = 0;
    if (!length) return 0;
    ZuBox<int> begin, end;
    int j;
    while (offset < length) {
      if (data[offset] == ',') {
	++offset;
	continue;
      }
      if ((j = begin.scan(data + offset, length - offset)) <= 0) break;
      offset += j;
      if (offset < length && data[offset] == '-') {
	if ((j = end.scan(data + offset + 1, length - offset - 1)) > 0)
	  offset += j + 1;
	else {
	  end = -1;
	  ++offset;
	}
      } else
	end = begin;
      set(begin, end);
    }
    return offset;
  }
  template <typename S> void print(S &s) const {
    if (!*this) return;
    Bitmap tmp = *this;
    ZuBox<int> begin = hwloc_bitmap_first(m_map);
    bool first = true;
    while (begin >= 0) {
      if (!first)
	s << ',';
      else
	first = false;
      ZuBox<int> end = begin, next;
      hwloc_bitmap_set_range(tmp.m_map, 0, begin);
      if (hwloc_bitmap_isfull(tmp.m_map)) {
	s << begin << '-';
	return;
      }
      while ((next = hwloc_bitmap_next(m_map, end)) == end + 1) end = next;
      if (end == begin)
	s << begin;
      else
	s << begin << '-' << end;
      begin = next;
    }
  }

  struct Traits : public ZuBaseTraits<Bitmap> {
    enum { IsComparable = 1 };
  };
  friend Traits ZuTraitsType(Bitmap *);

  friend ZuPrintFn ZuPrintType(Bitmap *);

  using iterator = Iterator<Bitmap, Bit>;
  using const_iterator = Iterator<const Bitmap, const Bit>;
  const_iterator begin() const { return const_iterator{*this, 0}; }
  const_iterator end() const { return const_iterator{*this, -1}; }
  const_iterator cbegin() const { return const_iterator{*this, 0}; }
  const_iterator cend() const { return const_iterator{*this, -1}; }
  iterator begin() { return iterator{*this, 0}; }
  iterator end() { return iterator{*this, -1}; }

private:
  hwloc_bitmap_t m_map;
};

template <typename Bitmap, typename Bit>
inline bool Iterator<Bitmap, Bit>::operator*() const {
  return bitmap[i];
}

} // namespace ZmBitmap_

using ZmBitmap = ZmBitmap_::Bitmap;

template <typename> struct ZuDeduce;
template <typename O_, typename R_, typename... Args_>
struct ZuDeduce<R_ (O_::*)(Args_...) const> {
  enum { Member = 1 };
  using O = O_;
  using R = R_;
  using Args = ZuTypeList<Args_...>;
};
template <typename O_, typename R_, typename... Args_>
struct ZuDeduce<R_ (O_::*)(Args_...)> {
  enum { Member = 1 };
  using O = O_;
  using R = R_;
  using Args = ZuTypeList<Args_...>;
};
template <typename R_, typename... Args_> struct ZuDeduce<R_ (*)(Args_...)> {
  enum { Member = 0 };
  using R = R_;
  using Args = ZuTypeList<Args_...>;
};

namespace ZuLambdaTraits {

template <typename L, auto Fn> struct ArgList__;
template <typename L, typename R, typename... FnArgs, R (*Fn)(FnArgs...)>
struct ArgList__<L, Fn> {
  using T = ZuTypeList<FnArgs...>;
};
template <typename L, typename R, typename... FnArgs, R (L::*Fn)(FnArgs...)>
struct ArgList__<L, Fn> {
  using T = ZuTypeList<FnArgs...>;
};
template <
  typename L, typename R, typename... FnArgs, R (L::*Fn)(FnArgs...) const>
struct ArgList__<L, Fn> {
  using T = ZuTypeList<FnArgs...>;
};
template <typename L, typename = void> struct ArgList_;
template <typename L>
struct ArgList_<L, decltype(&L::operator(), void())> :
  public ArgList__<L, &L::operator()> { };
template <typename L> using ArgList = typename ArgList_<ZuDecay<L>>::T;

template <typename L, typename ArgList_> struct Return_;
template <typename L> struct Return_<L, ZuTypeList<>> {
  using T = decltype(ZuDeclVal<L &>()());
};
template <typename L, typename... Args> struct Return_<L, ZuTypeList<Args...>> {
  using T = decltype(ZuDeclVal<L &>()(ZuDeclVal<Args>()...));
};
template <typename L, typename ArgList_ = ArgList<L>>
using Return = typename Return_<ZuDecay<L>, ArgList_>::T;

template <
  typename L, typename ArgList_ = ArgList<L>, typename = Return<L, ArgList_>>
struct IsVoidRet : public ZuFalse { };
template <typename L, typename ArgList_>
struct IsVoidRet<L, ArgList_, void> : public ZuTrue { };

template <typename L, typename = void>
struct IsMutable_NoArgs : public ZuTrue { };
template <typename L>
struct IsMutable_NoArgs<L, decltype(ZuDeclVal<const L &>()(), void())> :
  public ZuFalse { };
template <typename L, typename ArgList_, typename = void>
struct IsMutable_Args : public ZuTrue { };
template <typename L, typename... Args>
struct IsMutable_Args<
  L, ZuTypeList<Args...>,
  decltype(ZuDeclVal<const L &>()(ZuDeclVal<Args>()...), void())> :
  public ZuFalse { };
template <typename L, typename ArgList_ = ArgList<L>>
struct IsMutable : public IsMutable_Args<ZuDecay<L>, ArgList_> { };
template <typename L>
struct IsMutable<L, ZuTypeList<>> : public IsMutable_NoArgs<ZuDecay<L>> { };

template <typename ArgList_, typename FnArgList>
struct IsStateless_Fn__ : public ZuBool<ArgList_::N == FnArgList::N> { };
template <
  typename L, typename ArgList_, typename R, typename FnArgList,
  typename = void>
struct IsStateless_Fn_ : public ZuFalse { };
template <typename L, typename ArgList_, typename R, typename... FnArgs>
struct IsStateless_Fn_<
  L, ArgList_, R, ZuTypeList<FnArgs...>,
  decltype(static_cast<R (*)(FnArgs...)>(ZuDeclVal<const L &>()), void())> :
  public IsStateless_Fn__<ArgList_, ZuTypeList<FnArgs...>> { };
template <typename L, typename ArgList_, auto Fn>
struct IsStateless_Fn : public ZuFalse { };
template <
  typename L, typename ArgList_, typename R, typename... FnArgs,
  R (*Fn)(FnArgs...)>
struct IsStateless_Fn<L, ArgList_, Fn> :
  public IsStateless_Fn_<L, ArgList_, R, ZuTypeList<FnArgs...>> { };
template <
  typename L, typename ArgList_, typename R, typename... FnArgs,
  R (L::*Fn)(FnArgs...)>
struct IsStateless_Fn<L, ArgList_, Fn> :
  public IsStateless_Fn_<L, ArgList_, R, ZuTypeList<FnArgs...>> { };
template <
  typename L, typename ArgList_, typename R, typename... FnArgs,
  R (L::*Fn)(FnArgs...) const>
struct IsStateless_Fn<L, ArgList_, Fn> :
  public IsStateless_Fn_<L, ArgList_, R, ZuTypeList<FnArgs...>> { };
template <typename L, typename R, typename ArgList_, typename = void>
struct IsStateless_Generic_ : public ZuFalse { };
template <typename L, typename R, typename... Args>
struct IsStateless_Generic_<
  L, R, ZuTypeList<Args...>,
  decltype(static_cast<R (*)(Args...)>(ZuDeclVal<const L &>()), void())> :
  public ZuTrue { };
template <typename L, typename = void>
struct IsStateless_Generic_NoArgs : public ZuFalse { };
template <typename L>
struct IsStateless_Generic_NoArgs<L, decltype(ZuDeclVal<L &>()(), void())> :
  public IsStateless_Generic_<L, Return<L, ZuTypeList<>>, ZuTypeList<>> { };
template <typename L, typename ArgList, typename = void>
struct IsStateless_Generic_Args : public ZuFalse { };
template <typename L, typename... Args>
struct IsStateless_Generic_Args<
  L, ZuTypeList<Args...>,
  decltype(ZuDeclVal<L &>()(ZuDeclVal<Args>()...), void())> :
  public IsStateless_Generic_<
    L, Return<L, ZuTypeList<Args...>>, ZuTypeList<Args...>> { };
template <typename L, typename ArgList> struct IsStateless_Generic;
template <typename L>
struct IsStateless_Generic<L, ZuTypeList<>> :
  public IsStateless_Generic_NoArgs<L> { };
template <typename L, typename... Args>
struct IsStateless_Generic<L, ZuTypeList<Args...>> :
  public IsStateless_Generic_Args<L, ZuTypeList<Args...>> { };
template <typename L, typename ArgList_, typename = void>
struct IsStateless_ : public IsStateless_Generic<L, ArgList_> { };
template <typename L, typename ArgList_>
struct IsStateless_<L, ArgList_, decltype(&L::operator(), void())> :
  public IsStateless_Fn<L, ArgList_, &L::operator()> { };
template <typename L, typename ArgList_ = ArgList<L>>
using IsStateless = IsStateless_<ZuDecay<L>, ArgList_>;

template <typename L, typename R, typename ArgList_> struct InvokeFnT_;
template <typename L, typename R, typename... Args>
struct InvokeFnT_<L, R, ZuTypeList<Args...>> {
  typedef R (*T)(Args...);
};
template <
  typename L, typename ArgList_ = ArgList<L>, typename R = Return<L, ArgList_>>
using InvokeFnT = typename InvokeFnT_<ZuDecay<L>, R, ArgList_>::T;

} // namespace ZuLambdaTraits

template <typename L> using ZuArgList = ZuLambdaTraits::ArgList<L>;

template <typename L, typename ArgList = ZuArgList<L>>
using ZuIsMutableLambda = ZuLambdaTraits::IsMutable<L, ArgList>;
template <typename L, typename ArgList = ZuArgList<L>>
using ZuIsVoidRetLambda = ZuLambdaTraits::IsVoidRet<L, ArgList>;
template <typename L, typename ArgList = ZuArgList<L>>
using ZuIsStatelessLambda = ZuLambdaTraits::IsStateless<L, ArgList>;
template <typename L, typename ArgList = ZuArgList<L>>
using ZuLambdaReturn = ZuLambdaTraits::Return<L, ArgList>;
template <typename L, typename ArgList = ZuArgList<L>>
using ZuInvokeFnT = ZuLambdaTraits::InvokeFnT<L, ArgList>;

template <typename L, typename ArgList = ZuArgList<L>>
constexpr auto ZuInvokeFn(const L &l) {
  return static_cast<ZuInvokeFnT<L>>(l);
}

template <typename L_, typename ArgList = ZuArgList<L_>, typename... Args>
auto ZuInvokeLambda(Args &&...args) {
  using L = ZuDecay<L_>;
  static_assert(
    ((ZuIsStatelessLambda<L, ArgList>{})), "(ZuIsStatelessLambda<L, ArgList>{})"
  );

  return reinterpret_cast<L *>(

	   0

  )
    ->operator()(ZuFwd<Args>(args)...);
}

template <typename L, typename ArgList = ZuArgList<L>, typename R = void>
using ZuMutableLambda = ZuIfT<ZuIsMutableLambda<L, ArgList>{}, R>;
template <typename L, typename ArgList = ZuArgList<L>, typename R = void>
using ZuNotMutableLambda = ZuIfT<!ZuIsMutableLambda<L, ArgList>{}, R>;
template <typename L, typename ArgList = ZuArgList<L>, typename R = void>
using ZuVoidRetLambda = ZuIfT<ZuIsVoidRetLambda<L, ArgList>{}, R>;
template <typename L, typename ArgList = ZuArgList<L>, typename R = void>
using ZuNotVoidRetLambda = ZuIfT<!ZuIsVoidRetLambda<L, ArgList>{}, R>;
template <typename L, typename ArgList = ZuArgList<L>, typename R = void>
using ZuStatelessLambda = ZuIfT<ZuIsStatelessLambda<L, ArgList>{}, R>;
template <typename L, typename ArgList = ZuArgList<L>, typename R = void>
using ZuNotStatelessLambda = ZuIfT<!ZuIsStatelessLambda<L, ArgList>{}, R>;

class ZmPolymorph

  :
  public ZmObjectDebug

{
  ZmPolymorph(const ZmPolymorph &) = delete;
  ZmPolymorph &operator=(const ZmPolymorph &) = delete;

  friend ZmPolymorph ZuObjectType(ZmPolymorph *);

public:
  ZmPolymorph() : m_refCount{0} { }

  virtual ~ZmPolymorph() { this->del_(); }

  int refCount() const { return m_refCount.load_(); }

  void ref(const void *referrer = 0) const

  {
    if (__builtin_expect(!!(this->deleted_()), 0)) return;
    if (__builtin_expect(!!(this->debugging_()), 0))
      ZmObject_ref(this, referrer);

    this->ref_();
  }

  bool deref(const void *referrer = 0) const

  {
    if (__builtin_expect(!!(this->deleted_()), 0)) return false;
    if (__builtin_expect(!!(this->debugging_()), 0))
      ZmObject_deref(this, referrer);

    return this->deref_();
  }

  void mvref(const void *prev, const void *next) const {
    if (__builtin_expect(!!(this->debugging_()), 0)) {
      ZmObject_ref(this, next);
      ZmObject_deref(this, prev);
    }
  }

  void ref_() const { ++m_refCount; }
  void ref2_() const { m_refCount += 2; }
  bool deref_() const { return !--m_refCount; }

private:
  bool deleted_() const { return m_refCount.load_() < 0; }
  void del_() const { m_refCount.store_(-1); }

  mutable ZmAtomic<int> m_refCount;
};

template <typename Fn> class ZmFn;

class ZmAnyFn {
  struct Pass {
    Pass &operator=(const Pass &) = delete;
  };

  static constexpr const uintptr_t Owned = (uintptr_t(1) << 63);

protected:
  static constexpr bool owned(uintptr_t o) { return o & Owned; }
  static uintptr_t own(uintptr_t o) { return o | Owned; }
  static uintptr_t disown(uintptr_t o) { return o & ~Owned; }

  template <typename O = ZmPolymorph> static O *ptr(uintptr_t o) {
    return reinterpret_cast<O *>(o & ~Owned);
  }

public:
  ZmAnyFn() : m_invoker{0}, m_object{0} { }

  ~ZmAnyFn() {
    if (__builtin_expect(!!(owned(m_object)), 0))
      ZmRef__::ZmDEREF_((ptr(m_object)), this);
  }

  ZmAnyFn(const ZmAnyFn &fn) : m_invoker(fn.m_invoker), m_object(fn.m_object) {
    if (__builtin_expect(!!(owned(m_object)), 0))
      ZmRef__::ZmREF_((ptr(m_object)), this);
  }

  ZmAnyFn(ZmAnyFn &&fn) : m_invoker(fn.m_invoker), m_object(fn.m_object) {
    fn.m_invoker = fn.m_object = 0;

    if (__builtin_expect(!!(owned(m_object)), 0))
      ZmRef__::ZmMVREF_((ptr(m_object)), (&fn), (this));
  }

  ZmAnyFn &operator=(const ZmAnyFn &fn) {
    if (__builtin_expect(!!(this != &fn), 1)) {
      if (__builtin_expect(!!(owned(fn.m_object)), 0))
	ZmRef__::ZmREF_((ptr(fn.m_object)), this);
      if (__builtin_expect(!!(owned(m_object)), 0))
	ZmRef__::ZmDEREF_((ptr(m_object)), this);
      m_invoker = fn.m_invoker;
      m_object = fn.m_object;
    }
    return *this;
  }

  ZmAnyFn &operator=(ZmAnyFn &&fn) {
    if (__builtin_expect(!!(owned(m_object)), 0))
      ZmRef__::ZmDEREF_((ptr(m_object)), this);
    m_invoker = fn.m_invoker;
    m_object = fn.m_object;

    fn.m_invoker = fn.m_object = 0;

    if (__builtin_expect(!!(owned(m_object)), 0))
      ZmRef__::ZmMVREF_((ptr(m_object)), (&fn), (this));

    return *this;
  }

protected:
  template <typename Invoker, typename O>
  ZmAnyFn(const Invoker &invoker, O *o) :
    m_invoker{reinterpret_cast<uintptr_t>(invoker)}, m_object((uintptr_t)o) { }
  template <
    typename Invoker, typename O,
    decltype(ZuBase<ZmPolymorph, O, Pass>(), int()) = 0>
  ZmAnyFn(const Invoker &invoker, ZmRef<O> o) :
    m_invoker{reinterpret_cast<uintptr_t>(invoker)} {
    new (&m_object) ZmRef<O>(ZuMv(o));
    m_object = own(m_object);
  }

public:
  template <typename Fn> const Fn &as() const {
    return *static_cast<const Fn *>(this);
  }
  template <typename Fn> Fn &as() { return *static_cast<Fn *>(this); }

  template <typename O> O *object() const { return ptr<O>(m_object); }
  template <typename O> ZmRef<O> mvObject() {
    if (__builtin_expect(!!(!owned(m_object)), 0)) return ZmRef<O>{object<O>()};
    m_object = disown(m_object);
    return ZmRef<O>::acquire(object<O>());
  }
  template <typename O> void object(O *o) {
    if (__builtin_expect(!!(owned(m_object)), 0))
      ZmRef__::ZmDEREF_((ptr(m_object)), this);
    m_object = reinterpret_cast<uintptr_t>(o);
  }
  template <typename O> void object(ZmRef<O> o) {
    if (__builtin_expect(!!(owned(m_object)), 1))
      ZmRef__::ZmDEREF_((ptr(m_object)), this);
    new (&m_object) ZmRef<O>(ZuMv(o));
    m_object = own(m_object);
  }

  uintptr_t invoker() const { return m_invoker; }

  bool equals(const ZmAnyFn &fn) const {
    return m_invoker == fn.m_invoker && m_object == fn.m_object;
  }
  int cmp(const ZmAnyFn &fn) const {
    if (m_invoker < fn.m_invoker) return -1;
    if (m_invoker > fn.m_invoker) return 1;
    return ZuCmp<uintptr_t>::cmp(m_object, fn.m_object);
  }
  friend inline bool operator==(const ZmAnyFn &l, const ZmAnyFn &r) {
    return l.equals(r);
  }
  friend inline int operator<=>(const ZmAnyFn &l, const ZmAnyFn &r) {
    return l.cmp(r);
  }

  bool operator!() const { return !m_invoker; }
  operator const void *() const {
    return !*this ? reinterpret_cast<const void *>(0) :
		    static_cast<const void *>(this);
  }

  uint32_t hash() const {
    return ZuHash<uintptr_t>::hash(m_invoker) ^
      ZuHash<uintptr_t>::hash(m_object);
  }

  struct Traits : public ZuBaseTraits<ZmAnyFn> {
    enum { IsPOD = 1 };
  };
  friend Traits ZuTraitsType(ZmAnyFn *);

protected:
  uintptr_t m_invoker;
  mutable uintptr_t m_object;
};

inline constexpr const char *ZmLambda_HeapID() { return "ZmLambda"; }

template <typename Fn = void()> class ZmFn;
template <typename R_, typename... Args_>
class ZmFn<R_(Args_...)> : public ZmAnyFn {
  class Pass {
    friend ZmFn;
    Pass &operator=(const Pass &) = delete;
  };

public:
  using R = R_;
  using Args = ZuTypeList<Args_...>;

private:
  typedef R (*Invoker)(uintptr_t &, Args_...);
  template <bool Converts, auto> struct FnInvoker;
  template <typename, bool Converts, auto> struct BoundInvoker;
  template <typename, bool Converts, auto> struct MemberInvoker;

public:
  template <typename L, typename Args__, typename = void>
  struct IsCallable_ : public ZuFalse { };
  template <typename L, typename... Args__>
  struct IsCallable_<
    L, ZuTypeList<Args__...>,
    decltype(ZuDeclVal<L &>()(ZuDeclVal<Args__>()...), void())> :
    public ZuBool<
      ZuInspect<
	decltype(ZuDeclVal<L &>()(ZuDeclVal<Args__>()...)), R>::Converts &&
      !ZuInspect<ZmAnyFn, L>::Is> { };
  template <typename L>
  struct IsCallable : public IsCallable_<L, ZuTypeList<Args_...>> { };
  template <typename L, typename R__ = void>
  using MatchCallable = ZuIfT<IsCallable<L>{}, R__>;
  template <typename O, typename L>
  struct IsBoundCallable : public IsCallable_<L, ZuTypeList<O, Args_...>> { };
  template <typename L> struct IsBoundCallable<Pass, L> : public ZuFalse { };
  template <typename O, typename L, typename R__ = void>
  using MatchBoundCallable = ZuIfT<IsBoundCallable<O, L>{}, R__>;

public:
  ZmFn() : ZmAnyFn{} { }
  ZmFn(const ZmFn &fn) : ZmAnyFn{fn} { }
  ZmFn(ZmFn &&fn) : ZmAnyFn{static_cast<ZmAnyFn &&>(fn)} { }

private:
  template <typename... Args__>
  ZmFn(Pass, Args__ &&...args) : ZmAnyFn(ZuFwd<Args__>(args)...) { }

public:
  template <typename L, decltype(MatchCallable<L>(), int()) = 0>
  ZmFn(L &&l) : ZmAnyFn{fn(ZuFwd<L>(l))} { }
  template <
    typename O, typename L,
    decltype(MatchBoundCallable<ZuDeref<O>, L>(), int()) = 0>
  ZmFn(O &&o, L &&l) : ZmAnyFn{fn(ZuFwd<O>(o), ZuFwd<L>(l))} { }

  ZmFn &operator=(const ZmFn &fn) {
    ZmAnyFn::operator=(fn);
    return *this;
  }
  ZmFn &operator=(ZmFn &&fn) {
    ZmAnyFn::operator=(static_cast<ZmAnyFn &&>(fn));
    return *this;
  }

private:
  ZmFn &operator=(const ZmAnyFn &fn) {
    ZmAnyFn::operator=(fn);
    return *this;
  }
  ZmFn &operator=(ZmAnyFn &&fn) {
    ZmAnyFn::operator=(static_cast<ZmAnyFn &&>(fn));
    return *this;
  }

public:
  template <typename... Args__, typename R__ = R>
  ZuExact<void, R__, R> operator()(Args__ &&...args) const {
    if (ZmAnyFn::operator!()) return;
    (*reinterpret_cast<Invoker>(m_invoker))(m_object, ZuFwd<Args__>(args)...);
  }
  template <typename... Args__, typename R__ = R>
  ZuNotExact<void, R__, R> operator()(Args__ &&...args) const {
    if (ZmAnyFn::operator!()) return {};
    return (*reinterpret_cast<Invoker>(m_invoker))(
      m_object, ZuFwd<Args__>(args)...
    );
  }

  template <auto Fn> struct Ptr;
  template <typename R__, R__ (*Fn)(Args_...)> struct Ptr<Fn> {
    static ZmFn fn() {
      return ZmFn{
	ZmFn::Pass{}, &FnInvoker<ZuInspect<R__, R>::Converts, Fn>::invoke,
	static_cast<void *>(nullptr)
      };
    }
  };

  template <auto Fn> struct Bound;
  template <typename C, typename R__, R__ (*Fn)(C *, Args_...)>
  struct Bound<Fn> {
    template <typename O> static ZmFn fn(O *o) {
      return ZmFn{
	ZmFn::Pass{},
	&BoundInvoker<O *, ZuInspect<R__, R>::Converts, Fn>::invoke, o
      };
    }
    template <typename O> static ZmFn fn(ZmRef<O> o) {
      return ZmFn{
	ZmFn::Pass{},
	&BoundInvoker<ZmRef<O>, ZuInspect<R__, R>::Converts, Fn>::invoke,
	ZuMv(o)
      };
    }
    template <typename O> static ZmFn mvFn(ZmRef<O> o) {
      return ZmFn{
	ZmFn::Pass{},
	&BoundInvoker<ZmRef<O>, ZuInspect<R__, R>::Converts, Fn>::invoke,
	ZuMv(o)
      };
    }
  };
  template <typename O, typename R__, R__ (*Fn)(ZmRef<O>, Args_...)>
  struct Bound<Fn> {
    static ZmFn fn(O *o) {
      return ZmFn{
	ZmFn::Pass{},
	&BoundInvoker<O *, ZuInspect<R__, R>::Converts, Fn>::invoke, o
      };
    }
    static ZmFn fn(ZmRef<O> o) {
      return ZmFn{
	ZmFn::Pass{},
	&BoundInvoker<ZmRef<O>, ZuInspect<R__, R>::Converts, Fn>::invoke,
	ZuMv(o)
      };
    }
    static ZmFn mvFn(ZmRef<O> o) {
      return ZmFn{
	ZmFn::Pass{},
	&BoundInvoker<ZmRef<O>, ZuInspect<R__, R>::Converts, Fn>::mvInvoke,
	ZuMv(o)
      };
    }
  };

  template <auto Fn> struct Member;
  template <typename C, typename R__, R__ (C::*Fn)(Args_...)>
  struct Member<Fn> {
    template <typename O> static ZmFn fn(O *o) {
      return ZmFn{
	ZmFn::Pass{},
	&MemberInvoker<O *, ZuInspect<R__, R>::Converts, Fn>::invoke, o
      };
    }
    template <typename O> static ZmFn fn(ZmRef<O> o) {
      return ZmFn{
	ZmFn::Pass{},
	&MemberInvoker<O *, ZuInspect<R__, R>::Converts, Fn>::invoke, ZuMv(o)
      };
    }
  };
  template <typename C, typename R__, R__ (C::*Fn)(Args_...) const>
  struct Member<Fn> {
    template <typename O> static ZmFn fn(O *o) {
      return ZmFn{
	ZmFn::Pass{},
	&MemberInvoker<const O *, ZuInspect<R__, R>::Converts, Fn>::invoke, o
      };
    }
    template <typename O> static ZmFn fn(ZmRef<O> o) {
      return ZmFn{
	ZmFn::Pass{},
	&MemberInvoker<const O *, ZuInspect<R__, R>::Converts, Fn>::invoke,
	ZuMv(o)
      };
    }
  };

  template <auto HeapID, bool Sharded> struct Lambda;
  template <typename L> static MatchCallable<L, ZmFn> fn(L &&l) {
    return Lambda<ZmLambda_HeapID>::fn(ZuFwd<L>(l));
  }
  template <typename O, typename L>
  static MatchBoundCallable<ZuDeref<O>, L, ZmFn> fn(O &&o, L &&l) {
    return Lambda<ZmLambda_HeapID>::fn(ZuFwd<O>(o), ZuFwd<L>(l));
  }
  template <typename L> static MatchCallable<L, ZmFn> mvFn(L &&l) {
    return Lambda<ZmLambda_HeapID>::mvFn(ZuFwd<L>(l));
  }
  template <typename O, typename L>
  static MatchBoundCallable<ZuDeref<O>, L, ZmFn> mvFn(O &&o, L &&l) {
    return Lambda<ZmLambda_HeapID>::mvFn(ZuFwd<O>(o), ZuFwd<L>(l));
  }

private:
  template <typename L, typename ArgList>
  using IsMutable_ = ZuLambdaTraits::IsMutable<L, ArgList>;
  template <typename L> using IsMutable = IsMutable_<L, ZuTypeList<Args_...>>;
  template <typename O, typename L>
  using IsBoundMutable = IsMutable_<L, ZuTypeList<O, Args_...>>;

  template <typename L>
  using IsStateless = ZuIsStatelessLambda<L, ZuTypeList<Args_...>>;
  template <typename O, typename L>
  using IsBoundStateless = ZuIsStatelessLambda<L, ZuTypeList<O, Args_...>>;

  template <
    auto HeapID, bool Sharded, typename L, bool Stateless = IsStateless<L>{},
    bool Mutable = IsMutable<L>{}>
  struct LambdaInvoker;
  template <
    auto HeapID, bool Sharded, typename O, typename L,
    bool Stateless = IsBoundStateless<O *, L>{},
    bool Mutable = IsBoundMutable<O *, L>{}>
  struct LambdaPtrInvoker;
  template <
    auto HeapID, bool Sharded, typename O, typename L,
    bool Stateless = IsBoundStateless<ZmRef<O>, L>{},
    bool Mutable = IsBoundMutable<ZmRef<O>, L>{}>
  struct LambdaRefInvoker;
  template <
    auto HeapID, bool Sharded, typename O, typename L,
    bool Stateless = IsBoundStateless<ZmRef<O>, L>{},
    bool Mutable = IsBoundMutable<ZmRef<O>, L>{}>
  struct LambdaMvRefInvoker;

public:
  template <auto HeapID, bool Sharded = false> struct Lambda {
    template <typename L> static MatchCallable<L, ZmFn> fn(L &&l) {
      return LambdaInvoker<HeapID, Sharded, L>::fn(ZuFwd<L>(l));
    }
    template <typename O, typename L>
    static MatchBoundCallable<O *, L, ZmFn> fn(O *o, L &&l) {
      return LambdaPtrInvoker<HeapID, Sharded, O, L>::fn(o, ZuFwd<L>(l));
    }
    template <typename O, typename L>
    static MatchBoundCallable<ZmRef<O>, L, ZmFn> fn(ZmRef<O> o, L &&l) {
      return LambdaRefInvoker<HeapID, Sharded, O, L>::fn(ZuMv(o), ZuFwd<L>(l));
    }
    template <typename O, typename L>
    static MatchBoundCallable<ZmRef<O>, L, ZmFn> mvFn(ZmRef<O> o, L &&l) {
      return LambdaMvRefInvoker<HeapID, Sharded, O, L>::fn(
	ZuMv(o), ZuFwd<L>(l)
      );
    }
  };

private:
  template <typename R__, R__ (*Fn)(Args_...)> struct FnInvoker<true, Fn> {
    static R invoke(uintptr_t &, Args_... args) {
      return (*Fn)(ZuFwd<Args_>(args)...);
    }
  };

  template <typename O, typename C, typename R__, R__ (*Fn)(C *, Args_...)>
  struct BoundInvoker<O *, true, Fn> {
    static R invoke(uintptr_t &o, Args_... args) {
      return (*Fn)(static_cast<C *>(ptr<O>(o)), ZuFwd<Args_>(args)...);
    }
  };
  template <typename O, typename R__, R__ (*Fn)(ZmRef<O>, Args_...)>
  struct BoundInvoker<ZmRef<O>, true, Fn> {
    static R invoke(uintptr_t &o, Args_... args) {
      return (*Fn)(ptr<O>(o), ZuFwd<Args_>(args)...);
    }
    static R mvInvoke(uintptr_t &o, Args_... args) {
      o = disown(o);
      return (*Fn)(ZmRef<O>::acquire(ptr<O>(o)), ZuFwd<Args_>(args)...);
    }
  };

  template <typename O, typename C, typename R__, R__ (C::*Fn)(Args_...)>
  struct MemberInvoker<O *, true, Fn> {
    static R invoke(uintptr_t &o, Args_... args) {
      return (static_cast<C *>(ptr<O>(o))->*Fn)(ZuFwd<Args_>(args)...);
    }
  };
  template <typename O, typename C, typename R__, R__ (C::*Fn)(Args_...)>
  struct MemberInvoker<ZmRef<O>, true, Fn> {
    static R invoke(uintptr_t &o, Args_... args) {
      return (static_cast<C *>(ptr<O>(o))->*Fn)(ZuFwd<Args_>(args)...);
    }
  };
  template <typename O, typename C, typename R__, R__ (C::*Fn)(Args_...) const>
  struct MemberInvoker<O *, true, Fn> {
    static R invoke(uintptr_t &o, Args_... args) {
      return (static_cast<const C *>(ptr<O>(o))->*Fn)(ZuFwd<Args_>(args)...);
    }
  };
  template <typename O, typename C, typename R__, R__ (C::*Fn)(Args_...) const>
  struct MemberInvoker<ZmRef<O>, true, Fn> {
    static R invoke(uintptr_t &o, Args_... args) {
      return (static_cast<const C *>(ptr<O>(o))->*Fn)(ZuFwd<Args_>(args)...);
    }
  };

  template <auto HeapID, bool Sharded, typename L>
  struct LambdaInvoker<HeapID, Sharded, L, true, false> {
    static R invoke(uintptr_t &, Args_... args) {
      return ZuInvokeLambda<L, ZuTypeList<Args_...>>(ZuFwd<Args_>(args)...);
    }
    static ZmFn fn(L &&) {
      return {
	ZmFn::Pass{}, &LambdaInvoker::invoke, static_cast<void *>(nullptr)
      };
    }
  };

  template <auto HeapID, bool Sharded, typename L>
  struct LambdaInvoker<HeapID, Sharded, L, false, false> {
    template <typename L_> static ZmFn fn(L_ &&l);
  };

  template <auto HeapID, bool Sharded, typename L>
  struct LambdaInvoker<HeapID, Sharded, L, false, true> {
    template <typename L_> static ZmFn fn(L_ &&l);
  };

  template <auto HeapID, bool Sharded, typename O, typename L>
  struct LambdaPtrInvoker<HeapID, Sharded, O, L, false, false> {
    static ZmFn fn(O *o, L l) {
      return Lambda<HeapID, Sharded>::fn([o, l = ZuMv(l)](Args_... args) {
	l(o, ZuFwd<Args_>(args)...);
      });
    }
  };

  template <auto HeapID, bool Sharded, typename O, typename L>
  struct LambdaPtrInvoker<HeapID, Sharded, O, L, false, true> {
    static ZmFn fn(O *o, L l) {
      return Lambda<HeapID, Sharded>::fn(
	[o, l = ZuMv(l)](Args_... args) mutable { l(o, ZuFwd<Args_>(args)...); }
      );
    }
  };

  template <auto HeapID, bool Sharded, typename O, typename L>
  struct LambdaRefInvoker<HeapID, Sharded, O, L, false, false> {
    static ZmFn fn(ZmRef<O> o, L l) {
      return Lambda<HeapID, Sharded>::fn([o = ZuMv(o), l = ZuMv(l)](
					   Args_... args
					 ) { l(o, ZuFwd<Args_>(args)...); });
    }
  };

  template <auto HeapID, bool Sharded, typename O, typename L>
  struct LambdaRefInvoker<HeapID, Sharded, O, L, false, true> {
    static ZmFn fn(ZmRef<O> o, L l) {
      return Lambda<HeapID, Sharded>::fn([o = ZuMv(o),
					  l = ZuMv(l)](Args_... args) mutable {
	l(o, ZuFwd<Args_>(args)...);
      });
    }
  };

  template <auto HeapID, bool Sharded, typename O, typename L>
  struct LambdaMvRefInvoker<HeapID, Sharded, O, L, false, false> {
    static ZmFn fn(ZmRef<O> o, L l) {
      return Lambda<HeapID, Sharded>::fn([o = ZuMv(o),
					  l = ZuMv(l)](Args_... args) mutable {
	l(ZuMv(o), ZuFwd<Args_>(args)...);
      });
    }
  };

  template <auto HeapID, bool Sharded, typename O, typename L>
  struct LambdaMvRefInvoker<HeapID, Sharded, O, L, false, true> {
    static ZmFn fn(ZmRef<O> o, L l) {
      return Lambda<HeapID, Sharded>::fn([o = ZuMv(o),
					  l = ZuMv(l)](Args_... args) mutable {
	l(ZuMv(o), ZuFwd<Args_>(args)...);
      });
    }
  };

  template <auto HeapID, bool Sharded, typename O, typename L>
  struct LambdaPtrInvoker<HeapID, Sharded, O, L, true, false> {
    static R invoke(uintptr_t &o, Args_... args) {
      return reinterpret_cast<const L *>(0)->operator()(
	ptr<O>(o), ZuFwd<Args_>(args)...
      );
    }
    static ZmFn fn(O *o, L) {
      return ZmFn{ZmFn::Pass{}, &LambdaPtrInvoker::invoke, o};
    }
  };

  template <auto HeapID, bool Sharded, typename O, typename L>
  struct LambdaRefInvoker<HeapID, Sharded, O, L, true, false> {
    static R invoke(uintptr_t &o, Args_... args) {
      return reinterpret_cast<const L *>(0)->operator()(
	ptr<O>(o), ZuFwd<Args_>(args)...
      );
    }
    static ZmFn fn(ZmRef<O> o, L) {
      return ZmFn{ZmFn::Pass{}, &LambdaRefInvoker::invoke, ZuMv(o)};
    }
  };

  template <auto HeapID, bool Sharded, typename O, typename L>
  struct LambdaMvRefInvoker<HeapID, Sharded, O, L, true, false> {
    static R invoke(uintptr_t &o, Args_... args) {
      o = disown(o);
      return reinterpret_cast<const L *>(0)->operator()(
	ZmRef<O>::acquire(ptr<O>(o)), ZuFwd<Args_>(args)...
      );
    }
    static ZmFn fn(ZmRef<O> o, L) {
      return ZmFn{ZmFn::Pass{}, &LambdaMvRefInvoker::invoke, ZuMv(o)};
    }
  };

  friend ZuTraits<ZmAnyFn> ZuTraitsType(ZmFn *);
};

namespace ZmCleanup {
enum { Application = 0, Library, Platform, Heap, HeapMgr, Thread, Final, N };
}

namespace std __attribute__((__visibility__("default"))) {

  struct type_index {
    type_index(const type_info &__rhs) noexcept : _M_target(&__rhs) { }

    bool operator==(const type_index &__rhs) const noexcept {
      return *_M_target == *__rhs._M_target;
    }

    bool operator<(const type_index &__rhs) const noexcept {
      return _M_target->before(*__rhs._M_target);
    }

    bool operator<=(const type_index &__rhs) const noexcept {
      return !__rhs._M_target->before(*_M_target);
    }

    bool operator>(const type_index &__rhs) const noexcept {
      return __rhs._M_target->before(*_M_target);
    }

    bool operator>=(const type_index &__rhs) const noexcept {
      return !_M_target->before(*__rhs._M_target);
    }

    strong_ordering operator<=>(const type_index &__rhs) const noexcept {
      if (*_M_target == *__rhs._M_target) return strong_ordering::equal;
      if (_M_target->before(*__rhs._M_target)) return strong_ordering::less;
      return strong_ordering::greater;
    }

    size_t hash_code() const noexcept { return _M_target->hash_code(); }

    const char *name() const noexcept { return _M_target->name(); }

  private:
    const type_info *_M_target;
  };

  template <typename _Tp> struct hash;

  template <> struct hash<type_index> {
    typedef size_t result_type;
    typedef type_index argument_type;

    size_t operator()(const type_index &__ti) const noexcept {
      return __ti.hash_code();
    }
  };

} // namespace std

extern "C" {
  extern void ZmGlobal_atexit();
}

class ZuVStream;

class ZmGlobal {
  ZmGlobal(const ZmGlobal &);
  ZmGlobal &operator=(const ZmGlobal &);

  friend void ZmGlobal_atexit();

public:
  virtual ~ZmGlobal() { }

protected:
  ZmGlobal() :
    m_type(typeid(void)),

    m_name(nullptr),

    m_next(nullptr) { }

private:
  std::type_index m_type;

  const char *m_name;

  ZmGlobal *m_next;

  static ZmGlobal *
  add(std::type_index type, unsigned level, ZmGlobal *(*ctor)());

  static void dump(ZuVStream &);

  template <typename T> struct Ctor {
    static ZmGlobal *_() {
      ZmGlobal *global = static_cast<ZmGlobal *>(new T());
      const std::type_info &info = typeid(T);
      global->m_type = std::type_index(info);

      global->m_name = info.name();

      return global;
    }
  };

protected:
  template <typename T, unsigned Level> static T *global() {
    static uintptr_t addr_ = 0;
    ZmAtomic<uintptr_t> *__attribute__((__may_alias__)) addr =
      reinterpret_cast<ZmAtomic<uintptr_t> *>(&addr_);
    uintptr_t ptr;
    while (__builtin_expect(!!(!((ptr = addr->load_()) & ~1)), 0)) {
      if ((ptr == 1) || addr->cmpXch(1, 0)) {
	Zm::yield();
	continue;
      }
      *addr = ptr =
	reinterpret_cast<uintptr_t>(ZmGlobal::add(typeid(T), Level, &Ctor<T>::_)
	);
    }
    return static_cast<T *>(reinterpret_cast<ZmGlobal *>(ptr));
  }
};

class ZmSpecific_;
struct ZmSpecific_Object;

extern "C" {
  extern void ZmSpecific_lock();
  extern void ZmSpecific_unlock();
}

struct ZmSpecific_Object {
  typedef void (*DtorFn)(ZmSpecific_Object *);

  ZmSpecific_Object() { }
  ~ZmSpecific_Object() {
    ZmSpecific_lock();
    dtor();
  }

  void dtor() {
    if (__builtin_expect(!!(dtorFn), 1))
      (*dtorFn)(this);
    else
      ZmSpecific_unlock();
  }

  ZmObject *ptr = nullptr;
  DtorFn dtorFn = nullptr;
  ZmSpecific_Object *prev = nullptr;
  ZmSpecific_Object *next = nullptr;
};

template <typename O = ZmSpecific_Object> struct ZmSpecific_Allocator {
  pthread_key_t key;

  ZmSpecific_Allocator() {
    pthread_key_create(&key, [](void *o) { delete static_cast<O *>(o); });
  }
  ~ZmSpecific_Allocator() { pthread_key_delete(key); }

  bool set(const O *o) const {
    return pthread_setspecific(key, static_cast<const void *>(o));
  }
  O *get() const { return static_cast<O *>(pthread_getspecific(key)); }
};

class ZmSpecific_ {
  using Object = ZmSpecific_Object;

public:
  ZmSpecific_() { }
  ~ZmSpecific_() {
    Object *o = nullptr;
    for (;;) {
      ZmSpecific_lock();
      o = m_head;
      if (!o) {
	ZmSpecific_unlock();
	return;
      }
      o->dtor();
    }
  }

  void add(Object *o) {
    o->prev = nullptr;
    if (!(o->next = m_head))
      m_tail = o;
    else
      m_head->prev = o;
    m_head = o;

    ++m_count;
  }
  void del(Object *o) {
    if (!o->prev)
      m_head = o->next;
    else
      o->prev->next = o->next;
    if (!o->next)
      m_tail = o->prev;
    else
      o->next->prev = o->prev;

    o->dtorFn = nullptr;
    --m_count;
  }

  template <typename L> void all_(L l) { all_2(&l); }

  template <typename L> void all_2(L *l) {
    ZmSpecific_lock();

    if (__builtin_expect(!!(!m_count), 0)) {
      ZmSpecific_unlock();
      return;
    }

    auto objects = static_cast<Object **>(__builtin_alloca_with_align(
      m_count * sizeof(Object *), (alignof(Object *)) << 3
    ));
    if (__builtin_expect(!!(!objects), 0)) {
      ZmSpecific_unlock();
      return;
    }
    memset(objects, 0, sizeof(Object *) * m_count);
    all_3(objects, l);
  }

  template <typename L> void all_3(Object **objects, L *l) {
    unsigned j = 0, n = m_count;

    for (Object *o = m_head; j < n && o; ++j, o = o->next)
      if (!o->ptr)
	objects[j] = nullptr;
      else
	objects[j] = o;

    using Ptr = ZuType<0, typename ZuDeduce<decltype(&L::operator())>::Args>;

    for (j = 0; j < n; j++)
      if (Object *o = objects[j])
	if (Ptr ptr = static_cast<Ptr>(o->ptr)) ZmRef__::ZmREF_((ptr), this);

    ZmSpecific_unlock();

    for (j = 0; j < n; j++)
      if (Object *o = objects[j])
	if (Ptr ptr = static_cast<Ptr>(o->ptr)) {
	  (*l)(ptr);
	  ZmRef__::ZmDEREF_((ptr), this);
	}
  }

protected:
  using Allocator = ZmSpecific_Allocator<>;

  inline const Allocator &allocator() { return m_allocator; }

  Allocator m_allocator;

private:
  unsigned m_count = 0;
  Object *m_head = nullptr;
  Object *m_tail = nullptr;
};

struct ZmSpecific_Defaults {
  enum { Construct = true };
  template <typename T> struct Ctor {
    static constexpr auto Fn = []() { return new T(); };
  };
  enum { Cleanup = ZmCleanup::Application };
};

template <typename NTP = ZmSpecific_Defaults>
struct ZmSpecificNoCtor : public NTP {
  enum { Construct = false };
};

template <auto CtorFn_, typename NTP = ZmSpecific_Defaults>
struct ZmSpecificCtor : public NTP {
  enum { Construct = true };
  template <typename T> struct Ctor {
    static constexpr auto Fn = CtorFn_;
  };
};

template <unsigned Cleanup_, typename NTP = ZmSpecific_Defaults>
struct ZmSpecificCleanup : public NTP {
  enum { Cleanup = Cleanup_ };
};

template <class T_, typename NTP = ZmSpecific_Defaults>
class ZmSpecific : public ZmGlobal, public ZmSpecific_ {
  ZmSpecific(const ZmSpecific &);
  ZmSpecific &operator=(const ZmSpecific &);

public:
  using T = T_;
  enum { Construct = NTP::Construct };
  static constexpr auto CtorFn = NTP::template Ctor<T>::Fn;
  enum { Cleanup = NTP::Cleanup };

private:
  static void final(...) { }
  template <typename U> static auto final(U *u) -> decltype(u->final()) {
    return u->final();
  }

  using Object = ZmSpecific_Object;

  inline static ZmSpecific *global() {
    return ZmGlobal::global<ZmSpecific, Cleanup>();
  }

public:
  ZmSpecific() { }
  ~ZmSpecific() { }

private:
  using ZmSpecific_::add;
  using ZmSpecific_::del;

  inline Object *local_() {
    Object *o = allocator().get();
    if (__builtin_expect(!!(o), 1)) return o;
    o = new Object{};
    allocator().set(o);
    return o;
  }

  void dtor_(Object *o) {
    T *ptr;
    if (ptr = static_cast<T *>(o->ptr)) {
      this->del(o);
      o->ptr = nullptr;
    }
    ZmSpecific_unlock();
    if (ptr) {
      final(ptr);
      ZmRef__::ZmDEREF_((ptr), this);
    }
  }

  static void dtor__(Object *o) { global()->dtor_(o); }

  template <bool Construct_ = Construct>
  ZuIfT<!Construct_, T *> create_(Object *) {
    return nullptr;
  }
  template <bool Construct_ = Construct>
  ZuIfT<Construct_, T *> create_(Object *o) {
    T *ptr = nullptr;
    ZmSpecific_lock();
    if (o->ptr) {
      ptr = static_cast<T *>(o->ptr);
      ZmSpecific_unlock();
      return ptr;
    }

    ZmSpecific_unlock();
    ptr = CtorFn();
    ZmSpecific_lock();
retry:
    if (!o->ptr) {
      o->ptr = ptr;
      o->dtorFn = dtor__;
      add(o);
      ZmRef__::ZmREF_((ptr), this);
    } else {
      dtor_(o);
      ZmSpecific_lock();
      goto retry;
    }

    ZmSpecific_unlock();
    return ptr;
  }

  T *instance_() {
    Object *o = local_();
    auto ptr = o->ptr;
    if (__builtin_expect(!!(!ptr), 0)) return create_(o);
    return static_cast<T *>(ptr);
  }
  T *instance_(T *ptr) {
    Object *o = local_();
    ZmSpecific_lock();

retry:
    if (!o->ptr) {
      o->ptr = ptr;
      o->dtorFn = dtor__;
      add(o);
      ZmRef__::ZmREF_((ptr), this);
    } else {
      dtor_(o);
      ZmSpecific_lock();
      goto retry;
    }

    ZmSpecific_unlock();
    return ptr;
  }

public:
  inline static T *instance() { return global()->instance_(); }
  static T *instance(T *ptr) { return global()->instance_(ptr); }

  template <typename L> static void all(L l) { return global()->all_(ZuMv(l)); }
};

template <typename T, auto> struct ZmTLS_ : public ZmObject {
  T v = {};
  ZmTLS_() = default;
  template <typename U> ZmTLS_(U &&v_) : v{ZuFwd<U>(v_)} { }
};

template <
  unsigned Cleanup = ZmCleanup::Application, typename L,
  decltype(ZuStatelessLambda<L>(), int()) = 0>
inline auto &ZmTLS(L l) {
  using T = ZuDecay<decltype(ZuDeclVal<ZuLambdaReturn<L>>())>;
  using Object = ZmTLS_<T, &L::operator()>;
  auto m = []() { return new Object{ZuInvokeLambda<L>()}; };
  using TLS = ZmSpecific<
    Object, ZmSpecificCtor<ZuInvokeFn(m), ZmSpecificCleanup<Cleanup>>>;
  return TLS::instance()->v;
}

template <
  typename T, auto Scope = nullptr, unsigned Cleanup = ZmCleanup::Application>
inline auto &ZmTLS() {
  using TLS = ZmSpecific<ZmTLS_<T, Scope>, ZmSpecificCleanup<Cleanup>>;
  return TLS::instance()->v;
}

using ZmPLock_ = uint32_t;

inline void ZmPLock_lock_(ZmPLock_ &m) {
  int i = 0x00010000, j;
  __asm__ __volatile__(
    "lock; xaddl %0, %1\n\t"
    "movzwl %w0, %2\n\t"
    "shrl $16, %0\n"
    "1:\tcmpl %0, %2\n\t"
    "je 2f\n\t"
    "rep; nop\n\t"
    "movzwl %1, %2\n\t"
    "jmp 1b\n"
    "2:"
    : "+r"(i), "+m"(m), "=&r"(j)
    :
    : "memory", "cc"
  );
}

inline bool ZmPLock_trylock_(ZmPLock_ &m) {
  int i, j;
  __asm__ __volatile__(
    "movl %2,%0\n\t"
    "movl %0,%1\n\t"
    "roll $16, %0\n\t"
    "cmpl %0,%1\n\t"

    "leal 0x00010000(%q0), %1\n\t"

    "jne 1f\n\t"
    "lock; cmpxchgl %1,%2\n"
    "1:\tsete %b1\n\t"
    "movzbl %b1,%0\n\t"
    : "=&a"(i), "=&q"(j), "+m"(m)
    :
    : "memory", "cc"
  );
  return !i;
}

inline void ZmPLock_unlock_(ZmPLock_ &m) {
  __asm__ __volatile__("lock; incw %0" : "+m"(m) : : "memory", "cc");
}

class ZmPLock {
  ZmPLock(const ZmPLock &);
  ZmPLock &operator=(const ZmPLock &);

public:
  inline ZmPLock() { m_lock = 0; }
  inline ~ZmPLock() { (void()); }

  inline void lock() { ZmPLock_lock_(m_lock); }
  inline int trylock() { return -!ZmPLock_trylock_(m_lock); }
  inline void unlock() { ZmPLock_unlock_(m_lock); }

  struct Wait { };
  Wait wait() { return {}; }
  inline void lock_() { ZmPLock_lock_(m_lock); }
  inline void unlock_() { ZmPLock_unlock_(m_lock); }

private:
  ZmPLock_ m_lock;
};

template <> struct ZmLockTraits<ZmPLock> : public ZmGenericLockTraits<ZmPLock> {
  enum { CanTry = 1, Recursive = 0, RWLock = 0 };
};

class ZmHeapMgr;
class ZmHeapMgr_;
class ZmHeapCache;
template <auto ID, unsigned Size, unsigned Algnment, bool Sharded>
class ZmHeap__;
template <auto ID, unsigned Size, unsigned Algnment, bool Sharded>
class ZmHeapCacheT;

struct ZmHeapConfig {
  uint64_t cacheSize;
  ZmBitmap cpuset;
};

struct ZmHeapInfo {
  const char *id;
  unsigned size;
  unsigned alignment;
  unsigned partition;
  bool sharded;
  ZmHeapConfig config;
};

struct ZmHeapStats {
  uint64_t heapAllocs;
  uint64_t cacheAllocs;
  uint64_t frees;
};

struct ZmHeapTelemetry {
  ZmIDString id;
  uint64_t cacheSize = 0;
  ZmBitmap cpuset;
  uint64_t cacheAllocs = 0;
  uint64_t heapAllocs = 0;
  uint64_t frees = 0;
  uint32_t size = 0;
  uint16_t partition = 0;
  uint8_t sharded = 0;
  uint8_t alignment = 0;
};

class ZmHeapLookup;

typedef void (*ZmHeapStatsFn)();

class ZmHeapCache : public ZmObject {
  friend ZmHeapMgr;
  friend ZmHeapMgr_;
  friend ZmHeapLookup;
  template <auto, unsigned, unsigned, bool> friend class ZmHeap__;
  template <auto, unsigned, unsigned, bool> friend class ZmHeapCacheT;

  enum { CacheLineSize = Zm::CacheLineSize };

  using Lock = ZmPLock;
  using Guard = ZmGuard<Lock>;

  using StatsFn = ZmHeapStatsFn;

  void stats(const ZmHeapStats &s) {
    m_stats.heapAllocs += s.heapAllocs;
    m_stats.cacheAllocs += s.cacheAllocs;
    m_stats.frees += s.frees;
  }

  static const char *IDAxor(const ZmHeapCache *this_) {
    return this_->m_info.id;
  }
  using IDSize = ZuTuple<const char *, unsigned>;

  using Key = ZuTuple<const char *, unsigned, unsigned, unsigned, bool>;
  static Key KeyAxor(const ZmHeapCache *this_) {
    const auto &info = this_->m_info;
    return {info.id, info.partition, info.size, info.alignment, info.sharded};
  }

  void *operator new(size_t s);
  void *operator new(size_t s, void *p);

public:
  void operator delete(void *p);

private:
  ZmHeapCache(
    const char *id, unsigned size, unsigned alignment, unsigned partition,
    bool sharded, const ZmHeapConfig &, StatsFn, hwloc_topology_t
  );

  void lookup(ZmHeapLookup *l) { m_lookup = l; }
  ZmHeapLookup *lookup() const { return m_lookup; }

public:
  ~ZmHeapCache();

  const ZmHeapInfo &info() const { return m_info; }

  void telemetry(ZmHeapTelemetry &data) const;

  typedef void (*TraceFn)(const char *, unsigned);

private:
  void init(const ZmHeapConfig &, hwloc_topology_t);
  void init_(hwloc_topology_t);
  void final_();

  template <unsigned Align> void *alloc(ZmHeapStats &stats) {
    {
      TraceFn fn;
      if (__builtin_expect(!!(fn = m_traceAllocFn), 0))
	(*fn)(m_info.id, m_info.size);
    }

    void *ptr;
    if (__builtin_expect(!!(ptr = alloc_()), 1)) {
      ++stats.cacheAllocs;
      return ptr;
    }
    ptr = Zm::alignedAlloc<Align>(m_info.size);
    if (__builtin_expect(!!(!ptr), 0)) throw std::bad_alloc{};
    ++stats.heapAllocs;
    return ptr;
  }

  void free(ZmHeapStats &stats, void *p);

  void *alloc_() {
    uintptr_t p;
loop:
    p = m_head.load_();
    if (__builtin_expect(!!(!p), 0)) return nullptr;
    if (__builtin_expect(!!(m_info.sharded), 1)) {
      m_head.store_(*reinterpret_cast<uintptr_t *>(p));
      return reinterpret_cast<void *>(p);
    }
    if (__builtin_expect(!!(p & 1), 0)) {
      __atomic_thread_fence(2);
      goto loop;
    }
    if (__builtin_expect(!!(m_head.cmpXch(p | 1, p) != p), 0)) goto loop;
    m_head = reinterpret_cast<ZmAtomic<uintptr_t> *>(p)->load_();
    return reinterpret_cast<void *>(p);
  }
  void free_(void *p) {
    uintptr_t n;
loop:
    n = m_head.load_();
    if (n & 1) {
      __atomic_thread_fence(2);
      goto loop;
    }
    reinterpret_cast<ZmAtomic<uintptr_t> *>(p)->store_(n);
    if (m_head.cmpXch(reinterpret_cast<uintptr_t>(p), n) != n) goto loop;
  }
  void free_sharded(void *p) {
    *reinterpret_cast<uintptr_t *>(p) = m_head.load_();
    m_head.store_(reinterpret_cast<uintptr_t>(p));
  }

  bool owned(void *p) const { return p >= m_begin && p < m_end; }

  void stats() const;
  void histStats(const ZmHeapStats &stats) const;

  ZmAtomic<uintptr_t> m_head;
  char m__pad[CacheLineSize - sizeof(uintptr_t)];

  ZmHeapInfo m_info;
  ZmHeapLookup *m_lookup = nullptr;
  StatsFn m_statsFn;

  void *m_begin = nullptr;
  void *m_end = nullptr;

  TraceFn m_traceAllocFn = nullptr;
  TraceFn m_traceFreeFn = nullptr;

  using HistLock = ZmPLock;
  using HistGuard = ZmGuard<HistLock>;
  using HistReadGuard = ZmReadGuard<HistLock>;

  mutable HistLock m_histLock;
  mutable ZmHeapStats m_histStats{};
  mutable ZmHeapStats m_stats{};
};

class ZmHeapMgr {
  friend ZmHeapCache;
  template <auto, unsigned, unsigned, bool> friend class ZmHeapCacheT;

  template <class S> struct CSV_ {
    CSV_(S &stream) : m_stream(stream) { }
    void print() {
      m_stream << "ID,size,partition,sharded,alignment,cacheSize,cpuset,"
		  "cacheAllocs,heapAllocs,frees\n";
      ZmHeapMgr::all(ZmFn<void(ZmHeapCache *)>::Member<&CSV_::print_>::fn(this)
      );
    }
    void print_(ZmHeapCache *cache) {
      ZmHeapTelemetry data;
      cache->telemetry(data);
      m_stream << '"' << data.id << "\"," << ZuBoxed(data.size) << ','
	       << ZuBoxed(data.partition) << ',' << ZuBoxed(data.sharded) << ','
	       << ZuBoxed(data.alignment) << ',' << ZuBoxed(data.cacheSize)
	       << ',' << data.cpuset << ',' << ZuBoxed(data.cacheAllocs) << ','
	       << ZuBoxed(data.heapAllocs) << ',' << ZuBoxed(data.frees)
	       << '\n';
    }

  private:
    S &m_stream;
  };

public:
  static void
  init(const char *id, unsigned partition, const ZmHeapConfig &config);

  static void all(ZmFn<void(ZmHeapCache *)> fn);

  struct CSV {
    template <typename S> void print(S &s) const {
      ZmHeapMgr::CSV_<S>(s).print();
    }
    friend ZuPrintFn ZuPrintType(CSV *);
  };
  static CSV csv() { return CSV(); }

  using TraceFn = ZmHeapCache::TraceFn;

  static void trace(const char *id, TraceFn allocFn, TraceFn freeFn);

private:
  using StatsFn = ZmHeapStatsFn;

  static ZmHeapCache *cache(
    const char *id, unsigned size, unsigned alignment, bool sharded, StatsFn
  );
};

template <auto ID, unsigned Size, unsigned Align, bool Sharded>
class ZmHeapCacheT : public ZmObject {
  using TLS = ZmSpecific<ZmHeapCacheT, ZmSpecificCleanup<ZmCleanup::Heap>>;

public:
  ZmHeapCacheT() :
    m_cache{ZmHeapMgr::cache(ID(), Size, Align, Sharded, &stats)}, m_stats{} { }
  ~ZmHeapCacheT() { m_cache->histStats(m_stats); }

  static void stats();

  static ZmHeapCacheT *instance() { return TLS::instance(); }
  static void *alloc() {
    ZmHeapCacheT *this_ = instance();
    return this_->m_cache->template alloc<Align>(this_->m_stats);
  }
  static void free(void *p) {
    ZmHeapCacheT *this_ = instance();
    this_->m_cache->free(this_->m_stats, p);
  }

private:
  ZmHeapCache *m_cache;
  ZmHeapStats m_stats;
};

template <
  unsigned Size_, bool Small = (Size_ <= sizeof(uintptr_t)),
  unsigned RShift = 0, bool Big = (Size_ > (Zm::CacheLineSize >> RShift))>
struct ZmHeapAllocSize;
template <unsigned Size_, unsigned RShift, bool Big>
struct ZmHeapAllocSize<Size_, true, RShift, Big> {
  enum { N = sizeof(uintptr_t) };
};
template <unsigned Size_, unsigned RShift>
struct ZmHeapAllocSize<Size_, false, RShift, false> {
  enum { N = ZmHeapAllocSize<Size_, false, RShift + 1>::N };
};
template <unsigned Size_, unsigned RShift>
struct ZmHeapAllocSize<Size_, false, RShift, true> {
  enum { N = (Zm::CacheLineSize >> (RShift - 1)) };
};
template <unsigned Size_> struct ZmHeapAllocSize<Size_, false, 0, true> {
  enum { N = ((Size_ + Zm::CacheLineSize - 1) & ~(Zm::CacheLineSize - 1)) };
};

template <typename Heap> class ZmHeap_Init {
  template <auto, unsigned, unsigned, bool> friend class ZmHeap__;
  ZmHeap_Init();
};

template <auto ID_, unsigned Size_, unsigned Align_, bool Sharded_>
class ZmHeap__ {
public:
  static constexpr auto HeapID = ID_;
  enum { AllocSize = ZmHeapAllocSize<Size_>::N };
  enum { Align = Align_ };
  enum { Sharded = Sharded_ };

private:
  using Cache = ZmHeapCacheT<HeapID, AllocSize, Align, Sharded>;

public:
  void *operator new(size_t) { return Cache::alloc(); }
  void *operator new(size_t, void *p) noexcept { return p; }
  void operator delete(void *p) noexcept {
    if (__builtin_expect(!!(!p), 0)) return;
    Cache::free(p);
  }

private:
  static ZmHeap_Init<ZmHeap__> m_init;
};

template <typename Heap> ZmHeap_Init<Heap>::ZmHeap_Init() { delete new Heap(); }

template <auto ID, unsigned Size, unsigned Align, bool Sharded>
ZmHeap_Init<ZmHeap__<ID, Size, Align, Sharded>>
  ZmHeap__<ID, Size, Align, Sharded>::m_init;

inline constexpr auto ZmHeapDisable() {
  return []() -> const char * { return nullptr; };
};

template <auto ID, unsigned Size, unsigned Align, bool Sharded> struct ZmHeap_ {
  using T = ZmHeap__<ID, Size, Align, Sharded>;
};
template <unsigned Size, unsigned Align, bool Sharded>
struct ZmHeap_<ZmHeapDisable(), Size, Align, Sharded> {
  using T = ZuEmpty;
};
template <auto ID, typename T, bool Sharded = false>
using ZmHeap = typename ZmHeap_<ID, sizeof(T), alignof(T), Sharded>::T;

template <typename Heap, typename L, typename ArgList> struct ZmLambda_;
template <typename Heap, typename L, typename... Args>
struct ZmLambda_<Heap, L, ZuTypeList<Args...>> :
  public Heap,
  public ZmPolymorph,
  public L {
  template <typename L_> ZmLambda_(L_ &&l) : L{ZuFwd<L_>(l)} { }
  decltype(auto) invoke(Args... args) {
    return L::operator()(ZuFwd<Args>(args)...);
  }
  decltype(auto) cinvoke(Args... args) const {
    return L::operator()(ZuFwd<Args>(args)...);
  }
  ZmLambda_() = delete;
  ZmLambda_(const ZmLambda_ &) = delete;
  ZmLambda_ &operator=(const ZmLambda_ &) = delete;
  ZmLambda_(ZmLambda_ &&) = delete;
  ZmLambda_ &operator=(ZmLambda_ &&) = delete;
};
template <auto HeapID, bool Sharded, typename L, typename ArgList>
using ZmLambda = ZmLambda_<
  ZmHeap<HeapID, ZmLambda_<ZuEmpty, L, ArgList>, Sharded>, L, ArgList>;

template <typename R_, typename... Args_>
template <auto HeapID, bool Sharded, typename L>
template <typename L_>
ZmFn<R_(Args_...)>
ZmFn<R_(Args_...)>::LambdaInvoker<HeapID, Sharded, L, false, false>::fn(L_ &&l
) {
  static_assert(((!IsMutable<L>{})), "(!IsMutable<L>{})");
  static_assert(((!IsMutable<ZuDecay<L_>>{})), "(!IsMutable<ZuDecay<L_>>{})");

  using O = ZmLambda<HeapID, Sharded, ZuDecay<L>, Args>;
  return Member<&O::cinvoke>::fn(ZmRef<const O>{new O{ZuFwd<L_>(l)}});
}

template <typename R_, typename... Args_>
template <auto HeapID, bool Sharded, typename L>
template <typename L_>
ZmFn<R_(Args_...)>
ZmFn<R_(Args_...)>::LambdaInvoker<HeapID, Sharded, L, false, true>::fn(L_ &&l) {
  using O = ZmLambda<HeapID, Sharded, ZuDecay<L>, Args>;
  return Member<&O::invoke>::fn(ZmRef<O>{new O{ZuFwd<L>(l)}});
}

template <auto ID, unsigned Size, unsigned Align, bool Sharded>
inline void ZmHeapCacheT<ID, Size, Align, Sharded>::stats() {
  TLS::all([](ZmHeapCacheT *this_) { this_->m_cache->stats(this_->m_stats); });
}

template <typename Base, typename Heap, bool = ZuInspect<Heap, Base>::Is>
struct ZmNode__;
template <typename Base, typename Heap>
struct ZmNode__<Base, Heap, false> : public Heap, public Base {
  using Base::Base;
  template <typename... Args>
  ZmNode__(Args &&...args) : Base(ZuFwd<Args>(args)...) { }
};
template <typename Base, typename Heap>
struct ZmNode__<Base, Heap, true> : public Base {
  using Base::Base;
  template <typename... Args>
  ZmNode__(Args &&...args) : Base(ZuFwd<Args>(args)...) { }
};
template <typename Base> struct ZmNode__<Base, ZuEmpty, false> : public Base {
  using Base::Base;
  template <typename... Args>
  ZmNode__(Args &&...args) : Base(ZuFwd<Args>(args)...) { }
};
template <typename Heap>
struct ZmNode__<ZuEmpty, Heap, false> : public Heap { };
template <> struct ZmNode__<ZuEmpty, ZuEmpty, true> { };

template <
  typename T, auto KeyAxor, auto ValAxor, typename Base, typename NodeExt,
  typename Heap, bool = ZuInspect<Base, T>::Is>
class ZmNode_;

template <
  typename T_, auto KeyAxor_, auto ValAxor_, typename Base_, typename NodeExt,
  typename Heap>
class ZmNode_<T_, KeyAxor_, ValAxor_, Base_, NodeExt, Heap, false> :
  public ZmNode__<Base_, Heap>,
  public NodeExt {
public:
  using T = T_;
  static constexpr auto KeyAxor = KeyAxor_;
  static constexpr auto ValAxor = ValAxor_;
  using U = ZuDecay<T>;

  ZmNode_() = default;
  ZmNode_(const ZmNode_ &) = default;
  ZmNode_ &operator=(const ZmNode_ &) = default;
  ZmNode_(ZmNode_ &&) = default;
  ZmNode_ &operator=(ZmNode_ &&) = default;
  template <typename... Args>
  ZmNode_(Args &&...args) : m_data{ZuFwd<Args>(args)...} { }
  template <typename Arg> ZmNode_ &operator=(Arg &&arg) {
    m_data = ZuFwd<Arg>(arg);
    return *this;
  }
  virtual ~ZmNode_() = default;

  const auto &data() const & { return m_data; }
  auto &data() & { return m_data; }
  decltype(auto) data() && { return ZuMv(m_data); }

  decltype(auto) key() const & { return KeyAxor(data()); }
  decltype(auto) key() & { return KeyAxor(data()); }
  decltype(auto) key() && { return KeyAxor(data()); }

  decltype(auto) val() const & { return ValAxor(data()); }
  decltype(auto) val() & { return ValAxor(data()); }
  decltype(auto) val() && { return ValAxor(data()); }

private:
  U m_data;
};

template <
  typename T_, auto KeyAxor_, auto ValAxor_, typename Base_, typename NodeExt,
  typename Heap>
class ZmNode_<T_, KeyAxor_, ValAxor_, Base_, NodeExt, Heap, true> :
  public ZmNode__<ZuDecay<T_>, Heap>,
  public NodeExt {
  using Base = ZmNode__<ZuDecay<T_>, Heap>;

public:
  using T = T_;
  static constexpr auto KeyAxor = KeyAxor_;
  static constexpr auto ValAxor = ValAxor_;
  using U = ZuDecay<T>;

  using Base::Base;
  using Base::operator=;
  template <typename... Args>
  ZmNode_(Args &&...args) : Base(ZuFwd<Args>(args)...) { }
  virtual ~ZmNode_() = default;

  decltype(auto) data() const & { return static_cast<const U &>(*this); }
  decltype(auto) data() & { return static_cast<U &>(*this); }
  decltype(auto) data() && { return static_cast<U &&>(*this); }

  decltype(auto) key() const & { return KeyAxor(data()); }
  decltype(auto) key() & { return KeyAxor(data()); }
  decltype(auto) key() && { return KeyAxor(data()); }

  decltype(auto) val() const & { return ValAxor(data()); }
  decltype(auto) val() & { return ValAxor(data()); }
  decltype(auto) val() && { return ValAxor(data()); }
};

template <
  typename T, auto KeyAxor, auto ValAxor, typename Base, typename NodeExt,
  auto HeapID, bool Sharded>
using ZmNode = ZmNode_<
  T, KeyAxor, ValAxor, Base, NodeExt,
  ZmHeap<
    HeapID, ZmNode_<T, KeyAxor, ValAxor, Base, NodeExt, ZuEmpty>, Sharded>>;

struct ZuPtr_ { };

template <typename T_> class ZuPtr : public ZuPtr_ {
  template <typename> friend class ZuPtr;

public:
  using T = T_;

private:
  template <typename U>
  struct IsOtherPtr_ :
    public ZuBool<(
      ZuInspect<T, typename U::T>::Base || ZuInspect<typename U::T, T>::Base
    )> { };
  template <typename U, typename = void, bool = IsOtherPtr_<U>{}>
  struct MatchOtherPtr__ { };
  template <typename U, typename R> struct MatchOtherPtr__<U, R, true> {
    using T = R;
  };
  template <typename U>
  struct IsOtherPtr1 : public ZuBool<ZuInspect<ZuPtr_, U>::Base> { };
  template <typename U, typename = void, bool = IsOtherPtr1<U>{}>
  struct MatchOtherPtr_;
  template <typename U, typename R>
  struct MatchOtherPtr_<U, R, true> : public MatchOtherPtr__<U, R> { };
  template <typename U, typename R = void>
  using MatchOtherPtr = typename MatchOtherPtr_<U, R>::T;

  template <typename U>
  struct IsZuPtr__ :
    public ZuBool<
      (ZuInspect<T, typename U::T>::Is || ZuInspect<typename U::T, T>::Is)> { };
  template <typename U, typename = void, bool = IsZuPtr__<U>{}>
  struct MatchZuPtr__ { };
  template <typename U, typename R> struct MatchZuPtr__<U, R, true> {
    using T = R;
  };
  template <typename U>
  struct IsZuPtr_ : public ZuBool<ZuInspect<ZuPtr_, U>::Base> { };
  template <typename U, typename = void, bool = IsZuPtr_<U>{}>
  struct MatchZuPtr_;
  template <typename U, typename R>
  struct MatchZuPtr_<U, R, true> : public MatchZuPtr__<U, R> { };
  template <typename U, typename R = void>
  using MatchZuPtr = typename MatchZuPtr_<U, R>::T;

  template <typename U>
  struct IsPtr :
    public ZuBool<(ZuInspect<T, U>::Is || ZuInspect<U, T>::Is)> { };
  template <typename U, typename R = void>
  using MatchPtr = ZuIfT<IsPtr<U>{}, R>;

public:
  ZuPtr() : m_object{nullptr} { }
  ZuPtr(ZuPtr &&r) : m_object{r.m_object} { r.m_object = nullptr; }
  template <typename R, decltype(MatchOtherPtr<ZuDeref<R>>(), int()) = 0>
  ZuPtr(R &&r) :
    m_object{static_cast<T *>(const_cast<typename ZuDeref<R>::T *>(r.m_object))
    } {
    ZuBind<R>::mv(ZuFwd<R>(r), [](auto &&r) { r.m_object = nullptr; });
  }
  ZuPtr(T *o) : m_object{o} { }
  template <typename O, decltype(MatchPtr<O>(), int()) = 0>
  ZuPtr(O *o) : m_object{static_cast<T *>(o)} { }
  ~ZuPtr() {
    if (T *o = m_object) delete o;
  }

  template <typename R> MatchZuPtr<R> swap(R &r) noexcept {
    T *o = m_object;
    m_object = static_cast<T *>(r.m_object);
    r.m_object = static_cast<typename R::T *>(o);
  }

  template <typename R> friend MatchZuPtr<R> swap(ZuPtr &r1, R &r2) noexcept {
    r1.swap(r2);
  }

  ZuPtr &operator=(ZuPtr r) noexcept {
    swap(r);
    return *this;
  }
  template <typename R> MatchOtherPtr<R, ZuPtr &> operator=(R r) {
    swap(r);
    return *this;
  }

  template <typename O> MatchPtr<O, ZuPtr &> operator=(O *n) {
    T *o = m_object;
    m_object = n;
    if (o) delete o;
    return *this;
  }

  operator T *() const { return m_object; }
  T *operator->() const { return m_object; }

  template <typename O = T> MatchZuPtr<ZuPtr<O>, O *> ptr() const {
    return static_cast<O *>(m_object);
  }
  T *ptr_() const { return m_object; }

  template <typename O = T> MatchZuPtr<ZuPtr<O>, O *> release() && {
    auto ptr = static_cast<O *>(m_object);
    m_object = nullptr;
    return ptr;
  }

  bool operator!() const { return !m_object; }

  struct Traits : public ZuTraits<T *> {
    enum { IsPrimitive = 0, IsPOD = 0 };
  };
  friend Traits ZuTraitsType(ZuPtr *) { return {}; }

protected:
  T *m_object;
};

template <typename T> struct ZuCmp;
template <typename T> struct ZuCmp<ZuPtr<T>> : public ZuCmp<T *> {
  static bool null(const ZuPtr<T> &r) { return !r; }
  static const ZuPtr<T> &null() {
    static const ZuPtr<T> v;
    return v;
  }
};

template <typename T> struct ZuHash;
template <typename T> struct ZuHash<ZuPtr<T>> : public ZuHash<T *> { };

template <typename T> ZuPtr<T> ZuMkPtr(T *p) { return ZuPtr<T>{p}; }

template <bool Shadow, bool IsObject> struct ZmNodeFn_;

template <> struct ZmNodeFn_<false, true> {
  template <typename T> using Ref = ZmRef<T>;
  template <typename T> using MvRef = ZmRef<T>;

  template <typename T> void nodeRef(T *o) { ZmRef__::ZmREF_((o), this); }
  template <typename T> void nodeRef(const Ref<T> &o) {
    ZmRef__::ZmREF_((o), this);
  }
  template <typename T> void nodeDeref(T *o) { ZmRef__::ZmDEREF_((o), this); }
  template <typename T> void nodeDeref(const Ref<T> &o) {
    ZmRef__::ZmDEREF_((o), this);
  }

  template <typename T> static Ref<T> nodeAcquire(T *o) {
    return Ref<T>::acquire(o);
  }
  template <typename T> static T *nodeRelease(Ref<T> &&o) {
    return ZuMv(o).release();
  }
  template <typename T> static void nodeDelete(T *) { }
  template <typename T> static void nodeDelete(const Ref<T> &) { }
};

template <> struct ZmNodeFn_<false, false> {
  template <typename T> using Ref = T *;
  template <typename T> using MvRef = ZuPtr<T>;
  template <typename T> static void nodeRef(T *) { }
  template <typename T> static void nodeDeref(T *) { }
  template <typename T> static T *nodeAcquire(T *o) { return o; }
  template <typename T> static T *nodeRelease(T *o) { return o; }
  template <typename T> static void nodeDelete(T *o) { delete o; }
};

template <bool IsObject> struct ZmNodeFn_<true, IsObject> {
  template <typename T> using Ref = T *;
  template <typename T> using MvRef = T *;
  template <typename T> static void nodeRef(T *) { }
  template <typename T> static void nodeDeref(T *) { }
  template <typename T> static T *nodeAcquire(T *o) { return o; }
  template <typename T> static T *nodeRelease(T *o) { return o; }
  template <typename T> static void nodeDelete(T *) { }
};

template <bool Shadow, typename NodeBase>
using ZmNodeFn = ZmNodeFn_<Shadow, ZuObjectTraits<NodeBase>::IsObject>;

struct ZmList_Defaults {
  static constexpr auto KeyAxor = ZuDefaultAxor();
  static constexpr auto ValAxor = ZuDefaultAxor();
  template <typename T> using CmpT = ZuCmp<T>;
  template <typename T> using ValCmpT = ZuCmp<T>;
  using Lock = ZmNoLock;
  using Node = ZuEmpty;
  enum { Shadow = 0 };
  static const char *HeapID() { return "ZmList"; }
  enum { Sharded = 0 };
};

template <auto KeyAxor_, typename NTP = ZmList_Defaults>
struct ZmListKey : public NTP {
  static constexpr auto KeyAxor = KeyAxor_;
};

template <auto KeyAxor_, auto ValAxor_, typename NTP = ZmList_Defaults>
struct ZmListKeyVal : public NTP {
  static constexpr auto KeyAxor = KeyAxor_;
  static constexpr auto ValAxor = ValAxor_;
};

template <template <typename> typename Cmp_, typename NTP = ZmList_Defaults>
struct ZmListCmp : public NTP {
  template <typename T> using CmpT = Cmp_<T>;
};

template <class Lock_, class NTP = ZmList_Defaults>
struct ZmListLock : public NTP {
  using Lock = Lock_;
};

template <typename Node_, typename NTP = ZmList_Defaults>
struct ZmListNode : public NTP {
  using Node = Node_;
};

template <bool Shadow_, typename NTP = ZmList_Defaults> struct ZmListShadow;
template <typename NTP> struct ZmListShadow<true, NTP> : public NTP {
  enum { Shadow = true };
  static constexpr auto HeapID = ZmHeapDisable();
};
template <typename NTP> struct ZmListShadow<false, NTP> : public NTP {
  enum { Shadow = false };
};

template <auto HeapID_, class NTP = ZmList_Defaults>
struct ZmListHeapID : public NTP {
  static constexpr auto HeapID = HeapID_;
};

template <bool Sharded_, typename NTP = ZmList_Defaults>
struct ZmListSharded : public NTP {
  enum { Sharded = Sharded_ };
};

template <typename Node> struct ZmList_NodeExt {
  Node *next = nullptr, *prev = nullptr;
};

template <typename T_, class NTP = ZmList_Defaults>
class ZmList : public ZmNodeFn<NTP::Shadow, typename NTP::Node> {
public:
  using T = T_;
  static constexpr auto KeyAxor = NTP::KeyAxor;
  static constexpr auto ValAxor = NTP::ValAxor;
  using Key = ZuRDecay<decltype(KeyAxor(ZuDeclVal<const T &>()))>;
  using Val = ZuRDecay<decltype(ValAxor(ZuDeclVal<const T &>()))>;
  using Cmp = typename NTP::template CmpT<T>;
  using ValCmp = typename NTP::template ValCmpT<Val>;
  using Lock = typename NTP::Lock;
  using NodeBase = typename NTP::Node;
  enum { Shadow = NTP::Shadow };
  static constexpr auto HeapID = NTP::HeapID;
  enum { Sharded = NTP::Sharded };

private:
  using NodeFn = ZmNodeFn<Shadow, NodeBase>;

  using Guard = ZmGuard<Lock>;
  using ReadGuard = ZmReadGuard<Lock>;

private:
  template <typename I> class Iterator_;
  template <typename> friend class Iterator_;

private:
public:
  struct Node;
  using Node_ = ZmNode<
    T, KeyAxor, ValAxor, NodeBase, ZmList_NodeExt<Node>, HeapID, Sharded>;
  struct Node : public Node_ {
    using Node_::Node_;
    using Node_::operator=;
  };
  using NodeExt = ZmList_NodeExt<Node>;
  using NodeRef = typename NodeFn::template Ref<Node>;
  using NodeMvRef = typename NodeFn::template MvRef<Node>;
  using NodePtr = Node *;

private:
  using NodeFn::nodeRef;
  using NodeFn::nodeDeref;
  using NodeFn::nodeDelete;
  using NodeFn::nodeAcquire;

  static const Key &key(Node *node) {
    if (__builtin_expect(!!(node), 1)) return node->Node::key();
    return ZuNullRef<T, Cmp>();
  }
  static Key keyMv(NodeMvRef node) {
    if (__builtin_expect(!!(node), 1)) return ZuMv(*node).Node::key();
    return ZuNullRef<T, Cmp>();
  }
  static const Val &val(Node *node) {
    if (__builtin_expect(!!(node), 1)) return node->Node::val();
    return ZuNullRef<Val, ValCmp>();
  }
  static Val valMv(NodeMvRef node) {
    if (__builtin_expect(!!(node), 1)) return ZuMv(*node).Node::val();
    return ZuNullRef<Val, ValCmp>();
  }

private:
  template <typename I> struct Iterator__ {
    decltype(auto) iterateKey() {
      return key(static_cast<I *>(this)->iterate());
    }
    decltype(auto) iterateVal() {
      return val(static_cast<I *>(this)->iterate());
    }
  };

  template <typename I> class Iterator_ : public Iterator__<I> {
    Iterator_(const Iterator_ &) = delete;
    Iterator_ &operator=(const Iterator_ &) = delete;

    using List = ZmList<T, NTP>;
    friend List;

  protected:
    Iterator_(Iterator_ &&) = default;
    Iterator_ &operator=(Iterator_ &&) = default;

    Iterator_(List &list) : m_list(list) { }

  public:
    void reset() { m_list.startIterate(static_cast<I &>(*this)); }
    Node *iterate() { return m_list.iterate(static_cast<I &>(*this)); }

    unsigned count() const { return m_list.count_(); }

  protected:
    List &m_list;
    Node *m_node;
  };

public:
  class Iterator : public Iterator_<Iterator> {
    Iterator(const Iterator &) = delete;
    Iterator &operator=(const Iterator &) = delete;

    using List = ZmList<T, NTP>;
    friend List;
    using Base = Iterator_<Iterator>;

    using Base::m_list;

  public:
    Iterator(Iterator &&) = default;
    Iterator &operator=(Iterator &&) = default;

    Iterator(List &list) : Base{list} { list.startIterate(*this); }
    ~Iterator() { m_list.endIterate(); }

    template <typename P> NodeRef push(P &&data) {
      return m_list.pushIterate(*this, ZuFwd<P>(data));
    }
    template <typename P0, typename P1> NodeRef push(P0 &&p0, P1 &&p1) {
      return push(ZuFwdTuple(ZuFwd<P0>(p0), ZuFwd<P1>(p1)));
    }
    void pushNode(Node *node) { m_list.pushIterateNode(*this, node); }

    template <typename P> NodeRef unshift(P &&data) {
      return m_list.unshiftIterate(*this, ZuFwd<P>(data));
    }
    template <typename P0, typename P1> NodeRef unshift(P0 &&p0, P1 &&p1) {
      return unshift(ZuFwdTuple(ZuFwd<P0>(p0), ZuFwd<P1>(p1)));
    }
    void unshiftNode(Node *node) { m_list.unshiftIterateNode(*this, node); }

    NodeMvRef del() { return this->m_list.delIterate(*this); }
  };

  class ReadIterator : public Iterator_<ReadIterator> {
    ReadIterator(const ReadIterator &) = delete;
    ReadIterator &operator=(const ReadIterator &) = delete;

    using List = ZmList<T, NTP>;
    friend List;
    using Base = Iterator_<ReadIterator>;

    using Base::m_list;

  public:
    ReadIterator(ReadIterator &&) = default;
    ReadIterator &operator=(ReadIterator &&) = default;

    ReadIterator(const List &list) : Base{const_cast<List &>(list)} {
      const_cast<List &>(list).startIterate(*this);
    }
    ~ReadIterator() { m_list.endIterate(); }
  };

  ZmList() = default;

  ZmList(const ZmList &) = delete;
  ZmList &operator=(const ZmList &) = delete;

  ZmList(ZmList &&list) noexcept {
    Guard guard(list.m_lock);
    m_head = list.m_head, m_tail = list.m_tail;
    m_count = list.m_count;
    list.m_head = list.m_tail = nullptr;
    list.m_count = 0;
  }
  ZmList &operator=(ZmList &&list) noexcept {
    unsigned count;
    Node *head, *tail;
    {
      Guard guard(list.m_lock);
      head = list.m_head, tail = list.m_tail;
      count = list.m_count;
      list.m_head = list.m_tail = nullptr;
      list.m_count = 0;
    }
    {
      Guard guard(m_lock);
      clean_();
      m_head = head, m_tail = tail;
      m_count = count;
    }
    return *this;
  }
  ZmList &operator+=(ZmList &&list) {
    unsigned count;
    Node *head, *tail;
    {
      Guard guard(list.m_lock);
      head = list.m_head, tail = list.m_tail;
      count = list.m_count;
      list.m_head = list.m_tail = nullptr;
      list.m_count = 0;
    }
    if (head) {
      Guard guard(m_lock);
      if (m_tail) {
	m_tail->NodeExt::next = head;
	head->NodeExt::prev = m_tail;
	m_tail = tail;
	m_count += count;
      } else {
	m_head = head, m_tail = tail;
	m_count = count;
      }
    }
    return *this;
  }

  ~ZmList() { clean_(); }

  bool empty() const {
    ReadGuard guard(m_lock);
    return !m_count;
  }
  unsigned count_() const { return m_count; }
  bool empty_() const { return !m_count; }

  template <typename P> void add(P &&data) { push(ZuFwd<P>(data)); }
  template <typename P> void addNode(P &&node) { pushNode(ZuFwd<P>(node)); }

private:
  template <typename U, typename V = Key>
  struct IsKey : public ZuBool<ZuInspect<U, V>::Converts> { };
  template <typename U, typename R = void>
  using MatchKey = ZuIfT<IsKey<U>{}, R>;
  template <typename U, typename V = T, bool = ZuInspect<NodeBase, V>::Is>
  struct IsData : public ZuBool<!IsKey<U>{} && ZuInspect<U, V>::Converts> { };
  template <typename U, typename V>
  struct IsData<U, V, true> : public ZuFalse { };
  template <typename U, typename R = void>
  using MatchData = ZuIfT<IsData<U>{}, R>;

  template <typename P> static auto matchKey(const P &key) {
    return [&key](const Node *node) -> bool {
      return Cmp::equals(node->Node::key(), key);
    };
  }
  template <typename P> static auto matchData(const P &data) {
    return
      [&data](const Node *node) -> bool { return node->Node::data() == data; };
  }

public:
  template <typename P> MatchKey<P, NodeRef> find(const P &key) {
    return find_(matchKey(key));
  }
  template <typename P> MatchData<P, NodeRef> find(const P &data) {
    return find_(matchData(data));
  }
  template <typename P0, typename P1> NodeRef find(P0 &&p0, P1 &&p1) {
    return find(ZuFwdTuple(ZuFwd<P0>(p0), ZuFwd<P1>(p1)));
  }

  template <typename P> MatchKey<P, Node *> findPtr(const P &key) {
    return find_(matchKey(key));
  }
  template <typename P> MatchData<P, Node *> findPtr(const P &data) {
    return find_(matchData(data));
  }

  template <typename P> MatchKey<P, Key> findKey(const P &key) {
    return key(find_(matchKey(key)));
  }
  template <typename P> MatchData<P, Key> findKey(const P &data) {
    return key(find_(matchData(data)));
  }
  template <typename P0, typename P1> Key findKey(P0 &&p0, P1 &&p1) {
    return findKey(ZuFwdTuple(ZuFwd<P0>(p0), ZuFwd<P1>(p1)));
  }

  template <typename P> MatchKey<P, Val> findVal(const P &key) {
    return val(find_(matchKey(key)));
  }
  template <typename P> MatchData<P, Val> findVal(const P &data) {
    return val(find_(matchData(data)));
  }
  template <typename P0, typename P1> Val findVal(P0 &&p0, P1 &&p1) {
    return findVal(ZuFwdTuple(ZuFwd<P0>(p0), ZuFwd<P1>(p1)));
  }

private:
  template <typename Match> NodeRef find_(Match match) {
    Node *node;
    Guard guard(m_lock);
    if (!m_count) return nullptr;
    for (node = m_head; node && !match(node); node = node->NodeExt::next);
    return node;
  }

public:
  template <typename P> MatchKey<P, NodeRef> del(const P &key) {
    return del_(matchKey(key));
  }
  template <typename P> MatchData<P, NodeRef> del(const P &data) {
    return del_(matchData(data));
  }
  template <typename P0, typename P1> NodeMvRef del(P0 &&p0, P1 &&p1) {
    return del(ZuFwdTuple(ZuFwd<P0>(p0), ZuFwd<P1>(p1)));
  }
  NodeMvRef delNode(Node *node) {
    Guard guard(m_lock);
    if (__builtin_expect(!!(node), 1)) del__(node);
    return nodeAcquire(node);
  }

  template <typename P> MatchKey<P, Key> delKey(const P &key) {
    return keyMv(del_(matchKey(key)));
  }
  template <typename P> MatchData<P, Key> delKey(const P &data) {
    return keyMv(del_(matchData(data)));
  }
  template <typename P0, typename P1> Key delKey(P0 &&p0, P1 &&p1) {
    return delKey(ZuFwdTuple(ZuFwd<P0>(p0), ZuFwd<P1>(p1)));
  }
  template <typename P> Key delNodeKey(Node *node) {
    Guard guard(m_lock);
    if (__builtin_expect(!!(node), 1)) del__(node);
    return nodeAcquire(node);
  }

  template <typename P> MatchKey<P, Val> delVal(const P &key) {
    return valMv(del_(matchKey(key)));
  }
  template <typename P> MatchData<P, Val> delVal(const P &data) {
    return valMv(del_(matchData(data)));
  }
  template <typename P0, typename P1> Val delVal(P0 &&p0, P1 &&p1) {
    return delVal(ZuFwdTuple(ZuFwd<P0>(p0), ZuFwd<P1>(p1)));
  }
  template <typename P> Val delNodeVal(Node *node) {
    Guard guard(m_lock);
    if (__builtin_expect(!!(node), 1)) del__(node);
    return nodeAcquire(node);
  }

private:
  template <typename Match> NodeMvRef del_(Match match) {
    Guard guard(m_lock);
    if (!m_count) return nullptr;
    Node *node;
    for (node = m_head; node && !match(node); node = node->NodeExt::next);
    if (__builtin_expect(!!(node), 1)) del__(node);
    return nodeAcquire(node);
  }

public:
  template <typename P> NodeRef push(P &&data) {
    NodeRef node = new Node{ZuFwd<P>(data)};
    pushNode(node);
    return node;
  }
  template <typename P0, typename P1> NodeRef push(P0 &&p0, P1 &&p1) {
    return push(ZuFwdTuple(ZuFwd<P0>(p0), ZuFwd<P1>(p1)));
  }
  template <bool _ = !ZuInspect<NodeRef, Node *>::Same>
  ZuIfT<_> pushNode(const NodeRef &node_) {
    pushNode(node_.ptr());
  }
  template <bool _ = !ZuInspect<NodeRef, Node *>::Same>
  ZuIfT<_> pushNode(NodeRef &&node_) {
    Node *node = ZuMv(node_).release();
    Guard guard(m_lock);
    pushNode_(node);
  }
  void pushNode(Node *node) {
    nodeRef(node);
    Guard guard(m_lock);
    pushNode_(node);
  }

private:
  void pushNode_(Node *node) {
    node->NodeExt::next = nullptr;
    node->NodeExt::prev = m_tail;
    if (!m_tail)
      m_head = node;
    else
      m_tail->NodeExt::next = node;
    m_tail = node;
    ++m_count;
  }

public:
  NodeMvRef pop() {
    Guard guard(m_lock);
    Node *node;

    if (!(node = m_tail)) return nullptr;

    if (!(m_tail = node->NodeExt::prev))
      m_head = nullptr;
    else
      m_tail->NodeExt::next = nullptr;

    NodeMvRef ret = node;

    nodeDeref(node);
    --m_count;

    return ret;
  }
  Key popKey() { return keyMv(pop()); }
  Val popVal() { return valMv(pop()); }
  NodeRef rpop() {
    Guard guard(m_lock);
    Node *node;

    if (!(node = m_tail)) return nullptr;

    if (!(m_tail = node->NodeExt::prev))
      m_tail = node;
    else {
      node->NodeExt::next(m_head);
      m_head->NodeExt::prev = node;
      (m_head = node)->NodeExt::prev = nullptr;
      m_tail->NodeExt::next = nullptr;
    }

    return node;
  }
  Key rpopKey() { return keyMv(rpop()); }
  Val rpopVal() { return valMv(rpop()); }

  template <typename P> NodeRef unshift(P &&data) {
    NodeRef node = new Node{ZuFwd<P>(data)};
    unshiftNode(node);
    return node;
  }
  template <typename P0, typename P1> NodeRef unshift(P0 &&p0, P1 &&p1) {
    return unshift(ZuFwdTuple(ZuFwd<P0>(p0), ZuFwd<P1>(p1)));
  }
  void unshiftNode(Node *node) {
    Guard guard(m_lock);

    nodeRef(node);
    node->NodeExt::prev = nullptr;
    node->NodeExt::next = m_head;
    if (!m_head)
      m_tail = node;
    else
      m_head->NodeExt::prev = node;
    m_head = node;
    ++m_count;
  }

  NodeMvRef shift() {
    Guard guard(m_lock);
    Node *node;

    if (!(node = m_head)) return nullptr;

    if (!(m_head = node->NodeExt::next))
      m_tail = nullptr;
    else
      m_head->NodeExt::prev = nullptr;

    NodeMvRef ret = node;

    nodeDeref(node);
    --m_count;

    return ret;
  }
  Key shiftKey() { return keyMv(shift()); }
  Val shiftVal() { return valMv(shift()); }
  NodeRef rshift() {
    Guard guard(m_lock);
    Node *node;

    if (!(node = m_head)) return nullptr;

    if (!(m_head = node->NodeExt::next))
      m_head = node;
    else {
      node->NodeExt::prev = m_tail;
      m_tail->NodeExt::next = node;
      (m_tail = node)->NodeExt::next = nullptr;
      m_head->NodeExt::prev = nullptr;
    }

    return node;
  }
  Key rshiftKey() { return keyMv(rshift()); }
  Val rshiftVal() { return valMv(rshift()); }

  T head() const {
    ReadGuard guard(m_lock);
    if (__builtin_expect(!!(!m_head), 0)) return T{};
    return m_head->Node::data();
  }
  NodeRef headNode() const {
    ReadGuard guard(m_lock);
    return m_head;
  }
  T tail() const {
    ReadGuard guard(m_lock);
    if (__builtin_expect(!!(!m_tail), 0)) return T{};
    return m_tail->Node::data();
  }
  NodeRef tailNode() const {
    ReadGuard guard(m_lock);
    return m_tail;
  }

  void clean() {
    Guard guard(m_lock);
    clean_();
    m_head = m_tail = nullptr;
    m_count = 0;
  }

  auto iterator() { return Iterator{*this}; }
  auto readIterator() const { return ReadIterator{*this}; }

protected:
  template <typename I> void startIterate(I &iterator) {
    m_lock.lock();
    iterator.m_node = nullptr;
  }
  template <typename I> Node *iterate(I &iterator) {
    Node *node = iterator.m_node;

    if (!node)
      node = m_head;
    else
      node = node->NodeExt::next;

    if (!node) return nullptr;

    return iterator.m_node = node;
  }
  template <typename I, typename P> NodeRef pushIterate(I &iterator, P &&data) {
    pushIterateNode(iterator, new Node{ZuFwd<P>(data)});
  }
  template <typename I> void pushIterateNode(I &iterator, Node *node) {
    Node *prevNode = iterator.m_node;

    if (!prevNode) {
      push(node);
      return;
    }

    nodeRef(node);
    if (Node *nextNode = prevNode->NodeExt::next) {
      node->NodeExt::next = nextNode;
      nextNode->NodeExt::prev = node;
    } else {
      m_tail = node;
      node->NodeExt::next = nullptr;
    }
    node->NodeExt::prev = prevNode;
    prevNode->NodeExt::next = node;
    ++m_count;
  }

  template <typename I, typename P>
  NodeRef unshiftIterate(I &iterator, P &&data) {
    unshiftIterateNode(iterator, new Node{ZuFwd<P>(data)});
  }
  template <typename I> void unshiftIterateNode(I &iterator, Node *node) {
    Node *nextNode = iterator.m_node;

    if (!nextNode) {
      unshift(node);
      return;
    }

    nodeRef(node);
    if (Node *prevNode = nextNode->NodeExt::prev) {
      node->NodeExt::prev = prevNode;
      prevNode->NodeExt::next = node;
    } else {
      m_head = node;
      node->NodeExt::prev = nullptr;
    }
    node->NodeExt::next = nextNode;
    nextNode->NodeExt::prev(node);
    ++m_count;
  }

  template <typename I> NodeMvRef delIterate(I &iterator) {
    if (!m_count) return nullptr;

    Node *node = iterator.m_node;

    if (__builtin_expect(!!(node), 1)) {
      iterator.m_node = node->NodeExt::prev;
      del__(node);
    }

    return nodeAcquire(node);
  }

  void endIterate() { m_lock.unlock(); }

  void del__(Node *node) {
    Node *prevNode = node->NodeExt::prev;
    Node *nextNode = node->NodeExt::next;

    ((prevNode || nextNode || (m_head == node && m_tail == node)) ?
       void() :
       ZmAssert_fail(
	 "prevNode || nextNode || (m_head == node && m_tail == node)",
	 "../../zm/src/zlib/ZmList.hh", 747, __PRETTY_FUNCTION__
       ));

    if (!prevNode)
      m_head = nextNode;
    else
      prevNode->NodeExt::next = nextNode;

    if (!nextNode)
      m_tail = prevNode;
    else
      nextNode->NodeExt::prev = prevNode;

    --m_count;

    node->NodeExt::next = node->NodeExt::prev = nullptr;
  }

  void clean_() {
    if (!m_count) return;

    Node *node = m_head, *prevNode;

    while (prevNode = node) {
      node = prevNode->NodeExt::next;
      nodeDeref(prevNode);
      nodeDelete(prevNode);
    }
  }

  Lock m_lock;
  unsigned m_count = 0;
  Node *m_head = nullptr;
  Node *m_tail = nullptr;
};

template <typename P0, typename P1, typename NTP = ZmList_Defaults>
using ZmListKV = ZmList<
  ZuTuple<P0, P1>, ZmListKeyVal<ZuTupleAxor<0>(), ZuTupleAxor<1>(), NTP>>;

struct ZmRBTree_Defaults {
  static constexpr auto KeyAxor = ZuDefaultAxor();
  static constexpr auto ValAxor = ZuDefaultAxor();
  template <typename T> using CmpT = ZuCmp<T>;
  template <typename T> using ValCmpT = ZuCmp<T>;
  enum { Unique = 0 };
  using Lock = ZmNoLock;
  using Node = ZuEmpty;
  enum { Shadow = 0 };
  static const char *HeapID() { return "ZmRBTree"; }
  enum { Sharded = 0 };
};

template <auto KeyAxor_, typename NTP = ZmRBTree_Defaults>
struct ZmRBTreeKey : public NTP {
  static constexpr auto KeyAxor = KeyAxor_;
};

template <auto KeyAxor_, auto ValAxor_, typename NTP = ZmRBTree_Defaults>
struct ZmRBTreeKeyVal : public NTP {
  static constexpr auto KeyAxor = KeyAxor_;
  static constexpr auto ValAxor = ValAxor_;
};

template <template <typename> typename Cmp_, typename NTP = ZmRBTree_Defaults>
struct ZmRBTreeCmp : public NTP {
  template <typename T> using CmpT = Cmp_<T>;
};

template <
  template <typename> typename ValCmp_, typename NTP = ZmRBTree_Defaults>
struct ZmRBTreeValCmp : public NTP {
  template <typename T> using ValCmpT = ValCmp_<T>;
};

template <bool Unique_, class NTP = ZmRBTree_Defaults>
struct ZmRBTreeUnique : public NTP {
  enum { Unique = Unique_ };
};

template <class Lock_, class NTP = ZmRBTree_Defaults>
struct ZmRBTreeLock : public NTP {
  using Lock = Lock_;
};

template <typename Node_, typename NTP = ZmRBTree_Defaults>
struct ZmRBTreeNode : public NTP {
  using Node = Node_;
};

template <bool Shadow_, typename NTP = ZmRBTree_Defaults> struct ZmRBTreeShadow;
template <typename NTP> struct ZmRBTreeShadow<true, NTP> : public NTP {
  enum { Shadow = true };
  static constexpr auto HeapID = ZmHeapDisable();
};
template <typename NTP> struct ZmRBTreeShadow<false, NTP> : public NTP {
  enum { Shadow = false };
};

template <auto HeapID_, class NTP = ZmRBTree_Defaults>
struct ZmRBTreeHeapID : public NTP {
  static constexpr auto HeapID = HeapID_;
};

template <bool Sharded_, typename NTP = ZmRBTree_Defaults>
struct ZmRBTreeSharded : public NTP {
  enum { Sharded = Sharded_ };
};

template <typename Node> struct ZmRBTree_NodeExt_Dup {
  inline Node *dup() const { return m_dup; }
  inline void dup(Node *n) { m_dup = n; }

  inline void clear() { m_dup = nullptr; }

private:
  Node *m_dup = nullptr;
};
template <typename Node> struct ZmRBTree_NodeExt_Unique {
  constexpr Node *const dup() const { return nullptr; }
  void dup(Node *) { }

  void clear() { }
};
template <typename Node, bool Unique>
struct ZmRBTree_NodeExt :
  public ZuIf<
    Unique, ZmRBTree_NodeExt_Unique<Node>, ZmRBTree_NodeExt_Dup<Node>> {
  static constexpr uintptr_t Black() { return uintptr_t(1) << 63; }
  static constexpr uintptr_t Black(bool b) { return uintptr_t(b) << 63; }

  using Base =
    ZuIf<Unique, ZmRBTree_NodeExt_Unique<Node>, ZmRBTree_NodeExt_Dup<Node>>;

  inline bool black() { return m_parent & Black(); }
  inline void black(bool b) { m_parent = (m_parent & ~Black()) | Black(b); }
  inline void black(const ZmRBTree_NodeExt *node) {
    m_parent = (m_parent & ~Black()) | (node->m_parent & Black());
  }
  inline void setBlack() { m_parent |= Black(); }
  inline void clrBlack() { m_parent &= ~Black(); }

  inline Node *right() const { return m_right; }
  inline Node *left() const { return m_left; }
  inline Node *parent() const {
    return reinterpret_cast<Node *>(m_parent & ~Black());
  }

  inline void right(Node *n) { m_right = n; }
  inline void left(Node *n) { m_left = n; }
  inline void parent(Node *n) {
    m_parent = reinterpret_cast<uintptr_t>(n) | (m_parent & Black());
  }

  void clearDup() {
    Base::clear();
    m_parent = 0;
  }
  void clear() {
    Base::clear();
    m_right = nullptr;
    m_left = nullptr;
    m_parent = 0;
  }

private:
  Node *m_right = nullptr;
  Node *m_left = nullptr;
  uintptr_t m_parent = 0;
};

enum {
  ZmRBTreeEqual = 0,
  ZmRBTreeGreaterEqual = 1,
  ZmRBTreeLessEqual = -1,
  ZmRBTreeGreater = 2,
  ZmRBTreeLess = -2
};

template <typename Tree_, int Direction_> class ZmRBTreeIterator_ {
  ZmRBTreeIterator_(const ZmRBTreeIterator_ &) = delete;
  ZmRBTreeIterator_ &operator=(const ZmRBTreeIterator_ &) = delete;

  friend Tree_;

public:
  using Tree = Tree_;
  enum { Direction = Direction_ };
  using Node = typename Tree::Node;
  using NodeRef = typename Tree::NodeRef;

protected:
  ZmRBTreeIterator_(ZmRBTreeIterator_ &&) = default;
  ZmRBTreeIterator_ &operator=(ZmRBTreeIterator_ &&) = default;

  ZmRBTreeIterator_(Tree &tree) : m_tree(tree) { tree.startIterate(*this); }
  template <typename P>
  ZmRBTreeIterator_(Tree &tree, const P &key) : m_tree(tree) {
    tree.startIterate(*this, key);
  }

public:
  void reset() { m_tree.startIterate(*this); }
  template <typename P> void reset(const P &key) {
    m_tree.startIterate(*this, key);
  }

  Node *iterate() { return m_tree.iterate(*this); }

  decltype(auto) iterateKey() { return Tree::key(m_tree.iterate(*this)); }
  decltype(auto) iterateVal() { return Tree::val(m_tree.iterate(*this)); }

  unsigned count() const { return m_tree.count_(); }

protected:
  Tree &m_tree;
  Node *m_node;
};

template <typename Tree_, int Direction_ = ZmRBTreeGreaterEqual>
class ZmRBTreeIterator :
  public Tree_::Guard,
  public ZmRBTreeIterator_<Tree_, Direction_> {
  ZmRBTreeIterator(const ZmRBTreeIterator &) = delete;
  ZmRBTreeIterator &operator=(const ZmRBTreeIterator &) = delete;

  using Tree = Tree_;
  enum { Direction = Direction_ };
  using Guard = typename Tree::Guard;
  using Node = typename Tree::Node;
  using NodeRef = typename Tree::NodeRef;
  using NodeMvRef = typename Tree::NodeMvRef;

public:
  ZmRBTreeIterator(ZmRBTreeIterator &&) = default;
  ZmRBTreeIterator &operator=(ZmRBTreeIterator &&) = default;

  ZmRBTreeIterator(Tree &tree) :
    Guard{tree.lock()}, ZmRBTreeIterator_<Tree, Direction>{tree} { }
  template <typename P>
  ZmRBTreeIterator(Tree &tree, const P &key) :
    Guard{tree.lock()}, ZmRBTreeIterator_<Tree, Direction>{tree, key} { }

  NodeMvRef del(Node *node) { return this->m_tree.delIterate(node); }
};

template <typename Tree_, int Direction_ = ZmRBTreeGreaterEqual>
class ZmRBTreeReadIterator :
  public Tree_::ReadGuard,
  public ZmRBTreeIterator_<Tree_, Direction_> {
  ZmRBTreeReadIterator(const ZmRBTreeReadIterator &) = delete;
  ZmRBTreeReadIterator &operator=(const ZmRBTreeReadIterator &) = delete;

  using Tree = Tree_;
  enum { Direction = Direction_ };
  using ReadGuard = typename Tree::ReadGuard;

public:
  ZmRBTreeReadIterator(ZmRBTreeReadIterator &&) = default;
  ZmRBTreeReadIterator &operator=(ZmRBTreeReadIterator &&) = default;

  ZmRBTreeReadIterator(const Tree &tree) :
    ReadGuard(tree.lock()),
    ZmRBTreeIterator_<Tree, Direction>(const_cast<Tree &>(tree)) { }
  template <typename P>
  ZmRBTreeReadIterator(const Tree &tree, const P &key) :
    ReadGuard(tree.lock()),
    ZmRBTreeIterator_<Tree, Direction>(const_cast<Tree &>(tree), key) { }
};

template <typename T, typename Cmp, typename = void>
struct ZmRBTree_IsStaticCmp : public ZuFalse { };
template <typename T, typename Cmp>
struct ZmRBTree_IsStaticCmp<
  T, Cmp,
  decltype(Cmp::cmp(ZuDeclVal<const T &>(), ZuDeclVal<const T &>()), void())> :
  public ZuTrue { };

template <typename T, typename Cmp, typename = void>
struct ZmRBTree_IsStaticEquals : public ZuFalse { };
template <typename T, typename Cmp>
struct ZmRBTree_IsStaticEquals<
  T, Cmp,
  decltype(Cmp::equals(ZuDeclVal<const T &>(), ZuDeclVal<const T &>()), void())> :
  public ZuTrue { };

template <typename T_, class NTP = ZmRBTree_Defaults>
class ZmRBTree : public ZmNodeFn<NTP::Shadow, typename NTP::Node> {
  template <typename, int> friend class ZmRBTreeIterator_;
  template <typename, int> friend class ZmRBTreeIterator;
  template <typename, int> friend class ZmRBTreeReadIterator;

public:
  using T = T_;
  static constexpr auto KeyAxor = NTP::KeyAxor;
  static constexpr auto ValAxor = NTP::ValAxor;
  using KeyRet = decltype(KeyAxor(ZuDeclVal<const T &>()));
  using ValRet = decltype(ValAxor(ZuDeclVal<const T &>()));
  using Key = ZuRDecay<KeyRet>;
  using Val = ZuRDecay<ValRet>;
  using Cmp = typename NTP::template CmpT<Key>;
  using ValCmp = typename NTP::template ValCmpT<Val>;
  enum { Unique = NTP::Unique };
  using Lock = typename NTP::Lock;
  using NodeBase = typename NTP::Node;
  enum { Shadow = NTP::Shadow };
  static constexpr auto HeapID = NTP::HeapID;
  enum { Sharded = NTP::Sharded };

private:
  using NodeFn = ZmNodeFn<Shadow, NodeBase>;

  using Guard = ZmGuard<Lock>;
  using ReadGuard = ZmReadGuard<Lock>;

public:
  template <int Direction = ZmRBTreeGreaterEqual>
  using Iterator = ZmRBTreeIterator<ZmRBTree, Direction>;
  template <int Direction = ZmRBTreeGreaterEqual>
  using ReadIterator = ZmRBTreeReadIterator<ZmRBTree, Direction>;

  struct Node;
  using Node_ = ZmNode<
    T, KeyAxor, ValAxor, NodeBase, ZmRBTree_NodeExt<Node, Unique>, HeapID,
    Sharded>;
  struct Node : public Node_ {
    using Node_::Node_;
    using Node_::operator=;
  };
  using NodeExt = ZmRBTree_NodeExt<Node, Unique>;
  using NodeRef = typename NodeFn::template Ref<Node>;
  using NodeMvRef = typename NodeFn::template MvRef<Node>;
  using NodePtr = Node *;

private:
  using NodeFn::nodeRef;
  using NodeFn::nodeDeref;
  using NodeFn::nodeDelete;
  using NodeFn::nodeAcquire;

  static KeyRet key(Node *node) {
    if (__builtin_expect(!!(node), 1)) return node->Node::key();
    return ZuNullRef<Key, Cmp>();
  }
  static ValRet val(Node *node) {
    if (__builtin_expect(!!(node), 1)) return node->Node::val();
    return ZuNullRef<Val, ValCmp>();
  }

public:
  ZmRBTree() = default;

  ZmRBTree(const ZmRBTree &) = delete;
  ZmRBTree &operator=(const ZmRBTree &) = delete;

  ZmRBTree(ZmRBTree &&tree) noexcept {
    Guard guard(tree.m_lock);
    m_root = tree.m_root;
    m_minimum = tree.m_minimum, m_maximum = tree.m_maximum;
    m_count = tree.m_count;
    tree.m_root = tree.m_minimum = tree.m_maximum = nullptr;
    tree.m_count = 0;
  }
  ZmRBTree &operator=(ZmRBTree &&tree) noexcept {
    unsigned count;
    Node *root, *minimum, *maximum;
    {
      Guard guard(tree.m_lock);
      root = tree.m_root, minimum = tree.m_minimum, maximum = tree.m_maximum;
      count = tree.m_count;
      tree.m_root = tree.m_minimum = tree.m_maximum = nullptr;
      tree.m_count = 0;
    }
    {
      clean_();
      m_root = root, m_minimum = minimum, m_maximum = maximum;
      m_count = count;
    }
    return *this;
  }

  ZmRBTree(Cmp cmp) : m_cmp{ZuMv(cmp)} { }

  ~ZmRBTree() { clean_(); }

  Lock &lock() const { return m_lock; }

  unsigned count_() const { return m_count; }

private:
  template <typename U, typename V = Key>
  struct IsKey : public ZuBool<ZuInspect<U, V>::Converts> { };
  template <typename U, typename R = void>
  using MatchKey = ZuIfT<IsKey<U>{}, R>;
  template <typename U, typename V = T, bool = ZuInspect<NodeBase, V>::Is>
  struct IsData : public ZuBool<!IsKey<U>{} && ZuInspect<U, V>::Converts> { };
  template <typename U, typename V>
  struct IsData<U, V, true> : public ZuFalse { };
  template <typename U, typename R = void>
  using MatchData = ZuIfT<IsData<U>{}, R>;

public:
  template <
    typename Key_ = Key, typename Cmp_ = Cmp,
    decltype(ZuIfT<ZmRBTree_IsStaticCmp<Key_, Cmp_>{}>(), int()) = 0>
  inline static auto cmp(const Key &l, const Key &r) {
    return Cmp::cmp(l, r);
  }
  template <
    typename Key_ = Key, typename Cmp_ = Cmp,
    decltype(ZuIfT<!ZmRBTree_IsStaticCmp<Key_, Cmp_>{}>(), int()) = 0>
  inline auto cmp(const Key &l, const Key &r) const {
    return m_cmp.cmp(l, r);
  }
  template <
    typename Key_ = Key, typename Cmp_ = Cmp,
    decltype(ZuIfT<ZmRBTree_IsStaticEquals<Key_, Cmp_>{}>(), int()) = 0>
  inline static auto equals(const Key &l, const Key &r) {
    return Cmp::equals(l, r);
  }
  template <
    typename Key_ = Key, typename Cmp_ = Cmp,
    decltype(ZuIfT<!ZmRBTree_IsStaticEquals<Key_, Cmp_>{}>(), int()) = 0>
  inline auto equals(const Key &l, const Key &r) const {
    return m_cmp.equals(l, r);
  }

private:
  template <
    typename P, typename Key_ = Key, typename Cmp_ = Cmp,
    decltype(ZuIfT<ZmRBTree_IsStaticCmp<Key_, Cmp_>{}>(), int()) = 0>
  inline static auto matchKey(const P &key) {
    return
      [&key](const Node *node) { return Cmp::cmp(node->Node::key(), key); };
  }
  template <
    typename P, typename Key_ = Key, typename Cmp_ = Cmp,
    decltype(ZuIfT<!ZmRBTree_IsStaticCmp<Key_, Cmp_>{}>(), int()) = 0>
  inline auto matchKey(const P &key) const {
    return [this, &key](const Node *node) {
      return m_cmp.cmp(node->Node::key(), key);
    };
  }
  template <
    typename P, typename Key_ = Key, typename Cmp_ = Cmp,
    decltype(ZuIfT<ZmRBTree_IsStaticCmp<Key_, Cmp_>{}>(), int()) = 0>
  inline static auto matchData(const P &data) {
    return [&data](const Node *node) {
      return Cmp::cmp(node->Node::key(), KeyAxor(data));
    };
  }
  template <
    typename P, typename Key_ = Key, typename Cmp_ = Cmp,
    decltype(ZuIfT<!ZmRBTree_IsStaticCmp<Key_, Cmp_>{}>(), int()) = 0>
  inline auto matchData(const P &data) const {
    return [this, &data](const Node *node) {
      return m_cmp.cmp(node->Node::key(), KeyAxor(data));
    };
  }

public:
  template <typename P> NodeRef add(P &&data) {
    Node *node = new Node(ZuFwd<P>(data));
    addNode(node);
    return node;
  }
  template <typename P0, typename P1> NodeRef add(P0 &&p0, P1 &&p1) {
    return add(ZuFwdTuple(ZuFwd<P0>(p0), ZuFwd<P1>(p1)));
  }
  template <bool _ = !ZuInspect<NodeRef, Node *>::Same>
  ZuIfT<_> addNode(const NodeRef &node_) {
    addNode(node_.ptr());
  }
  template <bool _ = !ZuInspect<NodeRef, Node *>::Same>
  ZuIfT<_> addNode(NodeRef &&node_) {
    Node *node = ZuMv(node_).release();
    Guard guard(m_lock);
    addNode_(node);
  }
  void addNode(Node *node) {
    nodeRef(node);
    Guard guard(m_lock);
    addNode_(node);
  }

private:
  void addNode_(Node *newNode) {
    if constexpr (Unique)
      ((!newNode->NodeExt::dup()) ?
	 void() :
	 ZmAssert_fail(
	   "!newNode->NodeExt::dup()", "../../zm/src/zlib/ZmRBTree.hh", 532,
	   __PRETTY_FUNCTION__
	 ));
    ((!newNode->NodeExt::left()) ?
       void() :
       ZmAssert_fail(
	 "!newNode->NodeExt::left()", "../../zm/src/zlib/ZmRBTree.hh", 533,
	 __PRETTY_FUNCTION__
       ));
    ((!newNode->NodeExt::right()) ?
       void() :
       ZmAssert_fail(
	 "!newNode->NodeExt::right()", "../../zm/src/zlib/ZmRBTree.hh", 534,
	 __PRETTY_FUNCTION__
       ));
    ((!newNode->NodeExt::parent()) ?
       void() :
       ZmAssert_fail(
	 "!newNode->NodeExt::parent()", "../../zm/src/zlib/ZmRBTree.hh", 535,
	 __PRETTY_FUNCTION__
       ));
    ((!newNode->NodeExt::black()) ?
       void() :
       ZmAssert_fail(
	 "!newNode->NodeExt::black()", "../../zm/src/zlib/ZmRBTree.hh", 536,
	 __PRETTY_FUNCTION__
       ));

    Node *node;

    if (!(node = m_root)) {
      newNode->NodeExt::setBlack();
      m_root = m_minimum = m_maximum = newNode;
      ++m_count;
      return;
    }

    bool minimum = true, maximum = true;
    const Key &key = newNode->Node::key();

    for (;;) {
      int c = cmp(node->Node::key(), key);

      if constexpr (!Unique) {
	if (!c) {
	  Node *child;

	  newNode->NodeExt::dup(child = node->NodeExt::dup());
	  if (child) child->NodeExt::parent(newNode);
	  node->NodeExt::dup(newNode);
	  newNode->NodeExt::parent(node);
	  ++m_count;
	  return;
	}
      }

      if (c >= 0) {
	if (!node->NodeExt::left()) {
	  node->NodeExt::left(newNode);
	  newNode->NodeExt::parent(node);
	  if (minimum) m_minimum = newNode;
	  break;
	}

	node = node->NodeExt::left();
	maximum = false;
      } else {
	if (!node->NodeExt::right()) {
	  node->NodeExt::right(newNode);
	  newNode->NodeExt::parent(node);
	  if (maximum) m_maximum = newNode;
	  break;
	}

	node = node->NodeExt::right();
	minimum = false;
      }
    }

    rebalance(newNode);
    ++m_count;
  }

  template <int Direction, typename MatchCmp, typename MatchEquals>
  ZuIfT<Direction == ZmRBTreeEqual, Node *>
  find_(MatchCmp matchCmp, MatchEquals matchEquals) const {
    Node *node = m_root;
    for (;;) {
      if (!node) return nullptr;
      int c = matchCmp(node);
      if (!c) {
	if constexpr (Unique) {
	  if (matchEquals(node)) return node;
	  return nullptr;
	} else {
	  while (!matchEquals(node))
	    if (!(node = node->NodeExt::dup())) break;
	  return node;
	}
      } else if (c > 0) {
	node = node->NodeExt::left();
      } else {
	node = node->NodeExt::right();
      }
    }
  }
  template <int Direction, typename MatchCmp, typename MatchEquals>
  ZuIfT<Direction == ZmRBTreeGreaterEqual, Node *>
  find_(MatchCmp matchCmp, MatchEquals) const {
    Node *node = m_root, *foundNode = nullptr;
    for (;;) {
      if (!node) return foundNode;
      int c = matchCmp(node);
      if (!c) {
	return node;
      } else if (c > 0) {
	foundNode = node;
	node = node->NodeExt::left();
      } else {
	node = node->NodeExt::right();
      }
    }
  }
  template <int Direction, typename MatchCmp, typename MatchEquals>
  ZuIfT<Direction == ZmRBTreeGreater, Node *>
  find_(MatchCmp matchCmp, MatchEquals) const {
    Node *node = m_root, *foundNode = nullptr;
    for (;;) {
      if (!node) return foundNode;
      int c = matchCmp(node);
      if (!c) {
	node = node->NodeExt::right();
      } else if (c > 0) {
	foundNode = node;
	node = node->NodeExt::left();
      } else {
	node = node->NodeExt::right();
      }
    }
  }
  template <int Direction, typename MatchCmp, typename MatchEquals>
  ZuIfT<Direction == ZmRBTreeLessEqual, Node *>
  find_(MatchCmp matchCmp, MatchEquals) const {
    Node *node = m_root, *foundNode = nullptr;
    for (;;) {
      if (!node) return foundNode;
      int c = matchCmp(node);
      if (!c) {
	return node;
      } else if (c > 0) {
	node = node->NodeExt::left();
      } else {
	foundNode = node;
	node = node->NodeExt::right();
      }
    }
  }
  template <int Direction, typename MatchCmp, typename MatchEquals>
  ZuIfT<Direction == ZmRBTreeLess, Node *>
  find_(MatchCmp matchCmp, MatchEquals) const {
    Node *node = m_root, *foundNode = nullptr;
    for (;;) {
      if (!node) return foundNode;
      int c = matchCmp(node);
      if (!c) {
	node = node->NodeExt::left();
      } else if (c > 0) {
	node = node->NodeExt::left();
      } else {
	foundNode = node;
	node = node->NodeExt::right();
      }
    }
  }

public:
  template <int Direction = ZmRBTreeEqual, typename P>
  MatchKey<P, NodeRef> find(const P &key) const {
    ReadGuard guard(m_lock);
    return find_<Direction>(matchKey(key), [](const Node *) { return true; });
  }
  template <int Direction = ZmRBTreeEqual, typename P>
  MatchData<P, NodeRef> find(const P &data) const {
    ReadGuard guard(m_lock);
    return find_<Direction>(matchData(data), [&data](const Node *node) {
      return node->Node::data() == data;
    });
  }
  template <int Direction = ZmRBTreeEqual, typename P0, typename P1>
  NodeRef find(P0 &&p0, P1 &&p1) {
    return find<Direction>(ZuFwdTuple(ZuFwd<P0>(p0), ZuFwd<P1>(p1)));
  }

  template <int Direction = ZmRBTreeEqual, typename P>
  MatchKey<P, Node *> findPtr(const P &key) const {
    ReadGuard guard(m_lock);
    return find_<Direction>(matchKey(key), [](const Node *) { return true; });
  }
  template <int Direction = ZmRBTreeEqual, typename P>
  MatchData<P, Node *> findPtr(const P &data) const {
    ReadGuard guard(m_lock);
    return find_<Direction>(matchData(data), [&data](const Node *node) {
      return node->Node::data() == data;
    });
  }

  template <int Direction = ZmRBTreeEqual, typename P>
  MatchKey<P, Key> findKey(const P &key) const {
    ReadGuard guard(m_lock);
    return key(find_<Direction>(matchKey(key), [](const Node *) {
      return true;
    }));
  }
  template <int Direction = ZmRBTreeEqual, typename P>
  MatchData<P, Key> findKey(const P &data) const {
    ReadGuard guard(m_lock);
    return key(find_<Direction>(matchData(data), [&data](const Node *node) {
      return node->Node::data() == data;
    }));
  }
  template <int Direction = ZmRBTreeEqual, typename P0, typename P1>
  Key findKey(P0 &&p0, P1 &&p1) {
    return findKey<Direction>(ZuFwdTuple(ZuFwd<P0>(p0), ZuFwd<P1>(p1)));
  }

  template <int Direction = ZmRBTreeEqual, typename P>
  MatchKey<P, Val> findVal(const P &key) const {
    ReadGuard guard(m_lock);
    return val(find_<Direction>(matchKey(key), [](const Node *) {
      return true;
    }));
  }
  template <int Direction = ZmRBTreeEqual, typename P>
  MatchData<P, Val> findVal(const P &data) const {
    ReadGuard guard(m_lock);
    return val(find_<Direction>(matchData(data), [&data](const Node *node) {
      return node->Node::data() == data;
    }));
  }
  template <int Direction = ZmRBTreeEqual, typename P0, typename P1>
  Val findVal(P0 &&p0, P1 &&p1) {
    return findVal<Direction>(ZuFwdTuple(ZuFwd<P0>(p0), ZuFwd<P1>(p1)));
  }

public:
  NodeRef minimum() const {
    ReadGuard guard(m_lock);
    return m_minimum;
  }
  Node *minimumPtr() const {
    ReadGuard guard(m_lock);
    return m_minimum;
  }
  Key minimumKey() const {
    ReadGuard guard(m_lock);
    return key(m_minimum);
  }
  Val minimumVal() const {
    ReadGuard guard(m_lock);
    return val(m_minimum);
  }

  NodeRef maximum() const {
    ReadGuard guard(m_lock);
    return m_maximum;
  }
  Node *maximumPtr() const {
    ReadGuard guard(m_lock);
    return m_maximum;
  }
  Key maximumKey() const {
    ReadGuard guard(m_lock);
    return key(m_maximum);
  }
  Val maximumVal() const {
    ReadGuard guard(m_lock);
    return val(m_maximum);
  }

  template <int Direction = ZmRBTreeEqual, typename P>
  MatchKey<P, NodeMvRef> del(const P &key) {
    ReadGuard guard(m_lock);
    Node *node =
      find_<Direction>(matchKey(key), [](const Node *) { return true; });
    if (!node) return nullptr;
    delNode_(node);
    return nodeAcquire(node);
  }
  template <int Direction = ZmRBTreeEqual, typename P>
  MatchData<P, NodeMvRef> del(const P &data) {
    ReadGuard guard(m_lock);
    Node *node = find_<Direction>(matchData(data), [&data](const Node *node) {
      return node->Node::data() == data;
    });
    if (!node) return nullptr;
    delNode_(node);
    return nodeAcquire(node);
  }
  template <int Direction = ZmRBTreeEqual, typename P0, typename P1>
  NodeMvRef del(P0 &&p0, P1 &&p1) {
    return del<Direction>(ZuFwdTuple(ZuFwd<P0>(p0), ZuFwd<P1>(p1)));
  }

  template <int Direction = ZmRBTreeEqual, typename P>
  MatchKey<P, Key> delKey(const P &key) {
    ReadGuard guard(m_lock);
    NodeMvRef node =
      find_<Direction>(matchKey(key), [](const Node *) { return true; });
    if (!node) return ZuNullRef<Key, Cmp>();
    delNode_(node);
    return ZuMv(*node).Node::key();
  }
  template <int Direction = ZmRBTreeEqual, typename P>
  MatchData<P, Key> delKey(const P &data) {
    ReadGuard guard(m_lock);
    NodeMvRef node =
      find_<Direction>(matchData(data), [&data](const Node *node) {
      return node->Node::data() == data;
    });
    if (!node) return ZuNullRef<Key, Cmp>();
    delNode_(node);
    return ZuMv(*node).Node::key();
  }
  template <int Direction = ZmRBTreeEqual, typename P0, typename P1>
  Key delKey(P0 &&p0, P1 &&p1) {
    return delKey<Direction>(ZuFwdTuple(ZuFwd<P0>(p0), ZuFwd<P1>(p1)));
  }

  template <int Direction = ZmRBTreeEqual, typename P>
  MatchKey<P, Val> delVal(const P &key) {
    ReadGuard guard(m_lock);
    NodeMvRef node =
      find_<Direction>(matchKey(key), [](const Node *) { return true; });
    if (!node) return ZuNullRef<Val, ValCmp>();
    delNode_(node);
    return ZuMv(*node).Node::val();
  }
  template <int Direction = ZmRBTreeEqual, typename P>
  MatchData<P, Val> delVal(const P &data) {
    ReadGuard guard(m_lock);
    NodeMvRef node =
      find_<Direction>(matchData(data), [&data](const Node *node) {
      return node->Node::data() == data;
    });
    if (!node) return ZuNullRef<Val, ValCmp>();
    delNode_(node);
    return ZuMv(*node).Node::val();
  }
  template <int Direction = ZmRBTreeEqual, typename P0, typename P1>
  Val delVal(P0 &&p0, P1 &&p1) {
    return delVal<Direction>(ZuFwdTuple(ZuFwd<P0>(p0), ZuFwd<P1>(p1)));
  }

  NodeMvRef delNode(Node *node) {
    if (__builtin_expect(!!(!node), 0)) return nullptr;
    Guard guard(m_lock);
    delNode_(node);
    return nodeAcquire(node);
  }

private:
  void delNode_(Node *node) {
    if constexpr (!Unique) {
      Node *parent = node->NodeExt::parent();
      Node *dup = node->NodeExt::dup();

      if (parent && parent->NodeExt::dup() == node) {
	parent->NodeExt::dup(dup);
	if (dup) dup->NodeExt::parent(parent);
	--m_count;
	node->NodeExt::clearDup();
	return;
      }
      if (dup) {
	{
	  Node *child;

	  dup->NodeExt::left(child = node->NodeExt::left());
	  if (child) {
	    node->NodeExt::left(nullptr);
	    child->NodeExt::parent(dup);
	  }
	  dup->NodeExt::right(child = node->NodeExt::right());
	  if (child) {
	    node->NodeExt::right(nullptr);
	    child->NodeExt::parent(dup);
	  }
	}
	if (!parent) {
	  m_root = dup;
	  dup->NodeExt::parent(0);
	} else if (node == parent->NodeExt::right()) {
	  parent->NodeExt::right(dup);
	  dup->NodeExt::parent(parent);
	} else {
	  parent->NodeExt::left(dup);
	  dup->NodeExt::parent(parent);
	}
	dup->NodeExt::black(node);
	if (node == m_minimum) m_minimum = dup;
	if (node == m_maximum) m_maximum = dup;
	--m_count;
	node->NodeExt::clearDup();
	return;
      }
    }
    delRebalance(node);
    node->NodeExt::clear();
    --m_count;
  }

public:
  template <int Direction = ZmRBTreeGreaterEqual> auto iterator() {
    return Iterator<Direction>{*this};
  }
  template <int Direction = ZmRBTreeGreaterEqual, typename P>
  auto iterator(P &&key) {
    return Iterator<Direction>{*this, ZuFwd<P>(key)};
  }
  template <int Direction = ZmRBTreeGreaterEqual> auto readIterator() const {
    return ReadIterator<Direction>{*this};
  }
  template <int Direction = ZmRBTreeGreaterEqual, typename P>
  auto readIterator(P &&key) const {
    return ReadIterator<Direction>{*this, ZuFwd<P>(key)};
  }

  void clean() {
    clean([](auto) {});
  }
  template <typename L> void clean(L l) {
    Guard guard(m_lock);
    clean_(ZuMv(l));
    m_minimum = m_maximum = m_root = nullptr;
    m_count = 0;
  }

private:
  void clean_() {
    clean_([](auto) {});
  }
  template <typename L> void clean_(L l) {
    Node *node = m_minimum, *next;
    if (!node) return;
    do {
      if (next = node->NodeExt::left()) {
	node = next;
	continue;
      }
      if (next = node->NodeExt::dup()) {
	node = next;
	continue;
      }
      if (next = node->NodeExt::right()) {
	node = next;
	continue;
      }
      if (next = node->NodeExt::parent()) {
	if (node == next->NodeExt::left())
	  next->NodeExt::left(nullptr);
	else if constexpr (!Unique) {
	  if (node == next->NodeExt::dup())
	    next->NodeExt::dup(nullptr);
	  else
	    next->NodeExt::right(nullptr);
	} else
	  next->NodeExt::right(nullptr);
      }
      l(NodeMvRef{nodeAcquire(node)});
      node = next;
    } while (node);
  }

  void rotateRight(Node *node, Node *parent) {
    Node *left = node->NodeExt::left();
    Node *mid = left->NodeExt::right();

    if (parent) {
      if (parent->NodeExt::left() == node)
	parent->NodeExt::left(left);
      else
	parent->NodeExt::right(left);
    } else
      m_root = left;
    left->NodeExt::parent(parent);

    left->NodeExt::right(node), node->NodeExt::parent(left);

    node->NodeExt::left(mid);
    if (mid) mid->NodeExt::parent(node);
  }

  void rotateLeft(Node *node, Node *parent) {
    Node *right = node->NodeExt::right();
    Node *mid = right->NodeExt::left();

    if (parent) {
      if (parent->NodeExt::right() == node)
	parent->NodeExt::right(right);
      else
	parent->NodeExt::left(right);
    } else
      m_root = right;
    right->NodeExt::parent(parent);

    right->NodeExt::left(node), node->NodeExt::parent(right);

    node->NodeExt::right(mid);
    if (mid) mid->NodeExt::parent(node);
  }

  void rebalance(Node *node) {
    for (;;) {
      Node *parent = node->NodeExt::parent();

      if (!parent) {
	node->NodeExt::setBlack();
	return;
      }

      if (parent->NodeExt::black()) return;

      Node *gParent = parent->NodeExt::parent();

      if (parent == gParent->NodeExt::left()) {
	Node *uncle = gParent->NodeExt::right();

	if (uncle && !uncle->NodeExt::black()) {
	  parent->NodeExt::setBlack();
	  uncle->NodeExt::setBlack();
	  (node = gParent)->NodeExt::clrBlack();
	} else {
	  if (node == parent->NodeExt::right()) {
	    rotateLeft(node = parent, gParent);
	    gParent = (parent = node->NodeExt::parent())->NodeExt::parent();
	  }
	  parent->NodeExt::setBlack();
	  gParent->NodeExt::clrBlack();
	  rotateRight(gParent, gParent->NodeExt::parent());
	  m_root->NodeExt::setBlack();
	  return;
	}
      } else {
	Node *uncle = gParent->NodeExt::left();

	if (uncle && !uncle->NodeExt::black()) {
	  parent->NodeExt::setBlack();
	  uncle->NodeExt::setBlack();
	  (node = gParent)->NodeExt::clrBlack();
	} else {
	  if (node == parent->NodeExt::left()) {
	    rotateRight(node = parent, gParent);
	    gParent = (parent = node->NodeExt::parent())->NodeExt::parent();
	  }
	  parent->NodeExt::setBlack();
	  gParent->NodeExt::clrBlack();
	  rotateLeft(gParent, gParent->NodeExt::parent());
	  m_root->NodeExt::setBlack();
	  return;
	}
      }
    }
  }

  void delRebalance(Node *node) {
    Node *successor = node;
    Node *child, *parent;

    if (!successor->NodeExt::left())
      child = successor->NodeExt::right();
    else if (!successor->NodeExt::right())
      child = successor->NodeExt::left();
    else {
      successor = successor->NodeExt::right();
      while (successor->NodeExt::left()) successor = successor->NodeExt::left();
      child = successor->NodeExt::right();
    }

    if (successor != node) {
      node->NodeExt::left()->NodeExt::parent(successor);
      successor->NodeExt::left(node->NodeExt::left());
      if (successor != node->NodeExt::right()) {
	parent = successor->NodeExt::parent();
	if (child) child->NodeExt::parent(parent);
	successor->NodeExt::parent()->NodeExt::left(child);
	successor->NodeExt::right(node->NodeExt::right());
	node->NodeExt::right()->NodeExt::parent(successor);
      } else
	parent = successor;

      Node *childParent = parent;

      parent = node->NodeExt::parent();

      if (!parent)
	m_root = successor;
      else if (node == parent->NodeExt::left())
	parent->NodeExt::left(successor);
      else
	parent->NodeExt::right(successor);
      successor->NodeExt::parent(parent);

      bool black = node->NodeExt::black();

      node->NodeExt::black(successor);
      successor->NodeExt::black(black);

      successor = node;

      parent = childParent;
    } else {
      parent = node->NodeExt::parent();

      if (child) child->NodeExt::parent(parent);

      if (!parent)
	m_root = child;
      else if (node == parent->NodeExt::left())
	parent->NodeExt::left(child);
      else
	parent->NodeExt::right(child);

      if (node == m_minimum) {
	if (!node->NodeExt::right())
	  m_minimum = parent;
	else {
	  Node *minimum = child;

	  do {
	    m_minimum = minimum;
	  } while (minimum = minimum->NodeExt::left());
	}
      }

      if (node == m_maximum) {
	if (!node->NodeExt::left())
	  m_maximum = parent;
	else {
	  Node *maximum = child;

	  do {
	    m_maximum = maximum;
	  } while (maximum = maximum->NodeExt::right());
	}
      }
    }

    if (successor->NodeExt::black()) {
      Node *sibling;

      while (parent && (!child || child->NodeExt::black()))
	if (child == parent->NodeExt::left()) {
	  sibling = parent->NodeExt::right();
	  if (!sibling->NodeExt::black()) {
	    sibling->NodeExt::setBlack();
	    parent->NodeExt::clrBlack();
	    rotateLeft(parent, parent->NodeExt::parent());
	    sibling = parent->NodeExt::right();
	  }
	  if ((!sibling->NodeExt::left() ||
	       sibling->NodeExt::left()->NodeExt::black()) &&
	      (!sibling->NodeExt::right() ||
	       sibling->NodeExt::right()->NodeExt::black())) {
	    sibling->NodeExt::clrBlack();
	    child = parent;
	    parent = child->NodeExt::parent();
	  } else {
	    if (!sibling->NodeExt::right() ||
		sibling->NodeExt::right()->NodeExt::black()) {
	      if (sibling->NodeExt::left())
		sibling->NodeExt::left()->NodeExt::setBlack();
	      sibling->NodeExt::clrBlack();
	      rotateRight(sibling, parent);
	      sibling = parent->NodeExt::right();
	    }
	    sibling->NodeExt::black(parent);
	    parent->NodeExt::setBlack();
	    if (sibling->NodeExt::right())
	      sibling->NodeExt::right()->NodeExt::setBlack();
	    rotateLeft(parent, parent->NodeExt::parent());
	    break;
	  }
	} else {
	  sibling = parent->NodeExt::left();
	  if (!sibling->NodeExt::black()) {
	    sibling->NodeExt::setBlack();
	    parent->NodeExt::clrBlack();
	    rotateRight(parent, parent->NodeExt::parent());
	    sibling = parent->NodeExt::left();
	  }
	  if ((!sibling->NodeExt::right() ||
	       sibling->NodeExt::right()->NodeExt::black()) &&
	      (!sibling->NodeExt::left() ||
	       sibling->NodeExt::left()->NodeExt::black())) {
	    sibling->NodeExt::clrBlack();
	    child = parent;
	    parent = child->NodeExt::parent();
	  } else {
	    if (!sibling->NodeExt::left() ||
		sibling->NodeExt::left()->NodeExt::black()) {
	      if (sibling->NodeExt::right())
		sibling->NodeExt::right()->NodeExt::setBlack();
	      sibling->NodeExt::clrBlack();
	      rotateLeft(sibling, parent);
	      sibling = parent->NodeExt::left();
	    }
	    sibling->NodeExt::black(parent);
	    parent->NodeExt::setBlack();
	    if (sibling->NodeExt::left())
	      sibling->NodeExt::left()->NodeExt::setBlack();
	    rotateRight(parent, parent->NodeExt::parent());
	    break;
	  }
	}
      if (child) child->NodeExt::setBlack();
    }
  }

public:
  Node *next(Node *node) const {
    Node *next;

    if constexpr (!Unique) {
      if (next = node->NodeExt::dup()) return next;

      if (next = node->NodeExt::parent())
	while (node == next->NodeExt::dup()) {
	  node = next;
	  if (!(next = node->NodeExt::parent())) break;
	}
    }

    if (next = node->NodeExt::right()) {
      node = next;
      while (node = node->NodeExt::left()) next = node;
      return next;
    }

    if (!(next = node->NodeExt::parent())) return nullptr;

    while (node == next->NodeExt::right()) {
      node = next;
      if (!(next = node->NodeExt::parent())) return nullptr;
    }

    return next;
  }

  Node *prev(Node *node) const {
    Node *prev;

    if constexpr (!Unique) {
      if (prev = node->NodeExt::dup()) return prev;

      if (prev = node->NodeExt::parent())
	while (node == prev->NodeExt::dup()) {
	  node = prev;
	  if (!(prev = node->NodeExt::parent())) break;
	}
    }

    if (prev = node->NodeExt::left()) {
      node = prev;
      while (node = node->NodeExt::right()) prev = node;
      return prev;
    }

    if (!(prev = node->NodeExt::parent())) return nullptr;

    while (node == prev->NodeExt::left()) {
      node = prev;
      if (!(prev = node->NodeExt::parent())) return nullptr;
    }

    return prev;
  }

private:
  template <int Direction>
  using Iterator_ = ZmRBTreeIterator_<ZmRBTree, Direction>;

  template <int Direction>
  ZuIfT<(Direction >= 0)> startIterate(Iterator_<Direction> &iterator) {
    iterator.m_node = m_minimum;
  }
  template <int Direction>
  ZuIfT<(Direction < 0)> startIterate(Iterator_<Direction> &iterator) {
    iterator.m_node = m_maximum;
  }
  template <int Direction, typename P>
  void startIterate(Iterator_<Direction> &iterator, const P &key) {
    iterator.m_node =
      find_<Direction>(matchKey(key), [](const Node *) { return true; });
  }

  template <int Direction>
  ZuIfT<(Direction > 0), Node *> iterate(Iterator_<Direction> &iterator) {
    Node *node = iterator.m_node;
    if (!node) return nullptr;
    iterator.m_node = next(node);
    return node;
  }
  template <int Direction>
  ZuIfT<(!Direction), Node *> iterate(Iterator_<Direction> &iterator) {
    Node *node = iterator.m_node;
    if (!node) return nullptr;
    iterator.m_node = node->NodeExt::dup();
    return node;
  }
  template <int Direction>
  ZuIfT<(Direction < 0), Node *> iterate(Iterator_<Direction> &iterator) {
    Node *node = iterator.m_node;
    if (!node) return nullptr;
    iterator.m_node = prev(node);
    return node;
  }

  NodeMvRef delIterate(Node *node) {
    if (__builtin_expect(!!(!node), 0)) return nullptr;
    delNode_(node);
    return nodeAcquire(node);
  }

  Cmp m_cmp;
  mutable Lock m_lock;
  Node *m_root = nullptr;
  Node *m_minimum = nullptr;
  Node *m_maximum = nullptr;
  unsigned m_count = 0;
};

template <typename P0, typename P1, typename NTP = ZmRBTree_Defaults>
using ZmRBTreeKV = ZmRBTree<
  ZuTuple<P0, P1>, ZmRBTreeKeyVal<ZuTupleAxor<0>(), ZuTupleAxor<1>(), NTP>>;

class ZuVStreamBuf {
public:
  template <typename T>
  ZuVStreamBuf(const T &v) :
    m_ptr{&v}, m_lengthFn{[](const void *v) -> unsigned {
      return ZuPrint<T>::length(*static_cast<const T *>(v));
    }},
    m_printFn{[](const void *v, char *buf, unsigned n) -> unsigned {
      return ZuPrint<T>::print(buf, n, *static_cast<const T *>(v));
    }} { }

  ZuVStreamBuf(const ZuVStreamBuf &) = default;
  ZuVStreamBuf &operator=(const ZuVStreamBuf &) = default;
  ZuVStreamBuf(ZuVStreamBuf &&s) = default;
  ZuVStreamBuf &operator=(ZuVStreamBuf &&s) = default;

  unsigned length() const { return m_lengthFn(m_ptr); }
  unsigned print(char *buf, unsigned n) const {
    return m_printFn(m_ptr, buf, n);
  }

  struct PrintType : public ZuPrintBuffer {
    static unsigned length(const ZuVStreamBuf &b) { return b.length(); }
    static unsigned print(char *buf, unsigned n, const ZuVStreamBuf &b) {
      return b.print(buf, n);
    }
  };
  friend PrintType ZuPrintType(ZuVStreamBuf *);

private:
  typedef unsigned (*LengthFn)(const void *);
  typedef unsigned (*PrintFn)(const void *, char *, unsigned);

  const void *m_ptr;
  LengthFn m_lengthFn;
  PrintFn m_printFn;
};

class ZuVStream {
public:
  template <typename S>
  ZuVStream(S &s) :
    m_ptr{&s},
    m_strFn{[](void *s, const ZuCSpan &v) { *static_cast<S *>(s) << v; }},
    m_bufFn{[](void *s, const ZuVStreamBuf &v) { *static_cast<S *>(s) << v; }} {
  }

  ZuVStream() = delete;

  ZuVStream(const ZuVStream &) = default;
  ZuVStream &operator=(const ZuVStream &) = default;
  ZuVStream(ZuVStream &&s) = default;
  ZuVStream &operator=(ZuVStream &&s) = default;

private:
  template <typename U, typename R = void>
  using MatchChar = ZuIfT<ZuInspect<U, char>::Same, R>;

  template <typename U, typename R = void>
  using MatchReal = ZuIfT<
    ZuTraits<U>::IsPrimitive && ZuTraits<U>::IsReal &&
      !ZuInspect<U, char>::Same,
    R>;

  template <typename U, typename R = void>
  using MatchString = ZuIfT<
    ZuTraits<U>::IsString && !ZuTraits<U>::IsWString &&
      !ZuInspect<ZuCSpan, U>::Is,
    R>;

  template <typename U, typename R = void>
  using MatchPDelegate = ZuIfT<ZuPrint<U>::Delegate, R>;

  template <typename U, typename R = void>
  using MatchPBuffer = ZuIfT<ZuPrint<U>::Buffer, R>;

public:
  template <typename C> MatchChar<C, ZuVStream &> operator<<(C c) {
    (*m_strFn)(m_ptr, ZuCSpan{&c, 1});
    return *this;
  }
  template <typename R> MatchReal<R, ZuVStream &> operator<<(const R &r) {
    (*m_bufFn)(m_ptr, ZuVStreamBuf{ZuBoxed(r)});
    return *this;
  }
  ZuVStream &operator<<(ZuCSpan s) {
    (*m_strFn)(m_ptr, s);
    return *this;
  }
  template <typename S> MatchString<S, ZuVStream &> operator<<(S &&s_) {
    (*m_strFn)(m_ptr, ZuCSpan{ZuFwd<S>(s_)});
    return *this;
  }
  template <typename P> MatchPDelegate<P, ZuVStream &> operator<<(const P &p) {
    ZuPrint<P>::print(*this, p);
    return *this;
  }
  template <typename P> MatchPBuffer<P, ZuVStream &> operator<<(const P &p) {
    (*m_bufFn)(m_ptr, ZuVStreamBuf{p});
    return *this;
  }

private:
  typedef void (*StrFn)(void *, const ZuCSpan &);
  typedef void (*BufFn)(void *, const ZuVStreamBuf &);

  void *m_ptr;
  StrFn m_strFn;
  BufFn m_bufFn;
};

extern void ZmBackTrace_print(ZuVStream &s, const ZmBackTrace &bt);

struct ZmBackTrace_Print : public ZuPrintDelegate {
  template <typename S> static void print(S &s_, const ZmBackTrace &bt) {
    ZuVStream s{s_};
    ZmBackTrace_print(s, bt);
  }
  static void print(ZuVStream &s, const ZmBackTrace &bt) {
    ZmBackTrace_print(s, bt);
  }
};

template <auto ID, bool Sharded, unsigned Align> class ZmVHeap;
template <auto ID, bool Sharded, unsigned Align> class ZmVHeap_Init {
  template <auto, bool, unsigned> friend class ZmVHeap;
  ZmVHeap_Init();
};

inline unsigned ZmGrow(unsigned o, unsigned n) {
  if (__builtin_expect(!!(o >= n), 0)) return o;
  unsigned i = n <= 1 ? 0 : (sizeof(n) << 3) - ZuIntrin::clz(n - 1);
  if (__builtin_expect(!!(i >= 17), 0)) return ((n + 0xffffU) & ~0xffffU);
  return ZuSwitch::dispatch<17>(i, [](auto I) {
    return static_cast<unsigned>(ZmHeapAllocSize<(1 << I)>::N);
  });
}

template <auto ID, bool Sharded = false, unsigned Align = 1> class ZmVHeap {
  template <auto, bool, unsigned> friend class ZmVHeap_Init;

  template <unsigned N>
  using Cache = ZmHeapCacheT<ID, ZmHeapAllocSize<(1 << N)>::N, Align, Sharded>;

public:
  static void *valloc(size_t size) {
    if (__builtin_expect(!!(!size), 0)) return nullptr;
    ((size <

      (0x7fffffff * 2U + 1U)

     ) ?
       void() :
       ZmAssert_fail(
	 "size < UINT_MAX", "../../zm/src/zlib/ZmVHeap.hh", 49,
	 __PRETTY_FUNCTION__
       ));
    size += Align;
    unsigned i = (sizeof(size) << 3) - ZuIntrin::clz(size);

    if (__builtin_expect(!!(i >= 17), 0)) {
      auto ptr = static_cast<uint8_t *>(Zm::alignedAlloc<Align>(size));
      if (__builtin_expect(!!(!ptr), 0)) return nullptr;
      *ptr = i;
      return ptr + Align;
    }
    return ZuSwitch::dispatch<17>(i, [](auto I) -> void * {
      auto ptr = static_cast<uint8_t *>(Cache<I>::alloc());
      if (__builtin_expect(!!(!ptr), 0)) return nullptr;
      *ptr = I;
      return ptr + Align;
    });
  }
  static void vfree(const void *ptr_) {
    if (__builtin_expect(!!(!ptr_), 0)) return;
    auto ptr = (reinterpret_cast<const uint8_t *>(ptr_) - Align);
    auto i = *ptr;
    if (__builtin_expect(!!(i >= 17), 0)) {
      Zm::alignedFree(ptr);
      return;
    }
    ZuSwitch::dispatch<17>(i, [ptr](auto I) {
      Cache<I>::free(const_cast<uint8_t *>(ptr));
    });
  }

private:
  static ZmVHeap_Init<ID, Sharded, Align> m_init;
};

template <auto ID, bool Sharded, unsigned Align>
ZmVHeap_Init<ID, Sharded, Align>::ZmVHeap_Init() {
  using VHeap = ZmVHeap<ID, Sharded, Align>;
  for (unsigned i = 0; i < 16; i++)
    ZuSwitch::dispatch<16>(i, [](auto I) {
      if (auto ptr = VHeap::template Cache<I>::alloc())
	VHeap::template Cache<I>::free(ptr);
    });
}

template <auto ID, bool Sharded, unsigned Align>
ZmVHeap_Init<ID, Sharded, Align> ZmVHeap<ID, Sharded, Align>::m_init;

namespace Zt {

inline int putenv(const char *s) { return ::putenv(const_cast<char *>(s)); }

}

extern "C" {

  typedef void *iconv_t;

  extern int iconv_close(iconv_t __cd);

  extern iconv_t iconv_open(const char *__tocode, const char *__fromcode)
    __attribute__((__malloc__)) __attribute__((__malloc__(iconv_close, 1)));

  extern size_t iconv(
    iconv_t __cd, char **__restrict __inbuf, size_t *__restrict __inbytesleft,
    char **__restrict __outbuf, size_t *__restrict __outbytesleft
  );
}

template <typename... Ts> struct ZuMostAligned_;
template <typename T0> struct ZuMostAligned_<T0> {
  using T = T0;
};
template <typename T0, typename... Ts> struct ZuMostAligned_<T0, Ts...> {
  using T = ZuIf<
    (alignof(T0) >= alignof(typename ZuMostAligned_<Ts...>::T)), T0,
    typename ZuMostAligned_<Ts...>::T>;
};
template <typename... Ts> struct ZuMostAligned_<void, Ts...> {
  using T = typename ZuMostAligned_<Ts...>::T;
};
template <typename... Ts>
struct ZuMostAligned_<ZuTypeList<Ts...>> : public ZuMostAligned_<Ts...> { };
template <typename... Ts>
using ZuMostAligned = typename ZuMostAligned_<Ts...>::T;

template <typename> struct ZuUnion_OpBool;
template <> struct ZuUnion_OpBool<bool> {
  using T = void;
};
template <typename T, typename = void> struct ZuUnion_OpStar {
  static bool star(const void *p) {
    return !ZuCmp<T>::null(*static_cast<const T *>(p));
  }
};
template <typename T>
struct ZuUnion_OpStar<
  T, typename ZuUnion_OpBool<decltype(*(ZuDeclVal<const T &>()))>::T> {
  static bool star(const void *p) { return *(*static_cast<const T *>(p)); }
};
template <typename T, typename = void> struct ZuUnion_OpBang {
  static bool bang(const void *p) { return !(*static_cast<const T *>(p)); }
};
template <typename T>
struct ZuUnion_OpBang<
  T, typename ZuUnion_OpBool<decltype(!(ZuDeclVal<const T &>()))>::T> {
  static bool bang(const void *p) {
    return ZuCmp<T>::null(*static_cast<const T *>(p));
  }
};

template <typename T, bool IsPrimitive, bool IsPointer> class ZuUnion_Ops_;
template <typename T>
class ZuUnion_Ops_<T, 0, 0> :
  public ZuUnion_OpStar<T>,
  public ZuUnion_OpBang<T> {
public:
  static void ctor(void *p) { new (p) T(); }
  template <typename V> static void ctor(void *p, V &&v) {
    new (p) T(ZuFwd<V>(v));
  }
  static void dtor(void *p) { static_cast<T *>(p)->~T(); }
};
template <typename T> class ZuUnion_Ops_<T, 1, 0> {
public:
  static void ctor(void *p) { *static_cast<T *>(p) = ZuCmp<T>::null(); }
  template <typename V> static void ctor(void *p, V &&v) {
    *static_cast<T *>(p) = ZuFwd<V>(v);
  }
  static void dtor(void *p) { }
  static bool star(const void *p) {
    return !ZuCmp<T>::null(*static_cast<const T *>(p));
  }
  static bool bang(const void *p) { return !(*static_cast<const T *>(p)); }
};
template <typename T> class ZuUnion_Ops_<T, 1, 1> {
public:
  static void ctor(void *p) { *static_cast<T *>(p) = nullptr; }
  template <typename V> static void ctor(void *p, V &&v) {
    *static_cast<T *>(p) = ZuFwd<V>(v);
  }
  static void dtor(void *p) { }
  static bool star(const void *p) {
    return static_cast<bool>(*static_cast<const T *>(p));
  }
  static bool bang(const void *p) { return !(*static_cast<const T *>(p)); }
};
template <typename T>
struct ZuUnion_Ops :
  public ZuUnion_Ops_<
    T, ZuTraits<T>::IsPrimitive,
    ZuTraits<T>::IsPrimitive && ZuTraits<T>::IsPointer> {
  template <typename V> static void assign(void *p, V &&v) {
    *static_cast<T *>(p) = ZuFwd<V>(v);
  }
  template <typename V> static bool less(const void *p, const V &v) {
    return ZuCmp<T>::less(*static_cast<const T *>(p), v);
  }
  template <typename V> static bool equals(const void *p, const V &v) {
    return ZuCmp<T>::equals(*static_cast<const T *>(p), v);
  }
  template <typename V> static int cmp(const void *p, const V &v) {
    return ZuCmp<T>::cmp(*static_cast<const T *>(p), v);
  }
  static uint32_t hash(const void *p) {
    return ZuHash<T>::hash(*static_cast<const T *>(p));
  }
};

template <typename Base, typename... Ts> struct ZuUnion_Traits;
template <typename Base, typename T0>
struct ZuUnion_Traits<Base, T0> : public Base {
  enum { IsPOD = ZuTraits<T0>::IsPOD };
};
template <typename Base, typename T0, typename... Ts>
struct ZuUnion_Traits<Base, T0, Ts...> : public Base {
private:
  using Left = ZuTraits<T0>;
  using Right = ZuUnion_Traits<Base, Ts...>;

public:
  enum { IsPOD = Left::IsPOD && Right::IsPOD };
};

template <typename T> struct ZuUnion_IsVoid_ : public ZuFalse { };
template <> struct ZuUnion_IsVoid_<void> : public ZuTrue { };
template <typename T> using ZuUnion_IsVoid = ZuUnion_IsVoid_<ZuDecay<T>>;

namespace Zu_ {

template <typename... Ts> class Union;

struct Union_RDecayer {
  template <typename> struct Decay;
  template <typename... Ts> struct Decay<Union<Ts...>> {
    using T = ZuTypeApply<Union, ZuTypeMap<ZuRDecay, Ts...>>;
  };
};

template <typename... Ts> class Union {
public:
  using Types = ZuTypeList<Ts...>;
  using Largest = ZuLargest<Ts...>;
  enum { Size = ZuSize<Largest>{} };
  enum { N = sizeof...(Ts) };
  template <unsigned I> using Type = ZuType<I, Types>;
  template <unsigned I> using Type_ = ZuDecay<Type<I>>;
  template <typename T> using Index = ZuTypeIndex<T, Types>;
  template <typename T>
  using Index_ = ZuTypeIndex<T, ZuTypeMap<ZuDecay, Types>>;

  Union() {
    using T0 = Type<0>;
    type_(0);
    if constexpr (!ZuUnion_IsVoid<T0>{}) new (&m_u[0]) T0{};
  }

  ~Union() {
    ZuSwitch::dispatch<N>(type(), [this](auto I) {
      using T = Type<I>;
      if constexpr (!ZuUnion_IsVoid<T>{}) ZuUnion_Ops<T>::dtor(m_u);
    });
  }

  Union(const Union &u) {
    ZuSwitch::dispatch<N>(type_(u.type()), [this, &u](auto I) {
      using T = Type<I>;
      if constexpr (!ZuUnion_IsVoid<T>{}) {
	const T *__attribute__((__may_alias__)) ptr =
	  reinterpret_cast<const T *>(u.m_u);
	ZuUnion_Ops<T>::ctor(m_u, *ptr);
      }
    });
  }
  Union(Union &&u) {
    ZuSwitch::dispatch<N>(type_(u.type()), [this, &u](auto I) {
      using T = Type<I>;
      if constexpr (!ZuUnion_IsVoid<T>{}) {
	T *__attribute__((__may_alias__)) ptr = reinterpret_cast<T *>(u.m_u);
	ZuUnion_Ops<T>::ctor(m_u, ZuMv(*ptr));
      }
    });
  }

  Union &operator=(const Union &u) {
    if (this == &u) return *this;
    if (type() != u.type()) {
      this->~Union();
      new (this) Union(u);
      return *this;
    }
    ZuSwitch::dispatch<N>(type_(u.type()), [this, &u](auto I) {
      using T = Type<I>;
      if constexpr (!ZuUnion_IsVoid<T>{}) {
	const T *__attribute__((__may_alias__)) ptr =
	  reinterpret_cast<const T *>(u.m_u);
	ZuUnion_Ops<T>::assign(m_u, *ptr);
      }
    });
    return *this;
  }
  Union &operator=(Union &&u) {
    if (type() != u.type()) {
      this->~Union();
      new (this) Union(ZuMv(u));
      return *this;
    }
    ZuSwitch::dispatch<N>(type_(u.type()), [this, &u](auto I) {
      using T = Type<I>;
      if constexpr (!ZuUnion_IsVoid<T>{}) {
	T *__attribute__((__may_alias__)) ptr = reinterpret_cast<T *>(u.m_u);
	ZuUnion_Ops<T>::assign(m_u, ZuMv(*ptr));
      }
    });
    return *this;
  }

  template <unsigned I, bool New = false> Type<I> *new_() {
    if constexpr (!New) this->~Union();
    this->type_(I);
    return reinterpret_cast<Type<I> *>(&m_u[0]);
  }
  template <unsigned I, bool New = false> static Type<I> *new_(void *ptr) {
    return reinterpret_cast<Union *>(ptr)->new_<I, New>();
  }
  template <typename T, bool New = false> Type<Index<T>{}> *new_() {
    return new_<Index<T>{}, New>();
  }
  template <typename T, bool New = false>
  static Type<Index<T>{}> *new_(void *ptr) {
    return reinterpret_cast<Union *>(ptr)->new_<Index<T>{}, New>();
  }

private:
  template <typename V, bool = ZuInspect<Union, V>::Is> struct Fwd_Ctor_ {
    enum { I = Index_<V>{} };
    using T = Type<I>;
    static void ctor(Union *this_, V &&v) {
      new (new_<I, true>(this_)) T{ZuMv(v)};
    }
    static void ctor(Union *this_, const V &v) {
      new (new_<I, true>(this_)) T{v};
    }
  };
  template <typename V> struct Fwd_Ctor_<V, true> {
    static void ctor(Union *this_, V &&v) {
      new (this_) Union{static_cast<Union &&>(v)};
    }
    static void ctor(Union *this_, const V &v) {
      new (this_) Union{static_cast<const Union &>(v)};
    }
  };
  template <typename V> struct Fwd_Ctor : public Fwd_Ctor_<ZuDecay<V>> { };

public:
  template <typename V, decltype(ZuIfT<!ZuUnion_IsVoid<V>{}>(), int()) = 0>
  Union(V &&v) {
    Fwd_Ctor<V>::ctor(this, ZuFwd<V>(v));
  }

private:
  template <typename V, bool = ZuTraits<V>::IsPrimitive> struct Fwd_Assign__ {
    enum { I = Index_<V>{} };
    using T = Type<I>;
    static void assign(Union *this_, V &&v) {
      new (this_->new_<I>()) T{ZuMv(v)};
    }
    static void assign(Union *this_, const V &v) {
      new (this_->new_<I>()) T{v};
    }
  };
  template <typename V> struct Fwd_Assign__<V, true> {
    enum { I = Index_<V>{} };
    static void assign(Union *this_, V v) { *(this_->new_<I>()) = v; }
  };
  template <typename V, bool = ZuInspect<Union, V>::Is>
  struct Fwd_Assign_ : public Fwd_Assign__<V> { };
  template <typename V> struct Fwd_Assign_<V, true> {
    static void assign(Union *this_, V &&v) {
      this_->operator=(static_cast<Union &&>(v));
    }
    static void assign(Union *this_, const V &v) {
      this_->operator=(static_cast<const Union &>(v));
    }
  };
  template <typename V> struct Fwd_Assign : public Fwd_Assign_<ZuDecay<V>> { };

public:
  template <typename V> ZuIfT<!ZuUnion_IsVoid<V>{}, Union &> operator=(V &&v) {
    Fwd_Assign<V>::assign(this, ZuFwd<V>(v));
    return *this;
  }

  unsigned type_(unsigned i) { return m_u[Size] = i; }

  void null() {
    ZuSwitch::dispatch<N>(type(), [this](auto I) {
      using T = Type<I>;
      if constexpr (!ZuUnion_IsVoid<T>{}) ZuUnion_Ops<T>::dtor(m_u);
    });
    type_(0);
  }

  template <typename P> ZuIs<Union, P, bool> equals(const P &p) const {
    if (this == &p) return true;
    if (type() != p.type()) return false;
    return ZuSwitch::dispatch<N>(type(), [this, &p](auto I) -> bool {
      using T = Type<I>;
      if constexpr (!ZuUnion_IsVoid<T>{}) {
	const T *__attribute__((__may_alias__)) ptr =
	  reinterpret_cast<const T *>(p.m_u);
	return ZuUnion_Ops<T>::equals(m_u, *ptr);
      } else
	return true;
    });
  }
  template <typename P> ZuIsNot<Union, P, bool> equals(const P &p) const {
    return ZuSwitch::dispatch<N>(type(), [this, &p](auto I) -> bool {
      using T = Type<I>;
      if constexpr (!ZuUnion_IsVoid<T>{})
	return ZuUnion_Ops<T>::equals(m_u, p);
      else
	return false;
    });
  }
  template <typename P> ZuIs<Union, P, int> cmp(const P &p) const {
    if (this == &p) return 0;
    if (int i = ZuCmp<uint8_t>::cmp(type(), p.type())) return i;
    return ZuSwitch::dispatch<N>(type(), [this, &p](auto I) -> int {
      using T = Type<I>;
      if constexpr (!ZuUnion_IsVoid<T>{}) {
	const T *__attribute__((__may_alias__)) ptr =
	  reinterpret_cast<const T *>(p.m_u);
	return ZuUnion_Ops<T>::cmp(m_u, *ptr);
      } else
	return 0;
    });
  }
  template <typename P> ZuIsNot<Union, P, int> cmp(const P &p) const {
    return ZuSwitch::dispatch<N>(type(), [this, &p](auto I) -> int {
      using T = Type<I>;
      if constexpr (!ZuUnion_IsVoid<T>{})
	return ZuUnion_Ops<T>::cmp(m_u, p);
      else
	return -1;
    });
  }
  template <typename L, typename R>
  friend inline ZuIfT<ZuInspect<Union, L>::Is, bool>
  operator==(const L &l, const R &r) {
    return l.equals(r);
  }
  template <typename L, typename R>
  friend inline ZuIfT<ZuInspect<Union, L>::Is, int>
  operator<=>(const L &l, const R &r) {
    return l.cmp(r);
  }

  bool operator*() const {
    return ZuSwitch::dispatch<N>(type(), [this](auto I) -> bool {
      using T = Type<I>;
      if constexpr (!ZuUnion_IsVoid<T>{})
	return ZuUnion_Ops<T>::star(m_u);
      else
	return false;
    });
  }

  bool operator!() const {
    return ZuSwitch::dispatch<N>(type(), [this](auto I) -> bool {
      using T = Type<I>;
      if constexpr (!ZuUnion_IsVoid<T>{})
	return ZuUnion_Ops<T>::bang(m_u);
      else
	return true;
    });
  }

  uint32_t hash() const {
    return ZuSwitch::dispatch<N>(type(), [this](auto I) -> uint32_t {
      using T = Type<I>;
      if constexpr (!ZuUnion_IsVoid<T>{})
	return ZuHash<uint8_t>::hash(I) ^ ZuUnion_Ops<T>::hash(m_u);
      else
	return ZuHash<uint8_t>::hash(I);
    });
  }

  unsigned type() const { return m_u[Size]; }

  template <typename T> bool is() const { return type() == Index<T>{}; }

  template <unsigned I>
  ZuIfT<!ZuUnion_IsVoid<Type_<I>>{}, const Type_<I> &> p() const & {
    using T = Type<I>;

    (static_cast<bool>(

       type() == I

     ) ?
       void(0) :
       __assert_fail(

	 "type() == I"

	 ,
	 __builtin_FILE(), __builtin_LINE(), __extension__ __PRETTY_FUNCTION__
       ));
    const T *__attribute__((__may_alias__)) ptr =
      reinterpret_cast<const T *>(m_u);
    return *ptr;
  }
  template <unsigned I> ZuIfT<!ZuUnion_IsVoid<Type_<I>>{}, Type_<I> &> p() & {
    using T = Type<I>;

    (static_cast<bool>(

       type() == I

     ) ?
       void(0) :
       __assert_fail(

	 "type() == I"

	 ,
	 __builtin_FILE(), __builtin_LINE(), __extension__ __PRETTY_FUNCTION__
       ));
    T *__attribute__((__may_alias__)) ptr = reinterpret_cast<T *>(m_u);
    return *ptr;
  }
  template <unsigned I> ZuIfT<!ZuUnion_IsVoid<Type_<I>>{}, Type_<I> &&> p() && {
    using T = Type<I>;

    (static_cast<bool>(

       type() == I

     ) ?
       void(0) :
       __assert_fail(

	 "type() == I"

	 ,
	 __builtin_FILE(), __builtin_LINE(), __extension__ __PRETTY_FUNCTION__
       ));
    T *__attribute__((__may_alias__)) ptr = reinterpret_cast<T *>(m_u);
    return ZuMv(*ptr);
  }
  template <unsigned I, typename P>
  ZuIfT<!ZuUnion_IsVoid<Type_<I>>{}, Union &> p(P &&p) {
    using T = Type<I>;
    if (type() == I) {
      T *__attribute__((__may_alias__)) ptr = reinterpret_cast<T *>(m_u);
      *ptr = ZuFwd<P>(p);
      return *this;
    }
    this->~Union();
    type_(I);
    ZuUnion_Ops<T>::ctor(m_u, ZuFwd<P>(p));
    return *this;
  }

  template <typename T>
  ZuIfT<!ZuUnion_IsVoid<T>{}, const ZuDecay<T> &> p() const & {
    return this->template p<Index<T>{}>();
  }
  template <typename T> ZuIfT<!ZuUnion_IsVoid<T>{}, ZuDecay<T> &> p() & {
    return this->template p<Index<T>{}>();
  }
  template <typename T> ZuIfT<!ZuUnion_IsVoid<T>{}, ZuDecay<T> &&> p() && {
    return ZuMv(*this).template p<Index<T>{}>();
  }
  template <typename T, typename P>
  ZuIfT<!ZuUnion_IsVoid<T>{}, Union &> p(P &&p) {
    return this->template p<Index<T>{}>(ZuFwd<P>(p));
  }

  template <unsigned I> const Type<I> *ptr() const {
    if (type() != I) return nullptr;
    return ptr_<I>();
  }
  template <unsigned I> Type<I> *ptr() {
    if (type() != I) return nullptr;
    return ptr_<I>();
  }
  template <unsigned I> const Type<I> *ptr_() const {
    using T = Type<I>;
    const T *__attribute__((__may_alias__)) ptr =
      reinterpret_cast<const T *>(m_u);
    return ptr;
  }
  template <unsigned I> Type<I> *ptr_() {
    using T = Type<I>;
    T *__attribute__((__may_alias__)) ptr = reinterpret_cast<T *>(m_u);
    return ptr;
  }

  template <typename T> const auto *ptr() const { return ptr<Index<T>{}>(); }
  template <typename T> auto *ptr() { return ptr<Index<T>{}>(); }
  template <typename T> const auto *ptr_() const { return ptr_<Index<T>{}>(); }
  template <typename T> auto *ptr_() { return ptr_<Index<T>{}>(); }

  template <typename L> auto dispatch(L l) & {
    return ZuSwitch::dispatch<N>(type(), [this, &l](auto I) mutable {
      if constexpr (!ZuUnion_IsVoid<Type<I>>{})
	return l(I, this->template p<I>());
    });
  }
  template <typename L> auto dispatch(L l) const & {
    return ZuSwitch::dispatch<N>(type(), [this, &l](auto I) mutable {
      if constexpr (!ZuUnion_IsVoid<Type<I>>{})
	return l(I, this->template p<I>());
    });
  }
  template <typename L> auto dispatch(L l) && {
    return ZuSwitch::dispatch<N>(type(), [this, &l](auto I) mutable {
      if constexpr (!ZuUnion_IsVoid<Type<I>>{})
	return l(I, ZuMv(*this).template p<I>());
    });
  }
  template <typename L> auto cdispatch(L l) const & {
    return dispatch(ZuMv(l));
  }

  using Traits = ZuUnion_Traits<ZuBaseTraits<Union>, Ts...>;
  friend Traits ZuTraitsType(Union *) { return {}; }

  friend Union_RDecayer ZuRDecayer(Union *);

private:
  uint8_t m_u[Size + 1];
}

__attribute__((aligned(alignof(ZuMostAligned<Ts...>))));

} // namespace Zu_

template <typename... Ts> using ZuUnion = Zu_::Union<Ts...>;

namespace std {

template <class> struct tuple_size;
template <typename... Ts>
struct tuple_size<ZuUnion<Ts...>> :
  public integral_constant<size_t, sizeof...(Ts)> { };

template <size_t, typename> struct tuple_element;
template <size_t I, typename... Ts> struct tuple_element<I, ZuUnion<Ts...>> {
  using type = typename ZuUnion<Ts...>::template Type<I>;
};

}

namespace Zu_ {

using size_t = std::size_t;
using bad_variant_access = std::bad_variant_access;
namespace {
template <size_t I, typename T>
using tuple_element_t = typename std::tuple_element<I, T>::type;
}
template <size_t I, typename... Ts>
constexpr tuple_element_t<I, Union<Ts...>> &get(Union<Ts...> &p) {
  if (__builtin_expect(!!(p.type() != I), 0)) throw bad_variant_access{};
  return p.template p<I>();
}
template <size_t I, typename... Ts>
constexpr const tuple_element_t<I, Union<Ts...>> &get(const Union<Ts...> &p) {
  if (__builtin_expect(!!(p.type() != I), 0)) throw bad_variant_access{};
  return p.template p<I>();
}
template <size_t I, typename... Ts>
constexpr tuple_element_t<I, Union<Ts...>> &&get(Union<Ts...> &&p) {
  if (__builtin_expect(!!(p.type() != I), 0)) throw bad_variant_access{};
  return static_cast<tuple_element_t<I, Union<Ts...>> &&>(p.template p<I>());
}
template <size_t I, typename... Ts>
constexpr const tuple_element_t<I, Union<Ts...>> &&get(const Union<Ts...> &&p) {
  if (__builtin_expect(!!(p.type() != I), 0)) throw bad_variant_access{};
  return static_cast<const tuple_element_t<I, Union<Ts...>> &&>(p.template p<I>(
  ));
}

template <typename T, typename... Ts> constexpr T &get(Union<Ts...> &p) {
  if (__builtin_expect(
	!!(p.type() != typename Union<Ts...>::template Index<T>{}), 0
      ))
    throw bad_variant_access{};
  return p.template p<T>();
}
template <typename T, typename... Ts>
constexpr const T &get(const Union<Ts...> &p) {
  if (__builtin_expect(
	!!(p.type() != typename Union<Ts...>::template Index<T>{}), 0
      ))
    throw bad_variant_access{};
  return p.template p<T>();
}
template <typename T, typename... Ts> constexpr T &&get(Union<Ts...> &&p) {
  if (__builtin_expect(
	!!(p.type() != typename Union<Ts...>::template Index<T>{}), 0
      ))
    throw bad_variant_access{};
  return static_cast<T &&>(p.template p<T>());
}
template <typename T, typename... Ts>
constexpr const T &&get(const Union<Ts...> &&p) {
  if (__builtin_expect(
	!!(p.type() != typename Union<Ts...>::template Index<T>{}), 0
      ))
    throw bad_variant_access{};
  return static_cast<const T &&>(p.template p<T>());
}

} // namespace Zu_

template <typename Fmt> struct ZuDecimalFmt;
class ZuDecimalVFmt;

struct ZuDecimal {
  using ldouble = long double;

  template <unsigned N> using Pow10 = ZuDecimalFn::Pow10<N>;

  static constexpr const int128_t minimum() { return -Pow10<36U>{} + 1; }
  static constexpr const int128_t maximum() { return Pow10<36U>{} - 1; }
  static constexpr const int128_t reset() { return -Pow10<36U>{}; }
  static constexpr const int128_t null() { return int128_t(1) << 127; }
  static constexpr const uint64_t scale() { return Pow10<18U>{}; }
  static constexpr const ldouble scale_fp() { return 1000000000000000000.0L; }

  int128_t value;

  constexpr ZuDecimal() : value{null()} { }
  constexpr ZuDecimal(const ZuDecimal &v) : value{v.value} { }
  constexpr ZuDecimal &operator=(const ZuDecimal &v) {
    value = v.value;
    return *this;
  }
  constexpr ZuDecimal(ZuDecimal &&v) : value{v.value} { }
  constexpr ZuDecimal &operator=(ZuDecimal &&v) {
    value = v.value;
    return *this;
  }
  constexpr ~ZuDecimal() { }

  enum NoInit_ { NoInit };
  constexpr ZuDecimal(NoInit_ _) { }

  struct Unscaled {
    int128_t v;
  };

  constexpr ZuDecimal(Unscaled unscaled) : value{unscaled.v} { }

  template <typename V, decltype(ZuMatchIntegral<V>(), int()) = 0>
  constexpr ZuDecimal(V v) : value(int128_t(v) * scale()) { }

  template <typename V, decltype(ZuMatchFloatingPoint<V>(), int()) = 0>
  constexpr ZuDecimal(V v) {
    if (__builtin_expect(
	  !!(ZuFP<V>::nan(v) || ZuFP<V>::inf(v) || ZuFP<V>::inf(-v)), 0
	))
      value = null();
    else
      value = ldouble(v) * scale_fp();
  }

  template <typename V, decltype(ZuMatchIntegral<V>(), int()) = 0>
  constexpr ZuDecimal(V v, unsigned ndp) :
    value(int128_t(v) * ZuDecimalFn::pow10_64(18 - ndp)) { }

  constexpr int128_t adjust(unsigned ndp) const {
    if (__builtin_expect(!!(ndp == 18), 0)) return value;
    return value / ZuDecimalFn::pow10_64(18 - ndp);
  }

  constexpr ZuDecimal operator-() const {
    if (__builtin_expect(!!(value == null()), 0))
      return ZuDecimal{Unscaled{null()}};
    return ZuDecimal{Unscaled{-value}};
  }

  constexpr ZuDecimal operator+(const ZuDecimal &v) const {
    if (__builtin_expect(!!(value == null() || v.value == null()), 0))
      return ZuDecimal{Unscaled{null()}};
    int128_t result;
    if (ZuIntrin::add(value, v.value, &result) || result > maximum() ||
	result < minimum())
      return ZuDecimal{Unscaled{null()}};
    return ZuDecimal{Unscaled{result}};
  }
  constexpr ZuDecimal &operator+=(const ZuDecimal &v) {
    if (__builtin_expect(!!(value == null()), 0)) return *this;
    if (__builtin_expect(!!(v.value == null()), 0))
      value = null();
    else if (ZuIntrin::add(value, v.value, &value) || value > maximum() ||
	     value < minimum())
      value = null();
    return *this;
  }

  constexpr ZuDecimal operator-(const ZuDecimal &v) const {
    if (__builtin_expect(!!(value == null() || v.value == null()), 0))
      return ZuDecimal{Unscaled{null()}};
    int128_t result;
    if (ZuIntrin::sub(value, v.value, &result) || result > maximum() ||
	result < minimum())
      return ZuDecimal{Unscaled{null()}};
    return ZuDecimal{Unscaled{result}};
  }
  constexpr ZuDecimal &operator-=(const ZuDecimal &v) {
    if (__builtin_expect(!!(value == null()), 0)) return *this;
    if (__builtin_expect(!!(v.value == null()), 0))
      value = null();
    else if (ZuIntrin::sub(value, v.value, &value) || value > maximum() ||
	     value < minimum())
      value = null();
    return *this;
  }

  static void
  mul128by128(uint128_t u, uint128_t v, uint128_t &h, uint128_t &l) {
    uint128_t u1 = uint64_t(u);
    uint128_t v1 = uint64_t(v);
    uint128_t t = (u1 * v1);
    uint128_t w3 = uint64_t(t);
    uint128_t k = (t >> 64);

    u >>= 64;
    t = (u * v1) + k;
    k = uint64_t(t);
    uint128_t w1 = (t >> 64);

    v >>= 64;
    t = (u1 * v) + k;
    k = (t >> 64);

    h = (u * v) + w1 + k;
    l = (t << 64) + w3;
  }

  static void mul128scale(uint128_t u, uint128_t &h, uint128_t &l) {
    uint128_t u1 = uint64_t(u);
    const uint128_t v1 = scale();
    uint128_t t = (u1 * v1);
    uint128_t w3 = uint64_t(t);
    uint128_t k = (t >> 64);

    u >>= 64;

    t = u * v1 + k;
    k = uint64_t(t);

    h = (t >> 64) + (k >> 64);
    l = (k << 64) + w3;
  }

  static void div256by128(
    const uint128_t u1, const uint128_t u0, uint128_t v, uint128_t &q
  ) {
    const uint128_t b = ((uint128_t)1) << 64;
    uint128_t un1, un0, vn1, vn0, q1, q0, un128, un21, un10, rhat, left, right;
    size_t s;

    if (!v)
      s = 0;
    else if (v < b)
      s = ZuIntrin::clz(uint64_t(v)) + 64;
    else
      s = ZuIntrin::clz(uint64_t(v >> 64));
    v <<= s;
    vn0 = uint64_t(v);
    vn1 = v >> 64;

    if (s > 0) {
      un128 = (u1 << s) | (u0 >> (128 - s));
      un10 = u0 << s;
    } else {
      un128 = u1;
      un10 = u0;
    }

    un1 = un10 >> 64;
    un0 = uint64_t(un10);

    q1 = un128 / vn1;
    rhat = un128 % vn1;

    left = q1 * vn0;
    right = (rhat << 64) + un1;

loop1:
    if ((q1 >= b) || (left > right)) {
      --q1;
      rhat += vn1;
      if (rhat < b) {
	left -= vn0;
	right = (rhat << 64) | un1;
	goto loop1;
      }
    }

    un21 = (un128 << 64) + (un1 - (q1 * v));

    q0 = un21 / vn1;
    rhat = un21 % vn1;

    left = q0 * vn0;
    right = (rhat << 64) | un0;

loop2:
    if ((q0 >= b) || (left > right)) {
      --q0;
      rhat += vn1;
      if (rhat < b) {
	left -= vn0;
	right = (rhat << 64) | un0;
	goto loop2;
      }
    }

    q = (q1 << 64) | q0;
  }

  static uint128_t div256scale(const uint128_t u1, const uint128_t u0) {
    const uint128_t b = ((uint128_t)1) << 64;
    const uint128_t v = ((uint128_t)scale()) << 68;

    uint128_t un1, un0, vn1, vn0, q1, q0, un128, un21, un10, rhat, left, right;

    vn0 = uint64_t(v);
    vn1 = v >> 64;

    un128 = (u1 << 68) | (u0 >> 60);
    un10 = u0 << 68;

    un1 = un10 >> 64;
    un0 = uint64_t(un10);

    q1 = un128 / vn1;
    rhat = un128 % vn1;

    left = q1 * vn0;
    right = (rhat << 64) + un1;

loop1:
    if ((q1 >= b) || (left > right)) {
      --q1;
      rhat += vn1;
      if (rhat < b) {
	left -= vn0;
	right = (rhat << 64) | un1;
	goto loop1;
      }
    }

    un21 = (un128 << 64) + (un1 - (q1 * v));

    q0 = un21 / vn1;
    rhat = un21 % vn1;

    left = q0 * vn0;
    right = (rhat << 64) | un0;

loop2:
    if ((q0 >= b) || (left > right)) {
      --q0;
      rhat += vn1;
      if (rhat < b) {
	left -= vn0;
	right = (rhat << 64) | un0;
	goto loop2;
      }
    }

    return (q1 << 64) | q0;
  }

  static int128_t mul(int128_t u_, int128_t v_) {
    bool negative = u_ < 0;
    if (negative) u_ = -u_;
    if (v_ < 0) negative = !negative, v_ = -v_;

    uint128_t u = u_, v = v_;

    uint128_t h, l;

    mul128by128(u, v, h, l);

    if (h >= scale()) return null();

    u = div256scale(h, l);

    if (u > maximum()) return null();

    if (negative) return -int128_t(u);
    return u;
  }

  static int128_t div(int128_t u_, int128_t v_) {
    bool negative = u_ < 0;
    if (negative) u_ = -u_;
    if (v_ < 0) negative = !negative, v_ = -v_;

    uint128_t u = u_, v = v_;

    uint128_t h, l;

    mul128scale(u, h, l);

    if (h >= v) return null();

    div256by128(h, l, v, u);

    if (u > maximum()) return null();

    if (negative) return -int128_t(u);
    return u;
  }

public:
  constexpr ZuDecimal operator*(const ZuDecimal &v) const {
    if (__builtin_expect(!!(value == null() || v.value == null()), 0))
      return ZuDecimal{Unscaled{null()}};
    return ZuDecimal{Unscaled{mul(value, v.value)}};
  }

  ZuDecimal &operator*=(const ZuDecimal &v) {
    if (__builtin_expect(!!(value == null()), 0)) return *this;
    if (__builtin_expect(!!(v.value == null()), 0))
      value = null();
    else
      value = mul(value, v.value);
    return *this;
  }

  constexpr ZuDecimal operator/(const ZuDecimal &v) const {
    if (__builtin_expect(
	  !!(value == null() || v.value == null() || !v.value), 0
	))
      return ZuDecimal{Unscaled{null()}};
    return ZuDecimal{Unscaled{div(value, v.value)}};
  }
  ZuDecimal &operator/=(const ZuDecimal &v) {
    if (__builtin_expect(!!(value == null()), 0)) return *this;
    if (__builtin_expect(!!(v.value == null() || !v.value), 0))
      value = null();
    else
      value = div(value, v.value);
    return *this;
  }

  template <typename S, decltype(ZuMatchString<S>(), int()) = 0>
  ZuDecimal(const S &s) {
    scan(s);
  }

  unsigned scan(ZuCSpan s) {
    unsigned int m = 0;
    if (__builtin_expect(!!(!s), 0)) goto null;
    if (__builtin_expect(
	  !!(s.length() == 3 && s[0] == 'n' && s[1] == 'a' && s[2] == 'n'), 0
	)) {
      value = null();
      return 3;
    }
    {
      bool negative = s[0] == '-';
      if (__builtin_expect(!!(negative), 0)) {
	s.offset(1), ++m;
	if (__builtin_expect(!!(!s), 0)) goto null;
      }
      while (s[0] == '0') {
	s.offset(1), ++m;
	if (!s) goto zero;
      }
      uint64_t iv = 0, fv = 0;
      unsigned n = s.length();
      if (__builtin_expect(!!(s[0] == '.'), 0)) {
	++m;
	if (__builtin_expect(!!(n == 1), 0)) goto zero;
	goto frac;
      }
      n = Zu_atou(iv, s.data(), n);
      if (__builtin_expect(!!(!n), 0)) goto null;
      if (__builtin_expect(!!(n > 18), 0)) goto null;
      s.offset(n), m += n;
      if ((n = s.length()) > 1 && s[0] == '.') {
	++m;
frac:
	if (--n > 18) n = 18;
	n = Zu_atou(fv, &s[1], n);
	m += n;
	if (fv && n < 18) fv *= ZuDecimalFn::pow10_64(18 - n);
      }
      value = uint128_t(iv) * scale() + fv;
      if (__builtin_expect(!!(negative), 0)) value = -value;
    }
    return m;
zero:
    value = 0;
    return m;
null:
    value = null();
    return 0;
  }

  ldouble as_fp() const {
    if (__builtin_expect(!!(value == null()), 0)) return ZuFP<ldouble>::nan();
    return ldouble(value) / scale_fp();
  }

  constexpr int cmp(const ZuDecimal &v) const {
    return (value > v.value) - (value < v.value);
  }
  template <typename L, typename R>
  friend inline constexpr ZuIfT<
    bool(ZuIsExact<ZuDecimal, L>{}) && bool(ZuIsExact<ZuDecimal, R>{}), bool>
  operator==(const L &l, const R &r) {
    return l.value == r.value;
  }
  template <typename L, typename R>
  friend inline constexpr ZuIfT<
    bool(ZuIsExact<ZuDecimal, L>{}) && bool(ZuIsExact<ZuDecimal, R>{}), bool>
  operator<(const L &l, const R &r) {
    return l.value < r.value;
  }
  template <typename L, typename R>
  friend inline constexpr ZuIfT<
    bool(ZuIsExact<ZuDecimal, L>{}) && bool(ZuIsExact<ZuDecimal, R>{}), int>
  operator<=>(const L &l, const R &r) {
    return l.cmp(r);
  }

  template <typename L, typename R>
  friend inline constexpr ZuIfT<
    bool(ZuIsExact<ZuDecimal, L>{}) && !ZuIsExact<ZuDecimal, R>{}, bool>
  operator==(const L &l, const R &r) {
    return l.value == ZuDecimal{r}.value;
  }
  template <typename L, typename R>
  friend inline constexpr ZuIfT<
    bool(ZuIsExact<ZuDecimal, L>{}) && !ZuIsExact<ZuDecimal, R>{}, bool>
  operator<(const L &l, const R &r) {
    return l.value < ZuDecimal{r}.value;
  }
  template <typename L, typename R>
  friend inline constexpr ZuIfT<
    bool(ZuIsExact<ZuDecimal, L>{}) && !ZuIsExact<ZuDecimal, R>{}, int>
  operator<=>(const L &l, const R &r) {
    return l.cmp(ZuDecimal{r});
  }

  bool operator!() const { return !value; }
  operator const void *() const {
    return !*this ? reinterpret_cast<const void *>(0) :
		    static_cast<const void *>(this);
  }

  constexpr bool operator*() const {
    int128_t v = value - null();
    return bool(uint64_t(v >> 64) | uint64_t(v));
  }

  uint32_t hash() const { return ZuHash<int128_t>::hash(value); }

  constexpr int64_t floor() const {
    if (__builtin_expect(!!(value == null()), 0)) return ZuCmp<int64_t>::null();
    uint128_t scale_ = uint128_t(scale());
    if (value < 0) {
      auto j = (-value) / scale_;
      return -int64_t(j);
    } else
      return int64_t(value / scale_);
  }
  constexpr uint64_t frac() const {
    uint128_t scale_ = uint128_t(scale());
    uint128_t value_ = value < 0 ? -value : value;
    return value_ % scale_;
  }
  constexpr int64_t round() const {
    if (__builtin_expect(!!(value == null()), 0)) return ZuCmp<int64_t>::null();
    uint128_t scale_ = uint128_t(scale());
    if (value < 0) {
      auto j = (-value) / scale_;
      auto i = -int64_t(j);
      return i - ((uint128_t(-value) % scale_) >= 500000000000000000ULL);
    } else {
      auto i = int64_t(value / scale_);
      return i + ((uint128_t(value) % scale_) >= 500000000000000000ULL);
    }
  }

  constexpr unsigned ndp() const {
    auto frac = this->frac();
    if (__builtin_expect(!!(!frac), 1)) return 0;
    unsigned exp = 18;

    if (!(frac % 1000000000ULL)) {
      frac /= 1000000000ULL;
      exp -= 9;
    }
    if (!(frac % 100000ULL)) {
      frac /= 100000ULL;
      exp -= 5;
    }
    if (!(frac % 1000ULL)) {
      frac /= 1000ULL;
      exp -= 3;
    }
    if (exp >= 2 && !(frac % 100ULL)) {
      frac /= 100ULL;
      exp -= 2;
    }
    if (exp >= 1 && !(frac % 10ULL)) --exp;
    return exp;
  }

  template <typename S> void print(S &s) const;

  template <typename Fmt> ZuDecimalFmt<Fmt> fmt() const;
  template <bool Upper = false, typename Fmt = ZuFmt::Default>
  ZuDecimalFmt<ZuFmt::Hex<Upper, Fmt>> hex() const;
  template <
    int NDP = -ZuFmt::Default::NDP_, char Trim = '\0',
    typename Fmt = ZuFmt::Default>
  ZuDecimalFmt<ZuFmt::FP<NDP, Trim, Fmt>> fp() const;

  ZuDecimalVFmt vfmt() const;
  template <typename VFmt> ZuDecimalVFmt vfmt(VFmt &&) const;

  struct Traits : public ZuBaseTraits<ZuDecimal> {
    enum { IsReal = 1, IsSigned = 1 };
  };
  friend Traits ZuTraitsType(ZuDecimal *);

  friend ZuPrintFn ZuPrintType(ZuDecimal *);
};
template <typename Fmt> struct ZuDecimalFmt {
  const ZuDecimal &decimal;

  template <typename S> void print(S &s) const {
    if (__builtin_expect(!!(!*decimal), 0)) {
      s << "nan";
      return;
    }
    uint128_t iv, fv;
    if (__builtin_expect(!!(decimal.value < 0), 0)) {
      s << '-';
      iv = -decimal.value;
    } else
      iv = decimal.value;
    fv = iv % ZuDecimal::scale();
    iv /= ZuDecimal::scale();
    s << ZuBoxed(uint64_t(iv)).fmt<Fmt>();
    if (fv) s << '.' << ZuBoxed(uint64_t(fv)).fmt<ZuFmt::Frac<18, 18>>();
  }

  friend ZuPrintFn ZuPrintType(ZuDecimalFmt *);
};
template <class Fmt> inline ZuDecimalFmt<Fmt> ZuDecimal::fmt() const {
  return ZuDecimalFmt<Fmt>{*this};
}
template <bool Upper, typename Fmt>
inline ZuDecimalFmt<ZuFmt::Hex<Upper, Fmt>> ZuDecimal::hex() const {
  return ZuDecimalFmt<ZuFmt::Hex<Upper, Fmt>>{*this};
}
template <int NDP, char Trim, typename Fmt>
inline ZuDecimalFmt<ZuFmt::FP<NDP, Trim, Fmt>> ZuDecimal::fp() const {
  return ZuDecimalFmt<ZuFmt::FP<NDP, Trim, Fmt>>{*this};
}
template <typename S> inline void ZuDecimal::print(S &s) const {
  s << ZuDecimalFmt<ZuFmt::Default>{*this};
}
class ZuDecimalVFmt : public ZuVFmtWrapper<ZuDecimalVFmt> {
public:
  ZuDecimalVFmt(const ZuDecimal &decimal) : m_decimal{decimal} { }
  template <typename VFmt>
  ZuDecimalVFmt(const ZuDecimal &decimal, VFmt &&fmt) :
    ZuVFmtWrapper<ZuDecimalVFmt>{ZuFwd<VFmt>(fmt)}, m_decimal{decimal} { }

  template <typename S> void print(S &s) const {
    if (__builtin_expect(!!(!*m_decimal), 0)) {
      s << "nan";
      return;
    }
    uint128_t iv, fv;
    if (__builtin_expect(!!(m_decimal.value < 0), 0)) {
      s << '-';
      iv = -m_decimal.value;
    } else
      iv = m_decimal.value;
    fv = iv % ZuDecimal::scale();
    iv /= ZuDecimal::scale();
    s << ZuBoxed(iv).vfmt(fmt);
    if (fv) s << '.' << ZuBoxed(fv).fmt<ZuFmt::Frac<18, 18>>();
  }

  friend ZuPrintFn ZuPrintType(ZuDecimalVFmt *);

private:
  const ZuDecimal &m_decimal;
};

inline ZuDecimalVFmt ZuDecimal::vfmt() const { return ZuDecimalVFmt{*this}; }
template <typename VFmt>
inline ZuDecimalVFmt ZuDecimal::vfmt(VFmt &&fmt) const {
  return ZuDecimalVFmt{*this, ZuFwd<VFmt>(fmt)};
}

template <> struct ZuCmp<ZuDecimal> {
  template <typename L, typename R>
  static constexpr int cmp(const L &l, const R &r) {
    return l.cmp(r);
  }
  template <typename L, typename R>
  static constexpr bool equals(const L &l, const R &r) {
    return l == r;
  }
  template <typename L, typename R>
  static constexpr bool less(const L &l, const R &r) {
    return l < r;
  }
  static constexpr bool null(const ZuDecimal &v) { return !*v; }
  static constexpr ZuDecimal null() { return {}; }
  static constexpr ZuDecimal minimum() {
    return {ZuDecimal::Unscaled{ZuDecimal::minimum()}};
  }
  static constexpr ZuDecimal maximum() {
    return {ZuDecimal::Unscaled{ZuDecimal::maximum()}};
  }
};

class ZuTime {
  using ldouble = long double;

public:
  struct Nano {
    int128_t v;
  };

  constexpr ZuTime() = default;

  constexpr ZuTime(const ZuTime &t) : tv_sec{t.tv_sec}, tv_nsec{t.tv_nsec} { }
  constexpr ZuTime &operator=(const ZuTime &t) {
    if (this == &t) return *this;
    tv_sec = t.tv_sec, tv_nsec = t.tv_nsec;
    return *this;
  }

  constexpr ~ZuTime() { }

  template <typename T, typename U = ZuStrip<T>>
  struct IsInt :
    public ZuBool<
      ZuIsExact<int32_t, U>{} || ZuIsExact<uint32_t, U>{} ||
      ZuIsExact<int64_t, U>{} || ZuIsExact<uint64_t, U>{} ||
      ZuIsExact<time_t, U>{}> { };
  template <typename T, typename R = void>
  using MatchInt = ZuIfT<IsInt<T>{}, R>;

  template <typename T, typename = MatchInt<T>>
  constexpr ZuTime(T v) : tv_sec{v}, tv_nsec{0} { }
  constexpr ZuTime(ldouble v) {
    if (ZuCmp<ldouble>::null(v) || v >= ldouble(ZuCmp<int64_t>::maximum()) ||
	v <= ldouble(ZuCmp<int64_t>::minimum())) {
      null();
    } else {
      tv_sec = v;
      tv_nsec = (v - ldouble(tv_sec)) * 1000000000;
    }
  }
  constexpr ZuTime(const ZuDecimal &v) {
    if (!*v) {
      null();
    } else {
      tv_sec = v.floor();
      tv_nsec = v.frac() / 1000000000;
      if (__builtin_expect(!!(v < 0 && tv_nsec), 0)) {
	--tv_sec;
	tv_nsec = 1000000000 - tv_nsec;
      }
    }
  }
  constexpr ZuTime(int64_t t, int32_t n) : tv_sec{t}, tv_nsec{n} { }

  constexpr ZuTime(Nano nano) :
    tv_sec{int64_t(nano.v / 1000000000)},
    tv_nsec{int32_t(nano.v % 1000000000)} { }

  constexpr ZuTime(const timespec &t) :
    tv_sec{int64_t(t.tv_sec)}, tv_nsec{int32_t(t.tv_nsec)} { }
  ZuTime &operator=(const timespec &t) {
    new (this) ZuTime{t};
    return *this;
  }
  constexpr ZuTime(const timeval &t) :
    tv_sec{int64_t(t.tv_sec)}, tv_nsec{int32_t(t.tv_usec) * 1000} { }
  ZuTime &operator=(const timeval &t) {
    new (this) ZuTime{t};
    return *this;
  }

  template <typename S, decltype(ZuMatchString<S>(), int()) = 0>
  ZuTime(const S &s) {
    scan(s);
  }

  void null() {
    tv_sec = ZuCmp<int64_t>::null();
    tv_nsec = 0;
  }

  constexpr int64_t as_time_t() const { return (tv_sec); }
  constexpr ldouble as_fp() const {
    if (__builtin_expect(!!(!**this), 0)) return ZuCmp<double>::null();
    return (ldouble(tv_sec) * 1000000000 + tv_nsec) / 1000000000;
  }
  constexpr ZuDecimal as_decimal() const {
    if (__builtin_expect(!!(!**this), 0)) return {};
    return ZuDecimal{ZuDecimal::Unscaled{
      (int128_t(tv_sec) * 1000000000 + tv_nsec) * 1000000000
    }};
  }

  timeval as_timeval() const { return timeval{tv_sec, tv_nsec / 1000}; }

  constexpr int64_t millisecs() const {
    return int64_t(tv_sec) * 1000 + tv_nsec / 1000000;
  }
  constexpr int64_t microsecs() const {
    return int64_t(tv_sec) * 1000000 + tv_nsec / 1000;
  }
  constexpr int128_t nanosecs() const {
    return int128_t(tv_sec) * 1000000000 + tv_nsec;
  }

  constexpr ZuTime &operator=(int64_t t) {
    tv_sec = t;
    tv_nsec = 0;
    return *this;
  }
  constexpr ZuTime &operator=(const ZuDecimal &d) {
    tv_sec = d.floor();
    tv_nsec = d.frac() / 1000000000;
    return *this;
  }

  constexpr void normalize() {
    if (tv_nsec >= 1000000000) {
      tv_nsec -= 1000000000;
      if (ZuIntrin::add(tv_sec, 1, &tv_sec)) null();
    } else if (tv_nsec < 0) {
      tv_nsec += 1000000000;
      if (ZuIntrin::sub(tv_sec, 1, &tv_sec))
	null();
      else if (__builtin_expect(!!(tv_nsec < 0), 0)) {
	tv_nsec += 1000000000;
	if (ZuIntrin::sub(tv_sec, 1, &tv_sec)) null();
      }
    }
  }

  constexpr ZuTime operator-() const {
    return ZuTime{-tv_sec - 1, int32_t(1000000000) - tv_nsec};
  }

  template <typename T> constexpr MatchInt<T, ZuTime> operator+(T v) const {
    return ZuTime::operator+(ZuTime{v, 0});
  }
  constexpr ZuTime operator+(const ZuDecimal &d) const {
    return ZuTime::operator+(ZuTime{d});
  }
  constexpr ZuTime operator+(const ZuTime &t_) const {
    int64_t sec;
    int32_t nsec;
    if (__builtin_expect(
	  !!(
	    !**this || !*t_ || ZuIntrin::add(tv_sec, t_.tv_sec, &sec) ||
	    ZuIntrin::add(tv_nsec, t_.tv_nsec, &nsec)
	  ),
	  0
	)

    )
      return ZuTime{};
    ZuTime t{sec, nsec};
    t.normalize();
    return t;
  }
  template <typename T> constexpr MatchInt<T, ZuTime &> operator+=(T v) {
    return ZuTime::operator+=(ZuTime{v, 0});
  }
  constexpr ZuTime &operator+=(const ZuDecimal &d) {
    return ZuTime::operator+=(ZuTime{d});
  }
  constexpr ZuTime &operator+=(const ZuTime &t_) {
    if (__builtin_expect(
	  !!(
	    !**this || !*t_ || ZuIntrin::add(tv_sec, t_.tv_sec, &tv_sec) ||
	    ZuIntrin::add(tv_nsec, t_.tv_nsec, &tv_nsec)
	  ),
	  0
	)

    )
      null();
    else
      normalize();
    return *this;
  }
  template <typename T> constexpr MatchInt<T, ZuTime> operator-(T v) const {
    return ZuTime::operator-(ZuTime{v, 0});
  }
  constexpr ZuTime operator-(const ZuDecimal &d) const {
    return ZuTime::operator-(ZuTime{d});
  }
  constexpr ZuTime operator-(const ZuTime &t_) const {
    int64_t sec;
    int32_t nsec;
    if (__builtin_expect(
	  !!(
	    !**this || !*t_ || ZuIntrin::sub(tv_sec, t_.tv_sec, &sec) ||
	    ZuIntrin::sub(tv_nsec, t_.tv_nsec, &nsec)
	  ),
	  0
	)

    )
      return ZuTime{};
    ZuTime t{sec, nsec};
    t.normalize();
    return t;
  }
  template <typename T> constexpr MatchInt<T, ZuTime &> operator-=(T v) {
    return ZuTime::operator-=(ZuTime{v, 0});
  }
  constexpr ZuTime &operator-=(const ZuDecimal &d) {
    return ZuTime::operator-=(ZuTime{d});
  }
  constexpr ZuTime &operator-=(const ZuTime &t_) {
    if (__builtin_expect(
	  !!(
	    !**this || !*t_ || ZuIntrin::sub(tv_sec, t_.tv_sec, &tv_sec) ||
	    ZuIntrin::sub(tv_nsec, t_.tv_nsec, &tv_nsec)
	  ),
	  0
	)

    )
      null();
    else
      normalize();
    return *this;
  }

  constexpr ZuTime operator*(const ZuDecimal &d) {
    return ZuTime{as_decimal() * d};
  }
  constexpr ZuTime &operator*=(const ZuDecimal &d) {
    return operator=(as_decimal() * d);
  }
  constexpr ZuTime operator/(const ZuDecimal &d) {
    return ZuTime{as_decimal() / d};
  }
  constexpr ZuTime &operator/=(const ZuDecimal &d) {
    return operator=(as_decimal() / d);
  }

  constexpr bool equals(const ZuTime &t) const {
    return tv_sec == t.tv_sec && tv_nsec == t.tv_nsec;
  }
  constexpr int cmp(const ZuTime &t) const {
    if (int i = ZuCmp<int64_t>::cmp(tv_sec, t.tv_sec)) return i;
    return ZuCmp<int32_t>::cmp(tv_nsec, t.tv_nsec);
  }
  template <typename L, typename R>
  friend inline constexpr ZuIfT<
    bool(ZuIsExact<ZuTime, L>{}) && bool(ZuIsExact<ZuTime, R>{}), bool>
  operator==(const L &l, const R &r) {
    return l.equals(r);
  }
  template <typename L, typename R>
  friend inline constexpr ZuIfT<
    bool(ZuIsExact<ZuTime, L>{}) && bool(ZuIsExact<ZuTime, R>{}), bool>
  operator<(const L &l, const R &r) {
    return l.cmp(r) < 0;
  }
  template <typename L, typename R>
  friend inline constexpr ZuIfT<
    bool(ZuIsExact<ZuTime, L>{}) && bool(ZuIsExact<ZuTime, R>{}), int>
  operator<=>(const L &l, const R &r) {
    return l.cmp(r);
  }

  template <typename L, typename R>
  friend inline constexpr ZuIfT<
    bool(ZuIsExact<ZuTime, L>{}) && !ZuIsExact<ZuTime, R>{}, bool>
  operator==(const L &l, const R &r) {
    return l.equals(ZuTime{r});
  }
  template <typename L, typename R>
  friend inline constexpr ZuIfT<
    bool(ZuIsExact<ZuTime, L>{}) && !ZuIsExact<ZuTime, R>{}, bool>
  operator<(const L &l, const R &r) {
    return l.cmp(ZuTime{r}) < 0;
  }
  template <typename L, typename R>
  friend inline constexpr ZuIfT<
    bool(ZuIsExact<ZuTime, L>{}) && !ZuIsExact<ZuTime, R>{}, int>
  operator<=>(const L &l, const R &r) {
    return l.cmp(ZuTime{r});
  }

  constexpr bool operator*() const { return !ZuCmp<int64_t>::null(tv_sec); }
  constexpr bool operator!() const { return !tv_sec && !tv_nsec; }
  constexpr operator bool() const { return tv_sec || tv_nsec; }

  int64_t sec() const { return tv_sec; }
  int64_t &sec() { return tv_sec; }
  int32_t nsec() const { return tv_nsec; }
  int32_t &nsec() { return tv_nsec; }

  uint32_t hash() const {
    return ZuHash<int64_t>::hash(tv_sec) ^ ZuHash<int32_t>::hash(tv_nsec);
  }

  unsigned scan(ZuCSpan);

  void ymdhmsn(
    int &year, int &month, int &day, int &hour, int &minute, int &sec, int &nsec
  ) const {
    {
      int julian;
      int i, j, l, n;

      julian = static_cast<int>((tv_sec / 86400) + 2440588);
      sec = static_cast<int>(tv_sec % 86400);

      l = julian + 68569;
      n = (l << 2) / 146097;
      l = l - ((146097 * n + 3) >> 2);
      i = (4000 * (l + 1)) / 1461001;
      l = l - ((1461 * i) >> 2) + 31;
      j = (80 * l) / 2447;
      day = l - (2447 * j) / 80;
      l = j / 11;
      month = j + 2 - 12 * l;
      year = (100 * (n - 49) + i + l);
      hour = sec / 3600, sec %= 3600, minute = sec / 60, sec %= 60;
    }
    nsec = tv_nsec;
  }

  template <typename S> void print(S &s) const {
    if (__builtin_expect(!!(!**this), 0)) return;
    int year, month, day, hour, minute, sec, nsec;
    ymdhmsn(year, month, day, hour, minute, sec, nsec);
    if (year < 0) {
      s << '-';
      year = -year;
    }
    s << ZuBoxed(year).fmt<ZuFmt::Right<4>>() << '/'
      << ZuBoxed(month).fmt<ZuFmt::Right<2>>() << '/'
      << ZuBoxed(day).fmt<ZuFmt::Right<2>>() << ' '
      << ZuBoxed(hour).fmt<ZuFmt::Right<2>>() << ':'
      << ZuBoxed(minute).fmt<ZuFmt::Right<2>>() << ':'
      << ZuBoxed(sec).fmt<ZuFmt::Right<2>>() << '.'
      << ZuBoxed(nsec).fmt<ZuFmt::Frac<9, 9>>();
  }
  friend ZuPrintFn ZuPrintType(ZuTime *);

  struct Interval {
    const ZuTime &time;
    template <typename S> void print(S &s) const {
      if (!time) return;
      s << ZuBoxed(time.tv_sec) << '.'
	<< ZuBoxed(time.tv_nsec).fmt<ZuFmt::Frac<9, 9>>();
    }
    friend ZuPrintFn ZuPrintType(Interval *);
  };
  Interval interval() const { return {*this}; }

  struct Traits : public ZuBaseTraits<ZuTime> {
    enum { IsPOD = 1 };
  };
  friend Traits ZuTraitsType(ZuTime *);

private:
  int64_t tv_sec = ZuCmp<int64_t>::null();
  int32_t tv_nsec = 0;
  uint32_t _ = 0;
};

namespace Zm {

inline ZuTime now() {
  timespec t;
  clock_gettime(

    0

    ,
    &t
  );
  return ZuTime{t};
}

template <typename T> inline typename ZuTime::MatchInt<T, ZuTime>::T now(T d) {
  ZuTime t = now();
  return t += d;
}
inline ZuTime now(const ZuTime &d) {
  ZuTime t = now();
  return t += d;
}

extern void sleep(ZuTime);

} // namespace Zm

using ZmThreadID = Zm::ThreadID;

namespace ZmThreadPriority {
enum _ { Unset = -1, RealTime = 0, High = 1, Normal = 2, Low = 3 };
}

using ZmThreadName = ZuCArray<28>;

struct ZmThreadTelemetry {
  ZmThreadName name;
  uint64_t tid = 0;
  uint64_t stackSize = 0;
  ZmBitmap cpuset;
  double cpuUsage = 0.0;
  uint64_t allocStack = 0;
  uint64_t allocHeap = 0;
  int32_t sysPriority = 0;
  uint16_t sid = 0;
  uint16_t partition = 0;
  int8_t priority = -1;
  uint8_t main = 0;
  uint8_t detached = 0;
};

class ZmThreadContext;

extern "C" {
  extern void *ZmThread_start(void *);
}

class ZmThreadParams {
public:
  ZmThreadParams &&name(ZuCSpan s) {
    m_name = s;
    return ZuMv(*this);
  }
  ZmThreadParams &&stackSize(unsigned v) {
    m_stackSize = v;
    return ZuMv(*this);
  }
  ZmThreadParams &&priority(int v) {
    m_priority = v;
    return ZuMv(*this);
  }
  ZmThreadParams &&partition(unsigned v) {
    m_partition = v;
    return ZuMv(*this);
  }
  ZmThreadParams &&cpuset(const ZmBitmap &b) {
    m_cpuset = b;
    return ZuMv(*this);
  }
  ZmThreadParams &&detached(bool b) {
    m_detached = b;
    return ZuMv(*this);
  }

  const ZmThreadName &name() const { return m_name; }
  unsigned stackSize() const { return m_stackSize; }
  int priority() const { return m_priority; }
  int partition() const { return m_partition; }
  const ZmBitmap &cpuset() const { return m_cpuset; }
  bool detached() const { return m_detached; }

private:
  ZmThreadName m_name;
  unsigned m_stackSize = 0;
  int m_priority = -1;
  int m_partition = -1;
  ZmBitmap m_cpuset;
  bool m_detached = false;
};

template <typename> struct ZmAlloc_;

class ZmThreadContext_ {
  friend void *ZmThread_start(void *);

  template <typename> friend struct ZmAlloc_;

protected:
  ZmThreadContext_() { }

public:
  bool main() const { return m_main; }

  pthread_t pthread() const { return m_pthread; }

  pid_t tid() const { return m_tid; }

  clockid_t cid() const { return m_cid; }
  double cpuUsage() const {
    ZuTime cpuLast = m_cpuLast;
    ZuTime rtLast = m_rtLast;
    {
      timespec cpuLast_;
      clock_gettime(m_cid, &cpuLast_);
      m_cpuLast = ZuTime{cpuLast_};
    }
    m_rtLast = Zm::now();
    if (__builtin_expect(!!(!cpuLast || !rtLast), 0)) return 0.0;
    auto cpuDelta = (m_cpuLast - cpuLast).as_fp();
    auto rtDelta = (m_rtLast - rtLast).as_fp();
    return cpuDelta / rtDelta;
  }
  int32_t sysPriority() const {
    struct sched_param p;

    sched_getparam(m_tid, &p);

    return p.

      sched_priority;
  }

  void *stackAddr() const { return m_stackAddr; }
  unsigned stackSize() const { return m_stackSize; }

  uint64_t allocStack() const { return m_allocStack; }
  uint64_t allocHeap() const { return m_allocHeap; }

protected:
  void init();

  bool m_main = false;

  pthread_t m_pthread = 0;

  pid_t m_tid = 0;

  clockid_t m_cid = 0;
  mutable ZuTime m_cpuLast = 0;
  mutable ZuTime m_rtLast = 0;

  void *m_stackAddr = nullptr;
  unsigned m_stackSize = 0;
  uint64_t m_allocStack = 0;
  uint64_t m_allocHeap = 0;
};

class ZmThread;

class ZmThreadContext : public ZmObject, public ZmThreadContext_ {
  friend ZmThreadContext *ZmThreadContext_new();

  friend void *ZmThread_start(void *);

  friend ZmThread;

  ZmThreadContext() { init(); }

  template <
    typename L, decltype(ZuIfT<ZuInspect<L, void (*)()>::Same>(), int()) = 0>
  ZmThreadContext(L l, const ZmThreadParams &params, int sid = -1) :
    m_callFn{[](void *fn) -> void * {
      try {
	(*reinterpret_cast<L>(fn))();
      } catch (...) { }
      return nullptr;
    }},
    m_dtorFn{nullptr}, m_lambda{reinterpret_cast<void *>(l)},
    m_name{params.name()}, m_sid{sid}, m_priority{params.priority()},
    m_partition{params.partition()}, m_cpuset{params.cpuset()},
    m_detached{params.detached()} {
    m_stackSize = params.stackSize();
  }

  template <
    typename L, decltype(ZuIfT<ZuInspect<L, void *(*)()>::Same>(), int()) = 0>
  ZmThreadContext(L l, const ZmThreadParams &params, int sid = -1) :
    m_callFn{[](void *fn) -> void * {
      void *res = nullptr;
      try {
	res = reinterpret_cast<void *>((*reinterpret_cast<L>(fn))());
      } catch (...) { }
      return res;
    }},
    m_dtorFn{nullptr}, m_lambda{reinterpret_cast<void *>(l)},
    m_name{params.name()}, m_sid{sid}, m_priority{params.priority()},
    m_partition{params.partition()}, m_cpuset{params.cpuset()},
    m_detached{params.detached()} {
    m_stackSize = params.stackSize();
  }

  template <
    typename L,
    decltype(ZuIfT<bool{ZuIsStatelessLambda<L>{}} && bool{ZuIsVoidRetLambda<L>{}}>(), int()) =
      0>
  ZmThreadContext(L l, const ZmThreadParams &params, int sid = -1) :
    m_callFn{[](void *) -> void * {
      try {
	ZuInvokeLambda<L>();
      } catch (...) { }
      return nullptr;
    }},
    m_dtorFn{nullptr}, m_lambda{nullptr}, m_name{params.name()}, m_sid{sid},
    m_priority{params.priority()}, m_partition{params.partition()},
    m_cpuset{params.cpuset()}, m_detached{params.detached()} {
    m_stackSize = params.stackSize();
  }

  template <
    typename L,
    decltype(ZuIfT<!ZuIsStatelessLambda<L>{} && bool{ZuIsVoidRetLambda<L>{}}>(), int()) =
      0>
  ZmThreadContext(L l, const ZmThreadParams &params, int sid = -1) :
    m_callFn{[](void *lambda_) -> void * {
      if (__builtin_expect(!!(!lambda_), 0)) return nullptr;
      auto lambda = reinterpret_cast<L *>(lambda_);
      try {
	(*lambda)();
      } catch (...) { }
      delete lambda;
      return nullptr;
    }},
    m_dtorFn{[](void *lambda) { delete reinterpret_cast<L *>(lambda); }},
    m_lambda{new L{ZuMv(l)}}, m_name{params.name()}, m_sid{sid},
    m_priority{params.priority()}, m_partition{params.partition()},
    m_cpuset{params.cpuset()}, m_detached{params.detached()} {
    m_stackSize = params.stackSize();
  }

  template <
    typename L,
    decltype(ZuIfT<bool{ZuIsStatelessLambda<L>{}} && !ZuIsVoidRetLambda<L>{}>(), int()) =
      0>
  ZmThreadContext(L l, const ZmThreadParams &params, int sid = -1) :
    m_callFn{[](void *) -> void * {
      void *res = nullptr;
      try {
	res = static_cast<void *>(ZuInvokeLambda<L>());
      } catch (...) { }
      return res;
    }},
    m_dtorFn{nullptr}, m_lambda{nullptr}, m_name{params.name()}, m_sid{sid},
    m_priority{params.priority()}, m_partition{params.partition()},
    m_cpuset{params.cpuset()}, m_detached{params.detached()} {
    m_stackSize = params.stackSize();
  }

  template <
    typename L,
    decltype(ZuIfT<!ZuIsStatelessLambda<L>{} && !ZuIsVoidRetLambda<L>{}>(), int()) =
      0>
  ZmThreadContext(L l, const ZmThreadParams &params, int sid = -1) :
    m_callFn{[](void *lambda_) -> void * {
      if (__builtin_expect(!!(!lambda_), 0)) return nullptr;
      auto lambda = reinterpret_cast<L *>(lambda_);
      void *res = nullptr;
      try {
	res = static_cast<void *>((*lambda)());
      } catch (...) { }
      delete lambda;
      return res;
    }},
    m_dtorFn{[](void *lambda) { delete reinterpret_cast<L *>(lambda); }},
    m_lambda{new L{ZuMv(l)}}, m_name{params.name()}, m_sid{sid},
    m_priority{params.priority()}, m_partition{params.partition()},
    m_cpuset{params.cpuset()}, m_detached{params.detached()} {
    m_stackSize = params.stackSize();
  }

public:
  ~ZmThreadContext() {
    if (m_dtorFn) (*m_dtorFn)(m_lambda);
  }

  void init();

  void prioritize(int priority);
  void bind(unsigned partition, const ZmBitmap &cpuset);

  inline static ZmThreadContext *self();

  ZmThreadID tid() const { return m_tid; }

  const ZmThreadName &name() const { return m_name; }
  int sid() const { return m_sid; }

  int priority() const { return m_priority; }

  int partition() const { return m_partition; }
  const ZmBitmap &cpuset() const { return m_cpuset; }

  void *result() const { return m_result; }

  bool detached() const { return m_detached; }

  void telemetry(ZmThreadTelemetry &data) const;

  template <typename S> void print(S &s) const {
    s << this->name() << " (" << ZuBoxed(sid()) << ") [" << m_cpuset << "] "
      << ZuBoxed(cpuUsage() * 100.0).fmt<ZuFmt::FP<2>>() << '%';
  }
  friend ZuPrintFn ZuPrintType(ZmThreadContext *);

private:
  inline static ZmThreadContext *self(ZmThreadContext *c);

  void prioritize();
  void bind();

  typedef void *(*CallFn)(void *);
  typedef void (*DtorFn)(void *);

  CallFn m_callFn = nullptr;
  DtorFn m_dtorFn = nullptr;
  void *m_lambda = nullptr;

  ZmThreadName m_name;
  int m_sid = -1;

  int m_priority = -1;
  int m_partition = -1;
  ZmBitmap m_cpuset;

  void *m_result = nullptr;

  bool m_detached = false;
};

class ZmThread {
public:
  using Context = ZmThreadContext;
  using ID = ZmThreadID;

  ZmThread() { }
  template <typename L>
  ZmThread(L l, ZmThreadParams params = ZmThreadParams{}, int sid = -1) {
    run_(new ZmThreadContext{ZuMv(l), params, sid});
  }

  ZmThread(const ZmThread &t) : m_context(t.m_context) { }
  ZmThread &operator=(const ZmThread &t) {
    m_context = t.m_context;
    return *this;
  }

  ZmThread(ZmThread &&t) : m_context(ZuMv(t.m_context)) { }
  ZmThread &operator=(ZmThread &&t) {
    m_context = ZuMv(t.m_context);
    return *this;
  }

  ZmThread(Context *context) : m_context(context) { }
  ZmThread &operator=(Context *context) {
    m_context = context;
    return *this;
  }

  template <typename L>
  int run(L l, ZmThreadParams params = ZmThreadParams{}, int sid = -1) {
    return run_(new ZmThreadContext{ZuMv(l), params, sid});
  }

private:
  int run_(ZmThreadContext *c);

public:
  int join(void **status = 0);

  ZmRef<Context> context() { return m_context; }

  int sid() const {
    if (!m_context) return -1;
    return m_context->sid();
  }

  ID tid() const {
    if (!m_context) return 0;
    return m_context->tid();
  }

  bool equals(const ZmThread &t) const { return tid() == t.tid(); }
  int cmp(const ZmThread &t) const { return ZuCmp<ID>::cmp(tid(), t.tid()); }
  friend inline bool operator==(const ZmThread &l, const ZmThread &r) {
    return l.equals(r);
  }
  friend inline int operator<=>(const ZmThread &l, const ZmThread &r) {
    return l.cmp(r);
  }

  uint32_t hash() { return ZuHash<ID>::hash(tid()); }

  bool operator!() const { return !m_context; }
  operator const void *() const {
    return !*this ? reinterpret_cast<const void *>(0) :
		    static_cast<const void *>(this);
  }

  template <class S> struct CSV_ {
    CSV_(S &stream) : m_stream(stream) {
      m_stream << "name,sid,tid,cpuUsage,cpuSet,sysPriority,priority,"
		  "stackSize,partition,main,detached,allocStack,allocHeap\n";
    }
    void print(const ZmThreadContext *tc) {
      ZmThreadTelemetry data;
      static ZmPLock lock;
      ZmGuard<ZmPLock> guard(lock);
      tc->telemetry(data);
      m_stream << data.name << ',' << data.sid << ',' << data.tid << ','
	       << ZuBoxed(data.cpuUsage * 100.0).fmt<ZuFmt::FP<2>>() << ",\""
	       << ZmBitmap(data.cpuset) << '"' << ','
	       << ZuBoxed(data.sysPriority) << ',' << ZuBoxed(data.priority)
	       << ',' << data.stackSize << ',' << ZuBoxed(data.partition) << ','
	       << ZuBoxed(data.main) << ',' << ZuBoxed(data.detached) << ','
	       << ZuBoxed(data.allocStack) << ',' << ZuBoxed(data.allocHeap)
	       << '\n';
    }
    S &stream() { return m_stream; }

  private:
    S &m_stream;
  };
  struct CSV {
    template <typename S> void print(S &s) const;
    friend ZuPrintFn ZuPrintType(CSV *);
  };
  static CSV csv() { return {}; }

private:
  ZmRef<Context> m_context;
};

inline ZmThreadContext *ZmThreadContext_new() { return new ZmThreadContext(); }
using ZmThreadContextTLS = ZmSpecific<
  ZmThreadContext,
  ZmSpecificCtor<ZmThreadContext_new, ZmSpecificCleanup<ZmCleanup::Thread>>>;

inline ZmThreadContext *ZmThreadContext::self() {
  return ZmThreadContextTLS::instance();
}
inline ZmThreadContext *ZmThreadContext::self(ZmThreadContext *c) {
  return ZmThreadContextTLS::instance(c);
}
template <typename S> inline void ZmThread::CSV::print(S &s) const {
  CSV_<S> csv{s};
  ZmThreadContextTLS::all([&csv](const ZmThreadContext *tc) { csv.print(tc); });
}

template <unsigned N = 64> class ZmBackTracer {
public:
  ZmBackTracer() { }
  ~ZmBackTracer() { }

private:
  using Data = ZuTuple<ZmThreadID, ZmThreadName, ZmBackTrace>;
  using Capture = ZuUnion<void, Data>;

  using Lock = ZmPLock;
  using Guard = ZmGuard<Lock>;
  using ReadGuard = ZmReadGuard<Lock>;

public:
  void capture(unsigned skip = 0) {
    Guard guard(m_lock);
    unsigned i = m_offset;
    m_offset = (i + 1) & 63;
    Data *data = new (m_captures[i].template new_<1>()) Data();
    ZmThreadContext *self = (ZmThreadContext::self());
    data->p<0>() = self->tid();
    data->p<1>() = self->name();
    data->p<2>().capture(skip + 1);
  }

  template <typename S> void dump(S &s) const {
    ReadGuard guard(m_lock);
    bool first = true;
    for (unsigned i = 0; i < N; i++) {
      unsigned j = (m_offset + (N - 1) - i) % N;
      if (m_captures[j].is<Data>()) {
	const auto &data = m_captures[j].template p<Data>();
	if (!first) s << "---\n";
	first = false;
	s << data.template p<1>() << " (TID " << data.template p<0>() << ")\n"
	  << data.template p<2>();
      }
    }
  }

private:
  ZmPLock m_lock;
  ZuBox<unsigned, ZuBoxCmp<ZuCmp0>> m_offset;
  Capture m_captures[64];
};

class ZmLock;

template <unsigned> class ZmBackTracer;
class ZmLock_Debug {
  friend ZmLock;
  static void enable();
  static void disable();
  static void capture(unsigned skip = 1);
  static ZmBackTracer<64> *tracer();
};

class ZmLock {
  ZmLock(const ZmLock &);
  ZmLock &operator=(const ZmLock &);

public:
  ZmLock() { m_lock = 0; }
  ~ZmLock() { (void()); }

  void lock() {
    Zm::ThreadID tid = Zm::getTID();
    if (m_tid == tid) {
      m_count++;
      return;
    }

    if (m_prevTID && m_prevTID != tid) ZmLock_Debug::capture();
    m_prevTID = tid;

    ZmPLock_lock_(m_lock);
    m_count = 1;
    m_tid = tid;
  }
  int trylock() {
    auto tid = Zm::getTID();
    if (m_tid == tid) {
      ++m_count;
      return 0;
    }
    if (ZmPLock_trylock_(m_lock)) return -1;
    m_count = 1;
    m_tid = tid;
    return 0;
  }
  void unlock() {
    if (!m_count) return;
    auto tid = Zm::getTID();
    if (m_tid != tid) return;
    if (!--m_count) {
      m_tid = 0;
      ZmPLock_unlock_(m_lock);
    }
  }

  static void traceEnable() { ZmLock_Debug::enable(); }
  static void traceDisable() { ZmLock_Debug::disable(); }
  static ZmBackTracer<64> *tracer() { return ZmLock_Debug::tracer(); }

  class Wait;
  friend Wait;
  class Wait {
    friend ZmLock;

  private:
    Wait(ZmLock &lock) :
      m_lock(lock), m_count(lock.m_count), m_tid(lock.m_tid) {
      m_lock.m_count = 0;
      m_lock.m_tid = 0;
    }

  public:
    ~Wait() {
      m_lock.m_count = m_count;
      m_lock.m_tid = m_tid;
    }

  private:
    ZmLock &m_lock;
    uint32_t m_count;
    Zm::ThreadID m_tid;
  };
  Wait wait() { return {*this}; }
  inline void lock_() { ZmPLock_lock_(m_lock); }
  inline void unlock_() { ZmPLock_unlock_(m_lock); }

private:
  ZmPLock_ m_lock;
  uint32_t m_count = 0;
  ZmAtomic<Zm::ThreadID> m_tid = 0;

  Zm::ThreadID m_prevTID = 0;
};

template <class Out> struct ZtIconvFn {
  enum { N = sizeof(typename ZuTraits<Out>::Elem) };

  static size_t length(Out &buf, size_t n) {
    buf.length((n + N - 1) / N);
    return buf.length() * N;
  }

  static char *data(Out &buf) { return reinterpret_cast<char *>(buf.data()); }
};

class ZtIconv {
  ZtIconv();
  ZtIconv(const ZtIconv &);
  ZtIconv &operator=(const ZtIconv &);

  constexpr double factor() { return 1.1; }

  class IconvTraits {
  private:
    typedef char Small;
    struct Big {
      char _[2];
    };
    static Small
      test(size_t (*)(iconv_t, const char **, size_t *, char **, size_t *));
    static Big test(...);

  public:
    enum { Const = sizeof(test(&iconv)) == sizeof(Small) };
  };
  using InBuf = ZuIf<IconvTraits::Const, const char **, char **>;

public:
  ZtIconv(const char *tocode, const char *fromcode) :
    m_cd(iconv_open(tocode, fromcode)) { }
  ~ZtIconv() {
    if (m_cd != (iconv_t)-1) iconv_close(m_cd);
  }

  template <class Out, typename In>
  ZuIfT<ZuTraits<Out>::IsString && ZuTraits<In>::IsString, int>
  convert(Out &out, const In &in) {
    if (__builtin_expect(!!(m_cd == (iconv_t)-1), 0)) return -1;
    auto inBuf = reinterpret_cast<const char *>(ZuTraits<In>::data(in));
    size_t inSize =
      ZuTraits<In>::length(in) * sizeof(typename ZuTraits<In>::Elem);
    if (__builtin_expect(!!(!inSize), 0)) {
      ZtIconvFn<Out>::length(out, 0);
      return 0;
    }
    size_t outSize = inSize;
    outSize = ZtIconvFn<Out>::length(out, outSize);
    size_t inLen = inSize;
    size_t outLen = outSize;
    char *outBuf = ZtIconvFn<Out>::data(out);
resized:
    size_t n = iconv(m_cd, (InBuf)&inBuf, &inLen, &outBuf, &outLen);
    if (n == (size_t)-1 &&

	(*__errno_location())

	  ==

	  7

    ) {
      if (__builtin_expect(!!(inLen >= inSize), 0)) inLen = 0;
      double ratio = (double)(outSize - outLen) / (double)(inSize - inLen);
      if (__builtin_expect(!!(ratio < 1.0), 0)) ratio = 1.0;
      size_t newOutSize = (size_t)(ratio * factor() * (double)inSize);
      size_t minOutSize = (size_t)((double)outSize * factor());
      if (__builtin_expect(!!(newOutSize < minOutSize), 0))
	newOutSize = minOutSize;
      newOutSize = ZtIconvFn<Out>::length(out, newOutSize);
      if (__builtin_expect(!!(newOutSize <= minOutSize), 0)) {
	outLen += (newOutSize - outSize);
	outSize = newOutSize;
	goto ret;
      }
      outBuf = ZtIconvFn<Out>::data(out) + (outSize - outLen);
      outLen += (newOutSize - outSize);
      outSize = newOutSize;
      goto resized;
    }
ret:
    iconv(m_cd, 0, 0, 0, 0);
    ZtIconvFn<Out>::length(out, outSize - outLen);
    return outSize - outLen;
  }

private:
  iconv_t m_cd;
};

struct ZtArray_Defaults {
  template <typename T> using CmpT = ZuCmp<T>;
  static const char *HeapID() { return "ZtArray"; }
  enum { Sharded = 0 };
};

template <template <typename> typename Cmp_, typename NTP = ZtArray_Defaults>
struct ZtArrayCmp : public NTP {
  template <typename T> using CmpT = Cmp_<T>;
};

template <auto HeapID_, typename NTP = ZtArray_Defaults>
struct ZtArrayHeapID : public NTP {
  static constexpr auto HeapID = HeapID_;
};

template <bool Sharded_, typename NTP = ZtArray_Defaults>
struct ZtArraySharded : public NTP {
  enum { Sharded = Sharded_ };
};

template <typename T, typename NTP> class ZtArray;

template <typename T> struct ZtArray_ { };
template <> struct ZtArray_<char> {
  friend ZuPrintString ZuPrintType(ZtArray_ *);
};

template <typename T_> struct ZtArray_Char2 {
  using T = void;
};
template <> struct ZtArray_Char2<char> {
  using T = wchar_t;
};
template <> struct ZtArray_Char2<wchar_t> {
  using T = char;
};

template <typename T_, typename NTP = ZtArray_Defaults>
class ZtArray :
  private ZmVHeap<NTP::HeapID, NTP::Sharded, alignof(T_)>,
  public ZtArray_<ZuStrip<T_>>,
  public ZuArrayFn<T_, typename NTP::template CmpT<T_>> {
  template <typename, typename> friend class ZtArray;

public:
  using T = T_;
  using Cmp = typename NTP::template CmpT<T>;
  static constexpr auto HeapID = NTP::HeapID;
  enum { Sharded = NTP::Sharded };

  using Ops = ZuArrayFn<T, Cmp>;

  struct Move { };

private:
  using Char = T;
  using Char2 = typename ZtArray_Char2<T>::T;

  template <typename U, typename V = T>
  struct IsZtArray :
    public ZuBool<
      bool(ZuEquiv<typename ZuTraits<U>::Elem, V>{}) &&
      ZuInspect<ZtArray_<typename ZuTraits<U>::Elem>, U>::Base> { };
  template <typename U, typename R = void>
  using MatchZtArray = ZuIfT<IsZtArray<U>{}, R>;

  template <typename U, typename V = Char>
  struct IsStrLiteral :
    public ZuBool<
      ZuTraits<U>::IsCString &&
      ZuIsExact<U, const V (&)[sizeof(U) / sizeof(V)]>{}> { };
  template <typename U, typename R = void>
  using MatchStrLiteral = ZuIfT<IsStrLiteral<U>{}, R>;

  template <typename U, typename V = Char>
  struct IsAnyString :
    public ZuBool<
      !IsZtArray<U>{} && (ZuTraits<U>::IsSpan || ZuTraits<U>::IsString) &&
      bool(ZuEquiv<typename ZuTraits<U>::Elem, V>{})> { };
  template <typename U, typename R = void>
  using MatchAnyString = ZuIfT<IsAnyString<U>{}, R>;

  template <typename U, typename V = Char>
  struct IsString : public ZuBool<!IsStrLiteral<U>{} && IsAnyString<U>{}> { };
  template <typename U, typename R = void>
  using MatchString = ZuIfT<IsString<U>{}, R>;

  template <typename U, typename V = Char2>
  struct IsChar2String :
    public ZuBool<
      !ZuIsExact<void, V>{} && (ZuTraits<U>::IsSpan || ZuTraits<U>::IsString) &&
      bool(ZuEquiv<typename ZuTraits<U>::Elem, V>{})> { };
  template <typename U, typename R = void>
  using MatchChar2String = ZuIfT<IsChar2String<U>{}, R>;

  template <typename U, typename V = T>
  struct IsSpan :
    public ZuBool<
      !IsZtArray<U>{} && !IsAnyString<U>{} && !IsChar2String<U>{} &&
      !ZuIsExact<U, V>{} && ZuTraits<U>::IsSpan &&
      ZuInspect<typename ZuTraits<U>::Elem, V>::Converts> { };
  template <typename U, typename R = void>
  using MatchSpan = ZuIfT<IsSpan<U>{}, R>;

  template <typename U, typename V = T>
  struct IsSameSpan :
    public ZuBool<
      !IsZtArray<U>{} && !IsAnyString<U>{} && !IsChar2String<U>{} &&
      !ZuIsExact<U, V>{} && ZuTraits<U>::IsSpan &&
      ZuIsExact<typename ZuTraits<U>::Elem, V>{}> { };
  template <typename U, typename R = void>
  using MatchSameSpan = ZuIfT<IsSameSpan<U>{}, R>;

  template <typename U, typename = void>
  struct IsIterable_ : public ZuFalse { };
  template <typename U>
  struct IsIterable_<
    U,
    decltype(ZuDeclVal<const U &>().end() - ZuDeclVal<const U &>().begin(), void())> :
    public ZuTrue { };
  template <typename U, typename V = T>
  struct IsIterable :
    public ZuBool<
      !IsZtArray<U>{} && !IsAnyString<U>{} && !IsChar2String<U>{} &&
      !ZuIsExact<U, V>{} && !ZuTraits<U>::IsSpan &&
      bool(IsIterable_<ZuDecay<U>>{}) &&
      ZuInspect<typename ZuTraits<U>::Elem, V>::Constructs> { };
  template <typename U, typename R = void>
  using MatchIterable = ZuIfT<IsIterable<U>{}, R>;

  template <typename U, typename V = Char2>
  struct IsChar2 :
    public ZuBool<
      !ZuIsExact<void, V>{} && bool(ZuEquiv<U, V>{}) &&
      !ZuEquiv<U, wchar_t>{}> { };
  template <typename U, typename R = void>
  using MatchChar2 = ZuIfT<IsChar2<U>{}, R>;

  template <typename U, typename V = Char>
  struct IsPrint :
    public ZuBool<
      bool(ZuEquiv<char, V>{}) && ZuPrint<U>::OK && !ZuPrint<U>::String> { };
  template <typename U, typename R = void>
  using MatchPrint = ZuIfT<IsPrint<U>{}, R>;
  template <typename U, typename V = Char>
  struct IsPDelegate :
    public ZuBool<bool(ZuEquiv<char, V>{}) && ZuPrint<U>::Delegate> { };
  template <typename U, typename R = void>
  using MatchPDelegate = ZuIfT<IsPDelegate<U>{}, R>;
  template <typename U, typename V = Char>
  struct IsPBuffer :
    public ZuBool<bool(ZuEquiv<char, V>{}) && ZuPrint<U>::Buffer> { };
  template <typename U, typename R = void>
  using MatchPBuffer = ZuIfT<IsPBuffer<U>{}, R>;

  template <typename U, typename V = T>
  struct IsReal :
    public ZuBool<
      bool(ZuEquiv<char, V>{}) && !bool(ZuEquiv<U, V>{}) &&
      ZuTraits<U>::IsReal && ZuTraits<U>::IsPrimitive &&
      !ZuTraits<U>::IsArray> { };
  template <typename U, typename R = void>
  using MatchReal = ZuIfT<IsReal<U>{}, R>;

  template <typename U, typename V = Char>
  struct IsPtr :
    public ZuBool<
      bool(ZuEquiv<char, V>{}) && ZuTraits<U>::IsPointer &&
      ZuTraits<U>::IsPrimitive && !ZuTraits<U>::IsArray &&
      !ZuTraits<U>::IsString> { };
  template <typename U, typename R = void>
  using MatchPtr = ZuIfT<IsPtr<U>{}, R>;

  template <typename U, typename V = T>
  struct IsElem :
    public ZuBool<
      bool(ZuIsExact<U, V>{}) ||
      (!IsZtArray<U>{} && !IsString<U>{} && !ZuTraits<U>::IsArray &&
       !IsChar2<U>{} && !IsPrint<U>{} && !IsReal<U>{} && !IsPtr<U>{} &&
       ZuInspect<U, V>::Converts)> { };
  template <typename U, typename R = void>
  using MatchElem = ZuIfT<IsElem<U>{}, R>;

  template <typename U>
  struct IsStreamable :
    public ZuBool<
      bool(IsZtArray<U>{}) || bool(IsSpan<U>{}) || bool(IsAnyString<U>{}) ||
      bool(IsChar2String<U>{}) || bool(IsChar2<U>{}) ||
      bool(IsPDelegate<U>{}) || bool(IsPBuffer<U>{}) || bool(IsReal<U>{}) ||
      bool(IsPtr<U>{}) || bool(IsElem<U>{})> { };
  template <typename U, typename R = void>
  using MatchStreamable = ZuIfT<IsStreamable<U>{}, R>;

  template <typename U, typename V = T>
  struct IsCtorSize :
    public ZuBool<
      ZuTraits<U>::IsIntegral &&
      (sizeof(U) > 2 || !ZuIsExact<ZuNormChar<V>, ZuNormChar<U>>{})> { };
  template <typename U, typename R = void>
  using MatchCtorSize = ZuIfT<IsCtorSize<U>{}, R>;

  template <typename U, typename R = void>
  using MatchCtorPDelegate =
    ZuIfT<bool(IsPDelegate<U>{}) && !IsCtorSize<U>{}, R>;
  template <typename U, typename R = void>
  using MatchCtorPBuffer = ZuIfT<bool(IsPBuffer<U>{}) && !IsCtorSize<U>{}, R>;

  template <typename U, typename V = T, typename W = Char2>
  struct IsCtorElem :
    public ZuBool<
      !IsZtArray<U>{} && !IsString<U>{} && !ZuTraits<U>::IsArray &&
      !IsChar2<U>{} && !IsPrint<U>{} && !IsReal<U>{} && !IsPtr<U>{} &&
      !IsCtorSize<U>{} && ZuInspect<U, V>::Converts> { };
  template <typename U, typename R = void>
  using MatchCtorElem = ZuIfT<IsCtorElem<U>{}, R>;

public:
  ZtArray() { null_(); }

private:
  enum NoInit_ { NoInit };
  ZtArray(NoInit_ _) { }

public:
  ZtArray(const ZtArray &a) { ctor(a); }
  ZtArray(ZtArray &&a) noexcept {
    if (!a.owned())
      shadow_(a.m_data, a.length());
    else {
      own_(a.m_data, a.length(), a.size(), a.vallocd());
      a.owned(false);
    }
  }
  ZtArray(std::initializer_list<T> a) { copy__(a.begin(), a.size()); }

  template <typename A> ZtArray(A &&a) { ctor(ZuFwd<A>(a)); }

  template <typename A> ZtArray(Move, A &a_) {
    ZuSpan<const typename ZuTraits<A>::Elem> a(a_);
    move__(a.data(), a.length());
  }

private:
  using VHeap = ZmVHeap<HeapID, Sharded, alignof(T)>;
  using VHeap::valloc;
  using VHeap::vfree;

  template <typename A_> struct Fwd_ZtArray {
    using A = ZuDecay<A_>;

    static void ctor_(ZtArray *this_, const A &a) {
      this_->copy__(a.m_data, a.length());
    }
    static void ctor_(ZtArray *this_, A &&a) {
      if (!a.owned())
	this_->shadow_(reinterpret_cast<T *>(a.m_data), a.length());
      else {
	this_->own_(
	  reinterpret_cast<T *>(a.m_data), a.length(), a.size(), a.vallocd()
	);
	a.owned(false);
      }
    }

    static void assign_(ZtArray *this_, const A &a) {
      uint32_t oldLength = 0;
      T *oldData = this_->free_1(oldLength);
      this_->copy__(a.m_data, a.length());
      this_->free_2(oldData, oldLength);
    }
    static void assign_(ZtArray *this_, A &&a) {
      this_->free_();
      if (!a.owned())
	this_->shadow_(reinterpret_cast<T *>(a.m_data), a.length());
      else {
	this_->own_(
	  reinterpret_cast<T *>(a.m_data), a.length(), a.size(), a.vallocd()
	);
	a.owned(false);
      }
    }

    static ZtArray add_(const ZtArray *this_, const A &a) {
      return this_->add(a.m_data, a.length());
    }
    static ZtArray add_(const ZtArray *this_, A &&a) {
      return this_->add_mv(a.m_data, a.length());
    }

    static void splice_(
      ZtArray *this_, ZtArray *removed, int offset, int length, const A &a
    ) {
      if (this_ == &a) {
	ZtArray a_ = a;
	this_->splice_cp_(removed, offset, length, a_.m_data, a_.length());
      } else
	this_->splice_cp_(removed, offset, length, a.m_data, a.length());
    }
    static void
    splice_(ZtArray *this_, ZtArray *removed, int offset, int length, A &&a) {
      this_->splice_mv_(removed, offset, length, a.m_data, a.length());
    }
  };
  template <typename A_> struct Fwd_Array {
    using A = ZuDecay<A_>;
    using Elem = typename ZuTraits<A>::Elem;

    static void ctor_(ZtArray *this_, const A &a_) {
      ZuSpan<const Elem> a(a_);
      this_->copy__(a.data(), a.length());
    }
    static void ctor_(ZtArray *this_, A &&a_) {
      ZuSpan<Elem> a(a_);
      this_->move__(a.data(), a.length());
    }

    static void assign_(ZtArray *this_, const A &a_) {
      ZuSpan<const Elem> a(a_);
      uint32_t oldLength = 0;
      T *oldData = this_->free_1(oldLength);
      this_->copy__(a.data(), a.length());
      this_->free_2(oldData, oldLength);
    }
    static void assign_(ZtArray *this_, A &&a_) {
      ZuSpan<Elem> a(a_);
      uint32_t oldLength = 0;
      T *oldData = this_->free_1(oldLength);
      this_->move__(a.data(), a.length());
      this_->free_2(oldData, oldLength);
    }

    static ZtArray add_(const ZtArray *this_, const A &a_) {
      ZuSpan<const Elem> a(a_);
      return this_->add(a.data(), a.length());
    }
    static ZtArray add_(const ZtArray *this_, A &&a_) {
      ZuSpan<Elem> a(a_);
      return this_->add_mv(a.data(), a.length());
    }

    static void splice_(
      ZtArray *this_, ZtArray *removed, int offset, int length, const A &a_
    ) {
      ZuSpan<const Elem> a(a_);
      this_->splice_cp_(removed, offset, length, a.data(), a.length());
    }
    static void
    splice_(ZtArray *this_, ZtArray *removed, int offset, int length, A &&a_) {
      ZuSpan<Elem> a(a_);
      this_->splice_mv_(removed, offset, length, a.data(), a.length());
    }
  };

  template <typename A> MatchZtArray<A> ctor(A &&a) {
    Fwd_ZtArray<A>::ctor_(this, ZuFwd<A>(a));
  }
  template <typename A> MatchSpan<A> ctor(A &&a) {
    Fwd_Array<A>::ctor_(this, ZuFwd<A>(a));
  }
  template <typename A> MatchIterable<A> ctor(const A &a) {
    null_();
    auto i = a.begin();
    unsigned n = a.end() - i;
    this->size(n);
    for (unsigned j = 0; j < n; j++) this->initItem(push(), *i++);
  }

  template <typename S> MatchStrLiteral<S> ctor(S &&s_) {
    ZuSpan<const T> s(s_);
    shadow_(s.data(), s.length());
  }
  template <typename S> MatchString<S> ctor(S &&s_) {
    ZuSpan<const T> s(s_);
    copy__(s.data(), s.length());
  }

  template <typename S> MatchChar2String<S> ctor(S &&s_) {
    ZuSpan<const Char2> s(s_);
    unsigned o = ZuUTF<Char, Char2>::len(s);
    if (!o) {
      null_();
      return;
    }
    alloc_(o, 0);
    length_(ZuUTF<Char, Char2>::cvt(ZuSpan<Char>(m_data, o), s));
  }
  template <typename C> MatchChar2<C> ctor(C c) {
    ZuSpan<const Char2> s(&c, 1);
    unsigned o = ZuUTF<Char, Char2>::len(s);
    if (!o) {
      null_();
      return;
    }
    alloc_(o, 0);
    length_(ZuUTF<Char, Char2>::cvt(ZuSpan<Char>(m_data, o), s));
  }

  template <typename P> MatchCtorPDelegate<P> ctor(const P &p) {
    null_();
    ZuPrint<P>::print(*this, p);
  }
  template <typename P> MatchCtorPBuffer<P> ctor(const P &p) {
    unsigned o = ZuPrint<P>::length(p);
    if (!o) {
      null_();
      return;
    }
    alloc_(o, 0);
    length_(ZuPrint<P>::print(reinterpret_cast<char *>(m_data), o, p));
  }

  template <typename V> MatchCtorSize<V> ctor(V size) {
    if (!size) {
      null_();
      return;
    }
    alloc_(size, 0);
  }

  template <typename R> MatchCtorElem<R> ctor(R &&r) {
    unsigned z = grow_(0, 1);
    m_data = alloc__(z);
    if (!m_data) throw std::bad_alloc{};
    size_owned(z, 1);
    length_vallocd(1, 1);
    this->initItem(m_data, ZuFwd<R>(r));
  }

public:
  template <typename A> MatchZtArray<A> copy(const A &a) {
    copy__(a.m_data, a.length());
  }
  template <typename A> MatchSpan<A> copy(A &&a_) {
    ZuSpan<const typename ZuTraits<A>::Elem> a(a_);
    copy__(a.data(), a.length());
  }
  template <typename A> MatchIterable<A> copy(const A &a) { assign(a); }

  template <typename S> MatchAnyString<S> copy(S &&s) { ctor(ZuFwd<S>(s)); }
  template <typename S> MatchChar2String<S> copy(S &&s) { ctor(ZuFwd<S>(s)); }
  template <typename C> MatchChar2<C> copy(C c) { ctor(c); }
  template <typename R> MatchElem<R> copy(R &&r) { ctor(ZuFwd<R>(r)); }

public:
  ZtArray &operator=(const ZtArray &a) {
    assign(a);
    return *this;
  }
  ZtArray &operator=(ZtArray &&a) noexcept {
    this->~ZtArray();
    new (this) ZtArray(ZuMv(a));
    return *this;
  }

  template <typename A> ZtArray &operator=(A &&a) {
    assign(ZuFwd<A>(a));
    return *this;
  }

  ZtArray &operator=(std::initializer_list<T> a) {
    uint32_t oldLength = 0;
    T *oldData = free_1(oldLength);
    copy__(a.begin(), a.size());
    free_2(oldData, oldLength);
    return *this;
  }

private:
  template <typename A> MatchZtArray<A> assign(A &&a) {
    Fwd_ZtArray<A>::assign_(this, ZuFwd<A>(a));
  }
  template <typename A> MatchSpan<A> assign(A &&a) {
    Fwd_Array<A>::assign_(this, ZuFwd<A>(a));
  }
  template <typename A> MatchIterable<A> assign(const A &a) {
    auto i = a.begin();
    unsigned n = a.end() - i;
    this->length(0);
    this->ensure(n);
    for (unsigned j = 0; j < n; j++) this->initItem(push(), *i++);
  }

  template <typename S> MatchStrLiteral<S> assign(S &&s_) {
    ZuSpan<const T> s(s_);
    free_();
    shadow_(s.data(), s.length());
  }
  template <typename S> MatchString<S> assign(S &&s_) {
    ZuSpan<const T> s(s_);
    uint32_t oldLength = 0;
    T *oldData = free_1(oldLength);
    copy__(s.data(), s.length());
    free_2(oldData, oldLength);
  }

  template <typename S> MatchChar2String<S> assign(S &&s_) {
    ZuSpan<const Char2> s(s_);
    unsigned o = ZuUTF<Char, Char2>::len(s);
    if (!o) {
      null();
      return;
    }
    if (!owned() || size() < o) size(o);
    length_(ZuUTF<Char, Char2>::cvt(ZuSpan<Char>(m_data, o), s));
  }
  template <typename C> MatchChar2<C> assign(C c) {
    ZuSpan<const Char2> s(&c, 1);
    unsigned o = ZuUTF<Char, Char2>::len(s);
    if (!o) {
      null();
      return;
    }
    if (!owned() || size() < o) size(o);
    length_(ZuUTF<Char, Char2>::cvt(ZuSpan<Char>(m_data, o), s));
  }

  template <typename P> MatchPDelegate<P> assign(const P &p) {
    ZuPrint<P>::print(*this, p);
  }
  template <typename P> MatchPBuffer<P> assign(const P &p) {
    unsigned o = ZuPrint<P>::length(p);
    if (!o) {
      null();
      return;
    }
    if (!owned() || size() < o) size(o);
    length_(ZuPrint<P>::print(reinterpret_cast<char *>(m_data), o, p));
  }

  template <typename V> MatchReal<V> assign(V v) { assign(ZuBoxed(v)); }
  template <typename V> MatchPtr<V> assign(V v) {
    assign((ZuBox<uintptr_t, ZuBoxCmp<ZuCmp0>>{reinterpret_cast<uintptr_t>(v)})
	     .hex<false, ZuFmt::Alt<>>());
  }

  template <typename V> MatchElem<V> assign(V &&v) {
    free_();
    ctor(ZuFwd<V>(v));
  }

public:
  template <typename A> ZtArray &operator-=(A &&a) {
    shadow(ZuFwd<A>(a));
    return *this;
  }

private:
  template <typename A> MatchZtArray<A> shadow(const A &a) {
    if (this == &a) return;
    free_();
    shadow_(a.m_data, a.length());
  }
  template <typename A> MatchSameSpan<A> shadow(A &&a_) {
    ZuSpan<const typename ZuTraits<A>::Elem> a(ZuFwd<A>(a_));
    free_();
    shadow_(a.data(), a.length());
  }

public:
  template <typename S, decltype(ZuMatchString<S>(), int()) = 0>
  ZtArray(S &&s_, ZtIconv *iconv) {
    ZuSpan<const typename ZuTraits<S>::Elem> s(s_);
    convert_(s, iconv);
  }
  ZtArray(const Char *data, unsigned length, ZtIconv *iconv) {
    ZuSpan<const Char> s(data, length);
    convert_(s, iconv);
  }
  ZtArray(const Char2 *data, unsigned length, ZtIconv *iconv) {
    ZuSpan<const Char2> s(data, length);
    convert_(s, iconv);
  }

  ZtArray(
    unsigned length, unsigned size, bool initItems = !ZuTraits<T>::IsPrimitive
  ) {
    if (!size) {
      null_();
      return;
    }
    alloc_(size, length);
    if (initItems) this->initItems(m_data, length);
  }
  explicit ZtArray(const T *data, unsigned length) {
    if (!length) {
      null_();
      return;
    }
    copy__(data, length);
  }
  explicit ZtArray(Move, T *data, unsigned length) {
    if (!length) {
      null_();
      return;
    }
    move__(data, length);
  }
  explicit ZtArray(
    const T *data, unsigned length, unsigned size, bool vallocd
  ) {
    if (!size) {
      null_();
      return;
    }
    own_(data, length, size, vallocd);
  }

  ~ZtArray() { free_(); }

  void init() {
    free_();
    init_();
  }
  void init_() { null_(); }

  template <typename A> void init(A &&a) { assign(ZuFwd<A>(a)); }
  template <typename A> void init_(A &&a) { ctor(ZuFwd<A>(a)); }

  void init(
    unsigned length, unsigned size, bool initItems = !ZuTraits<T>::IsPrimitive
  ) {
    if (this->size() < size || initItems) {
      free_();
      alloc_(size, length);
    } else
      length_(length);
    if (initItems) this->initItems(m_data, length);
  }
  void init_(
    unsigned length, unsigned size, bool initItems = !ZuTraits<T>::IsPrimitive
  ) {
    if (!size) {
      null_();
      return;
    }
    alloc_(size, length);
    if (initItems) this->initItems(m_data, length);
  }
  void copy(const T *data, unsigned length) {
    uint32_t oldLength = 0;
    T *oldData = free_1(oldLength);
    copy__(data, length);
    free_2(oldData, oldLength);
  }
  void move(T *data, unsigned length) {
    uint32_t oldLength = 0;
    T *oldData = free_1(oldLength);
    copy__(data, length);
    free_2(oldData, oldLength);
  }
  void copy_(const T *data, unsigned length) {
    if (!length) {
      null_();
      return;
    }
    copy__(data, length);
  }
  void move_(T *data, unsigned length) {
    if (!length) {
      null_();
      return;
    }
    move__(data, length);
  }
  void init(const T *data, unsigned length, unsigned size, bool vallocd) {
    free_();
    init_(data, length, size, vallocd);
  }
  void init_(const T *data, unsigned length, unsigned size, bool vallocd) {
    if (!size) {
      null_();
      return;
    }
    own_(data, length, size, vallocd);
  }

private:
  void null_() {
    m_data = 0;
    size_owned(0, 0);
    length_vallocd(0, 0);
  }

  void own_(const T *data, unsigned length, unsigned size, bool vallocd) {
    ((size >= length) ? void() :
			ZmAssert_fail(
			  "size >= length", "../../zt/src/zlib/ZtArray.hh", 725,
			  __PRETTY_FUNCTION__
			));
    if (!size) {
      if (data && vallocd) vfree(data);
      null_();
      return;
    }
    m_data = const_cast<T *>(data);
    size_owned(size, 1);
    length_vallocd(length, vallocd);
  }

  void shadow_(const T *data, unsigned length) {
    if (!length) {
      null_();
      return;
    }
    m_data = const_cast<T *>(data);
    size_owned(length, 0);
    length_vallocd(length, 0);
  }

  void alloc_(unsigned size, unsigned length) {
    if (!size) {
      null_();
      return;
    }
    m_data = alloc__(size);
    if (!m_data) throw std::bad_alloc{};
    size_owned(size, 1);
    length_vallocd(length, 1);
  }

  auto alloc__(unsigned length) {
    auto ptr = static_cast<T *>(valloc(length * sizeof(T)));
    ((!(reinterpret_cast<uintptr_t>(ptr) & (alignof(T) - 1))) ?
       void() :
       ZmAssert_fail(
	 "!(reinterpret_cast<uintptr_t>(ptr) & (alignof(T) - 1))",
	 "../../zt/src/zlib/ZtArray.hh", 753, __PRETTY_FUNCTION__
       ));
    return ptr;
  }

  template <typename S> void copy__(const S *data, unsigned length) {
    if (!length) {
      null_();
      return;
    }
    m_data = alloc__(length);
    if (!m_data) throw std::bad_alloc{};
    if (length) this->copyItems(m_data, data, length);
    size_owned(length, 1);
    length_vallocd(length, 1);
  }

  template <typename S> void move__(S *data, unsigned length) {
    if (!length) {
      null_();
      return;
    }
    m_data = alloc__(length);
    if (!m_data) throw std::bad_alloc{};
    if (length) this->moveItems(m_data, data, length);
    size_owned(length, 1);
    length_vallocd(length, 1);
  }

  template <typename S> void convert_(const S &s, ZtIconv *iconv);

  void free_() {
    if (m_data && owned()) {
      this->destroyItems(m_data, length());
      if (vallocd()) vfree(m_data);
    }
  }
  T *free_1(uint32_t &length_vallocd) {
    if (!m_data || !owned()) return 0;
    length_vallocd = m_length_vallocd;
    return m_data;
  }
  void free_2(T *data, uint32_t length_vallocd) {
    if (data) {
      this->destroyItems(data, length_vallocd & ~(1U << 31U));
      if (length_vallocd >> 31U) vfree(data);
    }
  }

public:
  void truncate() {
    size(length());
    unsigned n = length();
    if (!m_data || size() <= n) return;
    T *newData = alloc__(n);
    if (!newData) throw std::bad_alloc{};
    this->moveItems(newData, m_data, n);
    free_();
    m_data = newData;
    vallocd(1);
    size_owned(length(), 1);
  }

  T &operator[](unsigned i) { return m_data[i]; }
  const T &operator[](unsigned i) const { return m_data[i]; }

  T *data() { return m_data; }
  const T *data() const { return m_data; }

  unsigned length() const { return m_length_vallocd & ~(1U << 31U); }
  unsigned size() const { return m_size_owned & ~(1U << 31U); }

  bool vallocd() const { return m_length_vallocd >> 31U; }
  bool owned() const { return m_size_owned >> 31U; }

  template <bool Mutable = false, typename L> ZuIfT<!Mutable> all(L l) const {
    for (unsigned i = 0, n = length(); i < n; i++) l(m_data[i]);
  }
  template <bool Mutable, typename L> ZuIfT<Mutable> all(L l) {
    for (unsigned i = 0, n = length(); i < n; i++) l(m_data[i]);
  }

  using iterator = T *;
  using const_iterator = const T *;
  const T *begin() const { return m_data; }
  const T *end() const { return &m_data[length()]; }
  const T *cbegin() const { return m_data; }
  const T *cend() const { return &m_data[length()]; }
  T *begin() { return m_data; }
  T *end() { return &m_data[length()]; }

private:
  void length_(unsigned v) {
    m_length_vallocd =
      (m_length_vallocd & (1U << 31U)) | static_cast<uint32_t>(v);
  }
  void vallocd(bool v) {
    m_length_vallocd =
      (m_length_vallocd & ~(1U << 31U)) | ((static_cast<uint32_t>(v)) << 31U);
  }
  void length_vallocd(unsigned l, bool m) {
    m_length_vallocd = l | ((static_cast<uint32_t>(m)) << 31U);
  }
  void size_(unsigned v) {
    m_size_owned = (m_size_owned & (1U << 31U)) | static_cast<uint32_t>(v);
  }
  void owned(bool v) {
    m_size_owned =
      (m_size_owned & ~(1U << 31U)) | ((static_cast<uint32_t>(v)) << 31U);
  }
  void size_owned(unsigned z, bool o) {
    m_size_owned = z | ((static_cast<uint32_t>(o)) << 31U);
  }

public:
  T *release() && {
    owned(0);
    return m_data;
  }
  static void free(const T *ptr) { vfree(ptr); }

  void null() {
    free_();
    null_();
  }

  void clear() {
    if (!owned()) {
      null_();
      return;
    }
    if constexpr (!ZuTraits<T>::IsPrimitive)
      if (unsigned n = this->length()) this->destroyItems(m_data, n);
    length_(0);
  }

  void length(unsigned length) {
    if (!owned() || length > size()) size(length);
    if constexpr (!ZuTraits<T>::IsPrimitive) {
      unsigned n = this->length();
      if (length > n) {
	this->initItems(m_data + n, length - n);
      } else if (length < n) {
	this->destroyItems(m_data + length, n - length);
      }
    }
    length_(length);
  }
  void length(unsigned length, bool initItems) {
    if (!owned() || length > size()) size(length);
    if (initItems) {
      unsigned n = this->length();
      if (length > n) {
	this->initItems(m_data + n, length - n);
      } else if (length < n) {
	this->destroyItems(m_data + length, n - length);
      }
    }
    length_(length);
  }

  T *ensure(unsigned z) {
    if (__builtin_expect(!!(z <= size()), 1)) return m_data;
    return size(z);
  }

  T *size(unsigned z) {
    if (!z) {
      null();
      return 0;
    }
    if (owned() && z == size()) return m_data;
    T *newData = alloc__(z);
    if (!newData) throw std::bad_alloc{};
    unsigned n = z;
    if (n > length()) n = length();
    if (m_data) {
      if (n) this->moveItems(newData, m_data, n);
      free_();
    } else
      n = 0;
    m_data = newData;
    size_owned(z, 1);
    length_vallocd(n, 1);
    return newData;
  }

  void *set(unsigned i) {
    unsigned n = length();
    if (__builtin_expect(!!(i < n), 1)) {
      this->destroyItem(m_data + i);
      return m_data + i;
    }
    unsigned z = size();
    if (!owned() || i + 1 > z) {
      z = grow_(z, i + 1);
      T *newData = alloc__(z);
      if (!newData) throw std::bad_alloc{};
      this->moveItems(newData, m_data, n);
      free_();
      m_data = newData;
      size_owned(z, 1);
      if (i > n) this->initItems(m_data + n, i - n);
      length_vallocd(i + 1, 1);
    } else {
      if (i > n) this->initItems(m_data + n, i - n);
      length_(i + 1);
    }
    return m_data + i;
  }
  template <typename V> void set(unsigned i, V &&v) {
    auto ptr = set(i);
    this->initItem(ptr, ZuFwd<V>(v));
  }

  const T *getPtr(unsigned i) const {
    if (__builtin_expect(!!(i >= length()), 0)) return nullptr;
    return static_cast<const T *>(m_data + i);
  }
  const T &get(unsigned i) const {
    if (__builtin_expect(!!(i >= length()), 0)) return ZuNullRef<T, Cmp>();
    return m_data[i];
  }

  uint32_t hash() const { return Ops::hash(m_data, length()); }

  auto buf() { return ZuSpan{data(), size()}; }
  auto cbuf() const { return ZuSpan{data(), length()}; }

  bool operator!() const { return !length(); }
  operator const void *() const {
    return !*this ? reinterpret_cast<const void *>(0) :
		    static_cast<const void *>(this);
  }

  template <typename A> MatchZtArray<A, bool> equals(const A &a) const {
    if (this == &a) return true;
    return equals(a.m_data, a.length());
  }
  template <typename A> MatchSpan<A, bool> equals(A &&a_) const {
    ZuSpan<const typename ZuTraits<A>::Elem> a(ZuFwd<A>(a_));
    return equals(a.data(), a.length());
  }
  template <typename S> MatchAnyString<S, bool> equals(S &&s_) const {
    ZuSpan<const typename ZuTraits<S>::Elem> s(ZuFwd<S>(s_));
    return equals(reinterpret_cast<const T *>(s.data()), s.length());
  }
  template <typename S> MatchChar2String<S, bool> equals(const S &s) const {
    return equals(ZtArray(s));
  }

  bool equals(const T *a, unsigned n) const {
    if (!a) return !m_data;
    if (!m_data) return false;
    if (length() != n) return false;
    return Ops::equals(m_data, a, n);
  }

  template <typename A> MatchZtArray<A, int> cmp(const A &a) const {
    if (this == &a) return 0;
    return cmp(a.m_data, a.length());
  }
  template <typename A> MatchSpan<A, int> cmp(A &&a_) const {
    ZuSpan<const typename ZuTraits<A>::Elem> a(ZuFwd<A>(a_));
    return cmp(a.data(), a.length());
  }
  template <typename S> MatchAnyString<S, int> cmp(S &&s_) const {
    ZuSpan<const typename ZuTraits<S>::Elem> s(ZuFwd<S>(s_));
    return cmp(s.data(), s.length());
  }
  template <typename S> MatchChar2String<S, int> cmp(const S &s) const {
    return cmp(ZtArray(s));
  }

  int cmp(const T *a, unsigned n) const {
    if (!a) return !!m_data;
    if (!m_data) return -1;
    unsigned l = length();
    if (int i = Ops::cmp(m_data, a, l < n ? l : n)) return i;
    return l - n;
  }

  template <typename L, typename R>
  friend inline ZuIfT<ZuInspect<ZtArray, L>::Is, bool>
  operator==(const L &l, const R &r) {
    return l.equals(r);
  }
  template <typename L, typename R>
  friend inline ZuIfT<ZuInspect<ZtArray, L>::Is, int>
  operator<=>(const L &l, const R &r) {
    return l.cmp(r);
  }

  template <typename A> ZtArray operator+(const A &a) const { return add(a); }

private:
  template <typename A> MatchZtArray<A, ZtArray> add(A &&a) const {
    return Fwd_ZtArray<A>::add_(this, ZuFwd<A>(a));
  }
  template <typename A> MatchSpan<A, ZtArray> add(A &&a) const {
    return Fwd_Array<A>::add_(this, ZuFwd<A>(a));
  }

  template <typename S> MatchAnyString<S, ZtArray> add(S &&s_) const {
    ZuSpan<const typename ZuTraits<S>::Elem> s(ZuFwd<S>(s_));
    return add(s.data(), s.length());
  }
  template <typename S> MatchChar2String<S, ZtArray> add(S &&s) const {
    return add(ZtArray(ZuFwd<S>(s)));
  }
  template <typename C> MatchChar2<C, ZtArray> add(C c) const {
    return add(ZtArray(c));
  }

  template <typename P> MatchPDelegate<P, ZtArray> add(P &&p) const {
    return add(ZtArray(ZuFwd<P>(p)));
  }
  template <typename P> MatchPBuffer<P, ZtArray> add(P &&p) const {
    return add(ZtArray(ZuFwd<P>(p)));
  }

  template <typename R> MatchElem<R, ZtArray> add(R &&r) const {
    unsigned n = length();
    unsigned z = grow_(n, n + 1);
    T *newData = alloc__(z);
    if (!newData) throw std::bad_alloc{};
    if (n) this->copyItems(newData, m_data, n);
    this->initItem(newData + n, ZuFwd<R>(r));
    return ZtArray(newData, n + 1, z);
  }

  ZtArray add(const T *data, unsigned length) const {
    unsigned n = this->length();
    unsigned z = n + length;
    if (__builtin_expect(!!(!z), 0)) return ZtArray{};
    T *newData = alloc__(z);
    if (!newData) throw std::bad_alloc{};
    if (n) this->copyItems(newData, m_data, n);
    if (length) this->copyItems(newData + n, data, length);
    return ZtArray(newData, z, z);
  }
  ZtArray add_mv(T *data, unsigned length) const {
    unsigned n = this->length();
    unsigned z = n + length;
    if (__builtin_expect(!!(!z), 0)) return ZtArray{};
    T *newData = alloc__(z);
    if (!newData) throw std::bad_alloc{};
    if (n) this->copyItems(newData, m_data, n);
    if (length) this->moveItems(newData + n, data, length);
    return ZtArray(newData, z, z);
  }

public:
  template <typename U> ZtArray &operator+=(U &&v) {
    return *this << ZuFwd<U>(v);
  }
  template <typename U> MatchStreamable<U, ZtArray &> operator<<(U &&v) {
    append_(ZuFwd<U>(v));
    return *this;
  }

private:
  template <typename A> MatchZtArray<A> append_(A &&a) {
    Fwd_ZtArray<A>::splice_(this, 0, length(), 0, ZuFwd<A>(a));
  }
  template <typename A> MatchSpan<A> append_(A &&a) {
    Fwd_Array<A>::splice_(this, 0, length(), 0, ZuFwd<A>(a));
  }
  template <typename A> MatchIterable<A> append_(const A &a) {
    auto i = a.begin();
    unsigned n = a.end() - i;
    this->ensure(length() + n);
    for (unsigned j = 0; j < n; j++) this->initItem(push(), *i++);
  }

  template <typename S> MatchAnyString<S> append_(S &&s_) {
    ZuSpan<const typename ZuTraits<S>::Elem> s(ZuFwd<S>(s_));
    splice_cp_(0, length(), 0, s.data(), s.length());
  }

  template <typename S> MatchChar2String<S> append_(S &&s) {
    append_(ZtArray(ZuFwd<S>(s)));
  }
  template <typename C> MatchChar2<C> append_(C c) { append_(ZtArray(c)); }

  template <typename P> MatchPDelegate<P> append_(const P &p) {
    ZuPrint<P>::print(*this, p);
  }
  template <typename P> MatchPBuffer<P> append_(const P &p) {
    unsigned n = length();
    unsigned o = ZuPrint<P>::length(p);
    if (!owned() || size() < n + o) size(n + o);
    length(n + ZuPrint<P>::print(reinterpret_cast<char *>(m_data) + n, o, p));
  }

  template <typename V> MatchReal<V> append_(V v) { append_(ZuBoxed(v)); }
  template <typename V> MatchPtr<V> append_(V v) {
    append_((ZuBox<uintptr_t, ZuBoxCmp<ZuCmp0>>{reinterpret_cast<uintptr_t>(v)})
	      .hex<false, ZuFmt::Alt<>>());
  }

  template <typename V> MatchElem<V> append_(V &&v) {
    this->initItem(push(), ZuFwd<V>(v));
  }

public:
  void append(const T *data, unsigned length) {
    if (data) splice_cp_(0, this->length(), 0, data, length);
  }
  void append_mv(T *data, unsigned length) {
    if (data) splice_mv_(0, this->length(), 0, data, length);
  }

public:
  template <typename A>
  void splice(ZtArray &removed, int offset, int length, A &&replace) {
    splice_(&removed, offset, length, ZuFwd<A>(replace));
  }

  template <typename A> void splice(int offset, int length, A &&replace) {
    splice_(nullptr, offset, length, ZuFwd<A>(replace));
  }

  void splice(ZtArray &removed, int offset, int length) {
    splice_del_(&removed, offset, length);
  }

  void splice(int offset, int length) { splice_del_(nullptr, offset, length); }

private:
  template <typename A>
  MatchZtArray<A> splice_(ZtArray *removed, int offset, int length, A &&a) {
    Fwd_ZtArray<A>::splice_(this, removed, offset, length, ZuFwd<A>(a));
  }
  template <typename A>
  MatchSpan<A> splice_(ZtArray *removed, int offset, int length, A &&a) {
    Fwd_Array<A>::splice_(this, removed, offset, length, ZuFwd<A>(a));
  }

  template <typename S>
  MatchAnyString<S>
  splice_(ZtArray *removed, int offset, int length, const S &s_) {
    ZuSpan<const typename ZuTraits<S>::Elem> s(s_);
    splice_cp_(removed, offset, length, s.data(), s.length());
  }

  template <typename S>
  MatchChar2String<S>
  splice_(ZtArray *removed, int offset, int length, const S &s) {
    splice_(removed, offset, length, ZtArray(s));
  }
  template <typename C>
  MatchChar2<C> splice_(ZtArray *removed, int offset, int length, C c) {
    splice_(removed, offset, length, ZtArray(c));
  }

  template <typename R>
  MatchElem<R> splice_(ZtArray *removed, int offset, int length, R &&r_) {
    T r{ZuFwd<R>(r_)};
    splice_mv_(removed, offset, length, &r, 1);
  }

public:
  template <typename R>
  void splice(
    ZtArray &removed, int offset, int length, const R *replace, unsigned rlength
  ) {
    splice_cp_(&removed, offset, length, replace, rlength);
  }
  template <typename R>
  void splice_mv(
    ZtArray &removed, int offset, int length, R *replace, unsigned rlength
  ) {
    splice_mv_(&removed, offset, length, replace, rlength);
  }

  template <typename R>
  void splice(int offset, int length, const R *replace, unsigned rlength) {
    splice_cp_(nullptr, offset, length, replace, rlength);
  }
  template <typename R>
  void splice_mv(int offset, int length, R *replace, unsigned rlength) {
    splice_mv_(nullptr, offset, length, replace, rlength);
  }

  void *push() {
    unsigned n = length();
    unsigned z = size();
    if (!owned() || n + 1 > z) {
      z = grow_(z, n + 1);
      T *newData = alloc__(z);
      if (!newData) throw std::bad_alloc{};
      this->moveItems(newData, m_data, n);
      free_();
      m_data = newData;
      size_owned(z, 1);
      length_vallocd(n + 1, 1);
    } else
      length_(n + 1);
    return static_cast<void *>(m_data + n);
  }
  template <typename V> T *push(V &&v) {
    auto ptr = push();
    if (__builtin_expect(!!(ptr), 1)) this->initItem(ptr, ZuFwd<V>(v));
    return static_cast<T *>(ptr);
  }
  T pop() {
    unsigned n = length();
    if (!n) return ZuNullRef<T, Cmp>();
    T v;
    if (__builtin_expect(!!(!owned()), 0)) {
      v = m_data[--n];
    } else {
      v = ZuMv(m_data[--n]);
      this->destroyItem(m_data + n);
    }
    length_(n);
    return v;
  }
  T shift() {
    unsigned n = length();
    if (!n) return ZuNullRef<T, Cmp>();
    T v;
    if (__builtin_expect(!!(!owned()), 0)) {
      v = m_data[0];
      ++m_data;
      --n;
    } else {
      v = ZuMv(m_data[0]);
      this->destroyItem(m_data);
      this->moveItems(m_data, m_data + 1, --n);
    }
    length_(n);
    return v;
  }

  template <typename A> MatchZtArray<A> unshift(A &&a) {
    Fwd_ZtArray<A>::splice_(this, nullptr, 0, 0, ZuFwd<A>(a));
  }
  template <typename A> MatchSpan<A> unshift(A &&a) {
    Fwd_Array<A>::splice_(this, nullptr, 0, 0, ZuFwd<A>(a));
  }

  void *unshift() {
    unsigned n = length();
    unsigned z = size();
    if (!owned() || n + 1 > z) {
      z = grow_(z, n + 1);
      T *newData = alloc__(z);
      if (!newData) throw std::bad_alloc{};
      this->moveItems(newData + 1, m_data, n);
      free_();
      m_data = newData;
      size_owned(z, 1);
      length_vallocd(n + 1, 1);
    } else {
      this->moveItems(m_data + 1, m_data, n);
      length_(n + 1);
    }
    return static_cast<void *>(m_data);
  }
  template <typename V> void unshift(V &&v) {
    this->initItem(unshift(), ZuFwd<V>(v));
  }

private:
  void splice_del_(ZtArray *removed, int offset, int length) {
    unsigned n = this->length();
    unsigned z = size();
    if (offset < 0) {
      if ((offset += n) < 0) offset = 0;
    }
    if (length < 0) {
      if ((length += (n - offset)) < 0) length = 0;
    }

    if (offset > static_cast<int>(n)) {
      if (removed) removed->clear();
      if (!owned() || offset > static_cast<int>(z)) {
	z = grow_(z, offset);
	size(z);
      }
      this->initItems(m_data + n, offset - n);
      length_(offset);
      return;
    }

    if (offset + length > static_cast<int>(n)) length = n - offset;

    int l = n - length;

    if (l > 0 && (!owned() || l > static_cast<int>(z))) {
      z = grow_(z, l);
      if (removed) removed->move(m_data + offset, length);
      T *newData = alloc__(z);
      if (!newData) throw std::bad_alloc{};
      this->moveItems(newData, m_data, offset);
      if (offset + length < static_cast<int>(n))
	this->moveItems(
	  newData + offset, m_data + offset + length, n - (offset + length)
	);
      free_();
      m_data = newData;
      size_owned(z, 1);
      length_vallocd(l, 1);
      return;
    }

    if (removed) removed->move(m_data + offset, length);
    this->destroyItems(m_data + offset, length);
    if (l > 0) {
      if (offset + length < static_cast<int>(n))
	this->moveItems(
	  m_data + offset, m_data + offset + length, n - (offset + length)
	);
    }
    length_(l);
  }

  template <typename R>
  void splice_cp_(
    ZtArray *removed, int offset, int length, const R *replace, unsigned rlength
  ) {
    unsigned n = this->length();
    unsigned z = size();
    if (offset < 0) {
      if ((offset += n) < 0) offset = 0;
    }
    if (length < 0) {
      if ((length += (n - offset)) < 0) length = 0;
    }

    if (offset > static_cast<int>(n)) {
      if (removed) removed->clear();
      if (!owned() ||
	  offset + static_cast<int>(rlength) > static_cast<int>(z)) {
	z = grow_(z, offset + rlength);
	size(z);
      }
      this->initItems(m_data + n, offset - n);
      this->copyItems(m_data + offset, replace, rlength);
      length_(offset + rlength);
      return;
    }

    if (offset + length > static_cast<int>(n)) length = n - offset;

    int l = n + rlength - length;

    if (l > 0 && (!owned() || l > static_cast<int>(z))) {
      z = grow_(z, l);
      if (removed) removed->move(m_data + offset, length);
      T *newData = alloc__(z);
      if (!newData) throw std::bad_alloc{};
      this->moveItems(newData, m_data, offset);
      this->copyItems(newData + offset, replace, rlength);
      if (offset + length < static_cast<int>(n))
	this->moveItems(
	  newData + offset + rlength, m_data + offset + length,
	  n - (offset + length)
	);
      free_();
      m_data = newData;
      size_owned(z, 1);
      length_vallocd(l, 1);
      return;
    }

    if (removed) removed->move(m_data + offset, length);
    this->destroyItems(m_data + offset, length);
    if (l > 0) {
      if (static_cast<int>(rlength) != length &&
	  offset + length < static_cast<int>(n))
	this->moveItems(
	  m_data + offset + rlength, m_data + offset + length,
	  n - (offset + length)
	);
      this->copyItems(m_data + offset, replace, rlength);
    }
    length_(l);
  }

  template <typename R>
  void splice_mv_(
    ZtArray *removed, int offset, int length, R *replace, unsigned rlength
  ) {
    unsigned n = this->length();
    unsigned z = size();
    if (offset < 0) {
      if ((offset += n) < 0) offset = 0;
    }
    if (length < 0) {
      if ((length += (n - offset)) < 0) length = 0;
    }

    if (offset > static_cast<int>(n)) {
      if (removed) removed->clear();
      if (!owned() ||
	  offset + static_cast<int>(rlength) > static_cast<int>(z)) {
	z = grow_(z, offset + rlength);
	size(z);
      }
      this->initItems(m_data + n, offset - n);
      this->moveItems(m_data + offset, replace, rlength);
      length_(offset + rlength);
      return;
    }

    if (offset + length > static_cast<int>(n)) length = n - offset;

    int l = n + rlength - length;

    if (l > 0 && (!owned() || l > static_cast<int>(z))) {
      z = grow_(z, l);
      if (removed) removed->move(m_data + offset, length);
      T *newData = alloc__(z);
      if (!newData) throw std::bad_alloc{};
      this->moveItems(newData, m_data, offset);
      this->moveItems(newData + offset, replace, rlength);
      if (static_cast<int>(rlength) != length &&
	  offset + length < static_cast<int>(n))
	this->moveItems(
	  newData + offset + rlength, m_data + offset + length,
	  n - (offset + length)
	);
      free_();
      m_data = newData;
      size_owned(z, 1);
      length_vallocd(l, 1);
      return;
    }

    if (removed) removed->move(m_data + offset, length);
    this->destroyItems(m_data + offset, length);
    if (l > 0) {
      if (static_cast<int>(rlength) != length &&
	  offset + length < static_cast<int>(n))
	this->moveItems(
	  m_data + offset + rlength, m_data + offset + length,
	  n - (offset + length)
	);
      this->moveItems(m_data + offset, replace, rlength);
    }
    length_(l);
  }

public:
  template <typename Fn> void iterate(Fn fn) {
    unsigned n = length();
    for (unsigned i = 0; i < n; i++) fn(m_data[i]);
  }

  template <typename L> void grep(L l) {
    for (unsigned i = 0, n = length(); i < n; i++) {
      if (l(m_data[i])) {
	splice_del_(0, i, 1);
	--i, --n;
      }
    }
  }

  void grow(unsigned length) {
    unsigned o = size();
    if (__builtin_expect(!!(length > o), 0)) size(grow_(o, length));
    o = this->length();
    if (__builtin_expect(!!(length > o), 0)) this->length(length);
  }
  void grow(unsigned length, bool initItems) {
    unsigned o = size();
    if (__builtin_expect(!!(length > o), 0)) size(grow_(o, length));
    o = this->length();
    if (__builtin_expect(!!(length > o), 0)) this->length(length, initItems);
  }

private:
  static unsigned grow_(unsigned o, unsigned n) {
    return ZmGrow(o * sizeof(T), n * sizeof(T)) / sizeof(T);
  }

public:
  struct Traits : public ZuBaseTraits<ZtArray> {
    using Elem = T;
    enum {
      IsArray = 1,
      IsSpan = 1,
      IsPrimitive = 0,
      IsString = bool(ZuIsExact<char, ZuDecay<T>>{}) ||
	bool(ZuIsExact<wchar_t, ZuDecay<T>>{}),
      IsWString = bool(ZuIsExact<wchar_t, ZuDecay<T>>{})
    };
    static T *data(ZtArray &a) { return a.data(); }
    static const T *data(const ZtArray &a) { return a.data(); }
    static unsigned length(const ZtArray &a) { return a.length(); }
  };
  friend Traits ZuTraitsType(ZtArray *);

private:
  uint32_t m_size_owned;
  uint32_t m_length_vallocd;
  T *m_data;
};

template <typename T, typename NTP>
template <typename S>
inline void ZtArray<T, NTP>::convert_(const S &s, ZtIconv *iconv) {
  null_();
  iconv->convert(*this, s);
}

using ZtBytes = ZtArray<uint8_t>;

template <typename Char> inline const Char *ZtString_Null();
template <> inline const char *ZtString_Null() { return ""; }
template <> inline const wchar_t *ZtString_Null() { return Zu::nullWString(); }

template <typename T_> struct ZtString_Char2;
template <> struct ZtString_Char2<char> {
  using T = wchar_t;
};
template <> struct ZtString_Char2<wchar_t> {
  using T = char;
};

template <typename> struct ZtString__ { };
template <> struct ZtString__<char> {
  friend ZuPrintString ZuPrintType(ZtString__ *);
};

inline constexpr const char *ZtString_ID() { return "ZtString"; }

template <typename Char_, auto HeapID_>
class ZtString_ : private ZmVHeap<HeapID_>, public ZtString__<ZuStrip<Char_>> {
public:
  using Char = Char_;
  using Char2 = typename ZtString_Char2<Char>::T;
  enum { IsWString = ZuInspect<Char, wchar_t>::Same };
  enum { BuiltinSize = 24 / sizeof(Char) };
  static constexpr auto HeapID = HeapID_;

private:
  template <typename U, typename V = Char>
  struct IsZtString : public ZuBool<ZuInspect<ZtString__<V>, U>::Base> { };
  template <typename U, typename R = void>
  using MatchZtString = ZuIfT<IsZtString<U>{}, R>;

  template <typename U, typename V = Char>
  struct IsStrLiteral :
    public ZuIsExact<U, const V (&)[sizeof(U) / sizeof(V)]> { };
  template <typename U, typename R = void>
  using MatchStrLiteral = ZuIfT<IsStrLiteral<U>{}, R>;

  template <typename U, typename V = Char>
  struct IsAnyCString :
    public ZuBool<
      !IsZtString<U>{} && ZuTraits<U>::IsCString &&
      bool{ZuEquiv<typename ZuTraits<U>::Elem, V>{}}> { };
  template <typename U, typename R = void>
  using MatchAnyCString = ZuIfT<IsAnyCString<U>{}, R>;

  template <typename U, typename V = Char>
  struct IsCString : public ZuBool<!IsStrLiteral<U>{} && IsAnyCString<U>{}> { };
  template <typename U, typename R = void>
  using MatchCString = ZuIfT<IsCString<U>{}, R>;

  template <typename U, typename V = Char>
  struct IsOtherString :
    public ZuBool<
      !IsZtString<U>{} && ZuTraits<U>::IsString && !ZuTraits<U>::IsCString &&
      bool{ZuEquiv<typename ZuTraits<U>::Elem, V>{}}> { };
  template <typename U, typename R = void>
  using MatchOtherString = ZuIfT<IsOtherString<U>{}, R>;

  template <typename U, typename V = Char2>
  struct IsChar2String :
    public ZuBool<
      (ZuTraits<U>::IsArray || ZuTraits<U>::IsString) &&
      bool{ZuEquiv<typename ZuTraits<U>::Elem, V>{}}> { };
  template <typename U, typename R = void>
  using MatchChar2String = ZuIfT<IsChar2String<U>{}, R>;

  template <typename U, typename V = Char2>
  struct IsChar2 :
    public ZuBool<bool{ZuEquiv<U, V>{}} && !bool{ZuEquiv<U, wchar_t>{}}> { };
  template <typename U, typename R = void>
  using MatchChar2 = ZuIfT<IsChar2<U>{}, R>;

  template <typename U, typename V = Char>
  struct IsPrint :
    public ZuBool<
      bool{ZuEquiv<char, V>{}} && ZuPrint<U>::OK && !ZuPrint<U>::String> { };
  template <typename U, typename R = void>
  using MatchPrint = ZuIfT<IsPrint<U>{}, R>;
  template <typename U, typename V = Char>
  struct IsPDelegate :
    public ZuBool<bool{ZuEquiv<char, V>{}} && ZuPrint<U>::Delegate> { };
  template <typename U, typename R = void>
  using MatchPDelegate = ZuIfT<IsPDelegate<U>{}, R>;
  template <typename U, typename V = Char>
  struct IsPBuffer :
    public ZuBool<bool{ZuEquiv<char, V>{}} && ZuPrint<U>::Buffer> { };
  template <typename U, typename R = void>
  using MatchPBuffer = ZuIfT<IsPBuffer<U>{}, R>;

  template <typename U, typename V = Char>
  struct IsReal :
    public ZuBool<
      bool{ZuEquiv<char, V>{}} && !bool{ZuEquiv<U, V>{}} &&
      ZuTraits<U>::IsReal && ZuTraits<U>::IsPrimitive &&
      !ZuTraits<U>::IsArray> { };
  template <typename U, typename R = void>
  using MatchReal = ZuIfT<IsReal<U>{}, R>;

  template <typename U, typename V = Char>
  struct IsPtr :
    public ZuBool<
      bool{ZuEquiv<char, V>{}} && ZuTraits<U>::IsPointer &&
      ZuTraits<U>::IsPrimitive && !ZuTraits<U>::IsArray &&
      !ZuTraits<U>::IsString> { };
  template <typename U, typename R = void>
  using MatchPtr = ZuIfT<IsPtr<U>{}, R>;

  template <typename U, typename V = Char>
  struct IsChar : public ZuBool<bool{ZuEquiv<U, V>{}}> { };
  template <typename U, typename R = void>
  using MatchChar = ZuIfT<IsChar<U>{}, R>;

  template <typename U>
  struct IsStreamable :
    public ZuBool<
      bool{IsZtString<U>{}} || bool{IsAnyCString<U>{}} ||
      bool{IsOtherString<U>{}} || bool{IsChar<U>{}} ||
      bool{IsChar2String<U>{}} || bool{IsChar2<U>{}} ||
      bool{IsPDelegate<U>{}} || bool{IsPBuffer<U>{}} || bool{IsReal<U>{}} ||
      bool{IsPtr<U>{}}> { };
  template <typename U, typename R = void>
  using MatchStreamable = ZuIfT<IsStreamable<U>{}, R>;

  template <typename U, typename V = Char>
  struct IsCtorSize :
    public ZuBool<
      ZuTraits<U>::IsIntegral &&
      (sizeof(U) > 2 || !ZuIsExact<ZuNormChar<V>, ZuNormChar<U>>{})> { };
  template <typename U, typename R = void>
  using MatchCtorSize = ZuIfT<IsCtorSize<U>{}, R>;

  template <typename U, typename R = void>
  using MatchCtorPDelegate =
    ZuIfT<bool(IsPDelegate<U>{}) && !IsCtorSize<U>{}, R>;
  template <typename U, typename R = void>
  using MatchCtorPBuffer = ZuIfT<bool(IsPBuffer<U>{}) && !IsCtorSize<U>{}, R>;

  template <typename U, typename V = Char>
  struct IsCtorReal : public ZuBool<IsReal<U>{} && !IsCtorSize<U>{}> { };
  template <typename U, typename R = void>
  using MatchCtorReal = ZuIfT<IsCtorReal<U>{}, R>;

public:
  ZtString_() { null_(); }

private:
  enum NoInit_ { NoInit };
  ZtString_(NoInit_ _) { }

public:
  ZtString_(const ZtString_ &s) { copy_(s.data_(), s.length()); }
  ZtString_(ZtString_ &&s) noexcept {
    if (__builtin_expect(!!(s.null__()), 0)) {
      null_();
      return;
    }
    if (__builtin_expect(!!(s.builtin()), 1)) {
      copy_(s.data_(), s.length());
      return;
    }
    if (__builtin_expect(!!(!s.owned()), 0)) {
      shadow_(s.data_(), s.length());
      return;
    }
    own_(s.data_(), s.length(), s.size(), s.vallocd());
    s.owned(s.builtin());
    s.vallocd(0);
  }

  template <typename S> ZtString_(S &&s) { ctor(ZuFwd<S>(s)); }

private:
  template <typename S> MatchZtString<S> ctor(const S &s) {
    copy_(s.data_(), s.length());
  }
  template <typename S> MatchStrLiteral<S> ctor(S &&s_) {
    ZuSpan<const Char> s(ZuFwd<S>(s_));
    shadow_(s.data(), s.length());
  }
  template <typename S> MatchCString<S> ctor(S &&s_) {
    ZuSpan<const Char> s(ZuFwd<S>(s_));
    copy_(s.data(), s.length());
  }
  template <typename S> MatchOtherString<S> ctor(S &&s_) {
    ZuSpan<const Char> s(ZuFwd<S>(s_));
    copy_(s.data(), s.length());
  }
  template <typename C> MatchChar<C> ctor(C c) { copy_(&c, 1); }

  template <typename S> MatchChar2String<S> ctor(S &&s_) {
    ZuSpan<const Char2> s(s_);
    unsigned o = ZuUTF<Char, Char2>::len(s);
    if (!o) {
      null_();
      return;
    }
    length_(ZuUTF<Char, Char2>::cvt(ZuSpan<Char>{alloc_(o + 1, 0), o}, s));
  }

  template <typename C> MatchChar2<C> ctor(C c) {
    ZuSpan<const Char2> s(&c, 1);
    unsigned o = ZuUTF<Char, Char2>::len(s);
    if (!o) {
      null_();
      return;
    }
    length_(ZuUTF<Char, Char2>::cvt(ZuSpan<Char>(alloc_(o + 1, 0), o), s));
  }

  template <typename P> MatchCtorPDelegate<P> ctor(const P &p) {
    null_();
    ZuPrint<P>::print(*this, p);
  }
  template <typename P> MatchCtorPBuffer<P> ctor(const P &p) {
    unsigned o = ZuPrint<P>::length(p);
    if (!o) {
      null_();
      return;
    }
    length_(ZuPrint<P>::print(alloc_(o + 1, 0), o, p));
  }

  template <typename V> MatchCtorSize<V> ctor(V size) {
    if (!size) {
      null_();
      return;
    }
    alloc_(size, 0)[0] = 0;
  }

  template <typename R> MatchCtorReal<R> ctor(R r) { ctor(ZuBoxed(r)); }

public:
  void copy(const ZtString_ &s) { copy_(s.data_(), s.length()); }
  template <typename S> MatchAnyCString<S> copy(S &&s_) {
    ZuSpan<const Char> s(ZuFwd<S>(s_));
    copy_(s.data(), s.length());
  }
  template <typename S> MatchOtherString<S> copy(S &&s_) {
    ZuSpan<const Char> s(ZuFwd<S>(s_));
    copy_(s.data(), s.length());
  }
  template <typename C> MatchChar<C> copy(C c) { copy_(&c, 1); }

  template <typename S> MatchChar2String<S> copy(S &&s_) {
    ZuSpan<const Char2> s(ZuFwd<S>(s_));
    unsigned o = ZuUTF<Char, Char2>::len(s);
    if (__builtin_expect(!!(!o), 0)) {
      length_(0);
      return;
    }
    unsigned z = size();
    Char *data;
    if (!owned() || o >= z)
      data = size(o + 1);
    else
      data = data_();
    length_(ZuUTF<Char, Char2>::cvt(ZuSpan<Char>(data, o), s));
  }

  template <typename C> MatchChar2<C> copy(C c) {
    ZuSpan<const Char2> s(&c, 1);
    unsigned o = ZuUTF<Char, Char2>::len(s);
    if (__builtin_expect(!!(!o), 0)) {
      length_(0);
      return;
    }
    unsigned z = size();
    Char *data;
    if (!owned() || o >= z)
      data = size(o + 1);
    else
      data = data_();
    length_(ZuUTF<Char, Char2>::cvt(ZuSpan<Char>(data, o), s));
  }

public:
  ZtString_ &operator=(const ZtString_ &s) {
    if (__builtin_expect(!!(this != &s), 1)) {
      Char *oldData = free_1();
      copy_(s.data_(), s.length());
      free_2(oldData);
    }
    return *this;
  }
  ZtString_ &operator=(ZtString_ &&s) noexcept {
    if (__builtin_expect(!!(this != &s), 1)) {
      this->~ZtString_();
      new (this) ZtString_(ZuMv(s));
    }
    return *this;
  }

  template <typename S> ZtString_ &operator=(S &&s) {
    assign(ZuFwd<S>(s));
    return *this;
  }

private:
  template <typename S> MatchZtString<S> assign(const S &s) {
    if (this == &s) return;
    Char *oldData = free_1();
    copy_(s.data_(), s.length());
    free_2(oldData);
  }
  template <typename S> MatchStrLiteral<S> assign(S &&s_) {
    ZuSpan<const Char> s(ZuFwd<S>(s_));
    free_();
    shadow_(s.data(), s.length());
  }
  template <typename S> MatchCString<S> assign(S &&s_) {
    ZuSpan<const Char> s(ZuFwd<S>(s_));
    Char *oldData = free_1();
    copy_(s.data(), s.length());
    free_2(oldData);
  }
  template <typename S> MatchOtherString<S> assign(S &&s_) {
    ZuSpan<const Char> s(ZuFwd<S>(s_));
    Char *oldData = free_1();
    copy_(s.data(), s.length());
    free_2(oldData);
  }
  template <typename C> MatchChar<C> assign(C c) {
    Char *oldData = free_1();
    copy_(&c, 1);
    free_2(oldData);
  }

  template <typename S> MatchChar2String<S> assign(S &&s_) {
    ZuSpan<const Char2> s(ZuFwd<S>(s_));
    unsigned o = ZuUTF<Char, Char2>::len(s);
    unsigned z = size();
    if (__builtin_expect(!!(!o), 0)) {
      length_(0);
      return;
    }
    Char *data;
    if (!owned() || o >= z)
      data = size(o + 1);
    else
      data = data_();
    length_(ZuUTF<Char, Char2>::cvt(ZuSpan<Char>(data, o), s));
  }
  template <typename C> MatchChar2<C> assign(C c) {
    ZuSpan<const Char2> s(&c, 1);
    unsigned o = ZuUTF<Char, Char2>::len(s);
    unsigned z = size();
    if (__builtin_expect(!!(!o), 0)) {
      length_(0);
      return;
    }
    Char *data;
    if (!owned() || o >= z)
      data = size(o + 1);
    else
      data = data_();
    length_(ZuUTF<Char, Char2>::cvt(ZuSpan<Char>(data, o), s));
  }

  template <typename P> MatchPDelegate<P> assign(const P &p) {
    ZuPrint<P>::print(*this, p);
  }
  template <typename P> MatchPBuffer<P> assign(const P &p) {
    unsigned o = ZuPrint<P>::length(p);
    if (__builtin_expect(!!(!o), 0)) {
      length_(0);
      return;
    }
    unsigned z = size();
    Char *data;
    if (!owned() || o >= z)
      data = size(o + 1);
    else
      data = data_();
    length_(ZuPrint<P>::print(data, o, p));
  }

  template <typename V> MatchReal<V> assign(V v) { assign(ZuBoxed(v)); }
  template <typename V> MatchPtr<V> assign(V v) {
    assign((ZuBox<uintptr_t, ZuBoxCmp<ZuCmp0>>{reinterpret_cast<uintptr_t>(v)})
	     .hex<false, ZuFmt::Alt<>>());
  }

public:
  template <typename S> ZtString_ &operator-=(const S &s) {
    shadow(s);
    return *this;
  }

private:
  template <typename S> MatchZtString<S> shadow(const S &s) {
    if (this == &s) return;
    free_();
    shadow_(s.data_(), s.length());
  }
  template <typename S> MatchAnyCString<S> shadow(S &&s_) {
    ZuSpan<const Char> s(ZuFwd<S>(s_));
    free_();
    shadow_(s.data(), s.length());
  }
  template <typename S> MatchOtherString<S> shadow(S &&s_) {
    ZuSpan<const Char> s(ZuFwd<S>(s_));
    free_();
    shadow_(s.data(), s.length());
  }

public:
  template <typename S, decltype(ZuMatchString<S>(), int()) = 0>
  ZtString_(S &&s_, ZtIconv *iconv) {
    ZuSpan<const typename ZuTraits<S>::Elem> s{ZuFwd<S>(s_)};
    convert_(s, iconv);
  }
  ZtString_(const Char *data, unsigned length, ZtIconv *iconv) {
    ZuSpan<const Char> s(data, length);
    convert_(s, iconv);
  }
  ZtString_(const Char2 *data, unsigned length, ZtIconv *iconv) {
    ZuSpan<const Char2> s(data, length);
    convert_(s, iconv);
  }

public:
  ZtString_(unsigned length, unsigned size) {
    if (!size) {
      null_();
      return;
    }
    alloc_(size, length)[length] = 0;
  }
  explicit ZtString_(const Char *data, unsigned length) {
    if (!length) {
      null_();
      return;
    }
    copy_(data, length);
  }
  explicit ZtString_(Char *data, unsigned length, unsigned size, bool vallocd) {
    if (!size) {
      null_();
      return;
    }
    own_(data, length, size, vallocd);
  }

  ~ZtString_() { free_(); }

  void init() {
    free_();
    init_();
  }
  void init_() { null_(); }

  template <typename S> void init(const S &s) { assign(s); }
  template <typename S> void init_(const S &s) { ctor(s); }

  void init(unsigned length, unsigned size) {
    if (!size) {
      null_();
      return;
    }
    unsigned z = this->size();
    if (z < size) {
      free_();
      alloc_(size, length);
    } else
      length_(length);
  }
  void init_(unsigned length, unsigned size) {
    if (!size) {
      null_();
      return;
    }
    alloc_(size, length);
  }
  void init(const Char *data, unsigned length) {
    Char *oldData = free_1();
    init_(data, length);
    free_2(oldData);
  }
  void init_(const Char *data, unsigned length) {
    if (!length) {
      null_();
      return;
    }
    copy_(data, length);
  }
  void init(const Char *data, unsigned length, unsigned size, bool vallocd) {
    free_();
    init_(data, length, size, vallocd);
  }
  void init_(const Char *data, unsigned length, unsigned size, bool vallocd) {
    if (!size) {
      null_();
      return;
    }
    own_(data, length, size, vallocd);
  }

private:
  using ZmVHeap<HeapID>::valloc;
  using ZmVHeap<HeapID>::vfree;

public:
  void length_(unsigned n) {
    null__(0);
    length__(n);
    data_()[n] = 0;
  }

private:
  void null_() {
    ptr__(nullptr);
    size_owned_null(BuiltinSize, 1, 1);
    length_vallocd_builtin(0, 0, 1);
  }

  void own_(const Char *data, unsigned length, unsigned size, bool vallocd) {
    if (!size) {
      ((!data) ?
	 void() :
	 ZmAssert_fail(
	   "!data", "../../zt/src/zlib/ZtString.hh", 536, __PRETTY_FUNCTION__
	 ));
      null_();
      return;
    }
    ptr__(data);
    size_owned_null(size, 1, 0);
    length_vallocd_builtin(length, vallocd, 0);
  }

  void shadow_(const Char *data, unsigned length) {
    if (!length) {
      null_();
      return;
    }
    ptr__(data);
    size_owned_null(length + 1, 0, 0);
    length_vallocd_builtin(length, 0, 0);
  }

  Char *alloc_(unsigned size, unsigned length) {
    if (__builtin_expect(!!(size <= BuiltinSize), 1)) {
      size_owned_null(size, 1, 0);
      length_vallocd_builtin(length, 0, 1);
      return data__();
    }
    Char *newData = static_cast<Char *>(valloc(size * sizeof(Char)));
    if (!newData) throw std::bad_alloc{};
    ptr__(newData);
    size_owned_null(size, 1, 0);
    length_vallocd_builtin(length, 1, 0);
    return newData;
    ;
  }

  void copy_(const Char *copyData, unsigned length) {
    if (!length) {
      null_();
      return;
    }
    if (length < BuiltinSize) {
      memcpy(data__(), copyData, length * sizeof(Char));
      (data__())[length] = 0;
      size_owned_null(BuiltinSize, 1, 0);
      length_vallocd_builtin(length, 0, 1);
      return;
    }
    Char *newData = static_cast<Char *>(valloc((length + 1) * sizeof(Char)));
    if (!newData) throw std::bad_alloc{};
    memcpy(newData, copyData, length * sizeof(Char));
    newData[length] = 0;
    ptr__(newData);
    size_owned_null(length + 1, 1, 0);
    length_vallocd_builtin(length, 1, 0);
  }

  template <typename S> void convert_(const S &s, ZtIconv *iconv);

  void free_() {
    if (vallocd())
      if (Char *data = ptr__()) vfree(data);
  }
  Char *free_1() {
    if (!vallocd()) return nullptr;
    return data_();
  }
  void free_2(Char *data) {
    if (data) vfree(data);
  }

public:
  void truncate() { size(length() + 1); }

  Char &operator[](unsigned i) { return data_()[i]; }
  Char operator[](unsigned i) const { return data_()[i]; }

  operator Char *() { return null__() ? nullptr : data_(); }
  operator const Char *() const { return null__() ? nullptr : data_(); }

  using iterator = Char *;
  using const_iterator = const Char *;
  const Char *begin() const {
    if (null__()) return nullptr;
    return data_();
  }
  const Char *end() const {
    if (null__()) return nullptr;
    return data_() + length();
  }
  Char *begin() {
    return const_cast<Char *>(static_cast<const ZtString_ &>(*this).begin());
  }
  Char *end() {
    return const_cast<Char *>(static_cast<const ZtString_ &>(*this).end());
  }

  Char *data() {
    if (null__()) return nullptr;
    return data_();
  }
  Char *data_() { return builtin() ? data__() : ptr__(); }
  const Char *data() const {
    if (null__()) return nullptr;
    return data_();
  }
  const Char *data_() const { return builtin() ? data__() : ptr__(); }
  const Char *ndata() const {
    if (null__()) return ZtString_Null<Char>();
    return data_();
  }

  unsigned length() const { return m_length_vallocd_builtin & ~(3U << 30); }
  unsigned size() const {
    uint32_t u = m_size_owned_null;
    return u & ~(uint32_t)(((int32_t)u) >> 31) & ~(3U << 30);
  }
  bool vallocd() const { return (m_length_vallocd_builtin >> 30) & 1U; }
  bool builtin() const { return m_length_vallocd_builtin >> 31; }
  bool owned() const { return (m_size_owned_null >> 30) & 1U; }

private:
  const Char *data__() const {
    return reinterpret_cast<const Char *>(&m_data[0]);
  }
  Char *data__() { return reinterpret_cast<Char *>(&m_data[0]); }

  const Char *ptr__() const {
    return *reinterpret_cast<const Char *const *>(&m_data[0]);
  }
  Char *ptr__() { return *reinterpret_cast<Char **>(&m_data[0]); }
  void ptr__(const Char *p) {
    *reinterpret_cast<const Char **>(&m_data[0]) = p;
  }

  void length__(unsigned v) {
    m_length_vallocd_builtin = (m_length_vallocd_builtin & (3U << 30)) | v;
  }
  void vallocd(bool v) {
    m_length_vallocd_builtin =
      (m_length_vallocd_builtin & ~(1U << 30)) | ((uint32_t(v)) << 30);
  }
  void builtin(bool v) {
    m_length_vallocd_builtin =
      (m_length_vallocd_builtin & ~(1U << 31)) | ((uint32_t(v)) << 31);
  }
  void length_vallocd_builtin(unsigned l, bool m, bool b) {
    m_length_vallocd_builtin =
      l | ((uint32_t(m)) << 30) | ((uint32_t(b)) << 31);
  }
  unsigned size_() const { return m_size_owned_null & ~(3U << 30); }
  void size_(unsigned v) {
    m_size_owned_null = (m_size_owned_null & (3U << 30)) | v;
  }
  void owned(bool v) {
    m_size_owned_null =
      (m_size_owned_null & ~(1U << 30)) | ((uint32_t(v)) << 30);
  }
  bool null__() const { return m_size_owned_null >> 31; }
  void null__(bool v) {
    m_size_owned_null =
      (m_size_owned_null & ~(1U << 31)) | ((uint32_t(v)) << 31);
  }
  void size_owned_null(unsigned z, bool o, bool n) {
    m_size_owned_null = z | ((uint32_t(o)) << 30) | ((uint32_t(n)) << 31);
  }

public:
  Char *release() && {
    if (null__()) return nullptr;
    if (builtin()) {
      Char *newData = static_cast<Char *>(valloc(BuiltinSize * sizeof(Char)));
      if (!newData) throw std::bad_alloc{};
      memcpy(newData, m_data, (length() + 1) * sizeof(Char));
      return newData;
    } else {
      owned(0);
      vallocd(0);
      return ptr__();
    }
  }
  static void free(const Char *ptr) { vfree(ptr); }

  void null() {
    free_();
    null_();
  }

  void clear() {
    if (!null__()) {
      if (!owned()) {
	null_();
	return;
      }
      length_(0);
    }
  }

  void length(unsigned n) {
    if (!owned() || n >= size_()) size(n + 1);
    length_(n);
  }
  void calcLength() {
    if (null__())
      length__(0);
    else {
      auto data = data_();
      data[size_() - 1] = 0;
      length__(Zu::strlen_(data));
    }
  }

  Char *ensure(unsigned z) {
    if (__builtin_expect(!!(owned() && z <= size_()), 1)) return data_();
    return size(z);
  }
  Char *size(unsigned z) {
    if (__builtin_expect(!!(!z), 0)) {
      null();
      return nullptr;
    }
    if (owned() && z == size_()) return data_();
    Char *oldData = data_();
    Char *newData;
    if (z <= BuiltinSize)
      newData = data__();
    else {
      newData = static_cast<Char *>(valloc(z * sizeof(Char)));
      if (!newData) throw std::bad_alloc{};
    }
    unsigned n = z - 1U;
    if (n > length()) n = length();
    if (oldData != newData) {
      memcpy(newData, oldData, (n + 1) * sizeof(Char));
      if (vallocd()) vfree(oldData);
    }
    if (z <= BuiltinSize) {
      size_owned_null(z, 1, 0);
      length_vallocd_builtin(n, 0, 1);
      return newData;
    }
    ptr__(newData);
    size_owned_null(z, 1, 0);
    length_vallocd_builtin(n, 1, 0);
    return newData;
  }

  template <typename S>
  MatchZtString<S, ZuSpan<const Char>> prefix(const S &s) {
    if (this == &s) return ZuSpan<const Char>{data_(), length() + 1};
    return prefix(s.data_(), s.length());
  }
  template <typename S> MatchAnyCString<S, ZuSpan<const Char>> prefix(S &&s_) {
    ZuSpan<const Char> s(ZuFwd<S>(s_));
    return prefix(s.data(), s.length());
  }
  template <typename S> MatchOtherString<S, ZuSpan<const Char>> prefix(S &&s_) {
    ZuSpan<const Char> s(ZuFwd<S>(s_));
    return prefix(s.data(), s.length());
  }

  ZuSpan<const Char> prefix(const Char *pfxData, unsigned length) const {
    if (null__()) return ZuSpan<const Char>();
    const Char *p1 = data_();
    if (!pfxData) return ZuSpan<const Char>(p1, 1);
    const Char *p2 = pfxData;
    unsigned i, n = this->length();
    n = n > length ? length : n;
    for (i = 0; i < n && p1[i] == p2[i]; ++i);
    return ZuSpan<const Char>(data_(), i);
  }

public:
  uint32_t hash() const { return ZuHash<ZtString_>::hash(*this); }

  auto buf() { return ZuSpan{data(), size() - 1}; }
  auto cbuf() const { return ZuSpan{data(), length()}; }

  bool operator!() const { return !length(); }

  template <typename S> bool equals(const S &s) const {
    return ZuCmp<ZtString_>::equals(*this, s);
  }
  template <typename S> int cmp(const S &s) const {
    return ZuCmp<ZtString_>::cmp(*this, s);
  }
  template <typename L, typename R>
  friend inline ZuIfT<
    ZuInspect<ZtString_, L>::Is && ZuTraits<R>::IsString, bool>
  operator==(const L &l, const R &r) {
    return l.equals(r);
  }
  template <typename L, typename R>
  friend inline ZuIfT<ZuInspect<ZtString_, L>::Is && ZuTraits<R>::IsString, int>
  operator<=>(const L &l, const R &r) {
    return l.cmp(r);
  }

  bool equals(const Char *s, unsigned n) const {
    if (null__()) return !s;
    if (!s) return false;
    return !Zu::strcmp_(data_(), s, n);
  }
  int cmp(const Char *s, unsigned n) const {
    if (null__()) return s ? -1 : 0;
    if (!s) return 1;
    return Zu::strcmp_(data_(), s, n);
  }
  int icmp(const Char *s, unsigned n) const {
    if (null__()) return s ? -1 : 0;
    if (!s) return 1;
    return Zu::stricmp_(data_(), s, n);
  }

  template <typename S> ZtString_ operator+(const S &s) const { return add(s); }

private:
  template <typename S> MatchZtString<S, ZtString_> add(const S &s) const {
    return add(s.data_(), s.length());
  }
  template <typename S> MatchAnyCString<S, ZtString_> add(S &&s_) const {
    ZuSpan<const Char> s(ZuFwd<S>(s_));
    return add(s.data(), s.length());
  }
  template <typename S> MatchOtherString<S, ZtString_> add(S &&s_) const {
    ZuSpan<const Char> s(ZuFwd<S>(s_));
    return add(s.data(), s.length());
  }
  template <typename C> MatchChar<C, ZtString_> add(C c) const {
    return add(&c, 1);
  }

  template <typename S> MatchChar2String<S, ZtString_> add(const S &s) const {
    return add(ZtString_(s));
  }
  template <typename C> MatchChar2<C, ZtString_> add(C c) const {
    return add(ZtString_(c));
  }

  template <typename P> MatchPDelegate<P, ZtString_> add(const P &p) const {
    return add(ZtString_(p));
  }
  template <typename P> MatchPBuffer<P, ZtString_> add(const P &p) const {
    return add(ZtString_(p));
  }

  ZtString_ add(const Char *data, unsigned length) const {
    unsigned n = this->length();
    unsigned o = n + length;
    if (__builtin_expect(!!(!o), 0)) return ZtString_{};
    Char *newData = static_cast<Char *>(valloc((o + 1) * sizeof(Char)));
    if (!newData) throw std::bad_alloc{};
    if (n) memcpy(newData, data_(), n * sizeof(Char));
    if (length) memcpy(newData + n, data, length * sizeof(Char));
    newData[o] = 0;
    return ZtString_{newData, o, o + 1, true};
  }

public:
  template <typename U> ZtString_ &operator+=(U &&v) {
    return *this << ZuFwd<U>(v);
  }
  template <typename U> MatchStreamable<U, ZtString_ &> operator<<(U &&v) {
    append_(ZuFwd<U>(v));
    return *this;
  }

private:
  template <typename S> MatchZtString<S> append_(const S &s) {
    if (this == &s) {
      ZtString_ s_ = s;
      splice__(0, length(), 0, s_.data_(), s_.length());
    } else
      splice__(0, length(), 0, s.data_(), s.length());
  }
  template <typename S> MatchAnyCString<S> append_(S &&s_) {
    ZuSpan<const Char> s(ZuFwd<S>(s_));
    splice__(0, length(), 0, s.data(), s.length());
  }
  template <typename S> MatchOtherString<S> append_(S &&s_) {
    ZuSpan<const Char> s(ZuFwd<S>(s_));
    splice__(0, length(), 0, s.data(), s.length());
  }
  template <typename C> MatchChar<C> append_(C c) {
    unsigned n = length();
    unsigned z = size_();
    Char *data;
    if (!owned() || n + 2 >= z)
      data = size(grow_(z, n + 2));
    else
      data = data_();
    data[n++] = c;
    length_(n);
  }

  template <typename S> MatchChar2String<S> append_(const S &s) {
    append_(ZtString_(s));
  }
  template <typename C> MatchChar2<C> append_(C c) { append_(ZtString_(c)); }

  template <typename P> MatchPDelegate<P> append_(const P &p) {
    ZuPrint<P>::print(*this, p);
  }
  template <typename P> MatchPBuffer<P> append_(const P &p) {
    unsigned n = length();
    unsigned z = size_();
    unsigned o = ZuPrint<P>::length(p);
    Char *data;
    if (!owned() || z <= n + o)
      data = size(grow_(z, n + o + 1));
    else
      data = data_();
    length_(n + ZuPrint<P>::print(data + n, o, p));
  }

  template <typename V> MatchReal<V> append_(V v) { append_(ZuBoxed(v)); }
  template <typename V> MatchPtr<V> append_(V v) {
    append_((ZuBox<uintptr_t, ZuBoxCmp<ZuCmp0>>{reinterpret_cast<uintptr_t>(v)})
	      .hex<false, ZuFmt::Alt<>>());
  }

public:
  void append(const Char *data, unsigned length) {
    if (data) splice__(0, this->length(), 0, data, length);
  }

  void
  splice(ZtString_ &removed, int offset, int length, const ZtString_ &replace) {
    splice_(&removed, offset, length, replace);
  }

  void splice(int offset, int length, const ZtString_ &replace) {
    splice_(0, offset, length, replace);
  }

  void splice(ZtString_ &removed, int offset, int length) {
    splice__(&removed, offset, length, 0, 0);
  }

  void splice(int offset) {
    splice__(
      0, offset, 0x7fffffff

      ,
      0, 0
    );
  }

  void splice(int offset, int length) { splice__(0, offset, length, 0, 0); }

  template <typename S>
  void splice(ZtString_ &removed, int offset, int length, const S &replace) {
    splice_(&removed, offset, length, replace);
  }

  template <typename S> void splice(int offset, int length, const S &replace) {
    splice_(0, offset, length, replace);
  }

private:
  template <typename S>
  MatchZtString<S>
  splice_(ZtString_ *removed, int offset, int length, const S &s) {
    if (this == &s) {
      ZtString_ s_ = s;
      splice__(removed, offset, length, s_.data_(), s_.length());
    } else
      splice__(removed, offset, length, s.data_(), s.length());
  }
  template <typename S>
  MatchAnyCString<S>
  splice_(ZtString_ *removed, int offset, int length, S &&s_) {
    ZuSpan<const Char> s(ZuFwd<S>(s_));
    splice__(removed, offset, length, s.data(), s.length());
  }
  template <typename S>
  MatchOtherString<S>
  splice_(ZtString_ *removed, int offset, int length, S &&s_) {
    ZuSpan<const Char> s(ZuFwd<S>(s_));
    splice__(removed, offset, length, s.data(), s.length());
  }
  template <typename C>
  MatchChar<C> splice_(ZtString_ *removed, int offset, int length, C c) {
    splice__(removed, offset, length, &c, 1);
  }
  template <typename S>
  MatchChar2String<S>
  splice_(ZtString_ *removed, int offset, int length, const S &s) {
    splice_(removed, offset, length, ZtString_(s));
  }
  template <typename C>
  MatchChar2<C> splice_(ZtString_ *removed, int offset, int length, C c) {
    splice_(removed, offset, length, ZtString_(c));
  }

public:
  void splice(
    ZtString_ &removed, int offset, int length, const Char *replace,
    unsigned rlength
  ) {
    splice__(&removed, offset, length, replace, rlength);
  }

  void splice(int offset, int length, const Char *replace, unsigned rlength) {
    splice__(0, offset, length, replace, rlength);
  }

  ZuSpan<const Char> splice(int offset) const {
    unsigned n = length();
    if (offset < 0) {
      if ((offset += n) < 0) offset = 0;
    } else {
      if (offset > static_cast<int>(n)) offset = n;
    }
    return ZuSpan<const Char>(data_() + offset, n - offset);
  }

  ZuSpan<const Char> splice(int offset, int length) const {
    unsigned n = this->length();
    if (offset < 0) {
      if ((offset += n) < 0) offset = 0;
    } else {
      if (offset > static_cast<int>(n)) offset = n;
    }
    if (length < 0) {
      if ((length += n - offset) < 0) length = 0;
    } else {
      if (offset + length > static_cast<int>(n)) length = n - offset;
    }
    return ZuSpan<const Char>(data_() + offset, length);
  }

private:
  void splice__(
    ZtString_ *removed, int offset, int length, const Char *replace,
    unsigned rlength
  ) {
    unsigned n = this->length();
    unsigned z = size_();
    if (offset < 0) {
      if ((offset += n) < 0) offset = 0;
    }
    if (length < 0) {
      if ((length += (n - offset)) < 0) length = 0;
    }

    if (offset > static_cast<int>(n)) {
      if (removed) removed->clear();
      Char *data;
      if (!owned() || offset + rlength >= static_cast<int>(z)) {
	z = grow_(z, offset + rlength + 1);
	data = size(z);
      } else
	data = data_();
      Zu::strpad(data + n, offset - n);
      if (rlength) memcpy(data + offset, replace, rlength * sizeof(Char));
      length_(offset + rlength);
      return;
    }

    if (length == 0x7fffffff

	|| offset + length > static_cast<int>(n))
      length = n - offset;

    int l = n + rlength - length;

    if (l > 0 && (!owned() || l >= static_cast<int>(z))) {
      z = grow_(z, l + 1);
      Char *oldData = data_();
      if (removed) removed->init(oldData + offset, length);
      Char *newData;
      if (z <= BuiltinSize)
	newData = data__();
      else {
	newData = static_cast<Char *>(valloc(z * sizeof(Char)));
	if (!newData) throw std::bad_alloc{};
      }
      if (oldData != newData && offset)
	memcpy(newData, oldData, offset * sizeof(Char));
      if (rlength) memcpy(newData + offset, replace, rlength * sizeof(Char));
      if (offset + length < static_cast<int>(n) &&
	  (oldData != newData || static_cast<int>(rlength) != length))
	memmove(
	  newData + offset + rlength, oldData + offset + length,
	  (n - (offset + length)) * sizeof(Char)
	);
      if (oldData != newData && vallocd()) vfree(oldData);
      newData[l] = 0;
      if (z <= BuiltinSize) {
	size_owned_null(z, 1, 0);
	length_vallocd_builtin(l, 0, 1);
	return;
      }
      ptr__(newData);
      size_owned_null(z, 1, 0);
      length_vallocd_builtin(l, 1, 0);
      return;
    }

    Char *data = data_();
    if (removed) removed->init(data + offset, length);
    if (l > 0) {
      if (static_cast<int>(rlength) != length &&
	  offset + length < static_cast<int>(n))
	memmove(
	  data + offset + rlength, data + offset + length,
	  (n - (offset + length)) * sizeof(Char)
	);
      if (rlength) memcpy(data + offset, replace, rlength * sizeof(Char));
    }
    length_(l);
  }

private:
  auto matchS() {
    return
      [](int c) { return c == ' ' || c == '\t' || c == '\n' || c == '\r'; };
  }

public:
  template <typename Match> void chomp(Match match) {
    if (!owned()) truncate();
    int o = length();
    if (!o) return;
    Char *data = data_();
    while (--o >= 0 && match(data[o]));
    length_(o + 1);
  }
  void chomp() { return chomp(matchS()); }

  template <typename Match> void trim(Match match) {
    if (!owned()) truncate();
    unsigned n = length();
    unsigned o;
    Char *data = data_();
    for (o = 0; o < n && match(data[o]); o++);
    if (!o) return;
    if (!(n -= o)) {
      null();
      return;
    }
    memmove(data, data + o, n * sizeof(Char));
    length_(n);
  }
  void trim() { return trim(matchS()); }

  template <typename Match> void strip(Match match) {
    if (!owned()) truncate();
    int o = length();
    if (!o) return;
    Char *data = data_();
    while (--o >= 0 && match(data[o]));
    if (o < 0) {
      null();
      return;
    }
    length_(o + 1);
    unsigned n = o + 1;
    for (o = 0; o < static_cast<int>(n) && match(data[o]); o++);
    if (!o) {
      length_(n);
      return;
    }
    if (!(n -= o)) {
      null();
      return;
    }
    memmove(data, data + o, n * sizeof(Char));
    length_(n);
  }
  void strip() { return strip(matchS()); }

  ZtString_ &sprintf(const Char *format, ...) {
    va_list args;

    __builtin_va_start(

      args

      ,

      format

    );
    vsnprintf(format, args);

    __builtin_va_end(

      args

    );
    return *this;
  }
  ZtString_ &vsprintf(const Char *format, va_list args) {
    vsnprintf(format, args);
    return *this;
  }

  void grow(unsigned length) {
    unsigned o = owned() ? size_() : 0U;
    if (__builtin_expect(!!(length + 1 > o), 1)) size(grow_(o, length + 1));
    o = this->length();
    if (__builtin_expect(!!(length > o), 0)) length_(length);
  }

private:
  static unsigned grow_(unsigned o, unsigned n) {
    if (n <= BuiltinSize) return BuiltinSize;
    return ZmGrow(o * sizeof(Char), n * sizeof(Char)) / sizeof(Char);
  }

  unsigned vsnprintf_grow(unsigned z) {
    z = grow_(z, z + 256);
    size(z);
    return z;
  }

public:
  void vsnprintf(const Char *format, va_list args) {
    unsigned n = length();
    unsigned z = size_();

    if (!owned() || n + 2 >= z) z = vsnprintf_grow(z);

retry:
    Char *data = data_();

    int r = Zu::vsnprintf(data + n, z - n, format, args);

    if (r < 0 || (n += r) == z || n == z - 1) {
      if (z >= (1U << 20)) goto truncate;
      z = vsnprintf_grow(z);
      n = length();
      goto retry;
    }

    if (n > z) {
      if (z >= (1U << 20)) goto truncate;
      size(z = grow_(z, n + 2));
      n = length();
      goto retry;
    }

    length_(n);
    return;

truncate:
    length_(z - 1);
  }

public:
  struct Traits : public ZuBaseTraits<ZtString_> {
    using Elem = Char;
    enum {
      IsCString = 1,
      IsString = 1,
      IsWString = bool{ZuEquiv<wchar_t, Char>{}}
    };
    static Char *data(ZtString_ &s) { return s.data(); }
    static const Char *data(const ZtString_ &s) { return s.data(); }
    static unsigned length(const ZtString_ &s) { return s.length(); }
  };
  friend Traits ZuTraitsType(ZtString_ *);

private:
  uint8_t m_data[BuiltinSize * sizeof(Char)];
  uint32_t m_size_owned_null;
  uint32_t m_length_vallocd_builtin;
}

__attribute__((aligned(alignof(void *))));

template <typename Char, auto HeapID>
template <typename S>
inline void ZtString_<Char, HeapID>::convert_(const S &s, ZtIconv *iconv) {
  null_();
  iconv->convert(*this, s);
}

using ZtString = ZtString_<char, ZtString_ID>;
template <auto HeapID> using ZtVString = ZtString_<char, HeapID>;
using ZtWString = ZtString_<wchar_t, ZtString_ID>;
template <auto HeapID> using ZtVWString = ZtString_<wchar_t, HeapID>;

ZtString ZtSprintf(const char *, ...) __attribute__((format(printf, 1, 2)));

inline ZtString ZtSprintf(const char *format, ...) {
  va_list args;

  __builtin_va_start(

    args

    ,

    format

  );
  ZtString s;
  s.vsprintf(format, args);

  __builtin_va_end(

    args

  );
  return s;
}
inline ZtWString ZtWSprintf(const wchar_t *format, ...) {
  va_list args;

  __builtin_va_start(

    args

    ,

    format

  );
  ZtWString s;
  s.vsprintf(format, args);

  __builtin_va_end(

    args

  );
  return s;
}

struct ZtBadBool { };

template <bool Validate = false> inline bool ZtScanBool(ZuCSpan s) {
  using Cmp = ZuICmp<ZuCSpan>;
  if (s == "1" || Cmp::equals(s, "y") || Cmp::equals(s, "yes") ||
      Cmp::equals(s, "true"))
    return true;
  if constexpr (Validate) {
    if (s == "0" || Cmp::equals(s, "n") || Cmp::equals(s, "no") ||
	Cmp::equals(s, "false"))
      return false;
    throw ZtBadBool{};
  } else
    return false;
}

using ZuFixedVal = ZuBox<
  int64_t,
  ZuBoxCmp<ZuBox_CmpN<(int64_t(-0x8000000000000000LL))>::template Cmp>>;
using ZuFixedNDP = ZuBox<uint8_t, ZuBoxCmp<ZuCmp0>>;

template <typename Fmt> struct ZuFixed_Fmt;
struct ZuFixed_VFmt;

struct ZuFixed {
  int64_t mantissa;
  uint8_t ndp;

  constexpr ZuFixed() : mantissa{(int64_t(-0x8000000000000000LL))}, ndp{0} { }

  template <typename M, decltype(ZuMatchIntegral<M>(), int()) = 0>
  constexpr ZuFixed(M mantissa_, unsigned ndp_) :
    mantissa{int64_t(mantissa_)}, ndp{uint8_t(ndp_)} { }

  template <typename V, decltype(ZuMatchFloatingPoint<V>(), int()) = 0>
  constexpr ZuFixed(V v, unsigned ndp_) :
    mantissa{int64_t(double(v) * ZuDecimalFn::pow10_64(ndp_))},
    ndp{uint8_t(ndp_)} { }

  constexpr ZuFixed(const ZuDecimal &v) {
    unsigned ndp_ = v.ndp();
    mantissa = v.value / ZuDecimalFn::pow10_128(18 - ndp_);
    ndp = ndp_;
  }
  constexpr ZuFixed(const ZuDecimal &v, unsigned ndp_) {
    mantissa = v.value / ZuDecimalFn::pow10_128(18 - ndp_);
    ndp = ndp_;
  }

  void init(int64_t mantissa_, unsigned ndp_) {
    mantissa = mantissa_;
    ndp = ndp_;
  }

  void null() {
    mantissa = (int64_t(-0x8000000000000000LL));
    ndp = 0;
  }

  double fp() const {
    if (__builtin_expect(!!(!operator*()), 0)) return ZuFP<double>::nan();
    return double(mantissa) / double(ZuDecimalFn::pow10_64(ndp));
  }

  ZuDecimal decimal() const {
    return ZuDecimal::Unscaled{
      int128_t(mantissa) * ZuDecimalFn::pow10_64(18 - ndp)
    };
  }

  ZuFixedVal adjust(unsigned ndp_) const {
    if (__builtin_expect(!!(!operator*()), 0)) return {};
    if (__builtin_expect(!!(ndp_ == ndp), 1)) return mantissa;
    if (ndp_ > ndp)
      return int128_t(mantissa) * ZuDecimalFn::pow10_64(ndp_ - ndp);
    return mantissa / ZuDecimalFn::pow10_64(ndp - ndp_);
  }

  bool equals(const ZuFixed &v) const {
    if (__builtin_expect(!!(ndp == v.ndp || !**this || !*v), 1))
      return mantissa == v.mantissa;
    return decimal() == v.decimal();
  }
  int cmp(const ZuFixed &v) const {
    if (__builtin_expect(!!(ndp == v.ndp || !**this || !*v), 1))
      return (mantissa > v.mantissa) - (mantissa < v.mantissa);
    return decimal().cmp(v.decimal());
  }
  template <typename L, typename R>
  friend inline ZuIfT<ZuInspect<ZuFixed, L>::Is, bool>
  operator==(const L &l, const R &r) {
    return l.equals(r);
  }
  template <typename L, typename R>
  friend inline ZuIfT<ZuInspect<ZuFixed, L>::Is, bool>
  operator<(const L &l, const R &r) {
    return l.cmp(r) < 0;
  }
  template <typename L, typename R>
  friend inline ZuIfT<ZuInspect<ZuFixed, L>::Is, int>
  operator<=>(const L &l, const R &r) {
    return l.cmp(r);
  }

  bool operator!() const { return !mantissa; }
  operator const void *() const {
    return !*this ? reinterpret_cast<const void *>(0) :
		    static_cast<const void *>(this);
  }

  constexpr bool operator*() const {
    return mantissa != (int64_t(-0x8000000000000000LL));
  }

  uint32_t hash() const {
    return ZuHash<int64_t>::hash(mantissa) ^ ZuHash<uint8_t>::hash(ndp);
  }

  template <typename S, decltype(ZuMatchString<S>(), int()) = 0>
  ZuFixed(const S &s) {
    scan(s);
  }
  template <typename S, decltype(ZuMatchString<S>(), int()) = 0>
  ZuFixed(const S &s, unsigned ndp_) {
    scan(s, ndp_);
  }

  template <bool NDP = true> unsigned scan(ZuCSpan s, unsigned ndp_) {
    unsigned int m = 0;
    if (__builtin_expect(!!(!s), 0)) goto null;
    if (__builtin_expect(
	  !!(s.length() == 3 && s[0] == 'n' && s[1] == 'a' && s[2] == 'n'), 0
	)) {
      null();
      return 3;
    }
    if constexpr (NDP)
      if (ndp_ > 18) ndp_ = 18;
    {
      bool negative = s[0] == '-';
      if (__builtin_expect(!!(negative), 0)) {
	s.offset(1), ++m;
	if (__builtin_expect(!!(!s), 0)) goto null;
      }
      while (s[0] == '0') {
	s.offset(1), ++m;
	if (!s) goto zero;
      }
      uint64_t iv = 0, fv = 0;
      unsigned n = s.length();
      if (__builtin_expect(!!(s[0] == '.'), 0)) {
	++m;
	if (__builtin_expect(!!(n == 1), 0)) goto zero;
	if constexpr (!NDP) ndp_ = n - 1;
	goto frac;
      }
      n = Zu_atou(iv, s.data(), n);
      if (__builtin_expect(!!(!n), 0)) goto null;
      if (__builtin_expect(!!(n > (18 - ndp_)), 0)) goto null;
      s.offset(n), m += n;
      if constexpr (!NDP) ndp_ = 18 - n;
      if ((n = s.length()) > 1 && s[0] == '.') {
	++m;
frac:
	if (--n > ndp_) n = ndp_;
	n = Zu_atou(fv, &s[1], n);
	m += n;
	if (fv && n < ndp_) fv *= ZuDecimalFn::pow10_64(ndp_ - n);
      }
      int64_t v = iv * ZuDecimalFn::pow10_64(ndp_) + fv;
      if (__builtin_expect(!!(negative), 0)) v = -v;
      init(v, ndp_);
    }
    return m;
zero:
    init(0, ndp_);
    return m;
null:
    null();
    return 0;
  }
  unsigned scan(ZuCSpan s) { return scan<false>(s, 0); }

public:
  struct Traits : public ZuBaseTraits<ZuFixed> {
    enum { IsReal = 1, IsSigned = 1 };
  };
  friend Traits ZuTraitsType(ZuFixed *);

  template <typename S> void print(S &s) const;
  friend ZuPrintFn ZuPrintType(ZuFixed *);

  template <typename Fmt> ZuFixed_Fmt<Fmt> fmt() const;
  template <bool Upper = false, typename Fmt = ZuFmt::Default>
  ZuFixed_Fmt<ZuFmt::Hex<Upper, Fmt>> hex() const;
  template <
    int NDP = -ZuFmt::Default::NDP_, char Trim = '\0',
    typename Fmt = ZuFmt::Default>
  ZuFixed_Fmt<ZuFmt::FP<NDP, Trim, Fmt>> fp() const;

  ZuFixed_VFmt vfmt() const;
  template <typename VFmt> ZuFixed_VFmt vfmt(VFmt &&) const;
};

template <typename Fmt> struct ZuFixed_Fmt {
  const ZuFixed &value;

  template <typename S> void print(S &s) const {
    if (__builtin_expect(!!(!*value), 0)) {
      s << "nan";
      return;
    }
    auto iv = value.mantissa;
    if (__builtin_expect(!!(iv < 0), 0)) {
      s << '-';
      iv = -iv;
    }
    uint64_t factor = ZuDecimalFn::pow10_64(value.ndp);
    ZuFixedVal fv = iv % factor;
    iv /= factor;
    s << ZuBoxed(iv).template fmt<Fmt>();
    auto ndp_ = value.ndp;
    if (fv) s << '.' << ZuBoxed(fv).vfmt().frac(ndp_, ndp_);
  }
  friend ZuPrintFn ZuPrintType(ZuFixed_Fmt *);
};
template <class Fmt> inline ZuFixed_Fmt<Fmt> ZuFixed::fmt() const {
  return ZuFixed_Fmt<Fmt>{*this};
}
template <bool Upper, typename Fmt>
inline ZuFixed_Fmt<ZuFmt::Hex<Upper, Fmt>> ZuFixed::hex() const {
  return ZuFixed_Fmt<ZuFmt::Hex<Upper, Fmt>>{*this};
}
template <int NDP, char Trim, typename Fmt>
inline ZuFixed_Fmt<ZuFmt::FP<NDP, Trim, Fmt>> ZuFixed::fp() const {
  return ZuFixed_Fmt<ZuFmt::FP<NDP, Trim, Fmt>>{*this};
}
template <typename S> inline void ZuFixed::print(S &s) const {
  s << ZuFixed_Fmt<ZuFmt::Default>{*this};
}
struct ZuFixed_VFmt : public ZuVFmtWrapper<ZuFixed_VFmt> {
  const ZuFixed &value;

  ZuFixed_VFmt(const ZuFixed &value_) : value{value_} { }
  template <typename VFmt>
  ZuFixed_VFmt(const ZuFixed &value_, VFmt &&fmt) :
    ZuVFmtWrapper<ZuFixed_VFmt>{ZuFwd<VFmt>(fmt)}, value{value_} { }

  template <typename S> void print(S &s) const {
    if (__builtin_expect(!!(!*value), 0)) {
      s << "nan";
      return;
    }
    ZuFixedVal iv = value.mantissa;
    if (__builtin_expect(!!(iv < 0), 0)) {
      s << '-';
      iv = -iv;
    }
    uint64_t factor = ZuDecimalFn::pow10_64(value.ndp);
    ZuFixedVal fv = iv % factor;
    iv /= factor;
    s << ZuBoxed(iv).vfmt(this->fmt);
    auto ndp_ = value.ndp;
    if (fv) s << '.' << ZuBoxed(fv).vfmt().frac(ndp_, ndp_);
  }
  friend ZuPrintFn ZuPrintType(ZuFixed_VFmt *);
};
inline ZuFixed_VFmt ZuFixed::vfmt() const { return ZuFixed_VFmt{*this}; }
template <typename VFmt> inline ZuFixed_VFmt ZuFixed::vfmt(VFmt &&fmt) const {
  return ZuFixed_VFmt{*this, ZuFwd<VFmt>(fmt)};
}

template <> struct ZuCmp<ZuFixed> {
  template <typename L, typename R>
  static constexpr int cmp(const L &l, const R &r) {
    return l.cmp(r);
  }
  template <typename L, typename R>
  static constexpr bool equals(const L &l, const R &r) {
    return l == r;
  }
  template <typename L, typename R>
  static constexpr bool less(const L &l, const R &r) {
    return l < r;
  }
  static constexpr bool null(const ZuFixed &v) { return !*v; }
  static constexpr ZuFixed null() { return {}; }
  static constexpr ZuFixed minimum() {
    return {(int64_t(-999999999999999999LL)), 0};
  }
  static constexpr ZuFixed maximum() {
    return {(int64_t(999999999999999999LL)), 0};
  }
};

class ZuDateTime;

namespace ZuDateTimeScan {
struct CSV {
  int tzOffset = 0;
};
struct FIX { };
struct ISO {
  int tzOffset = 0;
};

using Any_ = ZuUnion<CSV, FIX, ISO>;
class Any : public Any_ {
  using Union = Any_;

public:
  using Union::Union;
  using Union::operator=;
  Any(const Union &v) : Union(v) {};
  Any(Union &&v) : Union(ZuMv(v)) {};
  auto is_csv() const { return this->type() == 0; }
  const auto &csv() const & { return this->template p<0>(); }
  auto &csv() & { return this->template p<0>(); }
  auto &&csv() && { return ZuMv(this->template p<0>()); }
  template <typename P> auto &csv(P &&v) {
    this->template p<0>(ZuFwd<P>(v));
    return *this;
  }
  auto ptr_csv() { return this->template ptr<0>(); }
  auto new_csv() { return this->template new_<0>(); }
  auto is_fix() const { return this->type() == (0 + 1); }
  const auto &fix() const & { return this->template p<(0 + 1)>(); }
  auto &fix() & { return this->template p<(0 + 1)>(); }
  auto &&fix() && { return ZuMv(this->template p<(0 + 1)>()); }
  template <typename P> auto &fix(P &&v) {
    this->template p<(0 + 1)>(ZuFwd<P>(v));
    return *this;
  }
  auto ptr_fix() { return this->template ptr<(0 + 1)>(); }
  auto new_fix() { return this->template new_<(0 + 1)>(); }
  auto is_iso() const { return this->type() == ((0 + 1) + 1); }
  const auto &iso() const & { return this->template p<((0 + 1) + 1)>(); }
  auto &iso() & { return this->template p<((0 + 1) + 1)>(); }
  auto &&iso() && { return ZuMv(this->template p<((0 + 1) + 1)>()); }
  template <typename P> auto &iso(P &&v) {
    this->template p<((0 + 1) + 1)>(ZuFwd<P>(v));
    return *this;
  }
  auto ptr_iso() { return this->template ptr<((0 + 1) + 1)>(); }
  auto new_iso() { return this->template new_<((0 + 1) + 1)>(); }
  struct Traits : public ZuTraits<Any_> {
    using T = Any;
  };
  friend Traits ZuTraitsType(Any *);
};
} // namespace ZuDateTimeScan

namespace ZuDateTimeFmt {

class CSV {
  friend ::ZuDateTime;

public:
  CSV(const CSV &) = default;
  CSV &operator=(const CSV &) = default;
  CSV(CSV &&) = default;
  CSV &operator=(CSV &&) = default;

  CSV(int tzOffset = 0) : m_tzOffset{tzOffset} { reset(); }

  void tzOffset(int o) {
    if (m_tzOffset != o) {
      m_tzOffset = o;
      reset();
    }
  }
  int tzOffset() const { return m_tzOffset; }

  void pad(char c) { m_pad = c; }
  char pad() const { return m_pad; }

private:
  void reset() {
    m_julian = 0;
    m_sec = 0;
    memcpy(m_yyyymmdd, "0001/01/01", 10);
    memcpy(m_hhmmss, "00:00:00", 8);
  }

  int m_tzOffset;
  char m_pad = 0;

  mutable int m_julian;
  mutable int m_sec;
  mutable char m_yyyymmdd[10];
  mutable char m_hhmmss[8];
};

template <unsigned NDP, char Trim> struct FIX_ {
  template <typename S> static void frac_print(S &s, unsigned nsec) {
    s << '.' << ZuBoxed(nsec).fmt<ZuFmt::Frac<9, NDP, Trim>>();
  }
};
template <unsigned NDP> struct FIX_<NDP, '\0'> {
  template <typename S> static void frac_print(S &s, unsigned nsec) {
    if (__builtin_expect(!!(nsec), 1))
      s << '.' << ZuBoxed(nsec).fmt<ZuFmt::Frac<9, NDP, '\0'>>();
  }
};
template <char Trim> struct FIX_<0, Trim> {
  template <typename S> static void frac_print(S &, unsigned) { }
};
template <int NDP_, class Null_ = ZuPrintNull>
class FIX : public FIX_<(NDP_ < 0 ? -NDP_ : NDP_), (NDP_ < 0 ? '\0' : '0')> {
  friend ::ZuDateTime;

public:
  enum { NDP = NDP_ };
  using Null = Null_;

  static_assert((NDP >= -9 && NDP <= 9), "NDP >= -9 && NDP <= 9");

  FIX() {
    memcpy(m_yyyymmdd, "00010101", 8);
    memcpy(m_hhmmss, "00:00:00", 8);
  }

  FIX(const FIX &) = default;
  FIX &operator=(const FIX &) = default;
  FIX(FIX &&) = default;
  FIX &operator=(FIX &&) = default;

private:
  mutable int m_julian = 0;
  mutable int m_sec = 0;
  mutable char m_yyyymmdd[8];
  mutable char m_hhmmss[8];
};

class ISO {
  friend ::ZuDateTime;

public:
  ISO(int tzOffset = 0) : m_tzOffset{tzOffset} { reset(); }

  ISO(const ISO &) = default;
  ISO &operator=(const ISO &) = default;
  ISO(ISO &&) = default;
  ISO &operator=(ISO &&) = default;

  void tzOffset(int o) {
    if (m_tzOffset != o) {
      m_tzOffset = o;
      reset();
    }
  }
  int tzOffset() const { return m_tzOffset; }

private:
  void reset() {
    m_julian = 0;
    m_sec = 0;
    memcpy(m_yyyymmdd, "0001-01-01", 10);
    memcpy(m_hhmmss, "00:00:00", 8);
  }

  int m_tzOffset = 0;

  mutable int m_julian;
  mutable int m_sec;
  mutable char m_yyyymmdd[10];
  mutable char m_hhmmss[8];
};

struct Strftime {
  const char *format;
  int tzOffset;
};

struct FIXDeflt_Null : public ZuPrintable {
  template <typename S> void print(S &) const { }
};
using FIXDeflt = FIX<-9, FIXDeflt_Null>;
using Any_ = ZuUnion<CSV, FIXDeflt, ISO, Strftime>;
class Any : public Any_ {
  using Union = Any_;

public:
  using Union::Union;
  using Union::operator=;
  Any(const Union &v) : Union(v) {};
  Any(Union &&v) : Union(ZuMv(v)) {};
  auto is_csv() const { return this->type() == 0; }
  const auto &csv() const & { return this->template p<0>(); }
  auto &csv() & { return this->template p<0>(); }
  auto &&csv() && { return ZuMv(this->template p<0>()); }
  template <typename P> auto &csv(P &&v) {
    this->template p<0>(ZuFwd<P>(v));
    return *this;
  }
  auto ptr_csv() { return this->template ptr<0>(); }
  auto new_csv() { return this->template new_<0>(); }
  auto is_fix() const { return this->type() == (0 + 1); }
  const auto &fix() const & { return this->template p<(0 + 1)>(); }
  auto &fix() & { return this->template p<(0 + 1)>(); }
  auto &&fix() && { return ZuMv(this->template p<(0 + 1)>()); }
  template <typename P> auto &fix(P &&v) {
    this->template p<(0 + 1)>(ZuFwd<P>(v));
    return *this;
  }
  auto ptr_fix() { return this->template ptr<(0 + 1)>(); }
  auto new_fix() { return this->template new_<(0 + 1)>(); }
  auto is_iso() const { return this->type() == ((0 + 1) + 1); }
  const auto &iso() const & { return this->template p<((0 + 1) + 1)>(); }
  auto &iso() & { return this->template p<((0 + 1) + 1)>(); }
  auto &&iso() && { return ZuMv(this->template p<((0 + 1) + 1)>()); }
  template <typename P> auto &iso(P &&v) {
    this->template p<((0 + 1) + 1)>(ZuFwd<P>(v));
    return *this;
  }
  auto ptr_iso() { return this->template ptr<((0 + 1) + 1)>(); }
  auto new_iso() { return this->template new_<((0 + 1) + 1)>(); }
  auto is_strftime() const { return this->type() == (((0 + 1) + 1) + 1); }
  const auto &strftime() const & {
    return this->template p<(((0 + 1) + 1) + 1)>();
  }
  auto &strftime() & { return this->template p<(((0 + 1) + 1) + 1)>(); }
  auto &&strftime() && { return ZuMv(this->template p<(((0 + 1) + 1) + 1)>()); }
  template <typename P> auto &strftime(P &&v) {
    this->template p<(((0 + 1) + 1) + 1)>(ZuFwd<P>(v));
    return *this;
  }
  auto ptr_strftime() { return this->template ptr<(((0 + 1) + 1) + 1)>(); }
  auto new_strftime() { return this->template new_<(((0 + 1) + 1) + 1)>(); }
  struct Traits : public ZuTraits<Any_> {
    using T = Any;
  };
  friend Traits ZuTraitsType(Any *);
};

} // namespace ZuDateTimeFmt

struct ZuDateTimePrintCSV {
  const ZuDateTime &value;
  const ZuDateTimeFmt::CSV &fmt;

  template <typename S> void print(S &) const;
  friend ZuPrintFn ZuPrintType(ZuDateTimePrintCSV *);
};
template <int NDP = -9, class Null = ZuDateTimeFmt::FIXDeflt_Null>
struct ZuDateTimePrintFIX {
  const ZuDateTime &value;
  const ZuDateTimeFmt::FIX<NDP, Null> &fmt;

  template <typename S> void print(S &) const;
  friend ZuPrintFn ZuPrintType(ZuDateTimePrintFIX *);
};
struct ZuDateTimePrintISO {
  const ZuDateTime &value;
  const ZuDateTimeFmt::ISO &fmt;

  template <typename S> void print(S &) const;
  friend ZuPrintFn ZuPrintType(ZuDateTimePrintISO *);
};
struct ZuDateTimePrintStrftime {
  const ZuDateTime &value;
  ZuDateTimeFmt::Strftime fmt;

  template <typename Boxed>
  static auto vfmt(ZuVFmt &fmt, const Boxed &boxed, unsigned width, bool alt) {
    if (alt)
      fmt.reset();
    else
      fmt.right(width);
    return boxed.vfmt(fmt);
  }
  template <typename Boxed>
  static auto vfmt(
    ZuVFmt &fmt, const Boxed &boxed, ZuBox<unsigned> width, int deflt, bool alt
  ) {
    if (alt)
      fmt.reset();
    else {
      if (!*width) width = deflt;
      fmt.right(width);
    }
    return boxed.vfmt(fmt);
  }
  template <typename Boxed>
  static auto vfmt(
    ZuVFmt &fmt, const Boxed &boxed, ZuBox<unsigned> width, int deflt, bool alt,
    char pad
  ) {
    if (alt)
      fmt.reset();
    else {
      if (!*width) width = deflt;
      fmt.right(width, pad);
    }
    return boxed.vfmt(fmt);
  }

  template <typename S> void print(S &) const;
  friend ZuPrintFn ZuPrintType(ZuDateTimePrintStrftime *);
};

struct ZuDateTimePrint {
  const ZuDateTime &value;
  const ZuDateTimeFmt::Any &fmt;

  template <typename S> void print(S &) const;
  friend ZuPrintFn ZuPrintType(ZuDateTimePrint *);
};

class ZuDateTime {
public:
  struct Julian {
    int32_t v;
  };

  ZuDateTime() = default;

  ZuDateTime(const ZuDateTime &date) :
    m_julian{date.m_julian}, m_sec{date.m_sec}, m_nsec{date.m_nsec} { }

  ZuDateTime &operator=(const ZuDateTime &date) {
    if (__builtin_expect(!!(this == &date), 0)) return *this;
    m_julian = date.m_julian;
    m_sec = date.m_sec;
    m_nsec = date.m_nsec;
    return *this;
  }

  void update(const ZuDateTime &date) {
    if (__builtin_expect(!!(this == &date), 0) || !date) return;
    m_julian = date.m_julian;
    m_sec = date.m_sec;
    m_nsec = date.m_nsec;
  }

  template <typename T, decltype(ZuExact<ZuTime, T>(), int()) = 0>
  ZuDateTime(const T &t) {
    init(t.sec()), m_nsec = t.nsec();
  }
  template <typename T> ZuExact<ZuTime, T, ZuDateTime &> operator=(const T &t) {
    init(t.sec());
    m_nsec = t.nsec();
    return *this;
  }

  template <typename T, typename U = ZuStrip<T>>
  struct IsInt :
    public ZuBool<
      ZuIsExact<int32_t, U>{} || ZuIsExact<uint32_t, U>{} ||
      ZuIsExact<int64_t, U>{} || ZuIsExact<uint64_t, U>{} ||
      ZuIsExact<time_t, U>{}> { };
  template <typename T, typename R = void>
  using MatchInt = ZuIfT<IsInt<T>{}, R>;

  template <typename T, typename = MatchInt<T>> ZuDateTime(T v) {
    init(v);
    m_nsec = 0;
  }
  template <typename T> MatchInt<T, ZuDateTime &> operator=(T v) {
    init(v);
    m_nsec = 0;
    return *this;
  }

  ZuDateTime(const struct tm *tm_) {
    int year = tm_->tm_year + 1900, month = tm_->tm_mon + 1, day = tm_->tm_mday;
    int hour = tm_->tm_hour, minute = tm_->tm_min, sec = tm_->tm_sec;
    int nsec = 0;
    normalize(year, month);
    normalize(day, hour, minute, sec, nsec);
    ctor(year, month, day, hour, minute, sec, nsec);
  }
  ZuDateTime &operator=(const struct tm *tm_) {
    new (this) ZuDateTime(tm_);
    return *this;
  }

  template <typename T, typename = MatchInt<T>> ZuDateTime(T v, int nsec) {
    init(v);
    m_nsec = nsec;
  }

  explicit ZuDateTime(Julian julian, int sec, int nsec) :
    m_julian(julian.v), m_sec(sec), m_nsec(nsec) { }

  ZuDateTime(int year, int month, int day) {
    normalize(year, month);
    ctor(year, month, day);
  }
  ZuDateTime(int year, int month, int day, int hour, int minute, int sec) {
    normalize(year, month);
    int nsec = 0;
    normalize(day, hour, minute, sec, nsec);
    ctor(year, month, day, hour, minute, sec, nsec);
  }
  ZuDateTime(
    int year, int month, int day, int hour, int minute, int sec, int nsec
  ) {
    ctor(year, month, day, hour, minute, sec, nsec);
  }

  ZuDateTime(struct tm *tm_) {
    int year = tm_->tm_year + 1900, month = tm_->tm_mon + 1, day = tm_->tm_mday;
    int hour = tm_->tm_hour, minute = tm_->tm_min, sec = tm_->tm_sec;
    int nsec = 0;

    normalize(year, month);
    normalize(day, hour, minute, sec, nsec);
  }

  template <typename S, decltype(ZuMatchString<S>(), int()) = 0>
  ZuDateTime(const ZuDateTimeScan::CSV &fmt, const S &s) {
    scan(fmt, s);
  }

  template <typename S, decltype(ZuMatchString<S>(), int()) = 0>
  ZuDateTime(const ZuDateTimeScan::FIX &fmt, const S &s) {
    scan(fmt, s);
  }

  template <typename S, decltype(ZuMatchString<S>(), int()) = 0>
  ZuDateTime(const ZuDateTimeScan::ISO &fmt, const S &s) {
    scan(fmt, s);
  }

  template <typename S, decltype(ZuMatchString<S>(), int()) = 0>
  ZuDateTime(const S &s) {
    scan(ZuDateTimeScan::ISO{}, s);
  }

  template <typename S, decltype(ZuMatchString<S>(), int()) = 0>
  ZuDateTime(const ZuDateTimeScan::Any &fmt, const S &s) {
    scan(fmt, s);
  }

  enum YYYYMMDD_ { YYYYMMDD };
  enum YYMMDD_ { YYMMDD };
  enum HHMMSSmmm_ { HHMMSSmmm };
  enum HHMMSS_ { HHMMSS };

  ZuDateTime(int year, int month, int day, HHMMSSmmm_, int time) {
    int hour, minute, sec, nsec;
    hour = time / 10000000;
    minute = (time / 100000) % 100;
    sec = (time / 1000) % 100;
    nsec = (time % 1000) * 1000000;
    normalize(year, month);
    normalize(day, hour, minute, sec, nsec);
    ctor(year, month, day, hour, minute, sec, nsec);
  }
  ZuDateTime(int year, int month, int day, HHMMSS_, int time) {
    int hour, minute, sec, nsec = 0;
    hour = time / 10000;
    minute = (time / 100) % 100;
    sec = time % 100;
    normalize(year, month);
    normalize(day, hour, minute, sec, nsec);
    ctor(year, month, day, hour, minute, sec, nsec);
  }
  ZuDateTime(YYYYMMDD_, int date, HHMMSSmmm_, int time) {
    int year, month, day, hour, minute, sec, nsec;
    year = date / 10000;
    month = (date / 100) % 100;
    day = date % 100;
    hour = time / 10000000;
    minute = (time / 100000) % 100;
    sec = (time / 1000) % 100;
    nsec = (time % 1000) * 1000000;
    normalize(year, month);
    normalize(day, hour, minute, sec, nsec);
    ctor(year, month, day, hour, minute, sec, nsec);
  }
  ZuDateTime(YYYYMMDD_, int date, HHMMSS_, int time) {
    int year, month, day, hour, minute, sec, nsec = 0;
    year = date / 10000;
    month = (date / 100) % 100;
    day = date % 100;
    hour = time / 10000;
    minute = (time / 100) % 100;
    sec = time % 100;
    normalize(year, month);
    normalize(day, hour, minute, sec, nsec);
    ctor(year, month, day, hour, minute, sec, nsec);
  }
  ZuDateTime(YYMMDD_, int date, HHMMSSmmm_, int time) {
    int year, month, day, hour, minute, sec, nsec;
    year = date / 10000;
    month = (date / 100) % 100;
    day = date % 100;
    hour = time / 10000000;
    minute = (time / 100000) % 100;
    sec = (time / 1000) % 100;
    nsec = (time % 1000) * 1000000;
    year += (year < 70) ? 2000 : 1900;
    normalize(year, month);
    normalize(day, hour, minute, sec, nsec);
    ctor(year, month, day, hour, minute, sec, nsec);
  }
  ZuDateTime(YYMMDD_, int date, HHMMSS_, int time) {
    int year, month, day, hour, minute, sec, nsec = 0;
    year = date / 10000;
    month = (date / 100) % 100;
    day = date % 100;
    hour = time / 10000;
    minute = (time / 100) % 100;
    sec = time % 100;
    year += (year < 70) ? 2000 : 1900;
    normalize(year, month);
    normalize(day, hour, minute, sec, nsec);
    ctor(year, month, day, hour, minute, sec, nsec);
  }

  int yyyymmdd() const {
    if (__builtin_expect(!!(!*this), 0)) return -1;
    int year, month, day;
    ymd(year, month, day);
    year *= 10000;
    if (year >= 0) return year + month * 100 + day;
    return year - month * 100 - day;
  }
  int yymmdd() const {
    if (__builtin_expect(!!(!*this), 0)) return -1;
    int year, month, day;
    ymd(year, month, day);
    year = (year % 100) * 10000;
    if (year >= 0) return year + month * 100 + day;
    return year - month * 100 - day;
  }
  int hhmmssmmm() const {
    if (__builtin_expect(!!(!*this), 0)) return -1;
    int hour, minute, sec, nsec;
    hmsn(hour, minute, sec, nsec);
    return hour * 10000000 + minute * 100000 + sec * 1000 + nsec / 1000000;
  }
  int hhmmss() const {
    if (__builtin_expect(!!(!*this), 0)) return -1;
    int hour, minute, sec;
    hms(hour, minute, sec);
    return hour * 10000 + minute * 100 + sec;
  }

  const int &julian() const { return m_julian; }
  int &julian() { return m_julian; }
  const int &sec() const { return m_sec; }
  int &sec() { return m_sec; }
  const int &nsec() const { return m_nsec; }
  int &nsec() { return m_nsec; }

  static void reformation(int year, int month, int day);

  constexpr int64_t as_time_t() const {
    int64_t v;
    if (__builtin_expect(
	  !!(
	    !*this || ZuIntrin::sub(int64_t(m_julian), 2440588, &v) ||
	    ZuIntrin::mul(v, 86400, &v) || ZuIntrin::add(v, m_sec, &v)
	  ),
	  0
	)

    )
      return ZuCmp<int64_t>::null();
    return v;
  }
  constexpr ZuTime as_time() const {
    if (__builtin_expect(!!(!*this), 0)) return {};
    return ZuTime{this->as_time_t(), m_nsec};
  }

  struct tm *tm(struct tm *tm) const;

  void ymd(int &year, int &month, int &day) const;
  void hms(int &hour, int &minute, int &sec) const;
  void hmsn(int &hour, int &minute, int &sec, int &nsec) const;

  int days(int year, int month, int day) const {
    return m_julian - julian(year, month, day);
  }

  void ywd(int days, int &week, int &wkDay) const;

  void ywdSun(int days, int &week, int &wkDay) const;

  void ywdISO(int year, int days, int &wkYear, int &week, int &wkDay) const;

  static ZuCSpan dayShortName(int i);
  static ZuCSpan dayLongName(int i);
  static ZuCSpan monthShortName(int i);
  static ZuCSpan monthLongName(int i);

  auto fmt(const ZuDateTimeFmt::CSV &fmt) const {
    return ZuDateTimePrintCSV{*this, fmt};
  }
  template <typename S_>
  void csv_print(S_ &s, const ZuDateTimeFmt::CSV &fmt) const {
    if (__builtin_expect(!!(!*this), 0)) return;
    ZuDateTime date = *this + fmt.m_tzOffset;
    if (__builtin_expect(!!(date.m_julian != fmt.m_julian), 0)) {
      fmt.m_julian = date.m_julian;
      int y, m, d;
      date.ymd(y, m, d);
      if (__builtin_expect(!!(y < -9998 || y > 9999), 0)) return;
      if (__builtin_expect(!!(y < 1), 0)) {
	s << '-';
	y = 1 - y;
      }
      fmt.m_yyyymmdd[0] = y / 1000 + '0';
      fmt.m_yyyymmdd[1] = (y / 100) % 10 + '0';
      fmt.m_yyyymmdd[2] = (y / 10) % 10 + '0';
      fmt.m_yyyymmdd[3] = y % 10 + '0';
      fmt.m_yyyymmdd[5] = m / 10 + '0';
      fmt.m_yyyymmdd[6] = m % 10 + '0';
      fmt.m_yyyymmdd[8] = d / 10 + '0';
      fmt.m_yyyymmdd[9] = d % 10 + '0';
    }
    s << ZuCSpan{fmt.m_yyyymmdd, 10} << ' ';
    if (__builtin_expect(!!(date.m_sec != fmt.m_sec), 0)) {
      fmt.m_sec = date.m_sec;
      int H, M, S;
      date.hms(H, M, S);
      fmt.m_hhmmss[0] = H / 10 + '0';
      fmt.m_hhmmss[1] = H % 10 + '0';
      fmt.m_hhmmss[3] = M / 10 + '0';
      fmt.m_hhmmss[4] = M % 10 + '0';
      fmt.m_hhmmss[6] = S / 10 + '0';
      fmt.m_hhmmss[7] = S % 10 + '0';
    }
    s << ZuCSpan{fmt.m_hhmmss, 8};
    if (unsigned N = date.m_nsec) {
      char buf[9];
      if (fmt.m_pad) {
	Zu_ntoa::Base10_print_frac(N, 9, 9, fmt.m_pad, buf);
	s << '.' << ZuCSpan{buf, 9};
      } else {
	N = Zu_ntoa::Base10_print_frac_truncate(N, 9, 9, buf);
	if (N > 1 || buf[0] != '0') s << '.' << ZuCSpan{buf, N};
      }
    }
  }

  template <int NDP, class Null>
  auto fmt(const ZuDateTimeFmt::FIX<NDP, Null> &fmt) const {
    return ZuDateTimePrintFIX<NDP, Null>{*this, fmt};
  }
  template <typename S_, int NDP, class Null>
  void fix_print(S_ &s, const ZuDateTimeFmt::FIX<NDP, Null> &fmt) const {
    if (__builtin_expect(!!(!*this), 0)) {
      s << Null{};
      return;
    }
    if (__builtin_expect(!!(m_julian != fmt.m_julian), 0)) {
      fmt.m_julian = m_julian;
      int y, m, d;
      ymd(y, m, d);
      if (__builtin_expect(!!(y < 1 || y > 9999), 0)) {
	s << Null{};
	return;
      }
      fmt.m_yyyymmdd[0] = y / 1000 + '0';
      fmt.m_yyyymmdd[1] = (y / 100) % 10 + '0';
      fmt.m_yyyymmdd[2] = (y / 10) % 10 + '0';
      fmt.m_yyyymmdd[3] = y % 10 + '0';
      fmt.m_yyyymmdd[4] = m / 10 + '0';
      fmt.m_yyyymmdd[5] = m % 10 + '0';
      fmt.m_yyyymmdd[6] = d / 10 + '0';
      fmt.m_yyyymmdd[7] = d % 10 + '0';
    }
    s << ZuCSpan{fmt.m_yyyymmdd, 8} << '-';
    if (__builtin_expect(!!(m_sec != fmt.m_sec), 0)) {
      fmt.m_sec = m_sec;
      int H, M, S;
      hms(H, M, S);
      fmt.m_hhmmss[0] = H / 10 + '0';
      fmt.m_hhmmss[1] = H % 10 + '0';
      fmt.m_hhmmss[3] = M / 10 + '0';
      fmt.m_hhmmss[4] = M % 10 + '0';
      fmt.m_hhmmss[6] = S / 10 + '0';
      fmt.m_hhmmss[7] = S % 10 + '0';
    }
    s << ZuCSpan{fmt.m_hhmmss, 8};
    fmt.frac_print(s, m_nsec);
  }

  auto fmt(const ZuDateTimeFmt::ISO &fmt) const {
    return ZuDateTimePrintISO{*this, fmt};
  }
  template <typename S_>
  void iso_print(S_ &s, const ZuDateTimeFmt::ISO &fmt) const {
    if (__builtin_expect(!!(!*this), 0)) return;
    ZuDateTime date = *this + fmt.m_tzOffset;
    if (__builtin_expect(!!(date.m_julian != fmt.m_julian), 0)) {
      fmt.m_julian = date.m_julian;
      int y, m, d;
      date.ymd(y, m, d);
      if (__builtin_expect(!!(y < -9998 || y > 9999), 0)) return;
      if (__builtin_expect(!!(y < 1), 0)) {
	s << '-';
	y = 1 - y;
      }
      fmt.m_yyyymmdd[0] = y / 1000 + '0';
      fmt.m_yyyymmdd[1] = (y / 100) % 10 + '0';
      fmt.m_yyyymmdd[2] = (y / 10) % 10 + '0';
      fmt.m_yyyymmdd[3] = y % 10 + '0';
      fmt.m_yyyymmdd[5] = m / 10 + '0';
      fmt.m_yyyymmdd[6] = m % 10 + '0';
      fmt.m_yyyymmdd[8] = d / 10 + '0';
      fmt.m_yyyymmdd[9] = d % 10 + '0';
    }
    s << ZuCSpan{fmt.m_yyyymmdd, 10} << 'T';
    if (__builtin_expect(!!(date.m_sec != fmt.m_sec), 0)) {
      fmt.m_sec = date.m_sec;
      int H, M, S;
      date.hms(H, M, S);
      fmt.m_hhmmss[0] = H / 10 + '0';
      fmt.m_hhmmss[1] = H % 10 + '0';
      fmt.m_hhmmss[3] = M / 10 + '0';
      fmt.m_hhmmss[4] = M % 10 + '0';
      fmt.m_hhmmss[6] = S / 10 + '0';
      fmt.m_hhmmss[7] = S % 10 + '0';
    }
    s << ZuCSpan{fmt.m_hhmmss, 8};
    if (unsigned N = date.m_nsec) {
      char buf[9];
      N = Zu_ntoa::Base10_print_frac_truncate(N, 9, 9, buf);
      if (N > 1 || buf[0] != '0') s << '.' << ZuCSpan{buf, N};
    }
    if (fmt.m_tzOffset) {
      int offset_ = (fmt.m_tzOffset < 0) ? -fmt.m_tzOffset : fmt.m_tzOffset;
      int oH = offset_ / 3600, oM = (offset_ % 3600) / 60;
      char buf[5];
      buf[0] = oH / 10 + '0';
      buf[1] = oH % 10 + '0';
      buf[2] = ':';
      buf[3] = oM / 10 + '0';
      buf[4] = oM % 10 + '0';
      s << ((fmt.m_tzOffset < 0) ? '-' : '+') << ZuCSpan{buf, 5};
    } else
      s << 'Z';
  }

  auto strftime(const char *format, int tzOffset = 0) const {
    return ZuDateTimePrintStrftime{
      *this, ZuDateTimeFmt::Strftime{format, tzOffset}
    };
  }

  auto fmt(const ZuDateTimeFmt::Any &fmt) const {
    return ZuDateTimePrint{*this, fmt};
  }

  void null() {
    m_julian = ZuCmp<int32_t>::null();
    m_sec = 0;
  }

  ZuTime operator-(const ZuDateTime &date) const {
    int64_t day = int64_t(m_julian) - date.m_julian;
    int64_t sec = int64_t(m_sec) - date.m_sec;
    int64_t nsec = int64_t(m_nsec) - date.m_nsec;

    if (nsec < 0) nsec += 1000000000, --sec;
    if (sec < 0) sec += 86400, --day;

    if (__builtin_expect(
	  !!(ZuIntrin::mul(day, 86400, &day) || ZuIntrin::add(day, sec, &sec)),
	  0
	))
      return {};

    return ZuTime{sec, int32_t(nsec)};
  }

  template <typename T>
  ZuExact<ZuTime, T, ZuDateTime> operator+(const T &t) const {
    int64_t julian, sec, nsec;

    sec = m_sec;
    nsec = int64_t(m_nsec) + t.nsec();
    if (nsec < 0)
      nsec += 1000000000, --sec;
    else if (nsec >= 1000000000)
      nsec -= 1000000000, ++sec;

    {
      int64_t sec_ = t.sec();

      if (sec_ < 0) {
	sec_ = -sec_;
	julian = int64_t(m_julian) - sec_ / 86400;
	sec -= sec_ % 86400;

	if (sec < 0) sec += 86400, --julian;
      } else {
	julian = int64_t(m_julian) + sec_ / 86400;
	sec += sec_ % 86400;

	if (sec >= 86400) sec -= 86400, ++julian;
      }
    }

    if (julian != int32_t(julian)) return {};

    return ZuDateTime{Julian{int32_t(julian)}, int32_t(sec), int32_t(nsec)};
  }
  template <typename T> MatchInt<T, ZuDateTime> operator+(T sec_) const {
    int64_t julian, sec = sec_;

    if (sec < 0) {
      sec = -sec;
      if (__builtin_expect(!!(sec < 86400), 1))
	julian = m_julian, sec = int64_t(m_sec) - sec;
      else
	julian = int64_t(m_julian) - sec / 86400,
	sec = int64_t(m_sec) - sec % 86400;

      if (sec < 0) sec += 86400, --julian;
    } else {
      if (__builtin_expect(!!(sec < 86400), 1))
	julian = m_julian, sec = int64_t(m_sec) + sec;
      else
	julian = int64_t(m_julian) + sec / 86400,
	sec = int64_t(m_sec) + sec % 86400;

      if (sec >= 86400) sec -= 86400, ++julian;
    }

    if (julian != int32_t(julian)) return {};

    return ZuDateTime{Julian{int32_t(julian)}, int32_t(sec), m_nsec};
  }

  template <typename T>
  ZuExact<ZuTime, T, ZuDateTime &> operator+=(const T &t) {
    int64_t julian, sec, nsec;

    sec = m_sec;
    nsec = int64_t(m_nsec) + t.nsec();
    if (nsec < 0)
      nsec += 1000000000, --sec;
    else if (nsec >= 1000000000)
      nsec -= 1000000000, ++sec;

    {
      int64_t sec_ = t.sec();

      if (sec_ < 0) {
	sec_ = -sec_;
	julian = int64_t(m_julian) - sec_ / 86400;
	sec -= sec_ % 86400;

	if (sec < 0) sec += 86400, --julian;
      } else {
	julian = int64_t(m_julian) + sec_ / 86400;
	sec += sec_ % 86400;

	if (sec >= 86400) sec -= 86400, ++julian;
      }
    }

    if (julian != int32_t(julian)) {
      null();
      return *this;
    }

    m_julian = julian;
    m_sec = sec;
    m_nsec = nsec;

    return *this;
  }
  template <typename T> MatchInt<T, ZuDateTime &> operator+=(T sec_) {
    int64_t julian, sec = sec_;

    if (sec < 0) {
      sec = -sec;
      if (__builtin_expect(!!(sec < 86400), 1))
	julian = int64_t(m_julian), sec = int64_t(m_sec) - sec;
      else
	julian = int64_t(m_julian) - sec / 86400,
	sec = int64_t(m_sec) - sec % 86400;

      if (sec < 0) sec += 86400, --julian;
    } else {
      if (__builtin_expect(!!(sec < 86400), 1))
	julian = int64_t(m_julian), sec = int64_t(m_sec) + sec;
      else
	julian = int64_t(m_julian) + sec / 86400,
	sec = int64_t(m_sec) + sec % 86400;

      if (sec >= 86400) sec -= 86400, ++julian;
    }

    if (julian != int32_t(julian)) {
      null();
      return *this;
    }

    m_julian = julian;
    m_sec = sec;

    return *this;
  }

  template <typename T>
  ZuExact<ZuTime, T, ZuDateTime> operator-(const T &t) const {
    return ZuDateTime::operator+(-t);
  }
  template <typename T> MatchInt<T, ZuDateTime> operator-(T sec_) const {
    return ZuDateTime::operator+(-sec_);
  }
  template <typename T>
  ZuExact<ZuTime, T, ZuDateTime &> operator-=(const T &t) {
    return ZuDateTime::operator+=(-t);
  }
  template <typename T> MatchInt<T, ZuDateTime &> operator-=(T sec_) {
    return ZuDateTime::operator+=(-sec_);
  }

  bool equals(const ZuDateTime &v) const {
    return m_julian == v.m_julian && m_sec == v.m_sec && m_nsec == v.m_nsec;
  }
  int cmp(const ZuDateTime &v) const {
    if (int i = ZuCmp<int32_t>::cmp(m_julian, v.m_julian)) return i;
    if (int i = ZuCmp<int32_t>::cmp(m_sec, v.m_sec)) return i;
    return ZuCmp<int32_t>::cmp(m_nsec, v.m_nsec);
  }
  friend inline bool operator==(const ZuDateTime &l, const ZuDateTime &r) {
    return l.equals(r);
  }
  friend inline int operator<=>(const ZuDateTime &l, const ZuDateTime &r) {
    return l.cmp(r);
  }

  constexpr bool operator!() const { return ZuCmp<int32_t>::null(m_julian); }
  operator const void *() const {
    return !*this ? reinterpret_cast<const void *>(0) :
		    static_cast<const void *>(this);
  }

  uint32_t hash() const { return m_julian ^ m_sec ^ m_nsec; }

private:
  void ctor(int year, int month, int day) {
    normalize(year, month);
    m_julian = julian(year, month, day);
    m_sec = 0, m_nsec = 0;
  }
  void
  ctor(int year, int month, int day, int hour, int minute, int sec, int nsec) {
    normalize(year, month);
    normalize(day, hour, minute, sec, nsec);
    m_julian = julian(year, month, day);
    m_sec = second(hour, minute, sec);
    m_nsec = nsec;
  }

private:
  template <unsigned Width> struct Int {
    template <typename T, typename S> static unsigned scan(T &v, S &s) {
      unsigned i = v.scan(ZuFmt::Right<Width>(), s);
      if (__builtin_expect(!!(i > 0), 1)) s.offset(i);
      return i;
    }
  };

  template <typename T, typename S> static unsigned scanFrac(T &v, S &s) {
    unsigned i = v.scan(ZuFmt::Frac<9, 9>(), s);
    if (__builtin_expect(!!(i > 0), 1)) s.offset(i);
    return i;
  }

public:
  unsigned scan(const ZuDateTimeScan::CSV &, ZuCSpan);
  unsigned scan(const ZuDateTimeScan::FIX &, ZuCSpan);
  unsigned scan(const ZuDateTimeScan::ISO &, ZuCSpan);
  unsigned scan(const ZuDateTimeScan::Any &, ZuCSpan);

  void normalize(unsigned &year, unsigned &month);
  void normalize(int &year, int &month);

  void normalize(
    unsigned &day, unsigned &hour, unsigned &minute, unsigned &sec,
    unsigned &nsec
  );
  void normalize(int &day, int &hour, int &minute, int &sec, int &nsec);

  static int julian(int year, int month, int day);

  static int second(int hour, int minute, int second) {
    return hour * 3600 + minute * 60 + second;
  }

  void init(int64_t t) {
    if (__builtin_expect(!!(ZuCmp<time_t>::null(t)), 0)) {
      null();
    } else {
      if (__builtin_expect(!!(t >= 0), 1)) {
	int64_t j = t / 86400 + 2440588;
	if (j >= int64_t(1U << 31)) goto overflow;
	m_julian = j;
	m_sec = t % 86400;
      } else {
	if (ZuIntrin::sub(t, 86399, &t)) goto overflow;
	int64_t j = t / 86400 + 2440588;
	if (j < -int64_t(1U << 31)) goto overflow;
	m_julian = j;
	t = 86399 - (-t % 86400);
	m_sec = t;
      }
    }
    m_nsec = 0;
    return;
overflow:
    null();
  }

  struct DefltPrint : public ZuPrintDelegate {
    template <typename S> static void print(S &s, const ZuDateTime &v) {
      thread_local ZuDateTimeFmt::ISO fmt;
      s << v.fmt(fmt);
    }
  };
  friend DefltPrint ZuPrintType(ZuDateTime *);

  struct Traits : public ZuBaseTraits<ZuDateTime> {
    enum { IsPOD = 1 };
  };
  friend Traits ZuTraitsType(ZuDateTime *);

private:
  int32_t m_julian = ZuCmp<int32_t>::null();
  int32_t m_sec = 0;
  int32_t m_nsec = 0;

  static int m_reformationJulian;
  static int m_reformationYear;
  static int m_reformationMonth;
  static int m_reformationDay;
};

template <typename S> inline void ZuDateTimePrintCSV::print(S &s) const {
  value.csv_print(s, fmt);
}
template <int NDP, class Null>
template <typename S>
inline void ZuDateTimePrintFIX<NDP, Null>::print(S &s) const {
  value.fix_print(s, fmt);
}
template <typename S> inline void ZuDateTimePrintISO::print(S &s) const {
  value.iso_print(s, fmt);
}
template <typename S> inline void ZuDateTimePrintStrftime::print(S &s) const {
  auto format = fmt.format;

  if (!format || !*format) return;

  ZuDateTime value = this->value + fmt.tzOffset;

  ZuBox<int> year, month, day, hour, minute, second;
  ZuBox<int> days, week, wkDay, hour12;
  ZuBox<int> wkYearISO, weekISO, weekSun;
  ZuBox<time_t> seconds;

  ZuVFmt fmt_;

  while (char c = *format++) {
    if (c != '%') {
      s << c;
      continue;
    }
    bool alt = false;
    ZuBox<unsigned> width;
fmtchar:
    c = *format++;
    switch (c) {
    case '#':
    case 'E':
      alt = true;
    case 'O':
      goto fmtchar;
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
      format += width.scan(format);
      goto fmtchar;
    case 'a':
      if (!*wkDay) wkDay = value.julian() % 7 + 1;
      s << ZuDateTime::dayShortName(wkDay);
      break;
    case 'A':
      if (!*wkDay) wkDay = value.julian() % 7 + 1;
      s << ZuDateTime::dayLongName(wkDay);
      break;
    case 'b':
    case 'h':
      if (!*month) value.ymd(year, month, day);
      s << ZuDateTime::monthShortName(month);
      break;
    case 'B':
      if (!*month) value.ymd(year, month, day);
      s << ZuDateTime::monthLongName(month);
      break;
    case 'c':
      if (!*year) value.ymd(year, month, day);
      if (!*hour) value.hms(hour, minute, second);
      if (!*wkDay) wkDay = value.julian() % 7 + 1;
      s << ZuDateTime::dayShortName(wkDay) << ' '
	<< ZuDateTime::monthShortName(month) << ' ' << vfmt(fmt_, day, 2, alt)
	<< ' ' << vfmt(fmt_, hour, 2, alt) << ':' << vfmt(fmt_, minute, 2, alt)
	<< ':' << vfmt(fmt_, second, 2, alt) << ' ' << vfmt(fmt_, year, 4, alt);
      break;
    case 'C':
      if (!*year) value.ymd(year, month, day);
      {
	ZuBox<int> century = year / 100;
	s << vfmt(fmt_, century, width, 2, alt);
      }
      break;
    case 'd':
      if (!*day) value.ymd(year, month, day);
      s << vfmt(fmt_, day, width, 2, alt);
      break;
    case 'x':
    case 'D':
      if (!*year) value.ymd(year, month, day);
      {
	ZuBox<int> year_ = year % 100;
	s << vfmt(fmt_, month, 2, alt) << '/' << vfmt(fmt_, day, 2, alt) << '/'
	  << vfmt(fmt_, year_, 2, alt);
      }
      break;
    case 'e':
      if (!*year) value.ymd(year, month, day);
      s << vfmt(fmt_, day, width, 2, alt, ' ');
      break;
    case 'F':
      if (!*year) value.ymd(year, month, day);
      s << vfmt(fmt_, year, 4, alt) << '-' << vfmt(fmt_, month, 2, alt) << '-'
	<< vfmt(fmt_, day, 2, alt);
      break;
    case 'g':
    case 'G':
      if (!*wkYearISO) {
	if (!*year) value.ymd(year, month, day);
	if (!*days) days = value.days(year, 1, 1);
	value.ywdISO(year, days, wkYearISO, weekISO, wkDay);
      }
      {
	ZuBox<int> wkYearISO_ = wkYearISO;
	if (c == 'g') wkYearISO_ %= 100;
	s << vfmt(fmt_, wkYearISO_, width, (c == 'g' ? 2 : 4), alt);
      }
      break;
    case 'H':
      if (!*hour) value.hms(hour, minute, second);
      s << vfmt(fmt_, hour, width, 2, alt);
      break;
    case 'I':
      if (!*hour12) {
	if (!*hour) value.hms(hour, minute, second);
	hour12 = hour % 12;
	if (!hour12) hour12 += 12;
      }
      s << vfmt(fmt_, hour12, width, 2, alt);
      break;
    case 'j':
      if (!*year) value.ymd(year, month, day);
      if (!*days) days = value.days(year, 1, 1);
      {
	ZuBox<int> days_ = days + 1;
	s << vfmt(fmt_, days_, width, 3, alt);
      }
      break;
    case 'm':
      if (!*month) value.ymd(year, month, day);
      s << vfmt(fmt_, month, width, 2, alt);
      break;
    case 'M':
      if (!*minute) value.hms(hour, minute, second);
      s << vfmt(fmt_, minute, width, 2, alt);
      break;
    case 'n':
      s << '\n';
      break;
    case 'p':
      if (!*hour) value.hms(hour, minute, second);
      s << (hour >= 12 ? "PM" : "AM");
      break;
    case 'P':
      if (!*hour) value.hms(hour, minute, second);
      s << (hour >= 12 ? "pm" : "am");
      break;
    case 'r':
      if (!*hour) value.hms(hour, minute, second);
      if (!*hour12) {
	hour12 = hour % 12;
	if (!hour12) hour12 += 12;
      }
      s << vfmt(fmt_, hour12, 2, alt) << ':' << vfmt(fmt_, minute, 2, alt)
	<< ':' << vfmt(fmt_, second, 2, alt) << ' '
	<< (hour >= 12 ? "PM" : "AM");
      break;
    case 'R':
      if (!*hour) value.hms(hour, minute, second);
      s << vfmt(fmt_, hour, 2, alt) << ':' << vfmt(fmt_, minute, 2, alt);
      break;
    case 's':
      if (!*seconds) seconds = value.as_time_t();
      if (!alt && *width)
	s << seconds.vfmt(ZuVFmt{}.right(width));
      else
	s << seconds;
      break;
    case 'S':
      if (!*second) value.hms(hour, minute, second);
      s << vfmt(fmt_, second, width, 2, alt);
      break;
    case 't':
      s << '\t';
      break;
    case 'X':
    case 'T':
      if (!*hour) value.hms(hour, minute, second);
      s << vfmt(fmt_, hour, 2, alt) << ':' << vfmt(fmt_, minute, 2, alt) << ':'
	<< vfmt(fmt_, second, 2, alt);
      break;
    case 'u':
      if (!*wkDay) wkDay = value.julian() % 7 + 1;
      s << vfmt(fmt_, wkDay, width, 1, alt);
      break;
    case 'U':
      if (!*weekSun) {
	if (!*year) value.ymd(year, month, day);
	if (!*days) days = value.days(year, 1, 1);
	{
	  int wkDay_;
	  value.ywdSun(days, weekSun, wkDay_);
	}
      }
      s << vfmt(fmt_, weekSun, width, 2, alt);
      break;
    case 'V':
      if (!*weekISO) {
	if (!*year) value.ymd(year, month, day);
	if (!*days) days = value.days(year, 1, 1);
	value.ywdISO(year, days, wkYearISO, weekISO, wkDay);
      }
      s << vfmt(fmt_, weekISO, width, 2, alt);
      break;
    case 'w':
      if (!*wkDay) wkDay = value.julian() % 7 + 1;
      {
	ZuBox<int> wkDay_ = wkDay;
	if (wkDay_ == 7) wkDay_ = 0;
	s << vfmt(fmt_, wkDay_, width, 1, alt);
      }
      break;
    case 'W':
      if (!*week) {
	if (!*year) value.ymd(year, month, day);
	if (!*days) days = value.days(year, 1, 1);
	value.ywd(days, week, wkDay);
      }
      s << vfmt(fmt_, week, width, 2, alt);
      break;
    case 'y':
      if (!*year) value.ymd(year, month, day);
      {
	ZuBox<int> year_ = year % 100;
	s << vfmt(fmt_, year_, width, 2, alt);
      }
      break;
    case 'Y':
      if (!*year) value.ymd(year, month, day);
      s << vfmt(fmt_, year, width, 4, alt);
      break;
    case 'z':
    case 'Z': {
      ZuBox<int> tzOffset_ = fmt.tzOffset;
      if (tzOffset_ < 0) {
	s << '-';
	tzOffset_ = -tzOffset_;
      }
      tzOffset_ = (tzOffset_ / 3600) * 100 + (tzOffset_ % 3600) / 60;
      s << tzOffset_;
    } break;
    case '%':
      s << '%';
      break;
    }
  }
}
template <typename S> inline void ZuDateTimePrint::print(S &s) const {
  using namespace ZuDateTimeFmt;
  switch (fmt.type()) {
  default:
  case Any::Index<CSV>{}:
    s << value.fmt(fmt.csv());
    break;
  case Any::Index<FIXDeflt>{}:
    s << value.fmt(fmt.fix());
    break;
  case Any::Index<ISO>{}:
    s << value.fmt(fmt.iso());
    break;
  case Any::Index<Strftime>{}: {
    const auto &strftime = fmt.strftime();
    s << value.strftime(strftime.format, strftime.tzOffset);
  } break;
  }
}

namespace ZuFieldKeyID {
enum { All = -1, Union = -2 };
};

namespace ZuFieldProp {

template <unsigned I> struct Ctor { };

template <unsigned... KeyIDs> struct Keys { };

template <typename T, template <T> class Prop> struct GrepValue_ {
  template <typename> struct Is : public ZuFalse { };
  template <unsigned I> struct Is<Prop<I>> : public ZuTrue { };
  template <typename Props> using Apply = ZuTypeGrep<Is, Props>;
};
template <typename Props, typename T, template <T> class Prop>
using GrepValue = GrepValue_<T, Prop>::template Apply<Props>;

template <template <typename> class Prop> struct GrepType_ {
  template <typename> struct Is : public ZuFalse { };
  template <typename T> struct Is<Prop<T>> : public ZuTrue { };
  template <typename Props> using Apply = ZuTypeGrep<Is, Props>;
};
template <typename Props, template <typename> class Prop>
using GrepType = GrepType_<Prop>::template Apply<Props>;

template <template <unsigned...> class Prop> struct GrepSeq_ {
  template <typename> struct Is : public ZuFalse { };
  template <unsigned... Seq> struct Is<Prop<Seq...>> : public ZuTrue { };
  template <typename Props> using Apply = ZuTypeGrep<Is, Props>;
};
template <template <unsigned...> class Prop, typename Props>
using GrepSeq = GrepSeq_<Prop>::template Apply<Props>;

template <
  typename Props, typename U, template <U> class Prop,
  typename Filtered = GrepValue<Props, U, Prop>, unsigned N = Filtered::N>
struct Value_ {
  enum { Exists = 0 };
};
template <typename U, template <U> class Prop, typename> struct Value__;
template <typename U, template <U> class Prop, U I>
struct Value__<U, Prop, Prop<I>> {
  using T = ZuConstant<U, I>;
};
template <
  typename Props, typename U, template <U> class Prop, typename Filtered>
struct Value_<Props, U, Prop, Filtered, 1> {
  enum { Exists = 1 };
  using T = typename Value__<U, Prop, ZuType<0, Filtered>>::T;
};

template <typename Props, typename U, template <U> class Prop>
using HasValue = ZuBool<Value_<Props, U, Prop>::Exists>;
template <typename Props, typename U, template <U> class Prop>
using GetValue = typename Value_<Props, U, Prop>::T;

template <
  typename Props, template <typename> class Prop,
  typename Filtered = GrepType<Props, Prop>, unsigned N = Filtered::N>
struct Type_ {
  enum { Exists = 0 };
};
template <typename Props, template <typename> class Prop, typename Filtered>
struct Type_<Props, Prop, Filtered, 1> {
  enum { Exists = 1 };
  using T = typename ZuType<0, Filtered>::T;
};

template <typename Props, template <typename> class Prop>
using HasType = ZuBool<Type_<Props, Prop>::Exists>;
template <typename Props, template <typename> class Prop>
using GetType = typename Type_<Props, Prop>::T;

template <
  typename Props, template <unsigned...> class Prop,
  typename Filtered = GrepSeq<Prop, Props>, unsigned N = Filtered::N>
struct Seq_ {
  enum { Exists = 0 };
  using T = ZuSeq<>;
};
template <template <unsigned...> class, typename> struct Seq__;
template <template <unsigned...> class Prop, unsigned... Seq>
struct Seq__<Prop, Prop<Seq...>> {
  using T = ZuSeq<Seq...>;
};
template <typename Props, template <unsigned...> class Prop, typename Filtered>
struct Seq_<Props, Prop, Filtered, 1> {
  enum { Exists = 1 };
  using T = typename Seq__<Prop, ZuType<0, Filtered>>::T;
};

template <typename Props, template <unsigned...> class Prop>
using HasSeq = ZuBool<Seq_<Props, Prop>::Exists>;
template <typename Props, template <unsigned...> class Prop>
using GetSeq = typename Seq_<Props, Prop>::T;

template <typename Props> using HasCtor = HasValue<Props, unsigned, Ctor>;
template <typename Props> using GetCtor = GetValue<Props, unsigned, Ctor>;

template <typename Props> using GetKeys = GetSeq<Props, Keys>;

template <typename Props, int KeyID>
struct Key :
  public ZuTypeIn<ZuUnsigned<unsigned(KeyID)>, ZuSeqTL<GetKeys<Props>>> { };
template <typename Props>
struct Key<Props, ZuFieldKeyID::All> : public ZuTrue { };
template <typename Props>
struct Key<Props, ZuFieldKeyID::Union> : public ZuBool<GetKeys<Props>::N> { };
} // namespace ZuFieldProp

ZuTypeList<> ZuFields_(...);
void ZuFielded_(...);

template <typename U> using ZuFields = decltype(ZuFields_(ZuDeclVal<U *>()));

template <typename T>
using ZuFielded = decltype(ZuFielded_(ZuDeclVal<ZuDecay<T> *>()));

template <typename T> using ZuFieldOrig = typename T::Orig;

template <typename O, typename Tuple, typename Fields> struct ZuFieldTuple_;

struct ZuFieldTuple_RDecayer {
  template <typename> struct Decay;
  template <typename O, typename... Ts, typename Fields>
  struct Decay<ZuFieldTuple_<O, ZuTuple<Ts...>, Fields>> {
    using T = ZuFieldTuple_<
      O, ZuTypeApply<ZuTuple, ZuTypeMap<ZuRDecay, Ts...>>, Fields>;
  };
};
template <typename O_, typename Tuple, typename Fields_>
struct ZuFieldTuple_ : public Tuple {
  using Tuple::Tuple;
  using Tuple::operator=;
  template <typename... Args>
  ZuFieldTuple_(Args &&...args) : Tuple{ZuFwd<Args>(args)...} { }

  using O = O_;

  template <typename Base> struct Adapted : public Base {
    using Orig = Base;
    template <template <typename> typename Override>
    using Adapt = Adapted<Override<Orig>>;
    using O = Tuple;
    enum { I = ZuTypeIndex<Base, ZuTypeMap<ZuFieldOrig, Fields_>>{} };

  private:
    template <typename> struct CtorFilter : public ZuTrue { };
    template <unsigned J>
    struct CtorFilter<ZuFieldProp::Ctor<J>> : public ZuFalse { };

  public:
    using Props = ZuTypeGrep<
      CtorFilter, typename Orig::Props>::template Unshift<ZuFieldProp::Ctor<I>>;
    static decltype(auto) get(const O &o) { return o.template p<I>(); }
    static decltype(auto) get(O &o) { return o.template p<I>(); }
    static decltype(auto) get(O &&o) { return ZuMv(o).template p<I>(); }
    template <typename U> static void set(O &o, U &&v) {
      o.template p<I>(ZuFwd<U>(v));
    }
  };
  template <typename Field> using Map = typename Field::template Adapt<Adapted>;
  using Fields = ZuTypeMap<Map, Fields_>;

  friend ZuFieldTuple_ ZuFielded_(ZuFieldTuple_ *);
  friend Fields ZuFields_(ZuFieldTuple_ *);

  friend ZuFieldTuple_RDecayer ZuRDecayer(ZuFieldTuple_ *);
};

template <typename O, typename Tuple, typename Fields> struct ZuFieldTupleT__ {
  using T = ZuFieldTuple_<O, Tuple, Fields>;
};
template <
  typename O, typename Tuple_, typename Fields_, typename Tuple,
  typename Fields>
struct ZuFieldTupleT__<ZuFieldTuple_<O, Tuple_, Fields_>, Tuple, Fields> {
  using T = ZuFieldTuple_<O, Tuple, Fields>;
};
template <
  typename O, template <typename> typename ObjectMap,
  template <typename> typename ValueMap, typename... Fields>
struct ZuFieldTupleT_ {
  using T = typename ZuFieldTupleT__<
    O, ZuTuple<ValueMap<decltype(Fields::get(ZuDeclVal<ObjectMap<O>>()))>...>,
    ZuTypeList<Fields...>>::T;
};
template <
  typename O, template <typename> typename ObjectMap,
  template <typename> typename ValueMap, typename... Fields>
struct ZuFieldTupleT_<O, ObjectMap, ValueMap, ZuTypeList<Fields...>> :
  public ZuFieldTupleT_<O, ObjectMap, ValueMap, Fields...> { };
template <
  typename O, template <typename> typename ObjectMap,
  template <typename> typename ValueMap, typename... Fields>
using ZuFieldTupleT =
  typename ZuFieldTupleT_<ZuDecay<O>, ObjectMap, ValueMap, Fields...>::T;

template <typename O>
using ZuFieldTuple = ZuFieldTupleT<O, ZuMkCRef, ZuDecay, ZuFields<O>>;

template <typename O, typename... Fields> struct ZuFieldTuple_Bind {
  static decltype(auto) get(const O &o) {
    return ZuFieldTupleT<O, ZuMkCRef, ZuAsIs, Fields...>{Fields::get(o)...};
  }
  static decltype(auto) get(O &&o) {
    return ZuFieldTupleT<O, ZuMkRRef, ZuAsIs, Fields...>{Fields::get(ZuMv(o))...
    };
  }
};
template <typename O, typename... Fields>
struct ZuFieldTuple_Bind<O, ZuTypeList<Fields...>> :
  public ZuFieldTuple_Bind<O, Fields...> { };

template <typename Fields, typename P>
inline decltype(auto) ZuFieldExtract(P &&o) {
  using O = ZuFielded<P>;
  static_assert((Fields::N > 0), "Fields::N > 0");
  return ZuFieldTuple_Bind<O, Fields>::get(ZuFwd<P>(o));
}

template <int KeyID> struct ZuFieldKey_ {
  template <typename U>
  struct Filter : public ZuFieldProp::Key<typename U::Props, KeyID> { };
};
template <typename O, int KeyID> struct ZuKeyFields_ {
  using T = ZuTypeGrep<ZuFieldKey_<KeyID>::template Filter, ZuFields<O>>;
};
template <typename O, int KeyID = 0>
using ZuKeyFields = typename ZuKeyFields_<O, KeyID>::T;

template <int KeyID = 0, typename P> inline decltype(auto) ZuFieldKey(P &&o) {
  using O = ZuFielded<P>;
  return ZuFieldExtract<ZuKeyFields<O, KeyID>>(ZuFwd<P>(o));
}

template <typename O, int KeyID = 0> inline constexpr auto ZuFieldAxor() {
  using KeyFields = ZuKeyFields<O, KeyID>;

  static_assert((KeyFields::N > 0), "KeyFields::N > 0");

  return []<typename P>(P &&o) -> decltype(auto) {
    return ZuFieldTuple_Bind<O, KeyFields>::get(ZuFwd<P>(o));
  };
}

template <typename O, int KeyID> struct ZuFieldKeyT_ {
  using KeyFields = ZuKeyFields<O, KeyID>;

  static_assert((KeyFields::N > 0), "KeyFields::N > 0");

  using T = ZuFieldTupleT<O, ZuMkCRef, ZuDecay, KeyFields>;
};
template <typename O, int KeyID = 0>
using ZuFieldKeyT = typename ZuFieldKeyT_<ZuFielded<O>, KeyID>::T;

template <typename... Fields> struct ZuFieldKeyIDs_ {
  using T = ZuMkSeq<
    ZuMax<ZuSeq<ZuMax<ZuFieldProp::GetKeys<typename Fields::Props>>{}...>>{} +
    1>;
};
template <typename... Fields>
struct ZuFieldKeyIDs_<ZuTypeList<Fields...>> :
  public ZuFieldKeyIDs_<Fields...> { };
template <typename O>
using ZuFieldKeyIDs = typename ZuFieldKeyIDs_<ZuFields<O>>::T;

template <typename O> struct ZuFieldKeys_ {
  using KeyIDs = ZuSeqTL<ZuFieldKeyIDs<O>>;
  template <typename KeyID> using KeyT = ZuFieldKeyT<O, KeyID{}>;
  using T = ZuTypeMap<KeyT, KeyIDs>;
};
template <typename O> using ZuFieldKeys = typename ZuFieldKeys_<O>::T;

template <typename O> struct ZuFieldKeyUnion_ {
  using KeyIDs = ZuSeqTL<ZuFieldKeyIDs<O>>;
  template <typename KeyID> using KeyT = ZuFieldKeyT<O, KeyID{}>;
  using UnionTypes = typename ZuTypeMap<KeyT, KeyIDs>::template Unshift<void>;
  using T = ZuTypeApply<ZuUnion, UnionTypes>;
};
template <typename O> using ZuFieldKeyUnion = typename ZuFieldKeyUnion_<O>::T;

namespace ZuVArray_ {

template <typename Array_, typename Elem_>
class Iterator : public ZuIterator<Iterator<Array_, Elem_>, Array_, Elem_> {
  using Base = ZuIterator<Iterator<Array_, Elem_>, Array_, Elem_>;

public:
  using Array = Array_;
  using Elem = Elem_;
  using Base::Base;
  using Base::operator=;
  using Base::container;
  using Base::i;

  Elem operator*() const;
};

template <typename Array_> class Elem {
public:
  using Array = Array_;
  using T = typename Array::T;
  using R = typename Array::R;

  Elem() = delete;
  Elem(Array &array_, unsigned i_) : array{array_}, i{i_} { }
  Elem(const Elem &) = default;
  Elem &operator=(const Elem &) = default;
  Elem(Elem &&) = default;
  Elem &operator=(Elem &&) = default;

  R get() const;

  operator R() const { return get(); }

  Elem &operator=(T v);

  bool equals(const Elem &r) const { return get() == r.get(); }
  int cmp(const Elem &r) const { return ZuCmp<T>::cmp(get(), r.get()); }
  friend inline bool operator==(const Elem &l, const Elem &r) {
    return l.equals(r);
  }
  friend inline int operator<=>(const Elem &l, const Elem &r) {
    return l.cmp(r);
  }

  bool operator!() const { return !get(); }

  using Traits = ZuWrapTraits<Elem, R>;
  friend Traits ZuTraitsType(Elem *);

  friend R ZuUnderType(Elem *);

private:
  Array &array;
  unsigned i;
};

template <typename T_, typename R_ = T_> class Array {
public:
  using T = T_;
  using R = R_;
  using Elem = ZuVArray_::Elem<Array>;

  friend Elem;

  template <typename Array_>
  Array(const Array_ &array) :
    m_ptr{const_cast<Array_ *>(&array)},
    m_length{ZuTraits<Array_>::length(array)},
    m_getFn{[](const void *ptr, unsigned i) -> R {
      return (*static_cast<const Array_ *>(ptr))[i];
    }} { }

  template <typename Array_, typename Elem_ = typename ZuTraits<Array_>::Elem>
  Array(Array_ &array) :
    m_ptr{&array}, m_length{ZuTraits<Array_>::length(array)},
    m_getFn{[](const void *ptr, unsigned i) -> R {
      return (*static_cast<const Array_ *>(ptr))[i];
    }},
    m_setFn{[](void *ptr, unsigned i, T elem) {
      (*static_cast<Array_ *>(ptr))[i] = Elem_(ZuMv(elem));
    }} { }

  template <typename Array_, typename GetFn_>
  Array(Array_ &array, unsigned length, GetFn_ getFn) :
    m_ptr{&array}, m_length{length}, m_getFn{getFn} { }

  template <typename Array_, typename GetFn_, typename SetFn_>
  Array(Array_ &array, unsigned length, GetFn_ getFn, SetFn_ setFn) :
    m_ptr{&array}, m_length{length}, m_getFn{getFn}, m_setFn{setFn} { }

  Array() = default;
  Array(const Array &) = default;
  Array &operator=(const Array &) = default;
  Array(Array &&s) = default;
  Array &operator=(Array &&s) = default;

  unsigned length() const { return m_length; }

  const Elem operator[](unsigned i) const {
    return {const_cast<Array &>(*this), i};
  }
  Elem operator[](unsigned i) { return {*this, i}; }

  template <bool Mutable = false, typename L> ZuIfT<!Mutable> all(L l) const {
    for (unsigned i = 0, n = m_length; i < n; i++) l((*this)[i]);
  }
  template <bool Mutable, typename L> ZuIfT<Mutable> all(L l) {
    for (unsigned i = 0, n = m_length; i < n; i++) l((*this)[i]);
  }

  bool equals(const Array &r) const {
    if (this == &r) return true;
    unsigned l = length();
    unsigned n = r.length();
    if (l != n) return false;
    for (unsigned i = 0; i < n; i++)
      if (R((*this)[i]) != R(r[i])) return false;
    return true;
  }
  int cmp(const Array &r) const {
    if (this == &r) return 0;
    unsigned ln = m_length;
    unsigned rn = r.m_length;
    unsigned n = ln < rn ? ln : rn;
    for (unsigned i = 0; i < n; i++)
      if (int j = ZuCmp<T>::cmp(R((*this)[i]), R(r[i]))) return j;
    return ZuCmp<int>::cmp(ln, rn);
  }
  friend inline bool operator==(const Array &l, const Array &r) {
    return l.equals(r);
  }
  friend inline bool operator<(const Array &l, const Array &r) {
    return l.cmp(r) < 0;
  }
  friend inline int operator<=>(const Array &l, const Array &r) {
    return l.cmp(r);
  }

  bool operator!() const { return !m_length; }
  operator const void *() const {
    return !*this ? reinterpret_cast<const void *>(0) :
		    static_cast<const void *>(this);
  }

  using iterator = Iterator<Array, Elem>;
  using const_iterator = Iterator<const Array, const Elem>;
  const_iterator begin() const { return const_iterator{*this, 0}; }
  const_iterator end() const { return const_iterator{*this, m_length}; }
  const_iterator cbegin() const { return const_iterator{*this, 0}; }
  const_iterator cend() const { return const_iterator{*this, m_length}; }
  iterator begin() { return iterator{*this, 0}; }
  iterator end() { return iterator{*this, m_length}; }

private:
  typedef R (*GetFn)(const void *, unsigned);
  typedef void (*SetFn)(void *, unsigned, T);

  void *m_ptr = nullptr;
  unsigned m_length = 0;
  GetFn m_getFn = nullptr;
  SetFn m_setFn = nullptr;
};

template <typename Array, typename Elem>
inline Elem Iterator<Array, Elem>::operator*() const {
  return container[i];
}

template <typename Array>
inline typename Elem<Array>::R Elem<Array>::get() const {
  return (*array.m_getFn)(array.m_ptr, i);
}

template <typename Array>
inline Elem<Array> &Elem<Array>::operator=(typename Elem<Array>::T v) {
  (*array.m_setFn)(array.m_ptr, i, ZuMv(v));
  return *this;
}

} // namespace ZuVArray_

template <typename T, typename R = T> using ZuVArray = ZuVArray_::Array<T, R>;

class ZuID {
public:
  constexpr ZuID() { }

  constexpr ZuID(const ZuID &b) : m_val{b.m_val} { }
  constexpr ZuID &operator=(const ZuID &b) {
    m_val = b.m_val;
    return *this;
  }

  template <typename S, decltype(ZuMatchString<S>(), int()) = 0> ZuID(S &&s) {
    init(ZuFwd<S>(s));
  }
  template <typename S> ZuMatchString<S, ZuID &> operator=(S &&s) {
    init(ZuFwd<S>(s));
    return *this;
  }

  template <typename V>
  struct IsUInt64 :
    public ZuBool<!ZuTraits<V>::IsString && ZuInspect<V, uint64_t>::Converts> {
  };
  template <typename V, typename R = void>
  using MatchUInt64 = ZuIfT<IsUInt64<V>{}, R>;

  template <typename V, MatchUInt64<V, int> = 0>
  constexpr ZuID(V v) : m_val{v} { }
  template <typename V> constexpr MatchUInt64<V, ZuID &> operator=(V v) {
    m_val = v;
    return *this;
  }

  void init(ZuCSpan s) {
    if (__builtin_expect(!!(s.length() == 8), 1)) {
      const uint64_t *__attribute__((__may_alias__)) ptr =
	reinterpret_cast<const uint64_t *>(s.data());

      m_val = *ptr;

      return;
    }
    m_val = 0;
    unsigned n = s.length();
    if (__builtin_expect(!!(!n), 0)) return;
    if (__builtin_expect(!!(n > 8), 0)) n = 8;
    memcpy(&m_val, s.data(), n);
  }

  char *data() {
    char *__attribute__((__may_alias__)) ptr = reinterpret_cast<char *>(&m_val);
    return ptr;
  }
  const char *data() const {
    const char *__attribute__((__may_alias__)) ptr =
      reinterpret_cast<const char *>(&m_val);
    return ptr;
  }
  unsigned length() const {
    if (!m_val) return 0U;

    return (71U - ZuIntrin::clz(m_val)) >> 3U;
  }

  operator ZuCSpan() const { return ZuCSpan{data(), length()}; }
  ZuCSpan string() const { return ZuCSpan{data(), length()}; }

  template <typename S> void print(S &s) const { s << string(); }

  constexpr operator uint64_t() const { return m_val; }

  constexpr int cmp(ZuID v) const {
    return (m_val > v.m_val) - (m_val < v.m_val);
  }
  template <typename L, typename R>
  friend inline constexpr ZuIs<ZuID, L, bool>
  operator==(const L &l, const R &r) {
    return l.m_val == r.m_val;
  }
  template <typename L, typename R>
  friend inline constexpr ZuIs<ZuID, L, int> operator<(const L &l, const R &r) {
    return l.m_val < r.m_val;
  }
  template <typename L, typename R>
  friend inline constexpr ZuIs<ZuID, L, int>
  operator<=>(const L &l, const R &r) {
    return l.cmp(r);
  }

  constexpr bool operator!() const { return !m_val; }

  constexpr bool operator*() const { return m_val; }

  void null() { m_val = 0; }

  ZuID &update(ZuID id) {
    if (*id) m_val = id.m_val;
    return *this;
  }

  uint32_t hash() const { return ZuHash<uint64_t>::hash(m_val); }

  struct Traits : public ZuTraits<uint64_t> {
    enum { IsPrimitive = 0 };
  };
  friend Traits ZuTraitsType(ZuID *);

  friend ZuPrintFn ZuPrintType(ZuID *);

private:
  uint64_t m_val = 0;
};

template <> struct ZuCmp<ZuID> {
  template <typename L, typename R>
  static constexpr int cmp(const L &l, const R &r) {
    return l.cmp(r);
  }
  template <typename L, typename R>
  static constexpr bool equals(const L &l, const R &r) {
    return l == r;
  }
  template <typename L, typename R>
  static constexpr bool less(const L &l, const R &r) {
    return l < r;
  }
  static constexpr bool null(ZuID id) { return !id; }
  static constexpr ZuID null() { return {}; }
};

inline unsigned ZmStackAvail() {
  uint8_t *sp;

  __asm__("movq %%rsp, %0" : "=q"(sp));

  auto addr = static_cast<uint8_t *>((ZmThreadContext::self())->stackAddr());
  auto avail = sp - addr;
  if (__builtin_expect(!!(avail < 0), 0)) return 0;
  if (avail >= static_cast<ptrdiff_t>(

		 (0x7fffffff * 2U + 1U)

	       ))
    return

      (0x7fffffff * 2U + 1U);
  return avail;
}

template <typename T> struct ZmAlloc_ {
  T *ptr = nullptr;

  ZmAlloc_() = default;
  ZmAlloc_(T *ptr_) : ptr{ptr_} { }
  ZmAlloc_(const ZmAlloc_ &) = delete;
  ZmAlloc_ &operator=(const ZmAlloc_ &) = delete;
  ZmAlloc_(ZmAlloc_ &&a) : ptr{a.ptr} { a.ptr = nullptr; }
  ZmAlloc_ &operator=(ZmAlloc_ &&a) {
    ptr = a.ptr;
    a.ptr = nullptr;
    return *this;
  }
  ~ZmAlloc_() {
    if (__builtin_expect(!!(!ptr), 0)) return;
    uint8_t *ptr_ = reinterpret_cast<uint8_t *>(ptr);
    auto self = (ZmThreadContext::self());
    auto addr = reinterpret_cast<uint8_t *>(self->stackAddr());
    auto size = self->stackSize();
    if (__builtin_expect(!!(ptr_ >= addr && ptr_ < (addr + size)), 1))
      ++self->m_allocStack;
    else {
      ++self->m_allocHeap;
      Zm::alignedFree(ptr_);
    }
  }

  operator T *() const { return ptr; }
  T *operator->() const { return ptr; }
};

extern "C" {
  extern void ZmSingleton_ctor();
  extern void ZmSingleton_dtor();
}

template <typename T, bool = ZuObjectTraits<T>::IsObject> struct ZmSingleton_ {
  void ref(T *p) { ZmRef__::ZmREF_((p), this); }
  void deref(T *p) { ZmRef__::ZmDEREF_((p), this); }
};
template <typename T> struct ZmSingleton_<T, false> {
  static void ref(T *) { }
  static void deref(T *p) { delete p; }
};

struct ZmSingleton_Defaults {
  enum { Construct = true };
  template <typename T> struct Ctor {
    static constexpr auto Fn = []() { return new T(); };
  };
  enum { Cleanup = ZmCleanup::Application };
};

template <typename NTP = ZmSingleton_Defaults>
struct ZmSingletonNoCtor : public NTP {
  enum { Construct = false };
};

template <auto CtorFn_, typename NTP = ZmSingleton_Defaults>
struct ZmSingletonCtor : public NTP {
  enum { Construct = true };
  template <typename T> struct Ctor {
    static constexpr auto Fn = CtorFn_;
  };
};

template <unsigned Cleanup_, typename NTP = ZmSingleton_Defaults>
struct ZmSingletonCleanup : public NTP {
  enum { Cleanup = Cleanup_ };
};

template <class T_, typename NTP = ZmSingleton_Defaults>
class ZmSingleton : public ZmGlobal, public ZmSingleton_<T_> {
  ZmSingleton(const ZmSingleton &);
  ZmSingleton &operator=(const ZmSingleton &);

public:
  using T = T_;
  enum { Construct = NTP::Construct };
  static constexpr auto CtorFn = NTP::template Ctor<T>::Fn;
  enum { Cleanup = NTP::Cleanup };

private:
  static void final(...) { }
  template <typename U> static auto final(U *u) -> decltype(u->final()) {
    return u->final();
  }

  template <bool Construct_ = Construct> ZuIfT<Construct_> ctor() {
    T *ptr = CtorFn();
    this->ref(ptr);
    m_instance = ptr;
  }
  template <bool Construct_ = Construct> ZuIfT<!Construct_> ctor() { }

public:
  ZmSingleton() {
    ZmSingleton_ctor();

    ctor<>();
  };

  ~ZmSingleton() {
    ZmSingleton_dtor();

    if (T *ptr = m_instance.load_()) {
      final(ptr);
      this->deref(ptr);
    }
  }

private:
  ZmAtomic<T *> m_instance;

  inline static ZmSingleton *global() {
    return ZmGlobal::global<ZmSingleton, Cleanup>();
  }

  T *instance_(T *ptr) {
    this->ref(ptr);
    if (T *old = m_instance.xch(ptr)) {
      final(old);
      this->deref(old);
    }
    return ptr;
  }

public:
  inline static T *instance() { return global()->m_instance.load_(); }
  inline static T *instance(T *ptr) { return global()->instance_(ptr); }
};

template <
  unsigned Cleanup = ZmCleanup::Application, typename L,
  decltype(ZuStatelessLambda<L>(), int()) = 0>
inline auto &ZmStatic(L l) {
  using T = ZuDecay<decltype(*ZuDeclVal<ZuLambdaReturn<L>>())>;
  using Singleton =
    ZmSingleton<T, ZmSingletonCtor<ZuInvokeFn(l), ZmSingletonCleanup<Cleanup>>>;
  return *(Singleton::instance());
}

namespace cppcodec { namespace detail {

template <typename CodecVariant>
class base32 : public CodecVariant::template codec_impl<base32<CodecVariant>> {
public:
  inline static constexpr uint8_t binary_block_size() { return 5; }
  inline static constexpr uint8_t encoded_block_size() { return 8; }

  inline static __attribute__((always_inline)) constexpr uint8_t
  num_encoded_tail_symbols(uint8_t num_bytes) {
    return (num_bytes == 1) ?
      2 :
      (num_bytes == 2) ?
      4 :
      (num_bytes == 3) ?
      5 :
      (num_bytes == 4) ?
      7 :
      throw std::domain_error("invalid number of bytes in a tail block");
  }

  template <uint8_t I>
  inline static __attribute__((always_inline)) constexpr uint8_t
  index(const uint8_t *b) noexcept {
    static_assert(
      I >= 0 && I < encoded_block_size(),
      "invalid encoding symbol index in a block"
    );

    return (I == 0) ? ((b[0] >> 3) & 0x1F) :
      (I == 1)      ? (((b[0] << 2) & 0x1C) | ((b[1] >> 6) & 0x3)) :
      (I == 2)      ? ((b[1] >> 1) & 0x1F) :
      (I == 3)      ? (((b[1] << 4) & 0x10) | ((b[2] >> 4) & 0xF)) :
      (I == 4)      ? (((b[2] << 1) & 0x1E) | ((b[3] >> 7) & 0x1)) :
      (I == 5)      ? ((b[3] >> 2) & 0x1F) :
      (I == 6)      ? (((b[3] << 3) & 0x18) | ((b[4] >> 5) & 0x7)) :
		      (b[4] & 0x1F);
  }

  template <bool B> using uint8_if = typename std::enable_if<B, uint8_t>::type;

  template <uint8_t I>
  inline static __attribute__((always_inline)
  ) constexpr uint8_if<I == 1 || I == 3 || I == 4 || I == 6>
  index_last(const uint8_t *b) noexcept {
    return (I == 1) ? ((b[0] << 2) & 0x1C) :
      (I == 3)      ? ((b[1] << 4) & 0x10) :
      (I == 4)      ? ((b[2] << 1) & 0x1E) :
		      ((b[3] << 3) & 0x18);
  }

  template <uint8_t I>
  inline static __attribute__((always_inline))
  uint8_if<I != 1 && I != 3 && I != 4 && I != 6>
  index_last(const uint8_t *) {
    throw std::domain_error("invalid last encoding symbol index in a tail");
  }

  template <typename Result, typename ResultState>
  inline static __attribute__((always_inline)) void
  decode_block(Result &decoded, ResultState &, const alphabet_index_t *idx);

  template <typename Result, typename ResultState>
  inline static __attribute__((always_inline)) void decode_tail(
    Result &decoded, ResultState &, const alphabet_index_t *idx, size_t idx_len
  );
};

template <typename CodecVariant>
template <typename Result, typename ResultState>
inline __attribute__((always_inline)) void base32<CodecVariant>::decode_block(
  Result &decoded, ResultState &state, const alphabet_index_t *idx
) {
  put(
    decoded, state,
    static_cast<uint8_t>(((idx[0] << 3) & 0xF8) | ((idx[1] >> 2) & 0x7))
  );
  put(
    decoded, state,
    static_cast<uint8_t>(
      ((idx[1] << 6) & 0xC0) | ((idx[2] << 1) & 0x3E) | ((idx[3] >> 4) & 0x1)
    )
  );
  put(
    decoded, state,
    static_cast<uint8_t>(((idx[3] << 4) & 0xF0) | ((idx[4] >> 1) & 0xF))
  );
  put(
    decoded, state,
    static_cast<uint8_t>(
      ((idx[4] << 7) & 0x80) | ((idx[5] << 2) & 0x7C) | ((idx[6] >> 3) & 0x3)
    )
  );
  put(
    decoded, state,
    static_cast<uint8_t>(((idx[6] << 5) & 0xE0) | (idx[7] & 0x1F))
  );
}

template <typename CodecVariant>
template <typename Result, typename ResultState>
inline __attribute__((always_inline)) void base32<CodecVariant>::decode_tail(
  Result &decoded, ResultState &state, const alphabet_index_t *idx,
  size_t idx_len
) {
  if (idx_len == 1) {
    throw invalid_input_length(
      "invalid number of symbols in last base32 block: found 1, expected 2, 4, "
      "5 or 7"
    );
  }
  if (idx_len == 3) {
    throw invalid_input_length(
      "invalid number of symbols in last base32 block: found 3, expected 2, 4, "
      "5 or 7"
    );
  }
  if (idx_len == 6) {
    throw invalid_input_length(
      "invalid number of symbols in last base32 block: found 6, expected 2, 4, "
      "5 or 7"
    );
  }

  put(
    decoded, state,
    static_cast<uint8_t>(((idx[0] << 3) & 0xF8) | ((idx[1] >> 2) & 0x7))
  );
  if (idx_len == 2) { return; }

  put(
    decoded, state,
    static_cast<uint8_t>(
      ((idx[1] << 6) & 0xC0) | ((idx[2] << 1) & 0x3E) | ((idx[3] >> 4) & 0x1)
    )
  );
  if (idx_len == 4) { return; }

  put(
    decoded, state,
    static_cast<uint8_t>(((idx[3] << 4) & 0xF0) | ((idx[4] >> 1) & 0xF))
  );
  if (idx_len == 5) { return; }

  put(
    decoded, state,
    static_cast<uint8_t>(
      ((idx[4] << 7) & 0x80) | ((idx[5] << 2) & 0x7C) | ((idx[6] >> 3) & 0x3)
    )
  );
}

}} // namespace cppcodec::detail

namespace cppcodec {

namespace detail {

static constexpr const char base32_rfc4648_alphabet[] = {
  'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K',
  'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',
  'W', 'X', 'Y', 'Z', '2', '3', '4', '5', '6', '7'
};

class base32_rfc4648 {
public:
  template <typename Codec>
  using codec_impl = stream_codec<Codec, base32_rfc4648>;

  inline static __attribute__((always_inline)) constexpr size_t
  alphabet_size() {
    static_assert(
      sizeof(base32_rfc4648_alphabet) == 32,
      "base32 alphabet must have 32 values"
    );
    return sizeof(base32_rfc4648_alphabet);
  }
  inline static __attribute__((always_inline)) constexpr char
  symbol(alphabet_index_t idx) {
    return base32_rfc4648_alphabet[idx];
  }
  inline static __attribute__((always_inline)) constexpr char
  normalized_symbol(char c) {
    return (c >= 'a' && c <= 'z') ? (c - 'a' + 'A') : c;
  }

  inline static __attribute__((always_inline)) constexpr bool
  generates_padding() {
    return true;
  }
  inline static __attribute__((always_inline)) constexpr bool
  requires_padding() {
    return true;
  }
  inline static __attribute__((always_inline)) constexpr char padding_symbol() {
    return '=';
  }
  inline static __attribute__((always_inline)) constexpr bool
  is_padding_symbol(char c) {
    return c == '=';
  }
  inline static __attribute__((always_inline)) constexpr bool
  is_eof_symbol(char c) {
    return c == '\0';
  }

  inline static __attribute__((always_inline)) constexpr bool
  should_ignore(char) {
    return false;
  }
};

} // namespace detail

using base32_rfc4648 = detail::codec<detail::base32<detail::base32_rfc4648>>;

} // namespace cppcodec

namespace ZuBase32 {

inline constexpr bool is(char c) {
  return (c >= 'A' && c <= 'Z') || (c >= '2' && c <= '7') || c == '=';
}

inline constexpr unsigned enclen(unsigned slen) {
  return ((slen + 4) / 5) << 3;
}
inline unsigned encode(ZuSpan<uint8_t> dst, ZuBytes src) {
  using base32 = cppcodec::base32_rfc4648;
  try {
    return base32::encode(
      reinterpret_cast<char *>(dst.data()), dst.length(), src.data(),
      src.length()
    );
  } catch (...) { return 0; }
}

inline constexpr unsigned declen(unsigned slen) {
  return ((slen + 7) >> 3) * 5;
}
inline unsigned decode(ZuSpan<uint8_t> dst, ZuBytes src) {
  using base32 = cppcodec::base32_rfc4648;
  try {
    return base32::decode(
      dst.data(), dst.length(), reinterpret_cast<const char *>(src.data()),
      src.length()
    );
  } catch (...) { return 0; }
}

} // namespace ZuBase32

namespace ZtQuote {

struct CString {
  const char *v;
  template <typename S> friend S &operator<<(S &s, const CString &print) {
    const char *v = print.v;
    s << '"';
    if (v)
      for (unsigned i = 0; v[i]; i++) {
	char c = v[i];
	if (__builtin_expect(!!(c == '"'), 0)) s << '\\';
	s << c;
      }
    return s << '"';
  }
};

struct String {
  ZuCSpan v;
  template <typename S> friend S &operator<<(S &s, const String &print) {
    const auto &v = print.v;
    s << '"';
    for (unsigned i = 0, n = v.length(); i < n; i++) {
      char c = v[i];
      if (__builtin_expect(!!(c == '"'), 0)) s << '\\';
      s << c;
    }
    return s << '"';
  }
};

struct Base32 {
  ZuBytes v;
  template <typename S> friend S &operator<<(S &s, const Base32 &print) {
    const auto &v = print.v;
    auto n = ZuBase32::enclen(v.length());
    auto buf_ = ZmAlloc_<uint8_t>{static_cast<uint8_t *>(
      !(n) ? nullptr :
	     (((ZmStackAvail() >> 1) < ((n) * sizeof(uint8_t))) ?
		Zm::alignedAlloc<alignof(uint8_t)>((n) * sizeof(uint8_t)) :
		__builtin_alloca_with_align(
		  (n) * sizeof(uint8_t), (alignof(uint8_t)) << 3
		))
    )};
    ZuSpan<uint8_t> buf(&buf_[0], n);
    buf.trunc(ZuBase32::encode(buf, v));
    return s << ZuCSpan{buf};
  }
};

struct Base64 {
  ZuBytes v;
  template <typename S> friend S &operator<<(S &s, const Base64 &print) {
    const auto &v = print.v;
    auto n = ZuBase64::enclen(v.length());
    auto buf_ = ZmAlloc_<uint8_t>{static_cast<uint8_t *>(
      !(n) ? nullptr :
	     (((ZmStackAvail() >> 1) < ((n) * sizeof(uint8_t))) ?
		Zm::alignedAlloc<alignof(uint8_t)>((n) * sizeof(uint8_t)) :
		__builtin_alloca_with_align(
		  (n) * sizeof(uint8_t), (alignof(uint8_t)) << 3
		))
    )};
    ZuSpan<uint8_t> buf(&buf_[0], n);
    buf.trunc(ZuBase64::encode(buf, v));
    return s << ZuCSpan{buf};
  }
};

} // namespace ZtQuote

class ZmHashParams {
public:
  ZmHashParams() { }
  ZmHashParams(ZuCSpan id) { init(id); }
  ZmHashParams(uint32_t size) :
    m_bits{size <= 8 ? 3 : (32 - ZuIntrin::clz(size - 1))} { }

  const ZmHashParams &init(ZuCSpan id);

  ZmHashParams &bits(unsigned v) {
    m_bits = v;
    return *this;
  }
  ZmHashParams &loadFactor(double v) {
    m_loadFactor = v;
    return *this;
  }
  ZmHashParams &cBits(unsigned v) {
    m_cBits = v;
    return *this;
  }

  unsigned bits() const { return m_bits; }
  double loadFactor() const { return m_loadFactor; }
  unsigned cBits() const { return m_cBits; }

private:
  unsigned m_bits = 8;
  double m_loadFactor = 1.0;
  unsigned m_cBits = 3;
};

struct ZmHashTelemetry {
  ZmIDString id;
  uintptr_t addr = 9;
  double loadFactor = 0.0;
  double effLoadFactor = 0.0;
  uint64_t count = 0;
  uint32_t nodeSize = 0;
  uint32_t resized = 0;
  uint8_t bits = 0;
  uint8_t cBits = 0;
  uint8_t linear = 0;
  uint8_t shadow = 0;
};

class ZmAnyHash_ : public ZmPolymorph {
public:
  virtual void telemetry(ZmHashTelemetry &) const { }
};
inline uintptr_t ZmAnyHash_PtrAxor(const ZmAnyHash_ &h) {
  return reinterpret_cast<uintptr_t>(&h);
}
using ZmHashMgr_Tables = ZmRBTree<
  ZmAnyHash_,
  ZmRBTreeNode<
    ZmAnyHash_,
    ZmRBTreeKey<
      ZmAnyHash_PtrAxor,
      ZmRBTreeUnique<true, ZmRBTreeHeapID<ZmHeapDisable()>>>>>;
using ZmAnyHash = ZmHashMgr_Tables::Node;

template <typename, typename> class ZmHash;
template <typename, typename, typename, unsigned> class ZmLHash_;

class ZmHashMgr_;
class ZmHashMgr {
  friend ZmHashMgr_;
  friend ZmHashParams;
  template <typename, typename> friend class ZmHash;
  template <typename, typename, typename, unsigned> friend class ZmLHash_;

  template <class S> struct CSV_ {
    CSV_(S &stream) : m_stream(stream) {
      m_stream << "id,addr,shadow,linear,bits,cBits,loadFactor,nodeSize,"
		  "count,effLoadFactor,resized\n";
    }
    void print(ZmAnyHash *tbl) {
      ZmHashTelemetry data;
      tbl->telemetry(data);
      m_stream << data.id << ','
	       << (ZuBox<uintptr_t, ZuBoxCmp<ZuCmp0>>{
		     reinterpret_cast<uintptr_t>(data.addr)
		   })
		    .hex()
	       << ',' << unsigned(data.shadow) << ',' << unsigned(data.linear)
	       << ',' << unsigned(data.bits) << ',' << unsigned(data.cBits)
	       << ',' << ZuBoxed(data.loadFactor) << ',' << data.nodeSize << ','
	       << data.count << ',' << ZuBoxed(data.effLoadFactor) << ','
	       << data.resized << '\n';
    }
    S &stream() { return m_stream; }

  private:
    S &m_stream;
  };

public:
  static void init(ZuCSpan id, const ZmHashParams &params);

  static void all(ZmFn<void(ZmAnyHash *)> fn);

  struct CSV;
  friend CSV;
  struct CSV {
    template <typename S> void print(S &s) const {
      ZmHashMgr::CSV_<S> csv(s);
      ZmHashMgr::all(
	ZmFn<void(ZmAnyHash *)>::Member<&ZmHashMgr::CSV_<S>::print>::fn(&csv)
      );
    }
    friend ZuPrintFn ZuPrintType(CSV *);
  };
  static CSV csv() { return CSV(); }

private:
  static ZmHashParams &params(ZuCSpan id, ZmHashParams &in);

public:
  static void add(ZmAnyHash *);
  static void del(ZmAnyHash *);
};

inline const ZmHashParams &ZmHashParams::init(ZuCSpan id) {
  return ZmHashMgr::params(id, *this);
}

struct ZmLHash_Defaults {
  static constexpr auto KeyAxor = ZuDefaultAxor();
  static constexpr auto ValAxor = ZuDefaultAxor();
  template <typename T> using CmpT = ZuCmp<T>;
  template <typename T> using ValCmpT = ZuCmp<T>;
  template <typename T> using HashFnT = ZuHash<T>;
  using Lock = ZmNoLock;
  static const char *ID() { return "ZmHash"; }
  enum { Static = 0 };
  enum { Local = 0 };
};

template <auto KeyAxor_, typename NTP = ZmLHash_Defaults>
struct ZmLHashKey : public NTP {
  static constexpr auto KeyAxor = KeyAxor_;
};

template <auto KeyAxor_, auto ValAxor_, typename NTP = ZmLHash_Defaults>
struct ZmLHashKeyVal : public NTP {
  static constexpr auto KeyAxor = KeyAxor_;
  static constexpr auto ValAxor = ValAxor_;
};

template <template <typename> typename Cmp_, typename NTP = ZmLHash_Defaults>
struct ZmLHashCmp : public NTP {
  template <typename T> using CmpT = Cmp_<T>;
};

template <template <typename> typename ValCmp_, typename NTP = ZmLHash_Defaults>
struct ZmLHashValCmp : public NTP {
  template <typename T> using ValCmpT = ValCmp_<T>;
};

template <template <typename> typename HashFn_, typename NTP = ZmLHash_Defaults>
struct ZmLHashFn : public NTP {
  template <typename T> using HashFnT = HashFn_<T>;
};

template <class Lock_, typename NTP = ZmLHash_Defaults>
struct ZmLHashLock : public NTP {
  using Lock = Lock_;
};

template <auto ID_, typename NTP = ZmLHash_Defaults>
struct ZmLHashID : public NTP {
  static constexpr auto ID = ID_;
};

template <unsigned Static_, typename NTP = ZmLHash_Defaults>
struct ZmLHashStatic : public NTP {
  enum { Static = Static_ };
};

template <typename NTP = ZmLHash_Defaults> struct ZmLHashLocal : public NTP {
  enum { Local = 1 };
};

template <typename T> struct ZmLHash_Ops : public ZuArrayFn<T, ZuCmp<T>> {
  static T *alloc(unsigned size) {
    auto ptr =
      static_cast<T *>(Zm::alignedAlloc<Zm::CacheLineSize>(size * sizeof(T)));
    if (!ptr) throw std::bad_alloc{};
    return ptr;
  }
  static void free(T *ptr) { Zm::alignedFree(ptr); }
};

template <typename T_, auto KeyAxor, auto ValAxor> class ZmLHash_Node {
  template <typename, typename> friend class ZmLHash;
  template <typename, typename, typename, unsigned> friend class ZmLHash_;

public:
  using T = T_;

  ZmLHash_Node() { }
  ~ZmLHash_Node() {
    if (m_u) data().~T();
  }

  ZmLHash_Node(const ZmLHash_Node &n) {
    if (m_u = n.m_u) new (m_data) T{n.data()};
  }
  ZmLHash_Node &operator=(const ZmLHash_Node &n) {
    if (__builtin_expect(!!(this != &n), 1)) {
      if (m_u) data().~T();
      if (m_u = n.m_u) new (m_data) T{n.data()};
    }
    return *this;
  }

  ZmLHash_Node(ZmLHash_Node &&n) noexcept {
    if (m_u = n.m_u) new (m_data) T{ZuMv(n.data())};
  }
  ZmLHash_Node &operator=(ZmLHash_Node &&n) noexcept {
    if (__builtin_expect(!!(this != &n), 1)) {
      if (m_u) data().~T();
      if (m_u = n.m_u) new (m_data) T{ZuMv(n.data())};
    }
    return *this;
  }

private:
  template <typename P>
  void init(unsigned head, unsigned tail, unsigned next, P &&v) {
    if (!m_u)
      new (m_data) T{ZuFwd<P>(v)};
    else
      data() = ZuFwd<P>(v);
    m_u = (next << 3) | (head << 2) | (tail << 1) | 1U;
  }
  void null() {
    if (m_u) {
      data().~T();
      m_u = 0;
    }
  }

public:
  bool operator!() const { return !m_u; }
  operator const void *() const {
    return !*this ? reinterpret_cast<const void *>(0) :
		    static_cast<const void *>(this);
  }

  bool equals(const ZmLHash_Node &n) const {
    if (!n.m_u) return !m_u;
    if (!m_u) return false;
    return data().equals(n.data());
  }
  int cmp(const ZmLHash_Node &n) const {
    if (!n.m_u) return !m_u ? 0 : 1;
    if (!m_u) return -1;
    return data().cmp(n.data());
  }
  friend inline bool operator==(const ZmLHash_Node &l, const ZmLHash_Node &r) {
    return l.equals(r);
  }
  friend inline int operator<=>(const ZmLHash_Node &l, const ZmLHash_Node &r) {
    return l.cmp(r);
  }

private:
  bool head() const { return m_u & 4U; }
  void setHead() { m_u |= 4U; }
  void clrHead() { m_u &= ~4U; }
  bool tail() const { return m_u & 2U; }
  void setTail() { m_u |= 2U; }
  void clrTail() { m_u &= ~2U; }
  unsigned next() const { return m_u >> 3U; }
  void next(unsigned n) { m_u = (n << 3U) | (m_u & 7U); }

  decltype(auto) key() const & { return KeyAxor(data()); }
  decltype(auto) key() & { return KeyAxor(data()); }
  decltype(auto) key() && { return KeyAxor(ZuMv(data())); }

  decltype(auto) val() const & { return ValAxor(data()); }
  decltype(auto) val() & { return ValAxor(data()); }
  decltype(auto) val() && { return ValAxor(ZuMv(data())); }

  const auto &data() const & {
    ((m_u) ? void() :
	     ZmAssert_fail(
	       "m_u", "../../zm/src/zlib/ZmLHash.hh", 218, __PRETTY_FUNCTION__
	     ));
    const T *__attribute__((__may_alias__)) ptr =
      reinterpret_cast<const T *>(m_data);
    return *ptr;
  }
  auto &data() & {
    ((m_u) ? void() :
	     ZmAssert_fail(
	       "m_u", "../../zm/src/zlib/ZmLHash.hh", 223, __PRETTY_FUNCTION__
	     ));
    T *__attribute__((__may_alias__)) ptr = reinterpret_cast<T *>(m_data);
    return *ptr;
  }
  decltype(auto) data() && {
    ((m_u) ? void() :
	     ZmAssert_fail(
	       "m_u", "../../zm/src/zlib/ZmLHash.hh", 228, __PRETTY_FUNCTION__
	     ));
    T *__attribute__((__may_alias__)) ptr = reinterpret_cast<T *>(m_data);
    return ZuMv(*ptr);
  }

public:
  struct Traits : public ZuBaseTraits<ZmLHash_Node> {
    enum { IsPOD = ZuTraits<T>::IsPOD };
  };
  friend Traits ZuTraitsType(ZmLHash_Node *);

private:
  char m_data[sizeof(T)];
  uint32_t m_u = 0;
};

template <
  typename Hash, typename NTP, bool Local = NTP::Local,
  bool Static = bool(NTP::Static)>
class ZmLHash__;

template <typename Hash, typename NTP> class ZmLHash__<Hash, NTP, true, true> {
  using Lock = typename NTP::Lock;

public:
  static unsigned loadFactor_() { return 16; }
  static double loadFactor() { return 1.0; }

  unsigned count_() const { return m_count.load_(); }

protected:
  ZmAtomic<unsigned> m_count = 0;
  Lock m_lock;
};

template <typename Hash, typename NTP>
class ZmLHash__<Hash, NTP, false, true> :
  public ZmLHash__<Hash, NTP, true, true> { };

template <typename Hash, typename NTP> class ZmLHash__<Hash, NTP, true, false> {
  using Lock = typename NTP::Lock;

public:
  unsigned loadFactor_() const { return m_loadFactor; }
  double loadFactor() const { return double(m_loadFactor) / 16.0; }

  unsigned count_() const { return m_count.load_(); }

protected:
  ZmLHash__(const ZmHashParams &params) {
    double loadFactor = params.loadFactor();
    if (loadFactor < 0.5)
      loadFactor = 0.5;
    else if (loadFactor > 1.0)
      loadFactor = 1.0;
    m_loadFactor = unsigned(loadFactor * 16.0);
  }

  unsigned m_loadFactor = 0;
  ZmAtomic<unsigned> m_count = 0;
  Lock m_lock;
};

template <typename Hash, typename NTP>
class ZmLHash__<Hash, NTP, false, false> :
  public ZmAnyHash,
  public ZmLHash__<Hash, NTP, true, false> {
protected:
  ZmLHash__(ZuCSpan id, const ZmHashParams &params) :
    ZmLHash__<Hash, NTP, true, false>{params}, m_id{id} { }

  void init() { ZmHashMgr::add(this); }
  void final() { ZmHashMgr::del(this); }

  void telemetry(ZmHashTelemetry &data) const {
    data.id = m_id;
    static_cast<const Hash *>(this)->telemetry_(data);
  }

private:
  ZmIDString m_id;
};

template <typename Hash, typename T, typename NTP, unsigned Static>
class ZmLHash_ : public ZmLHash__<Hash, NTP> {
  using Base = ZmLHash__<Hash, NTP>;
  static constexpr auto KeyAxor = NTP::KeyAxor;
  static constexpr auto ValAxor = NTP::ValAxor;
  using Key = ZuRDecay<decltype(KeyAxor(ZuDeclVal<const T &>()))>;
  using Val = ZuRDecay<decltype(ValAxor(ZuDeclVal<const T &>()))>;
  using Cmp = typename NTP::template CmpT<Key>;
  using ValCmp = typename NTP::template ValCmpT<Val>;
  using HashFn = typename NTP::template HashFnT<Key>;
  using Node = ZmLHash_Node<T, KeyAxor, ValAxor>;
  using Ops = ZmLHash_Ops<Node>;

public:
  static constexpr unsigned bits() { return Static; }

protected:
  ZmLHash_() = default;

  void init() { Ops::initItems(m_table, 1U << Static); }
  void final() { Ops::destroyItems(m_table, 1U << Static); }
  void resize() { }
  static constexpr unsigned resized() { return 0; }

  Node m_table[1U << Static];
};

template <class Hash, typename T, typename NTP>
class ZmLHash_<Hash, T, NTP, 0> : public ZmLHash__<Hash, NTP> {
  using Base = ZmLHash__<Hash, NTP>;
  static constexpr auto KeyAxor = NTP::KeyAxor;
  static constexpr auto ValAxor = NTP::ValAxor;
  using Key = ZuRDecay<decltype(KeyAxor(ZuDeclVal<const T &>()))>;
  using Val = ZuRDecay<decltype(ValAxor(ZuDeclVal<const T &>()))>;
  using Cmp = typename NTP::template CmpT<Key>;
  using ValCmp = typename NTP::template ValCmpT<Val>;
  using HashFn = typename NTP::template HashFnT<Key>;
  using Node = ZmLHash_Node<T, KeyAxor, ValAxor>;
  using Ops = ZmLHash_Ops<Node>;
  enum { Local = NTP::Local };

public:
  unsigned bits() const { return m_bits; }

protected:
  template <typename _ = NTP, decltype(ZuIfT<_::Local>(), int()) = 0>
  ZmLHash_(const ZmHashParams &params) : Base{params}, m_bits{params.bits()} { }
  template <typename _ = NTP, decltype(ZuIfT<!_::Local>(), int()) = 0>
  ZmLHash_(ZuCSpan id, const ZmHashParams &params) :
    Base{id, params}, m_bits{params.bits()} { }

  void init() {
    unsigned size = 1U << m_bits;
    m_table = Ops::alloc(size);
    Ops::initItems(m_table, size);
    if constexpr (!Local) Base::init();
  }

  void final() {
    if constexpr (!Local) Base::final();
    Ops::destroyItems(m_table, 1U << m_bits);
    Ops::free(m_table);
  }

  void resize() {
    ++m_resized;
    ++m_bits;
    unsigned size = 1U << m_bits;
    Node *oldTable = m_table;
    m_table = Ops::alloc(size);
    Ops::initItems(m_table, size);
    for (unsigned i = 0; i < (size >> 1U); i++)
      if (!!oldTable[i]) {
	auto code = HashFn::hash(oldTable[i].key());
	static_cast<Hash *>(this)->add__(ZuMv(oldTable[i].data()), code);
      }
    Ops::destroyItems(oldTable, (size >> 1U));
    Ops::free(oldTable);
  }

  unsigned resized() const { return m_resized.load_(); }

  ZmAtomic<unsigned> m_resized = 0;
  unsigned m_bits;
  Node *m_table = nullptr;
};

template <typename T_, typename NTP = ZmLHash_Defaults>
class ZmLHash : public ZmLHash_<ZmLHash<T_, NTP>, T_, NTP, NTP::Static> {
  template <typename, typename, typename, unsigned> friend class ZmLHash_;

  friend class ZmLHash__<ZmLHash<T_, NTP>, NTP>;

  using Base = ZmLHash_<ZmLHash<T_, NTP>, T_, NTP, NTP::Static>;

public:
  using T = T_;
  static constexpr auto KeyAxor = NTP::KeyAxor;
  static constexpr auto ValAxor = NTP::ValAxor;
  using KeyRet = decltype(KeyAxor(ZuDeclVal<const T &>()));
  using ValRet = decltype(ValAxor(ZuDeclVal<const T &>()));
  using Key = ZuRDecay<KeyRet>;
  using Val = ZuRDecay<ValRet>;
  using Cmp = typename NTP::template CmpT<Key>;
  using ValCmp = typename NTP::template ValCmpT<Val>;
  using HashFn = typename NTP::template HashFnT<Key>;
  using Lock = typename NTP::Lock;
  static constexpr auto ID = NTP::ID;
  enum { Static = NTP::Static };

  using LockTraits = ZmLockTraits<Lock>;
  using Guard = ZmGuard<Lock>;
  using ReadGuard = ZmReadGuard<Lock>;

  using Node = ZmLHash_Node<T, KeyAxor, ValAxor>;
  using Ops = ZmLHash_Ops<Node>;

private:
  class CheckHashFn {
    using Small = char;
    struct Big {
      char _[2];
    };
    static Small test(const uint32_t &_);
    static Big test(const int &_);
    static Big test(...);

  public:
    CheckHashFn();
    enum _ {
      IsUInt32 = sizeof(test(HashFn::hash(ZuDeclVal<Key>()))) == sizeof(Small)
    };
  };
  static_assert((CheckHashFn::IsUInt32), "CheckHashFn::IsUInt32");

  using Base::m_count;
  using Base::m_lock;
  using Base::m_table;

public:
  using Base::bits;
  using Base::loadFactor_;
  using Base::loadFactor;
  using Base::resized;

private:
  const T *ptr(int slot) const {
    if (__builtin_expect(!!(slot >= 0), 1)) return &m_table[slot].data();
    return nullptr;
  }
  KeyRet key(int slot) const {
    if (__builtin_expect(!!(slot >= 0), 1)) return m_table[slot].key();
    return ZuNullRef<Key, Cmp>();
  }
  ValRet val(int slot) const {
    if (__builtin_expect(!!(slot >= 0), 1)) return m_table[slot].val();
    return ZuNullRef<Val, ValCmp>();
  }

protected:
  class Iterator_;
  friend Iterator_;
  class Iterator_ {
    using Hash = ZmLHash<T, NTP>;
    friend Hash;

    Iterator_(const Iterator_ &) = delete;
    Iterator_ &operator=(const Iterator_ &) = delete;

  protected:
    Hash &hash;
    int slot = -1;
    int next = -1;

  protected:
    Iterator_(Iterator_ &&) = default;
    Iterator_ &operator=(Iterator_ &&) = default;

    Iterator_(Hash &hash_) : hash{hash_} { }

    virtual void lock(Lock &l) = 0;
    virtual void unlock(Lock &l) = 0;

  public:
    void reset() { hash.startIterate(*this); }
    const T *iterate() { return hash.iterate(*this); }

    decltype(auto) iterateIKey() { return hash.iterateIKey(*this); }
    decltype(auto) iterateVal() { return hash.iterateVal(*this); }

    unsigned count() const { return hash.count_(); }

    bool operator!() const { return slot < 0; }
    operator const void *() const {
      return !*this ? reinterpret_cast<const void *>(0) :
		      static_cast<const void *>(this);
    }
  };

  template <typename> class KeyIterator_;
  template <typename> friend class KeyIterator_;
  template <typename IKey_> class KeyIterator_ : public Iterator_ {
    KeyIterator_(const KeyIterator_ &) = delete;
    KeyIterator_ &operator=(const KeyIterator_ &) = delete;

    using Hash = ZmLHash<T, NTP>;
    friend Hash;

    using Iterator_::hash;

  public:
    using IKey = IKey_;

  protected:
    IKey key;
    int prev;

  protected:
    KeyIterator_(KeyIterator_ &&) = default;
    KeyIterator_ &operator=(KeyIterator_ &&) = default;

    template <typename IKey__>
    KeyIterator_(Hash &hash_, IKey__ &&key_) :
      Iterator_{hash_}, key{ZuFwd<IKey__>(key_)}, prev{-1} { }

  public:
    void reset() { hash.startIterate(*this); }
    const T *iterate() { return hash.iterate(*this); }
    decltype(auto) iterateIKey() { return hash.iterateIKey(*this); }
    decltype(auto) iterateVal() { return hash.iterateVal(*this); }
  };

public:
  class Iterator : public Iterator_ {
    Iterator(const Iterator &) = delete;
    Iterator &operator=(const Iterator &) = delete;

    using Hash = ZmLHash<T, NTP>;
    friend Hash;

    using Base = Iterator_;
    using Base::hash;

    void lock(Lock &l) { LockTraits::lock(l); }
    void unlock(Lock &l) { LockTraits::unlock(l); }

  public:
    Iterator(Iterator &&) = default;
    Iterator &operator=(Iterator &&) = default;

    Iterator(Hash &hash_) : Base{hash_} { hash.startIterate(*this); }
    ~Iterator() { hash.endIterate(*this); }
    void del() { hash.delIterate(*this); }
  };

  class ReadIterator : public Iterator_ {
    ReadIterator(const ReadIterator &) = delete;
    ReadIterator &operator=(const ReadIterator &) = delete;

    using Hash = ZmLHash<T, NTP>;
    friend Hash;

    using Base = Iterator_;
    using Base::hash;

    void lock(Lock &l) { LockTraits::readlock(l); }
    void unlock(Lock &l) { LockTraits::readunlock(l); }

  public:
    ReadIterator(ReadIterator &&) = default;
    ReadIterator &operator=(ReadIterator &&) = default;

    ReadIterator(const Hash &hash_) : Base{const_cast<Hash &>(hash_)} {
      const_cast<Hash &>(hash).startIterate(*this);
    }
    ~ReadIterator() { hash.endIterate(*this); }
  };

  template <typename IKey_> class KeyIterator : public KeyIterator_<IKey_> {
    KeyIterator(const KeyIterator &) = delete;
    KeyIterator &operator=(const KeyIterator &) = delete;

    using Hash = ZmLHash<T, NTP>;
    friend Hash;

    using Base = KeyIterator_<IKey_>;
    using typename Base::IKey;
    using Base::key;
    using Base::hash;

    void lock(Lock &l) { LockTraits::lock(l); }
    void unlock(Lock &l) { LockTraits::unlock(l); }

  public:
    KeyIterator(KeyIterator &&) = default;
    KeyIterator &operator=(KeyIterator &&) = default;

    template <typename IKey__>
    KeyIterator(Hash &hash_, IKey__ &&key_) : Base{hash_, ZuFwd<IKey__>(key_)} {
      hash.startIterate(*this);
    }
    ~KeyIterator() { hash.endIterate(*this); }
    void del() { hash.delIterate(*this); }
  };

  template <typename IKey_> class ReadKeyIterator : public KeyIterator_<IKey_> {
    ReadKeyIterator(const ReadKeyIterator &) = delete;
    ReadKeyIterator &operator=(const ReadKeyIterator &) = delete;

    using Hash = ZmLHash<T, NTP>;
    friend Hash;

    using Base = KeyIterator_<IKey_>;
    using typename Base::IKey;
    using Base::key;
    using Base::hash;

    void lock(Lock &l) { LockTraits::readlock(l); }
    void unlock(Lock &l) { LockTraits::readunlock(l); }

  public:
    ReadKeyIterator(ReadKeyIterator &&) = default;
    ReadKeyIterator &operator=(ReadKeyIterator &&) = default;

    template <typename IKey__>
    ReadKeyIterator(const Hash &hash_, IKey__ &&key_) :
      Base{const_cast<Hash &>(hash_), ZuFwd<IKey__>(key_)} {
      const_cast<Hash &>(hash).startIterate(*this);
    }
    ~ReadKeyIterator() { hash.endIterate(*this); }
  };

  template <typename _ = NTP, decltype(ZuIfT<bool(_::Static)>(), int()) = 0>
  ZmLHash() : Base{} { }

  template <
    typename _ = NTP, decltype(ZuIfT<_::Local && !_::Static>(), int()) = 0>
  ZmLHash() : Base{ZmHashParams{ID()}} {
    Base::init();
  }
  template <
    typename _ = NTP, decltype(ZuIfT<_::Local && !_::Static>(), int()) = 0>
  ZmLHash(const ZmHashParams &params) : Base{params} {
    Base::init();
  }

  template <
    typename _ = NTP, decltype(ZuIfT<!_::Local && !_::Static>(), int()) = 0>
  ZmLHash() : Base{ID(), ZmHashParams{ID()}} {
    Base::init();
  }

  template <
    typename _ = NTP, decltype(ZuIfT<!_::Local && !_::Static>(), int()) = 0>
  ZmLHash(ZuCSpan id) : Base{id, ZmHashParams{id}} {
    Base::init();
  }

  template <
    typename _ = NTP, decltype(ZuIfT<!_::Local && !_::Static>(), int()) = 0>
  ZmLHash(const ZmHashParams &params) : Base{ID(), params} {
    Base::init();
  }

  template <
    typename _ = NTP, decltype(ZuIfT<!_::Local && !_::Static>(), int()) = 0>
  ZmLHash(ZuCSpan id, const ZmHashParams &params) : Base{id, params} {
    Base::init();
  }

  ZmLHash(const ZmLHash &) = delete;
  ZmLHash &operator=(const ZmLHash &) = delete;
  ZmLHash(ZmLHash &&) = delete;
  ZmLHash &operator=(ZmLHash &&) = delete;

  ~ZmLHash() { Base::final(); }

  unsigned size() const { return double(uint64_t(1) << bits()) * loadFactor(); }

  template <typename P> const T *add(P &&data) {
    uint32_t code = HashFn::hash(KeyAxor(data));
    Guard guard(m_lock);
    return ptr(add_(ZuFwd<P>(data), code));
  }

  template <typename P0, typename P1> const T *add(P0 &&p0, P1 &&p1) {
    return add(ZuFwdTuple(ZuFwd<P0>(p0), ZuFwd<P1>(p1)));
  }

private:
  int alloc(unsigned slot) {
    unsigned size = 1U << bits();
    for (unsigned i = 1; i < size; i++) {
      unsigned probe = (slot + i) & (size - 1);
      if (!m_table[probe]) return probe;
    }
    return -1;
  }
  int prev(unsigned slot) {
    unsigned size = 1U << bits();
    for (unsigned i = 1; i < size; i++) {
      unsigned prev = (slot + size - i) & (size - 1);
      if (m_table[prev] && !m_table[prev].tail() &&
	  m_table[prev].next() == slot)
	return prev;
    }
    return -1;
  }
  template <typename P> int add_(P &&data, uint32_t code) {
    unsigned size = 1U << bits();

    unsigned count = m_count.load_();
    if (count < (1U << 28) && ((count << 4) >> bits()) >= loadFactor_()) {
      Base::resize();
      size = 1U << bits();
    }

    if (count >= size) return -1;

    m_count.store_(count + 1);

    return add__(ZuFwd<P>(data), code);
  }
  template <typename P> int add__(P &&data, uint32_t code) {
    unsigned size = 1U << bits();
    unsigned slot = code & (size - 1);

    if (!m_table[slot]) {
      m_table[slot].init(1, 1, 0, ZuFwd<P>(data));
      return slot;
    }

    int vacant = alloc(slot);
    if (vacant < 0) return -1;

    if (m_table[slot].head()) {
      (m_table[vacant] = ZuMv(m_table[slot])).clrHead();
      m_table[slot].init(1, 0, vacant, ZuFwd<P>(data));

      return slot;
    }

    int prev = this->prev(slot);
    if (prev < 0) return -1;

    m_table[vacant] = ZuMv(m_table[slot]);
    m_table[prev].next(vacant);
    m_table[slot].init(1, 1, 0, ZuFwd<P>(data));

    return slot;
  }

  template <typename U, typename V = Key>
  struct IsKey : public ZuBool<ZuInspect<U, V>::Converts> { };
  template <typename U, typename R = void>
  using MatchKey = ZuIfT<IsKey<U>{}, R>;
  template <typename U, typename V = T>
  struct IsData : public ZuBool<!IsKey<U>{} && ZuInspect<U, V>::Converts> { };
  template <typename U, typename R = void>
  using MatchData = ZuIfT<IsData<U>{}, R>;

  template <typename P> inline static auto matchKey(const P &key) {
    return [&key](const Node *node) -> bool {
      return Cmp::equals(node->Node::key(), key);
    };
  }
  template <typename P> inline static auto matchData(const P &data) {
    return
      [&data](const Node *node) -> bool { return node->Node::data() == data; };
  }

public:
  template <typename P> MatchKey<P, bool> exists(const P &key) const {
    uint32_t code = HashFn::hash(key);
    ReadGuard guard(const_cast<Lock &>(m_lock));
    return find_(matchKey(key), code) >= 0;
  }
  template <typename P> MatchData<P, bool> exists(const P &data) const {
    uint32_t code = HashFn::hash(KeyAxor(data));
    ReadGuard guard(const_cast<Lock &>(m_lock));
    return find_(matchData(data), code) >= 0;
  }

  template <typename P> MatchKey<P, const T *> find(const P &key) const {
    uint32_t code = HashFn::hash(key);
    ReadGuard guard(const_cast<Lock &>(m_lock));
    return ptr(find_(matchKey(key), code));
  }
  template <typename P> MatchData<P, const T *> find(const P &data) const {
    uint32_t code = HashFn::hash(KeyAxor(data));
    ReadGuard guard(const_cast<Lock &>(m_lock));
    return ptr(find_(matchData(data), code));
  }
  template <typename P0, typename P1> const T *find(P0 &&p0, P1 &&p1) {
    return find(ZuFwdTuple(ZuFwd<P0>(p0), ZuFwd<P1>(p1)));
  }

  template <typename P> MatchKey<P, Key> findKey(const P &key) const {
    uint32_t code = HashFn::hash(key);
    ReadGuard guard(const_cast<Lock &>(m_lock));
    return key(find_(matchKey(key), code));
  }
  template <typename P> MatchData<P, Key> findKey(const P &data) const {
    uint32_t code = HashFn::hash(KeyAxor(data));
    ReadGuard guard(const_cast<Lock &>(m_lock));
    return key(find_(matchData(data), code));
  }
  template <typename P0, typename P1> Key findKey(P0 &&p0, P1 &&p1) {
    return findKey(ZuFwdTuple(ZuFwd<P0>(p0), ZuFwd<P1>(p1)));
  }

  template <typename P> MatchKey<P, Val> findVal(const P &key) const {
    uint32_t code = HashFn::hash(key);
    ReadGuard guard(const_cast<Lock &>(m_lock));
    return val(find_(matchKey(key), code));
  }
  template <typename P> MatchData<P, Val> findVal(const P &data) const {
    uint32_t code = HashFn::hash(KeyAxor(data));
    ReadGuard guard(const_cast<Lock &>(m_lock));
    return val(find_(matchData(data), code));
  }
  template <typename P0, typename P1> Val findVal(P0 &&p0, P1 &&p1) {
    return findVal(ZuFwdTuple(ZuFwd<P0>(p0), ZuFwd<P1>(p1)));
  }

private:
  template <typename Match> int find_(Match match, uint32_t code) const {
    unsigned size = 1U << bits();
    unsigned slot = code & (size - 1);

    if (!m_table[slot] || !m_table[slot].head()) { return -1; }
    for (;;) {
      if (match(&m_table[slot])) { return slot; }
      if (m_table[slot].tail()) { return -1; }
      slot = m_table[slot].next();
    }
  }
  template <typename Match> int findPrev_(Match match, uint32_t code) const {
    unsigned size = 1U << bits();
    unsigned slot = code & (size - 1);

    if (!m_table[slot] || !m_table[slot].head()) { return -1; }
    int prev = -1;
    for (;;) {
      if (match(&m_table[slot])) {
	prev = prev < 0 ? (-int(slot) - 2) : prev;

	return prev;
      }
      if (m_table[slot].tail()) { return -1; }
      prev = slot, slot = m_table[slot].next();
    }
  }

public:
  template <typename P> const T *findAdd(P &&data) {
    uint32_t code = HashFn::hash(KeyAxor(data));
    Guard guard(m_lock);
    return this->ptr(findAdd__(ZuFwd<P>(data), code));
  }
  template <typename P0, typename P1> const T *findAdd(P0 &&p0, P1 &&p1) {
    return findAdd(ZuFwdTuple(ZuFwd<P0>(p0), ZuFwd<P1>(p1)));
  }

private:
  template <typename P> int findAdd__(P &&data, uint32_t code) {
    unsigned size = 1U << bits();
    unsigned slot = code & (size - 1);

    if (!!m_table[slot] && m_table[slot].head())
      for (;;) {
	if (m_table[slot].data() == data) return slot;
	if (m_table[slot].tail()) break;
	slot = m_table[slot].next();
      }
    return add_(ZuFwd<P>(data), code);
  }

public:
  template <typename P> MatchKey<P> del(const P &key) {
    uint32_t code = HashFn::hash(key);
    Guard guard(m_lock);
    del_(findPrev_(matchKey(key), code));
  }
  template <typename P> MatchData<P> del(const P &data) {
    uint32_t code = HashFn::hash(KeyAxor(data));
    Guard guard(m_lock);
    del_(findPrev_(matchData(data), code));
  }
  template <typename P0, typename P1> void del(P0 &&p0, P1 &&p1) {
    del(ZuFwdTuple(ZuFwd<P0>(p0), ZuFwd<P1>(p1)));
  }

  template <typename P> MatchKey<P, Key> delKey(const P &key) {
    uint32_t code = HashFn::hash(key);
    Guard guard(m_lock);
    return delKey_(findPrev_(matchKey(key), code));
  }
  template <typename P> MatchData<P, Key> delKey(const P &data) {
    uint32_t code = HashFn::hash(KeyAxor(data));
    Guard guard(m_lock);
    return delKey_(findPrev_(matchData(data), code));
  }
  template <typename P0, typename P1> Key delKey(P0 &&p0, P1 &&p1) {
    return delKey(ZuFwdTuple(ZuFwd<P0>(p0), ZuFwd<P1>(p1)));
  }

  template <typename P> MatchKey<P, Val> delVal(const P &key) {
    uint32_t code = HashFn::hash(key);
    Guard guard(m_lock);
    return delVal_(findPrev_(matchKey(key), code));
  }
  template <typename P> MatchData<P, Val> delVal(const P &data) {
    uint32_t code = HashFn::hash(KeyAxor(data));
    Guard guard(m_lock);
    return delVal_(findPrev_(matchData(data), code));
  }
  template <typename P0, typename P1> Val delVal(P0 &&p0, P1 &&p1) {
    return delVal(ZuFwdTuple(ZuFwd<P0>(p0), ZuFwd<P1>(p1)));
  }

private:
  void del__(int prev) {
    int slot;

    if (prev < 0)
      slot = (-prev - 2), prev = -1;
    else
      slot = m_table[prev].next();

    if (!m_table[slot]) { return; }

    if (unsigned count = m_count.load_()) m_count.store_(count - 1);

    if (m_table[slot].head()) {
      ((prev < 0) ?
	 void() :
	 ZmAssert_fail(
	   "prev < 0", "../../zm/src/zlib/ZmLHash.hh", 1022, __PRETTY_FUNCTION__
	 ));
      if (m_table[slot].tail()) {
	m_table[slot].null();
	return;
      }
      unsigned next = m_table[slot].next();
      (m_table[slot] = ZuMv(m_table[next])).setHead();

      m_table[next].null();

      return;
    }

    if (m_table[slot].tail()) {
      ((prev >= 0) ? void() :
		     ZmAssert_fail(
		       "prev >= 0", "../../zm/src/zlib/ZmLHash.hh", 1037,
		       __PRETTY_FUNCTION__
		     ));
      if (prev >= 0) m_table[prev].setTail();

      m_table[slot].null();

      return;
    }

    unsigned next = m_table[slot].next();
    m_table[slot] = ZuMv(m_table[next]);

    m_table[next].null();
  }

  void del_(int prev) {
    if (prev == -1) return;
    del__(prev);
  }
  Key delKey_(int prev) {
    if (prev == -1) return ZuNullRef<Key, Cmp>();
    int slot = prev < 0 ? (-prev - 2) : m_table[prev].next();
    Key key{ZuMv(m_table[slot]).key()};
    del__(prev);
    return key;
  }
  Key delVal_(int prev) {
    if (prev == -1) return ZuNullRef<Key, Cmp>();
    int slot = prev < 0 ? (-prev - 2) : m_table[prev].next();
    Val val{ZuMv(m_table[slot]).val()};
    del__(prev);
    return val;
  }

public:
  void clean() {
    unsigned size = 1U << bits();
    Guard guard(m_lock);

    for (unsigned i = 0; i < size; i++) m_table[i].null();
    m_count = 0;
  }

  auto iterator() { return Iterator{*this}; }
  template <typename P> auto iterator(P key) {
    return KeyIterator<P>{*this, ZuMv(key)};
  }

  auto readIterator() const { return ReadIterator{*this}; }
  template <typename P> auto readIterator(P key) const {
    return ReadKeyIterator<P>{*this, ZuMv(key)};
  }

private:
  void startIterate(Iterator_ &iterator) {
    iterator.lock(m_lock);
    iterator.slot = -1;
    int next = -1;
    int size = 1 << bits();
    while (++next < size)
      if (!!m_table[next]) {
	iterator.next = next;
	return;
      }
    iterator.next = -1;
  }
  template <typename IKey> void startIterate(KeyIterator_<IKey> &iterator) {
    iterator.lock(m_lock);
    iterator.slot = -1;
    int prev = findPrev_(matchKey(iterator.key), HashFn::hash(iterator.key));
    if (prev == -1) {
      iterator.next = iterator.prev = -1;

      return;
    }
    if (prev < 0)
      iterator.next = -prev - 2, iterator.prev = -1;
    else
      iterator.next = m_table[iterator.prev = prev].next();
  }
  void iterate_(Iterator_ &iterator) {
    int next = iterator.next;
    if (next < 0) {
      iterator.slot = -1;
      return;
    }
    iterator.slot = next;
    int size = 1 << bits();
    while (++next < size)
      if (!!m_table[next]) {
	iterator.next = next;
	return;
      }
    iterator.next = -1;
  }
  template <typename IKey> void iterate_(KeyIterator_<IKey> &iterator) {
    iterator.prev = iterator.slot;
    iterator.slot = iterator.next;
    int next = iterator.next;
    if (next < 0) {
end:
      iterator.slot = iterator.next = -1;

      return;
    }

    while (!Cmp::equals(m_table[next].key(), iterator.key)) {
      if (m_table[next].tail()) goto end;
      iterator.prev = next;
      next = m_table[next].next();
    }

    iterator.slot = next;
    iterator.next = m_table[next].tail() ? -1 : m_table[next].next();
  }
  template <typename I> const T *iterate(I &iterator) {
    iterate_(iterator);
    return ptr(iterator.slot);
  }
  template <typename I> decltype(auto) iterateKey(I &iterator) {
    iterate_(iterator);
    return key(iterator.slot);
  }
  template <typename I> decltype(auto) iterateVal(I &iterator) {
    iterate_(iterator);
    return val(iterator.slot);
  }
  void endIterate(Iterator_ &iterator) {
    iterator.unlock(m_lock);
    iterator.slot = iterator.next = -1;
  }
  void delIterate(Iterator_ &iterator) {
    int slot = iterator.slot;
    if (slot < 0) return;
    bool advanceRegardless =
      !m_table[slot].tail() && int(m_table[slot].next()) < slot;
    del__(m_table[slot].head() ? (-slot - 2) : prev(slot));
    if (!advanceRegardless && !!m_table[slot]) iterator.next = slot;
    iterator.slot = -1;
  }
  template <typename IKey> void delIterate(KeyIterator_<IKey> &iterator) {
    int slot = iterator.slot;
    if (slot < 0) return;
    del__(iterator.prev < 0 ? (-slot - 2) : iterator.prev);
    iterator.slot = -1;
    if (!m_table[slot]) return;
    for (;;) {
      if (Cmp::equals(m_table[slot].key(), iterator.key)) {
	iterator.next = slot;
	return;
      }
      if (m_table[slot].tail()) break;
      slot = m_table[slot].next();
    }
    iterator.next = -1;
  }

private:
  void telemetry_(ZmHashTelemetry &data) const {
    data.addr = reinterpret_cast<uintptr_t>(this);
    data.loadFactor = loadFactor();
    unsigned count = m_count.load_();
    unsigned bits = this->bits();
    data.effLoadFactor = double(count) / (1 << bits);
    data.nodeSize = sizeof(Node);
    data.count = count;
    data.resized = resized();
    data.bits = bits;
    data.cBits = 0;
    data.linear = true;
    data.shadow = false;
  }
};

template <typename P0, typename P1, typename NTP = ZmLHash_Defaults>
using ZmLHashKV = ZmLHash<
  ZuTuple<P0, P1>, ZmLHashKeyVal<ZuTupleAxor<0>(), ZuTupleAxor<1>(), NTP>>;

extern "C" {

  struct real_pcre8_or_16;
  typedef struct real_pcre8_or_16 pcre;

  struct real_pcre8_or_16;
  typedef struct real_pcre8_or_16 pcre16;

  struct real_pcre32;
  typedef struct real_pcre32 pcre32;

  struct real_pcre_jit_stack;
  typedef struct real_pcre_jit_stack pcre_jit_stack;

  struct real_pcre16_jit_stack;
  typedef struct real_pcre16_jit_stack pcre16_jit_stack;

  struct real_pcre32_jit_stack;
  typedef struct real_pcre32_jit_stack pcre32_jit_stack;

  typedef struct pcre_extra {
    unsigned long int flags;
    void *study_data;
    unsigned long int match_limit;
    void *callout_data;
    const unsigned char *tables;
    unsigned long int match_limit_recursion;
    unsigned char **mark;
    void *executable_jit;
  } pcre_extra;

  typedef struct pcre16_extra {
    unsigned long int flags;
    void *study_data;
    unsigned long int match_limit;
    void *callout_data;
    const unsigned char *tables;
    unsigned long int match_limit_recursion;
    unsigned short **mark;
    void *executable_jit;
  } pcre16_extra;

  typedef struct pcre32_extra {
    unsigned long int flags;
    void *study_data;
    unsigned long int match_limit;
    void *callout_data;
    const unsigned char *tables;
    unsigned long int match_limit_recursion;
    unsigned int **mark;
    void *executable_jit;
  } pcre32_extra;

  typedef struct pcre_callout_block {
    int version;

    int callout_number;
    int *offset_vector;
    const char *subject;
    int subject_length;
    int start_match;
    int current_position;
    int capture_top;
    int capture_last;
    void *callout_data;

    int pattern_position;
    int next_item_length;

    const unsigned char *mark;

  } pcre_callout_block;

  typedef struct pcre16_callout_block {
    int version;

    int callout_number;
    int *offset_vector;
    const unsigned short *subject;
    int subject_length;
    int start_match;
    int current_position;
    int capture_top;
    int capture_last;
    void *callout_data;

    int pattern_position;
    int next_item_length;

    const unsigned short *mark;

  } pcre16_callout_block;

  typedef struct pcre32_callout_block {
    int version;

    int callout_number;
    int *offset_vector;
    const unsigned int *subject;
    int subject_length;
    int start_match;
    int current_position;
    int capture_top;
    int capture_last;
    void *callout_data;

    int pattern_position;
    int next_item_length;

    const unsigned int *mark;

  } pcre32_callout_block;

  extern "C" void *(*pcre_malloc)(size_t);
  extern "C" void (*pcre_free)(void *);
  extern "C" void *(*pcre_stack_malloc)(size_t);
  extern "C" void (*pcre_stack_free)(void *);
  extern "C" int (*pcre_callout)(pcre_callout_block *);
  extern "C" int (*pcre_stack_guard)(void);

  extern "C" void *(*pcre16_malloc)(size_t);
  extern "C" void (*pcre16_free)(void *);
  extern "C" void *(*pcre16_stack_malloc)(size_t);
  extern "C" void (*pcre16_stack_free)(void *);
  extern "C" int (*pcre16_callout)(pcre16_callout_block *);
  extern "C" int (*pcre16_stack_guard)(void);

  extern "C" void *(*pcre32_malloc)(size_t);
  extern "C" void (*pcre32_free)(void *);
  extern "C" void *(*pcre32_stack_malloc)(size_t);
  extern "C" void (*pcre32_stack_free)(void *);
  extern "C" int (*pcre32_callout)(pcre32_callout_block *);
  extern "C" int (*pcre32_stack_guard)(void);

  typedef pcre_jit_stack *(*pcre_jit_callback)(void *);
  typedef pcre16_jit_stack *(*pcre16_jit_callback)(void *);
  typedef pcre32_jit_stack *(*pcre32_jit_callback)(void *);

  extern "C" pcre *
  pcre_compile(const char *, int, const char **, int *, const unsigned char *);
  extern "C" pcre16 *
  pcre16_compile(const unsigned short *, int, const char **, int *, const unsigned char *);
  extern "C" pcre32 *
  pcre32_compile(const unsigned int *, int, const char **, int *, const unsigned char *);
  extern "C" pcre *
  pcre_compile2(const char *, int, int *, const char **, int *, const unsigned char *);
  extern "C" pcre16 *
  pcre16_compile2(const unsigned short *, int, int *, const char **, int *, const unsigned char *);
  extern "C" pcre32 *
  pcre32_compile2(const unsigned int *, int, int *, const char **, int *, const unsigned char *);
  extern "C" int pcre_config(int, void *);
  extern "C" int pcre16_config(int, void *);
  extern "C" int pcre32_config(int, void *);
  extern "C" int pcre_copy_named_substring(
    const pcre *, const char *, int *, int, const char *, char *, int
  );
  extern "C" int pcre16_copy_named_substring(
    const pcre16 *, const unsigned short *, int *, int, const unsigned short *,
    unsigned short *, int
  );
  extern "C" int pcre32_copy_named_substring(
    const pcre32 *, const unsigned int *, int *, int, const unsigned int *,
    unsigned int *, int
  );
  extern "C" int
  pcre_copy_substring(const char *, int *, int, int, char *, int);
  extern "C" int pcre16_copy_substring(
    const unsigned short *, int *, int, int, unsigned short *, int
  );
  extern "C" int pcre32_copy_substring(
    const unsigned int *, int *, int, int, unsigned int *, int
  );
  extern "C" int pcre_dfa_exec(
    const pcre *, const pcre_extra *, const char *, int, int, int, int *, int,
    int *, int
  );
  extern "C" int pcre16_dfa_exec(
    const pcre16 *, const pcre16_extra *, const unsigned short *, int, int, int,
    int *, int, int *, int
  );
  extern "C" int pcre32_dfa_exec(
    const pcre32 *, const pcre32_extra *, const unsigned int *, int, int, int,
    int *, int, int *, int
  );
  extern "C" int pcre_exec(
    const pcre *, const pcre_extra *, const char *, int, int, int, int *, int
  );
  extern "C" int pcre16_exec(
    const pcre16 *, const pcre16_extra *, const unsigned short *, int, int, int,
    int *, int
  );
  extern "C" int pcre32_exec(
    const pcre32 *, const pcre32_extra *, const unsigned int *, int, int, int,
    int *, int
  );
  extern "C" int
  pcre_jit_exec(const pcre *, const pcre_extra *, const char *, int, int, int, int *, int, pcre_jit_stack *);
  extern "C" int
  pcre16_jit_exec(const pcre16 *, const pcre16_extra *, const unsigned short *, int, int, int, int *, int, pcre16_jit_stack *);
  extern "C" int
  pcre32_jit_exec(const pcre32 *, const pcre32_extra *, const unsigned int *, int, int, int, int *, int, pcre32_jit_stack *);
  extern "C" void pcre_free_substring(const char *);
  extern "C" void pcre16_free_substring(const unsigned short *);
  extern "C" void pcre32_free_substring(const unsigned int *);
  extern "C" void pcre_free_substring_list(const char **);
  extern "C" void pcre16_free_substring_list(const unsigned short **);
  extern "C" void pcre32_free_substring_list(const unsigned int **);
  extern "C" int pcre_fullinfo(const pcre *, const pcre_extra *, int, void *);
  extern "C" int
  pcre16_fullinfo(const pcre16 *, const pcre16_extra *, int, void *);
  extern "C" int
  pcre32_fullinfo(const pcre32 *, const pcre32_extra *, int, void *);
  extern "C" int
  pcre_get_named_substring(const pcre *, const char *, int *, int, const char *, const char **);
  extern "C" int
  pcre16_get_named_substring(const pcre16 *, const unsigned short *, int *, int, const unsigned short *, const unsigned short **);
  extern "C" int
  pcre32_get_named_substring(const pcre32 *, const unsigned int *, int *, int, const unsigned int *, const unsigned int **);
  extern "C" int pcre_get_stringnumber(const pcre *, const char *);
  extern "C" int
  pcre16_get_stringnumber(const pcre16 *, const unsigned short *);
  extern "C" int pcre32_get_stringnumber(const pcre32 *, const unsigned int *);
  extern "C" int
  pcre_get_stringtable_entries(const pcre *, const char *, char **, char **);
  extern "C" int
  pcre16_get_stringtable_entries(const pcre16 *, const unsigned short *, unsigned short **, unsigned short **);
  extern "C" int
  pcre32_get_stringtable_entries(const pcre32 *, const unsigned int *, unsigned int **, unsigned int **);
  extern "C" int
  pcre_get_substring(const char *, int *, int, int, const char **);
  extern "C" int
  pcre16_get_substring(const unsigned short *, int *, int, int, const unsigned short **);
  extern "C" int
  pcre32_get_substring(const unsigned int *, int *, int, int, const unsigned int **);
  extern "C" int
  pcre_get_substring_list(const char *, int *, int, const char ***);
  extern "C" int
  pcre16_get_substring_list(const unsigned short *, int *, int, const unsigned short ***);
  extern "C" int
  pcre32_get_substring_list(const unsigned int *, int *, int, const unsigned int ***);
  extern "C" const unsigned char *pcre_maketables(void);
  extern "C" const unsigned char *pcre16_maketables(void);
  extern "C" const unsigned char *pcre32_maketables(void);
  extern "C" int pcre_refcount(pcre *, int);
  extern "C" int pcre16_refcount(pcre16 *, int);
  extern "C" int pcre32_refcount(pcre32 *, int);
  extern "C" pcre_extra *pcre_study(const pcre *, int, const char **);
  extern "C" pcre16_extra *pcre16_study(const pcre16 *, int, const char **);
  extern "C" pcre32_extra *pcre32_study(const pcre32 *, int, const char **);
  extern "C" void pcre_free_study(pcre_extra *);
  extern "C" void pcre16_free_study(pcre16_extra *);
  extern "C" void pcre32_free_study(pcre32_extra *);
  extern "C" const char *pcre_version(void);
  extern "C" const char *pcre16_version(void);
  extern "C" const char *pcre32_version(void);

  extern "C" int
  pcre_pattern_to_host_byte_order(pcre *, pcre_extra *, const unsigned char *);
  extern "C" int
  pcre16_pattern_to_host_byte_order(pcre16 *, pcre16_extra *, const unsigned char *);
  extern "C" int
  pcre32_pattern_to_host_byte_order(pcre32 *, pcre32_extra *, const unsigned char *);
  extern "C" int pcre16_utf16_to_host_byte_order(
    unsigned short *, const unsigned short *, int, int *, int
  );
  extern "C" int pcre32_utf32_to_host_byte_order(
    unsigned int *, const unsigned int *, int, int *, int
  );

  extern "C" pcre_jit_stack *pcre_jit_stack_alloc(int, int);
  extern "C" pcre16_jit_stack *pcre16_jit_stack_alloc(int, int);
  extern "C" pcre32_jit_stack *pcre32_jit_stack_alloc(int, int);
  extern "C" void pcre_jit_stack_free(pcre_jit_stack *);
  extern "C" void pcre16_jit_stack_free(pcre16_jit_stack *);
  extern "C" void pcre32_jit_stack_free(pcre32_jit_stack *);
  extern "C" void
  pcre_assign_jit_stack(pcre_extra *, pcre_jit_callback, void *);
  extern "C" void
  pcre16_assign_jit_stack(pcre16_extra *, pcre16_jit_callback, void *);
  extern "C" void
  pcre32_assign_jit_stack(pcre32_extra *, pcre32_jit_callback, void *);
  extern "C" void pcre_jit_free_unused_memory(void);
  extern "C" void pcre16_jit_free_unused_memory(void);
  extern "C" void pcre32_jit_free_unused_memory(void);
}

struct ZtRegexError {
  const char *message = 0;
  int code;
  int offset;

  static const char *strerror(int);

  template <typename S> void print(S &s) const {
    if (message) {
      s << "ZtRegex Error \"" << message << "\" (" << code
	<< ")"
	   " at offset "
	<< offset;
    } else {
      s << "ZtRegex pcre_exec() Error: " << strerror(code);
    }
  }
  friend ZuPrintFn ZuPrintType(ZtRegexError *);
};

class ZtRegex {
  ZtRegex(const ZtRegex &) = delete;
  ZtRegex &operator=(const ZtRegex &) = delete;

  ZtRegex();

public:
  using Capture = ZuCSpan;
  using Captures = ZtArray<Capture>;

  ZtRegex(
    const char *pattern,
    int options =

      0x00000800

  );

  ZtRegex(ZtRegex &&r) :
    m_regex(r.m_regex), m_extra(r.m_extra), m_captureCount(r.m_captureCount) {
    r.m_regex = 0;
    r.m_extra = 0;
    r.m_captureCount = 0;
  }
  ZtRegex &operator=(ZtRegex &&r) {
    if (this == &r) return *this;
    m_regex = r.m_regex;
    m_extra = r.m_extra;
    m_captureCount = r.m_captureCount;
    r.m_regex = 0;
    r.m_extra = 0;
    r.m_captureCount = 0;
    return *this;
  }

  ~ZtRegex();

  void study();

  unsigned captureCount() const { return m_captureCount; }

  unsigned m(ZuCSpan s, unsigned offset = 0, int options = 0) const {
    auto ovector_size = (unsigned(m_captureCount) * 3);
    auto ovector_ = ZmAlloc_<unsigned>{static_cast<unsigned *>(
      !(ovector_size) ?
	nullptr :
	(((ZmStackAvail() >> 1) < ((ovector_size) * sizeof(unsigned))) ?
	   Zm::alignedAlloc<alignof(unsigned)>(
	     (ovector_size) * sizeof(unsigned)
	   ) :
	   __builtin_alloca_with_align(
	     (ovector_size) * sizeof(unsigned), (alignof(unsigned)) << 3
	   ))
    )};
    ZtArray<unsigned> ovector(&ovector_[0], 0, ovector_size, false);
    return exec(s, offset, options, ovector);
  }
  unsigned
  m(ZuCSpan s, Captures &captures, unsigned offset = 0, int options = 0) const {
    auto ovector_size = (unsigned(m_captureCount) * 3);
    auto ovector_ = ZmAlloc_<unsigned>{static_cast<unsigned *>(
      !(ovector_size) ?
	nullptr :
	(((ZmStackAvail() >> 1) < ((ovector_size) * sizeof(unsigned))) ?
	   Zm::alignedAlloc<alignof(unsigned)>(
	     (ovector_size) * sizeof(unsigned)
	   ) :
	   __builtin_alloca_with_align(
	     (ovector_size) * sizeof(unsigned), (alignof(unsigned)) << 3
	   ))
    )};
    ZtArray<unsigned> ovector(&ovector_[0], 0, ovector_size, false);
    unsigned i = exec(s, offset, options, ovector);
    if (i) capture(s, ovector, captures);
    return i;
  }

  template <typename S>
  ZuIfT<ZuInspect<ZtString, S>::Is || ZuInspect<ZtArray<char>, S>::Is, unsigned>
  s(S &s, ZuCSpan r, unsigned offset = 0, int options = 0) const {
    auto ovector_size = (unsigned(m_captureCount) * 3);
    auto ovector_ = ZmAlloc_<unsigned>{static_cast<unsigned *>(
      !(ovector_size) ?
	nullptr :
	(((ZmStackAvail() >> 1) < ((ovector_size) * sizeof(unsigned))) ?
	   Zm::alignedAlloc<alignof(unsigned)>(
	     (ovector_size) * sizeof(unsigned)
	   ) :
	   __builtin_alloca_with_align(
	     (ovector_size) * sizeof(unsigned), (alignof(unsigned)) << 3
	   ))
    )};
    ZtArray<unsigned> ovector(&ovector_[0], 0, ovector_size, false);
    unsigned i = exec(s, offset, options, ovector);
    if (i) s.splice(ovector[0], ovector[1] - ovector[0], r.data(), r.length());
    return i;
  }

  template <typename S>
  ZuIfT<ZuInspect<ZtString, S>::Is || ZuInspect<ZtArray<char>, S>::Is, unsigned>
  sg(S &s, ZuCSpan r, unsigned offset = 0, int options = 0) const {
    auto ovector_size = (unsigned(m_captureCount) * 3);
    auto ovector_ = ZmAlloc_<unsigned>{static_cast<unsigned *>(
      !(ovector_size) ?
	nullptr :
	(((ZmStackAvail() >> 1) < ((ovector_size) * sizeof(unsigned))) ?
	   Zm::alignedAlloc<alignof(unsigned)>(
	     (ovector_size) * sizeof(unsigned)
	   ) :
	   __builtin_alloca_with_align(
	     (ovector_size) * sizeof(unsigned), (alignof(unsigned)) << 3
	   ))
    )};
    ZtArray<unsigned> ovector(&ovector_[0], 0, ovector_size, false);
    unsigned n = 0;
    unsigned slength = s.length(), rlength = r.length();

    while (offset < slength && exec(s, offset, options, ovector)) {
      s.splice(ovector[0], ovector[1] - ovector[0], r.data(), rlength);
      offset = ovector[0] + rlength;
      if (ovector[1] == ovector[0]) offset++;
      options |=

	0x00002000;
      ++n;
    }

    return n;
  }

  unsigned split(ZuCSpan s, Captures &a, int options = 0) const;

  int index(const char *name) const;

private:
  unsigned exec(
    ZuCSpan s, unsigned offset, int options, ZtArray<unsigned> &ovector
  ) const;
  void capture(
    ZuCSpan s, const ZtArray<unsigned> &ovector, Captures &captures
  ) const;

  pcre *m_regex;
  pcre_extra *m_extra;
  unsigned m_captureCount;
};

namespace ZtFieldTypeCode {
using T = int8_t;
enum {
  Invalid = -1,
  CString,
  String,
  Bytes,
  Bool,
  Int8,
  UInt8,
  Int16,
  UInt16,
  Int32,
  UInt32,
  Int64,
  UInt64,
  Int128,
  UInt128,
  Float,
  Fixed,
  Decimal,
  Time,
  DateTime,
  UDT,
  CStringVec,
  StringVec,
  BytesVec,
  Int8Vec,
  UInt8Vec,
  Int16Vec,
  UInt16Vec,
  Int32Vec,
  UInt32Vec,
  Int64Vec,
  UInt64Vec,
  Int128Vec,
  UInt128Vec,
  FloatVec,
  FixedVec,
  DecimalVec,
  TimeVec,
  DateTimeVec,
  N
};
static_assert((N <= 1024), "N <= 1024");
enum {
  Bits = N <= 2 ? 1 :
    N <= 4      ? 2 :
    N <= 8      ? 3 :
    N <= 16     ? 4 :
    N <= 32     ? 5 :
    N <= 64     ? 6 :
    N <= 128    ? 7 :
    N <= 256    ? 8 :
    N <= 512    ? 9 :
		  10
};
template <typename Impl> struct Map_ : public ZuObject {
private:
  using V2S = ZmLHashKV<T, ZuCSpan, ZmLHashStatic<Bits, ZmLHashLocal<>>>;
  using S2V = ZmLHashKV<ZuCSpan, T, ZmLHashStatic<Bits, ZmLHashLocal<>>>;

protected:
  void init(const char *s, int v, ...) {
    if (__builtin_expect(!!(!s), 0)) return;
    add(s, v);
    va_list args;

    __builtin_va_start(

      args

      ,

      v

    );
    while (s =

	     __builtin_va_arg(

	       args

	       ,

	       const char *

	     )

    )
      add(
	s,
	v =

	  __builtin_va_arg(

	    args

	    ,

	    int

	  )

      );

    __builtin_va_end(

      args

    );
  }
  void add(ZuCSpan s, T v) {
    m_s2v.add(s, v);
    m_v2s.add(v, s);
  }
  static Impl *instance() { return ZmSingleton<Impl>::instance(); }

private:
  T s2v_(ZuCSpan s) const { return m_s2v.findVal(s); }
  ZuCSpan v2s_(T v) const { return m_v2s.findVal(v); }
  template <typename L> void all_(L l) const {
    auto i = m_s2v.readIterator();
    while (auto kv = i.iterate()) {
      l(kv->template p<0>(), kv->template p<1>());
    }
  }

public:
  Map_() = default;
  static T s2v(ZuCSpan s) { return instance()->s2v_(s); }
  static ZuCSpan v2s(T v) { return instance()->v2s_(v); }
  template <typename L> static void all(L l) { instance()->all_(ZuMv(l)); }

private:
  S2V m_s2v;
  V2S m_v2s;
};
inline ZuTuple<const char *const *const, unsigned> names() {
  static const char *names[] = {
    "CString",    "String",    "Bytes",      "Bool",      "Int8",
    "UInt8",      "Int16",     "UInt16",     "Int32",     "UInt32",
    "Int64",      "UInt64",    "Int128",     "UInt128",   "Float",
    "Fixed",      "Decimal",   "Time",       "DateTime",  "UDT",
    "CStringVec", "StringVec", "BytesVec",   "Int8Vec",   "UInt8Vec",
    "Int16Vec",   "UInt16Vec", "Int32Vec",   "UInt32Vec", "Int64Vec",
    "UInt64Vec",  "Int128Vec", "UInt128Vec", "FloatVec",  "FixedVec",
    "DecimalVec", "TimeVec",   "DateTimeVec"
  };
  return ZuTuple<const char *const *const, unsigned>{
    names, static_cast<unsigned>(sizeof(names) / sizeof(names[0]))
  };
}
inline const char *name(int i) {
  ZuTuple<const char *const *const, unsigned> names_ = names();
  if (i >= (int)names_.p<1>()) return "Unknown";
  if (i < 0) return "";
  return names_.p<0>()[i];
}
struct Map : public Map_<Map> {
  static constexpr const char *id() { return "ZtFieldTypeCode"; }
  Map() {
    for (unsigned i = 0; i < N; i++) this->add(name(i), i);
  }
};
template <typename S> inline T lookup(const S &s) { return Map::s2v(s); };
} // namespace ZtFieldTypeCode

namespace ZuFieldProp {

template <unsigned... KeyIDs> struct Group { };

template <unsigned... KeyIDs> struct Descend { };

struct Synthetic { };
struct Mutable { };
struct Hidden { };
struct Hex { };
struct Required { };
struct Series { };
struct Index { };
struct Delta { };
struct Delta2 { };

template <typename Map> struct Enum {
  using T = Map;
};
template <typename Map> struct Flags {
  using T = Map;
};

template <int8_t> struct NDP { };

template <typename Props> using GetGroup = GetSeq<Props, Group>;

template <typename Props> using GetDescend = GetSeq<Props, Descend>;

template <typename Props, unsigned KeyID>
struct IsGroup_ :
  public ZuTypeIn<ZuUnsigned<KeyID>, ZuSeqTL<GetGroup<Props>>> { };
template <typename Props, unsigned KeyID>
struct IsGroup :
  public ZuBool<bool(Key<Props, KeyID>{}) && bool(IsGroup_<Props, KeyID>{})> {
};

template <typename Props> using HasEnum = HasType<Props, Enum>;
template <typename Props> using GetEnum = GetType<Props, Enum>;

template <typename Props> using HasFlags = HasType<Props, Flags>;
template <typename Props> using GetFlags = GetType<Props, Flags>;

template <typename Props> using HasNDP = HasValue<Props, int8_t, NDP>;
template <typename Props> using GetNDP = GetValue<Props, int8_t, NDP>;
} // namespace ZuFieldProp
namespace ZtVFieldProp {
using namespace ZuFieldProp;

template <typename Props, bool = HasValue<Props, unsigned, Ctor>{}>
struct GetCtor_ {
  using T = GetValue<Props, unsigned, Ctor>;
};
template <typename Props> struct GetCtor_<Props, false> {
  using T = ZuInt<-1>;
};
template <typename Props> using GetCtor = typename GetCtor_<Props>::T;

template <typename Props, bool = HasValue<Props, int8_t, NDP>{}>
struct GetNDP_ {
  using T = GetValue<Props, int8_t, NDP>;
};
template <typename Props> struct GetNDP_<Props, false> {
  using T = ZuConstant<int8_t, ZuCmp<int8_t>::null()>;
};
template <typename Props> using GetNDP = typename GetNDP_<Props>::T;
} // namespace ZtVFieldProp

namespace ZtFieldFmt {
using namespace ZuFmt;

struct Default : public ZuFmt::Default {
  static ZuDateTimeScan::Any &DateScan_() {
    return ZmTLS([] { return ZuDateTimeScan::Any{}; });
  }
  static ZuDateTimeFmt::Any &DatePrint_() {
    return ZmTLS([] { return ZuDateTimeFmt::Any{}; });
  }
  static ZuCSpan FlagsDelim() { return "|"; }

  static ZuCSpan VecPrefix() { return "["; }
  static ZuCSpan VecDelim() { return ", "; }
  static ZuCSpan VecSuffix() { return "]"; }
};

template <auto Scan, typename NTP = Default> struct DateScan : public NTP {
  static constexpr auto DateScan_ = Scan;
};

template <auto Print, typename NTP = Default> struct DatePrint : public NTP {
  static constexpr auto DatePrint_ = Print;
};

template <auto Delim, typename NTP = Default> struct Flags : public NTP {
  static constexpr auto FlagsDelim = Delim;
};

template <auto Prefix, auto Delim, auto Suffix, typename NTP = Default>
struct Vec : public NTP {
  static constexpr auto VecPrefix = Prefix;
  static constexpr auto VecDelim = Delim;
  static constexpr auto VecSuffix = Suffix;
};
} // namespace ZtFieldFmt

struct ZtFieldVFmt {
  ZtFieldVFmt() { }

  template <typename Fmt>
  ZtFieldVFmt(Fmt fmt) :
    scalar{fmt}, dateScan{Fmt::DateScan_()}, datePrint{Fmt::DatePrint_()},
    flagsDelim{Fmt::FlagsDelim()}, vecPrefix{Fmt::VecPrefix()},
    vecDelim{Fmt::VecDelim()}, vecSuffix{Fmt::VecSuffix()} { }

  ZtFieldVFmt(const ZtFieldVFmt &) = default;
  ZtFieldVFmt &operator=(const ZtFieldVFmt &) = default;
  ZtFieldVFmt(ZtFieldVFmt &&) = default;
  ZtFieldVFmt &operator=(ZtFieldVFmt &&) = default;

  ZuVFmt scalar;
  ZuDateTimeScan::Any dateScan;
  ZuDateTimeFmt::Any datePrint;
  ZuCSpan flagsDelim = "|";

  ZuCSpan vecPrefix = "[";
  ZuCSpan vecDelim = ", ";
  ZuCSpan vecSuffix = "]";
};

template <typename Prop> struct ZtFieldType_Props : public ZuFalse { };
template <> struct ZtFieldType_Props<ZuFieldProp::Hidden> : public ZuTrue { };
template <> struct ZtFieldType_Props<ZuFieldProp::Hex> : public ZuTrue { };
template <typename Map>
struct ZtFieldType_Props<ZuFieldProp::Enum<Map>> : public ZuTrue { };
template <typename Map>
struct ZtFieldType_Props<ZuFieldProp::Flags<Map>> : public ZuTrue { };
template <auto I>
struct ZtFieldType_Props<ZuFieldProp::NDP<I>> : public ZuTrue { };

namespace ZtVFieldProp {
using T = uint16_t;
enum {
  Invalid = -1,
  Ctor_,
  Synthetic_,
  Mutable_,
  Hidden_,
  Hex_,
  Required_,
  Series_,
  Index_,
  Delta_,
  Delta2_,
  Enum_,
  Flags_,
  NDP_,
  N
};
static_assert((N <= 1024), "N <= 1024");
enum {
  Bits = N <= 2 ? 1 :
    N <= 4      ? 2 :
    N <= 8      ? 3 :
    N <= 16     ? 4 :
    N <= 32     ? 5 :
    N <= 64     ? 6 :
    N <= 128    ? 7 :
    N <= 256    ? 8 :
    N <= 512    ? 9 :
		  10
};
template <typename Impl> struct Map_ : public ZuObject {
private:
  using V2S = ZmLHashKV<T, ZuCSpan, ZmLHashStatic<Bits, ZmLHashLocal<>>>;
  using S2V = ZmLHashKV<ZuCSpan, T, ZmLHashStatic<Bits, ZmLHashLocal<>>>;

protected:
  void init(const char *s, int v, ...) {
    if (__builtin_expect(!!(!s), 0)) return;
    add(s, v);
    va_list args;

    __builtin_va_start(

      args

      ,

      v

    );
    while (s =

	     __builtin_va_arg(

	       args

	       ,

	       const char *

	     )

    )
      add(
	s,
	v =

	  __builtin_va_arg(

	    args

	    ,

	    int

	  )

      );

    __builtin_va_end(

      args

    );
  }
  void add(ZuCSpan s, T v) {
    m_s2v.add(s, v);
    m_v2s.add(v, s);
  }
  static Impl *instance() { return ZmSingleton<Impl>::instance(); }

private:
  T s2v_(ZuCSpan s) const { return m_s2v.findVal(s); }
  ZuCSpan v2s_(T v) const { return m_v2s.findVal(v); }
  template <typename L> void all_(L l) const {
    auto i = m_s2v.readIterator();
    while (auto kv = i.iterate()) {
      l(kv->template p<0>(), kv->template p<1>());
    }
  }

public:
  Map_() = default;
  static T s2v(ZuCSpan s) { return instance()->s2v_(s); }
  static ZuCSpan v2s(T v) { return instance()->v2s_(v); }
  template <typename L> static void all(L l) { instance()->all_(ZuMv(l)); }

private:
  S2V m_s2v;
  V2S m_v2s;
};
inline static constexpr uint16_t Ctor() { return (uint16_t(1) << Ctor_); }
inline static constexpr uint16_t Synthetic() {
  return (uint16_t(1) << Synthetic_);
}
inline static constexpr uint16_t Mutable() { return (uint16_t(1) << Mutable_); }
inline static constexpr uint16_t Hidden() { return (uint16_t(1) << Hidden_); }
inline static constexpr uint16_t Hex() { return (uint16_t(1) << Hex_); }
inline static constexpr uint16_t Required() {
  return (uint16_t(1) << Required_);
}
inline static constexpr uint16_t Series() { return (uint16_t(1) << Series_); }
inline static constexpr uint16_t Index() { return (uint16_t(1) << Index_); }
inline static constexpr uint16_t Delta() { return (uint16_t(1) << Delta_); }
inline static constexpr uint16_t Delta2() { return (uint16_t(1) << Delta2_); }
inline static constexpr uint16_t Enum() { return (uint16_t(1) << Enum_); }
inline static constexpr uint16_t Flags() { return (uint16_t(1) << Flags_); }
inline static constexpr uint16_t NDP() { return (uint16_t(1) << NDP_); };
class Map : public Map_<Map> {
public:
  static constexpr const char *id() { return "ZtVFieldProp"; }
  Map() {
    this->init(
      "Ctor", Ctor_, "Synthetic", Synthetic_, "Mutable", Mutable_, "Hidden",
      Hidden_, "Hex", Hex_, "Required", Required_, "Series", Series_, "Index",
      Index_, "Delta", Delta_, "Delta2", Delta2_, "Enum", Enum_, "Flags",
      Flags_, "NDP", NDP_, (const char *)0
    );
  }

private:
  template <typename S, typename Flags_>
  unsigned print_(S &s, Flags_ v, ZuCSpan delim = "|") const {
    if (!v) return 0;
    bool first = true;
    unsigned n = 0;
    Flags_ mask = 1;
    for (unsigned i = 0; i < N; i++, (mask <<= 1)) {
      if (v & mask) {
	if (ZuCSpan s_ = this->v2s(i)) {
	  if (!first) s << delim;
	  s << s_;
	  first = false;
	  n++;
	}
      }
    }
    return n;
  }
  template <typename Flags_> Flags_ scan_(ZuCSpan s, ZuCSpan delim) const {
    if (!s) return 0;
    Flags_ v = 0;
    bool end = false;
    unsigned len = 0, clen = 0;
    const char *cstr = s.data(), *next;
    char c = 0;
    Flags_ mask = 1;
    do {
      for (next = cstr; len < s.length() && (c = *next) != 0;
	   clen++, len++, next++) {
	unsigned n = delim.length();
	if (!n || (len + n < s.length() && c == delim[0])) {
	  bool delimited = true;
	  for (unsigned i = 1; i < n; i++)
	    if (next[i] != delim[i]) {
	      delimited = false;
	      break;
	    }
	  if (delimited) {
	    len += n;
	    next += n;
	    break;
	  }
	}
      }
      if (len > s.length() || c == 0) end = true;
      T i = this->s2v(ZuCSpan(cstr, clen));
      if (__builtin_expect(!!(i == T(-1)), 0)) return 0;
      v |= (mask << unsigned(i));
      cstr = next;
      clen = 0;
    } while (!end);
    return v;
  }

public:
  template <typename Flags_>
  static Flags_ scan(ZuCSpan s, ZuCSpan delim = "|") {
    return instance()->template scan_<Flags_>(s, delim);
  }
  template <typename Flags_> struct Print : public ZuPrintable {
    Print(Flags_ v_, ZuCSpan delim_ = "|") : v(v_), delim{delim_} { }
    template <typename S> void print(S &s) const {
      ZmSingleton<Map>::instance()->print_(s, v, delim);
    }
    const Flags_ v;
    ZuCSpan delim;
  };
  template <typename Flags_>
  static Print<Flags_> print(Flags_ v, ZuCSpan delim = "|") {
    return Print<Flags_>{v, delim};
  }
};
;

using V = T;

template <V I> using Constant = ZuConstant<V, I>;

template <typename> struct Value_ {
  using T = Constant<0>;
};

template <auto I> struct Value_<Constant<I>> {
  using T = Constant<I>;
};

template <typename U> using Value = typename Value_<U>::T;

namespace _ = ZuFieldProp;

template <auto I> struct Value_<_::Ctor<I>> {
  using T = Constant<Ctor()>;
};
template <> struct Value_<_::Synthetic> {
  using T = Constant<Synthetic()>;
};
template <> struct Value_<_::Mutable> {
  using T = Constant<Mutable()>;
};
template <> struct Value_<_::Hidden> {
  using T = Constant<Hidden()>;
};
template <> struct Value_<_::Hex> {
  using T = Constant<Hex()>;
};
template <> struct Value_<_::Required> {
  using T = Constant<Required()>;
};
template <> struct Value_<_::Series> {
  using T = Constant<Series()>;
};
template <> struct Value_<_::Index> {
  using T = Constant<Index()>;
};
template <> struct Value_<_::Delta> {
  using T = Constant<Delta()>;
};
template <> struct Value_<_::Delta2> {
  using T = Constant<Delta2()>;
};
template <typename Map> struct Value_<_::Enum<Map>> {
  using T = Constant<Enum()>;
};
template <typename Map> struct Value_<_::Flags<Map>> {
  using T = Constant<Flags()>;
};
template <auto I> struct Value_<_::NDP<I>> {
  using T = Constant<NDP()>;
};

template <typename...> struct Or_;
template <> struct Or_<> {
  using T = Constant<0>;
};
template <typename U> struct Or_<U> {
  using T = Value<U>;
};
template <typename L, typename R> struct Or_<L, R> {
  using T = Constant<V(Value<L>{}) | V(Value<R>{})>;
};
template <typename... Props> using Or = typename Or_<Props...>::T;

template <typename... Props> struct Value_<ZuTypeList<Props...>> {
  using T = ZuTypeReduce<Or, ZuTypeList<Props...>>;
};
} // namespace ZtVFieldProp

template <typename Props> struct ZtFieldType_ {
  static constexpr ZtVFieldProp::T mprops() {
    return ZtVFieldProp::Value<Props>{};
  }
};

template <int Code, typename T, typename Props> struct ZtFieldType;

template <typename T, typename = void> struct ZtFieldType_Scan {
  static auto fn() {
    typedef void (*Fn)(void *, ZuCSpan, const ZtFieldVFmt &);
    return static_cast<Fn>(nullptr);
  }
};
template <typename T>
struct ZtFieldType_Scan<T, decltype((ZuDeclVal<T &>() = ZuCSpan{}), void())> {
  static auto fn() {
    return [](void *ptr, ZuCSpan s, const ZtFieldVFmt &) {
      *static_cast<T *>(ptr) = s;
    };
  }
};

template <typename T, typename = void> struct ZtFieldType_Cmp {
  static auto fn() {
    typedef int (*Fn)(const void *, const void *);
    return static_cast<Fn>(nullptr);
  }
};
template <typename T>
struct ZtFieldType_Cmp<T, decltype(&ZuCmp<T>::cmp, void())> {
  static auto fn() {
    return [](const void *p1, const void *p2) -> int {
      return ZuCmp<T>::cmp(
	*static_cast<const T *>(p1), *static_cast<const T *>(p2)
      );
    };
  }
};

struct ZtVFieldEnum {
  const char *(*id)();
  ZuCSpan (*print)(int);
  int (*scan)(ZuCSpan);
};
template <typename Map> struct ZtVFieldEnum_ : public ZtVFieldEnum {
  ZtVFieldEnum_() :
    ZtVFieldEnum{.id = []() -> const char * {
		   return Map::id();
		 }, .print = [](int i) -> ZuCSpan {
		   return Map::v2s(i);
		 }, .scan = [](ZuCSpan s) -> int { return Map::s2v(s); }} { }

  static ZtVFieldEnum *instance() {
    return ZmSingleton<ZtVFieldEnum_>::instance();
  }
};

struct ZtVFieldFlags {
  const char *(*id)();
  void (*print)(uint128_t, ZuVStream &, const ZtFieldVFmt &);
  uint128_t (*scan)(ZuCSpan, const ZtFieldVFmt &);
};
template <typename Map> struct ZtVFieldFlags_ : public ZtVFieldFlags {
  ZtVFieldFlags_() :
    ZtVFieldFlags{
      .id = []() -> const char * { return Map::id(); },
      .print = [](uint128_t v, ZuVStream &s, const ZtFieldVFmt &fmt) -> void {
	s << Map::print(v, fmt.flagsDelim);
      },
      .scan = [](ZuCSpan s, const ZtFieldVFmt &fmt) -> uint128_t {
	return Map::template scan<uint128_t>(s, fmt.flagsDelim);
      }
    } { }

  static ZtVFieldFlags *instance() {
    return ZmSingleton<ZtVFieldFlags_>::instance();
  }
};

typedef void (*ZtVFieldPrint)(const void *, ZuVStream &, const ZtFieldVFmt &);
typedef void (*ZtVFieldScan)(void (*)(void *, const void *), void *, ZuCSpan, const ZtFieldVFmt &);

inline ZuID ZtVFieldTypeID(...) { return {}; }

struct ZtVFieldUDT {
  ZuID id;
  const std::type_info *info;
  ZtVFieldPrint print;
  ZtVFieldScan scan;
};

struct ZtVFieldType {
  int code;
  ZtVFieldProp::T props;

  union {
    void *null;
    ZtVFieldEnum *(*enum_)();
    ZtVFieldFlags *(*flags)();
    ZtVFieldUDT *(*udt)();
  } info;
};

namespace ZtVFieldConstant {
enum { Null = 0, Deflt, Minimum, Maximum };
}

struct ZtVField;

namespace ZtField_ {

namespace Print {

using namespace ZtQuote;

using Bytes = Base64;

}

namespace Scan {
static constexpr bool isspace__(char c) {
  return c == ' ' || c == '\t' || c == '\r' || c == '\n';
}

extern unsigned string(ZuSpan<char> dst, ZuCSpan &src);

extern unsigned
strElem(ZuSpan<char> dst, ZuCSpan &src, ZuCSpan delim, ZuCSpan suffix);
}

using CStringVec = ZuVArray<const char *>;
using StringVec = ZuVArray<ZuCSpan>;
using BytesVec = ZuVArray<ZuBytes>;
using Int8Vec = ZuVArray<int8_t>;
using UInt8Vec = ZuVArray<uint8_t>;
using Int16Vec = ZuVArray<int16_t>;
using UInt16Vec = ZuVArray<uint16_t>;
using Int32Vec = ZuVArray<int32_t>;
using UInt32Vec = ZuVArray<uint32_t>;
using Int64Vec = ZuVArray<int64_t>;
using UInt64Vec = ZuVArray<uint64_t>;
using Int128Vec = ZuVArray<int128_t>;
using UInt128Vec = ZuVArray<uint128_t>;
using FloatVec = ZuVArray<double>;
using FixedVec = ZuVArray<ZuFixed>;
using DecimalVec = ZuVArray<ZuDecimal>;
using TimeVec = ZuVArray<ZuTime>;
using DateTimeVec = ZuVArray<ZuDateTime>;

struct MGet {
  union {
    void *null;

    const char *(*cstring)(const void *);
    ZuCSpan (*string)(const void *);
    ZuBytes (*bytes)(const void *);
    bool (*bool_)(const void *);
    int8_t (*int8)(const void *);
    uint8_t (*uint8)(const void *);
    int16_t (*int16)(const void *);
    uint16_t (*uint16)(const void *);
    int32_t (*int32)(const void *);
    uint32_t (*uint32)(const void *);
    int64_t (*int64)(const void *);
    uint64_t (*uint64)(const void *);
    int128_t (*int128)(const void *);
    uint128_t (*uint128)(const void *);
    int (*enum_)(const void *);
    uint128_t (*flags)(const void *);
    double (*float_)(const void *);
    ZuFixed (*fixed)(const void *);
    ZuDecimal (*decimal)(const void *);
    ZuTime (*time)(const void *);
    ZuDateTime (*dateTime)(const void *);
    const void *(*udt)(const void *);

    CStringVec (*cstringVec)(const void *);
    StringVec (*stringVec)(const void *);
    BytesVec (*bytesVec)(const void *);
    Int8Vec (*int8Vec)(const void *);
    UInt8Vec (*uint8Vec)(const void *);
    Int16Vec (*int16Vec)(const void *);
    UInt16Vec (*uint16Vec)(const void *);
    Int32Vec (*int32Vec)(const void *);
    UInt32Vec (*uint32Vec)(const void *);
    Int64Vec (*int64Vec)(const void *);
    UInt64Vec (*uint64Vec)(const void *);
    Int128Vec (*int128Vec)(const void *);
    UInt128Vec (*uint128Vec)(const void *);
    FloatVec (*floatVec)(const void *);
    FixedVec (*fixedVec)(const void *);
    DecimalVec (*decimalVec)(const void *);
    TimeVec (*timeVec)(const void *);
    DateTimeVec (*dateTimeVec)(const void *);
  } get_;

  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::CString, const char *>
  get(const void *o) const {
    return get_.cstring(o);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::String, ZuCSpan> get(const void *o) const {
    return get_.string(o);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::Bytes, ZuBytes> get(const void *o) const {
    return get_.bytes(o);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::Bool, bool> get(const void *o) const {
    return get_.bool_(o);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::Int8, int8_t> get(const void *o) const {
    return get_.int8(o);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::UInt8, uint8_t> get(const void *o) const {
    return get_.uint8(o);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::Int16, int16_t> get(const void *o) const {
    return get_.int16(o);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::UInt16, uint16_t> get(const void *o) const {
    return get_.uint16(o);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::Int32, int32_t> get(const void *o) const {
    return get_.int32(o);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::UInt32, uint32_t> get(const void *o) const {
    return get_.uint32(o);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::Int64, int64_t> get(const void *o) const {
    return get_.int64(o);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::UInt64, uint64_t> get(const void *o) const {
    return get_.uint64(o);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::Int128, int128_t> get(const void *o) const {
    return get_.int128(o);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::UInt128, uint128_t> get(const void *o) const {
    return get_.uint128(o);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::Float, double> get(const void *o) const {
    return get_.float_(o);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::Fixed, ZuFixed> get(const void *o) const {
    return get_.fixed(o);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::Decimal, ZuDecimal> get(const void *o) const {
    return get_.decimal(o);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::Time, ZuTime> get(const void *o) const {
    return get_.time(o);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::DateTime, ZuDateTime>
  get(const void *o) const {
    return get_.dateTime(o);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::UDT, const void *> get(const void *o) const {
    return get_.udt(o);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::CStringVec, CStringVec>
  get(const void *o) const {
    return get_.cstringVec(o);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::StringVec, StringVec>
  get(const void *o) const {
    return get_.stringVec(o);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::BytesVec, BytesVec> get(const void *o) const {
    return get_.bytesVec(o);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::Int8Vec, Int8Vec> get(const void *o) const {
    return get_.int8Vec(o);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::UInt8Vec, UInt8Vec> get(const void *o) const {
    return get_.uint8Vec(o);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::Int16Vec, Int16Vec> get(const void *o) const {
    return get_.int16Vec(o);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::UInt16Vec, UInt16Vec>
  get(const void *o) const {
    return get_.uint16Vec(o);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::Int32Vec, Int32Vec> get(const void *o) const {
    return get_.int32Vec(o);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::UInt32Vec, UInt32Vec>
  get(const void *o) const {
    return get_.uint32Vec(o);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::Int64Vec, Int64Vec> get(const void *o) const {
    return get_.int64Vec(o);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::UInt64Vec, UInt64Vec>
  get(const void *o) const {
    return get_.uint64Vec(o);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::Int128Vec, Int128Vec>
  get(const void *o) const {
    return get_.int128Vec(o);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::UInt128Vec, UInt128Vec>
  get(const void *o) const {
    return get_.uint128Vec(o);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::FloatVec, FloatVec> get(const void *o) const {
    return get_.floatVec(o);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::FixedVec, FixedVec> get(const void *o) const {
    return get_.fixedVec(o);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::DecimalVec, DecimalVec>
  get(const void *o) const {
    return get_.decimalVec(o);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::TimeVec, TimeVec> get(const void *o) const {
    return get_.timeVec(o);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::DateTimeVec, DateTimeVec>
  get(const void *o) const {
    return get_.dateTimeVec(o);
  }

  template <unsigned Code, typename S>
  ZuIfT<Code == ZtFieldTypeCode::CString>
  print(S &, const void *, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code, typename S>
  ZuIfT<Code == ZtFieldTypeCode::String>
  print(S &, const void *, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code, typename S>
  ZuIfT<Code == ZtFieldTypeCode::Bytes>
  print(S &, const void *, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code, typename S>
  ZuIfT<Code == ZtFieldTypeCode::Bool>
  print(S &, const void *, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code, typename S>
  ZuIfT<Code == ZtFieldTypeCode::Int8>
  print(S &, const void *, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code, typename S>
  ZuIfT<Code == ZtFieldTypeCode::UInt8>
  print(S &, const void *, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code, typename S>
  ZuIfT<Code == ZtFieldTypeCode::Int16>
  print(S &, const void *, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code, typename S>
  ZuIfT<Code == ZtFieldTypeCode::UInt16>
  print(S &, const void *, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code, typename S>
  ZuIfT<Code == ZtFieldTypeCode::Int32>
  print(S &, const void *, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code, typename S>
  ZuIfT<Code == ZtFieldTypeCode::UInt32>
  print(S &, const void *, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code, typename S>
  ZuIfT<Code == ZtFieldTypeCode::Int64>
  print(S &, const void *, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code, typename S>
  ZuIfT<Code == ZtFieldTypeCode::UInt64>
  print(S &, const void *, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code, typename S>
  ZuIfT<Code == ZtFieldTypeCode::Int128>
  print(S &, const void *, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code, typename S>
  ZuIfT<Code == ZtFieldTypeCode::UInt128>
  print(S &, const void *, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code, typename S>
  ZuIfT<Code == ZtFieldTypeCode::Float>
  print(S &, const void *, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code, typename S>
  ZuIfT<Code == ZtFieldTypeCode::Fixed>
  print(S &, const void *, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code, typename S>
  ZuIfT<Code == ZtFieldTypeCode::Decimal>
  print(S &, const void *, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code, typename S>
  ZuIfT<Code == ZtFieldTypeCode::Time>
  print(S &, const void *, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code, typename S>
  ZuIfT<Code == ZtFieldTypeCode::DateTime>
  print(S &, const void *, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code, typename S>
  ZuIfT<Code == ZtFieldTypeCode::UDT>
  print(S &, const void *, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code, typename S>
  ZuIfT<Code == ZtFieldTypeCode::CStringVec>
  print(S &, const void *, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code, typename S>
  ZuIfT<Code == ZtFieldTypeCode::StringVec>
  print(S &, const void *, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code, typename S>
  ZuIfT<Code == ZtFieldTypeCode::BytesVec>
  print(S &, const void *, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code, typename S>
  ZuIfT<Code == ZtFieldTypeCode::Int8Vec>
  print(S &, const void *, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code, typename S>
  ZuIfT<Code == ZtFieldTypeCode::UInt8Vec>
  print(S &, const void *, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code, typename S>
  ZuIfT<Code == ZtFieldTypeCode::Int16Vec>
  print(S &, const void *, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code, typename S>
  ZuIfT<Code == ZtFieldTypeCode::UInt16Vec>
  print(S &, const void *, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code, typename S>
  ZuIfT<Code == ZtFieldTypeCode::Int32Vec>
  print(S &, const void *, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code, typename S>
  ZuIfT<Code == ZtFieldTypeCode::UInt32Vec>
  print(S &, const void *, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code, typename S>
  ZuIfT<Code == ZtFieldTypeCode::Int64Vec>
  print(S &, const void *, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code, typename S>
  ZuIfT<Code == ZtFieldTypeCode::UInt64Vec>
  print(S &, const void *, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code, typename S>
  ZuIfT<Code == ZtFieldTypeCode::Int128Vec>
  print(S &, const void *, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code, typename S>
  ZuIfT<Code == ZtFieldTypeCode::UInt128Vec>
  print(S &, const void *, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code, typename S>
  ZuIfT<Code == ZtFieldTypeCode::FloatVec>
  print(S &, const void *, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code, typename S>
  ZuIfT<Code == ZtFieldTypeCode::FixedVec>
  print(S &, const void *, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code, typename S>
  ZuIfT<Code == ZtFieldTypeCode::DecimalVec>
  print(S &, const void *, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code, typename S>
  ZuIfT<Code == ZtFieldTypeCode::TimeVec>
  print(S &, const void *, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code, typename S>
  ZuIfT<Code == ZtFieldTypeCode::DateTimeVec>
  print(S &, const void *, const ZtVField *, const ZtFieldVFmt &) const;
};

struct MSet {
  union {
    void *null;

    void (*cstring)(void *, const char *);
    void (*string)(void *, ZuCSpan);
    void (*bytes)(void *, ZuBytes);
    void (*bool_)(void *, bool);
    void (*int8)(void *, int8_t);
    void (*uint8)(void *, uint8_t);
    void (*int16)(void *, int16_t);
    void (*uint16)(void *, uint16_t);
    void (*int32)(void *, int32_t);
    void (*uint32)(void *, uint32_t);
    void (*int64)(void *, int64_t);
    void (*uint64)(void *, uint64_t);
    void (*int128)(void *, int128_t);
    void (*uint128)(void *, uint128_t);
    void (*float_)(void *, double);
    void (*fixed)(void *, ZuFixed);
    void (*decimal)(void *, ZuDecimal);
    void (*time)(void *, ZuTime);
    void (*dateTime)(void *, ZuDateTime);
    void (*udt)(void *, const void *);

    void (*cstringVec)(void *, CStringVec);
    void (*stringVec)(void *, StringVec);
    void (*bytesVec)(void *, BytesVec);
    void (*int8Vec)(void *, Int8Vec);
    void (*uint8Vec)(void *, UInt8Vec);
    void (*int16Vec)(void *, Int16Vec);
    void (*uint16Vec)(void *, UInt16Vec);
    void (*int32Vec)(void *, Int32Vec);
    void (*uint32Vec)(void *, UInt32Vec);
    void (*int64Vec)(void *, Int64Vec);
    void (*uint64Vec)(void *, UInt64Vec);
    void (*int128Vec)(void *, Int128Vec);
    void (*uint128Vec)(void *, UInt128Vec);
    void (*floatVec)(void *, FloatVec);
    void (*fixedVec)(void *, FixedVec);
    void (*decimalVec)(void *, DecimalVec);
    void (*timeVec)(void *, TimeVec);
    void (*dateTimeVec)(void *, DateTimeVec);
  } set_;

  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::CString> set(void *o, const char *v) const {
    set_.cstring(o, v);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::String> set(void *o, ZuCSpan v) const {
    set_.string(o, v);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::Bytes> set(void *o, ZuBytes v) const {
    set_.bytes(o, v);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::Bool> set(void *o, bool v) const {
    set_.bool_(o, v);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::Int8> set(void *o, int8_t v) const {
    set_.int8(o, v);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::UInt8> set(void *o, uint8_t v) const {
    set_.uint8(o, v);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::Int16> set(void *o, int16_t v) const {
    set_.int16(o, v);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::UInt16> set(void *o, uint16_t v) const {
    set_.uint16(o, v);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::Int32> set(void *o, int32_t v) const {
    set_.int32(o, v);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::UInt32> set(void *o, uint32_t v) const {
    set_.uint32(o, v);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::Int64> set(void *o, int64_t v) const {
    set_.int64(o, v);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::UInt64> set(void *o, uint64_t v) const {
    set_.uint64(o, v);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::Int128> set(void *o, int128_t v) const {
    set_.int128(o, v);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::UInt128> set(void *o, uint128_t v) const {
    set_.uint128(o, v);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::Float> set(void *o, double v) const {
    set_.float_(o, v);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::Fixed> set(void *o, ZuFixed v) const {
    set_.fixed(o, v);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::Decimal> set(void *o, ZuDecimal v) const {
    set_.decimal(o, v);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::Time> set(void *o, ZuTime v) const {
    set_.time(o, v);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::DateTime> set(void *o, ZuDateTime v) const {
    set_.dateTime(o, v);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::UDT> set(void *o, const void *v) const {
    set_.udt(o, v);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::CStringVec> set(void *o, CStringVec v) const {
    set_.cstringVec(o, v);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::StringVec> set(void *o, StringVec v) const {
    set_.stringVec(o, v);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::BytesVec> set(void *o, BytesVec v) const {
    set_.bytesVec(o, v);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::Int8Vec> set(void *o, Int8Vec v) const {
    set_.int8Vec(o, v);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::UInt8Vec> set(void *o, UInt8Vec v) const {
    set_.uint8Vec(o, v);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::Int16Vec> set(void *o, Int16Vec v) const {
    set_.int16Vec(o, v);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::UInt16Vec> set(void *o, UInt16Vec v) const {
    set_.uint16Vec(o, v);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::Int32Vec> set(void *o, Int32Vec v) const {
    set_.int32Vec(o, v);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::UInt32Vec> set(void *o, UInt32Vec v) const {
    set_.uint32Vec(o, v);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::Int64Vec> set(void *o, Int64Vec v) const {
    set_.int64Vec(o, v);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::UInt64Vec> set(void *o, UInt64Vec v) const {
    set_.uint64Vec(o, v);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::Int128Vec> set(void *o, Int128Vec v) const {
    set_.int128Vec(o, v);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::UInt128Vec> set(void *o, UInt128Vec v) const {
    set_.uint128Vec(o, v);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::FloatVec> set(void *o, FloatVec v) const {
    set_.floatVec(o, v);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::FixedVec> set(void *o, FixedVec v) const {
    set_.fixedVec(o, v);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::DecimalVec> set(void *o, DecimalVec v) const {
    set_.decimalVec(o, v);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::TimeVec> set(void *o, TimeVec v) const {
    set_.timeVec(o, v);
  }
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::DateTimeVec>
  set(void *o, DateTimeVec v) const {
    set_.dateTimeVec(o, v);
  }

  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::CString>
  scan(void *, ZuCSpan, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::String>
  scan(void *, ZuCSpan, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::Bytes>
  scan(void *, ZuCSpan, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::Bool>
  scan(void *, ZuCSpan, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::Int8>
  scan(void *, ZuCSpan, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::UInt8>
  scan(void *, ZuCSpan, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::Int16>
  scan(void *, ZuCSpan, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::UInt16>
  scan(void *, ZuCSpan, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::Int32>
  scan(void *, ZuCSpan, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::UInt32>
  scan(void *, ZuCSpan, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::Int64>
  scan(void *, ZuCSpan, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::UInt64>
  scan(void *, ZuCSpan, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::Int128>
  scan(void *, ZuCSpan, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::UInt128>
  scan(void *, ZuCSpan, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::Float>
  scan(void *, ZuCSpan, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::Fixed>
  scan(void *, ZuCSpan, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::Decimal>
  scan(void *, ZuCSpan, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::Time>
  scan(void *, ZuCSpan, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::DateTime>
  scan(void *, ZuCSpan, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::UDT>
  scan(void *, ZuCSpan, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::CStringVec>
  scan(void *, ZuCSpan, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::StringVec>
  scan(void *, ZuCSpan, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::BytesVec>
  scan(void *, ZuCSpan, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::Int8Vec>
  scan(void *, ZuCSpan, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::UInt8Vec>
  scan(void *, ZuCSpan, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::Int16Vec>
  scan(void *, ZuCSpan, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::UInt16Vec>
  scan(void *, ZuCSpan, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::Int32Vec>
  scan(void *, ZuCSpan, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::UInt32Vec>
  scan(void *, ZuCSpan, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::Int64Vec>
  scan(void *, ZuCSpan, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::UInt64Vec>
  scan(void *, ZuCSpan, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::Int128Vec>
  scan(void *, ZuCSpan, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::UInt128Vec>
  scan(void *, ZuCSpan, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::FloatVec>
  scan(void *, ZuCSpan, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::FixedVec>
  scan(void *, ZuCSpan, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::DecimalVec>
  scan(void *, ZuCSpan, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::TimeVec>
  scan(void *, ZuCSpan, const ZtVField *, const ZtFieldVFmt &) const;
  template <unsigned Code>
  ZuIfT<Code == ZtFieldTypeCode::DateTimeVec>
  scan(void *, ZuCSpan, const ZtVField *, const ZtFieldVFmt &) const;
};

} // namespace ZtField_

using ZtVFieldGet = ZtField_::MGet;
using ZtVFieldSet = ZtField_::MSet;

struct ZtVField {
  ZtVFieldType *type;
  const char *id;
  ZtVFieldProp::T props;
  uint64_t keys;
  uint64_t group;
  uint64_t descend;
  int16_t ctor;
  int8_t ndp;

  ZtVFieldGet get;
  ZtVFieldSet set;

  ZtVFieldGet constant;

  template <typename Field>
  ZtVField(Field) :
    type{Field::Type::mtype()}, id{Field::id()}, props{Field::mprops()},
    keys{ZuSeqBitmap<ZuFieldProp::GetKeys<typename Field::Props>>()},
    group{ZuSeqBitmap<ZuFieldProp::GetGroup<typename Field::Props>>()},
    descend{ZuSeqBitmap<ZuFieldProp::GetDescend<typename Field::Props>>()},
    ctor{ZtVFieldProp::GetCtor<typename Field::Props>{}},
    ndp{ZtVFieldProp::GetNDP<typename Field::Props>{}}, get{Field::getFn()},
    set{Field::setFn()}, constant{Field::constantFn()} { }

  static const void *cget(int c) {
    return reinterpret_cast<void *>(static_cast<uintptr_t>(c));
  }

  template <typename S> void print_(S &s) const {
    s << "id=" << id << " type=" << ZtFieldTypeCode::name(type->code);
    s << " props="
      << ZtVFieldProp::Map::print(
	   props & ~(ZtVFieldProp::Ctor() | ZtVFieldProp::NDP())
	 );
    if (props & ZtVFieldProp::Ctor()) {
      if (props & ~(ZtVFieldProp::Ctor() | ZtVFieldProp::NDP())) s << '|';
      s << "Ctor(" << ctor << ')';
    }
    if (props & ZtVFieldProp::NDP()) {
      if (props & ~ZtVFieldProp::NDP()) s << '|';
      s << "NDP(" << int(ndp) << ')';
    }
    s << " keys=" << *reinterpret_cast<const ZuBitmap<64> *>(&keys);
    s << " group=" << *reinterpret_cast<const ZuBitmap<64> *>(&group);
    s << " descend=" << *reinterpret_cast<const ZuBitmap<64> *>(&descend);
  }
  friend ZuPrintLambda<
    []() { return [](auto &s, const auto &v) { v.print_(s); }; }>
  ZuPrintType(ZtVField *);
};

namespace ZtField_ {

template <unsigned Code, typename S>
inline ZuIfT<Code == ZtFieldTypeCode::CString> MGet::print(
  S &s, const void *o, const ZtVField *field, const ZtFieldVFmt &fmt
) const {
  auto v = get_.cstring(o);
  s << Print::CString{v};
}
template <unsigned Code, typename S>
inline ZuIfT<Code == ZtFieldTypeCode::String> MGet::print(
  S &s, const void *o, const ZtVField *field, const ZtFieldVFmt &fmt
) const {
  auto v = get_.string(o);
  s << Print::String{v};
}
template <unsigned Code, typename S>
inline ZuIfT<Code == ZtFieldTypeCode::Bytes>
MGet::print(S &s, const void *o, const ZtVField *, const ZtFieldVFmt &) const {
  ZuBytes v = get_.bytes(o);
  auto n = ZuBase64::enclen(v.length());
  auto buf_ = ZmAlloc_<uint8_t>{static_cast<uint8_t *>(
    !(n) ? nullptr :
	   (((ZmStackAvail() >> 1) < ((n) * sizeof(uint8_t))) ?
	      Zm::alignedAlloc<alignof(uint8_t)>((n) * sizeof(uint8_t)) :
	      __builtin_alloca_with_align(
		(n) * sizeof(uint8_t), (alignof(uint8_t)) << 3
	      ))
  )};
  ZuSpan<uint8_t> buf(&buf_[0], n);
  buf.trunc(ZuBase64::encode(buf, v));
  s << ZuCSpan{buf};
}
template <unsigned Code, typename S>
inline ZuIfT<Code == ZtFieldTypeCode::Bool>
MGet::print(S &s, const void *o, const ZtVField *, const ZtFieldVFmt &) const {
  s << (get_.bool_(o) ? '1' : '0');
}

template <typename S, typename T>
inline void ZtVField_printInt_(
  S &s, const T &v, const ZtVField *field, const ZtFieldVFmt &fmt
) {
  if (__builtin_expect(!!(field->props & ZtVFieldProp::Enum()), 0)) {
    s << field->type->info.enum_()->print(v);
    return;
  }
  if (__builtin_expect(!!(field->props & ZtVFieldProp::Flags()), 0)) {
    ZuVStream s_{s};
    field->type->info.flags()->print(v, s_, fmt);
    return;
  }
  if (field->props & ZtVFieldProp::Hex()) {
    s << v.vfmt(fmt.scalar).hex();
    return;
  }
  s << v.vfmt(fmt.scalar);
}

template <unsigned Code, typename S>
inline ZuIfT<Code == ZtFieldTypeCode::Int8> MGet::print(
  S &s, const void *o, const ZtVField *field, const ZtFieldVFmt &fmt
) const {
  ZuBox<int8_t> v = get_.int8(o);
  ZtVField_printInt_(s, v, field, fmt);
}
template <unsigned Code, typename S>
inline ZuIfT<Code == ZtFieldTypeCode::UInt8> MGet::print(
  S &s, const void *o, const ZtVField *field, const ZtFieldVFmt &fmt
) const {
  ZuBox<uint8_t> v = get_.uint8(o);
  ZtVField_printInt_(s, v, field, fmt);
}
template <unsigned Code, typename S>
inline ZuIfT<Code == ZtFieldTypeCode::Int16> MGet::print(
  S &s, const void *o, const ZtVField *field, const ZtFieldVFmt &fmt
) const {
  ZuBox<int16_t> v = get_.int16(o);
  ZtVField_printInt_(s, v, field, fmt);
}
template <unsigned Code, typename S>
inline ZuIfT<Code == ZtFieldTypeCode::UInt16> MGet::print(
  S &s, const void *o, const ZtVField *field, const ZtFieldVFmt &fmt
) const {
  ZuBox<uint16_t> v = get_.uint16(o);
  ZtVField_printInt_(s, v, field, fmt);
}
template <unsigned Code, typename S>
inline ZuIfT<Code == ZtFieldTypeCode::Int32> MGet::print(
  S &s, const void *o, const ZtVField *field, const ZtFieldVFmt &fmt
) const {
  ZuBox<int32_t> v = get_.int32(o);
  ZtVField_printInt_(s, v, field, fmt);
}
template <unsigned Code, typename S>
inline ZuIfT<Code == ZtFieldTypeCode::UInt32> MGet::print(
  S &s, const void *o, const ZtVField *field, const ZtFieldVFmt &fmt
) const {
  ZuBox<uint32_t> v = get_.uint32(o);
  ZtVField_printInt_(s, v, field, fmt);
}
template <unsigned Code, typename S>
inline ZuIfT<Code == ZtFieldTypeCode::Int64> MGet::print(
  S &s, const void *o, const ZtVField *field, const ZtFieldVFmt &fmt
) const {
  ZuBox<int64_t> v = get_.int64(o);
  ZtVField_printInt_(s, v, field, fmt);
}
template <unsigned Code, typename S>
inline ZuIfT<Code == ZtFieldTypeCode::UInt64> MGet::print(
  S &s, const void *o, const ZtVField *field, const ZtFieldVFmt &fmt
) const {
  ZuBox<uint64_t> v = get_.uint64(o);
  ZtVField_printInt_(s, v, field, fmt);
}
template <unsigned Code, typename S>
inline ZuIfT<Code == ZtFieldTypeCode::Int128> MGet::print(
  S &s, const void *o, const ZtVField *field, const ZtFieldVFmt &fmt
) const {
  ZuBox<int128_t> v = get_.int128(o);
  ZtVField_printInt_(s, v, field, fmt);
}
template <unsigned Code, typename S>
inline ZuIfT<Code == ZtFieldTypeCode::UInt128> MGet::print(
  S &s, const void *o, const ZtVField *field, const ZtFieldVFmt &fmt
) const {
  ZuBox<uint128_t> v = get_.uint128(o);
  ZtVField_printInt_(s, v, field, fmt);
}

template <unsigned Code, typename S>
inline ZuIfT<Code == ZtFieldTypeCode::Float> MGet::print(
  S &s, const void *o, const ZtVField *field, const ZtFieldVFmt &fmt
) const {
  ZuBox<double> v = get_.float_(o);
  auto ndp = field->ndp;
  if (!ZuCmp<decltype(ndp)>::null(ndp))
    s << v.vfmt(fmt.scalar).fp(ndp);
  else
    s << v.vfmt(fmt.scalar);
}
template <unsigned Code, typename S>
inline ZuIfT<Code == ZtFieldTypeCode::Fixed> MGet::print(
  S &s, const void *o, const ZtVField *field, const ZtFieldVFmt &fmt
) const {
  ZuFixed v = get_.fixed(o);
  auto ndp = field->ndp;
  if (!ZuCmp<decltype(ndp)>::null(ndp))
    s << v.vfmt(fmt.scalar).fp(ndp);
  else
    s << v.vfmt(fmt.scalar);
}
template <unsigned Code, typename S>
inline ZuIfT<Code == ZtFieldTypeCode::Decimal> MGet::print(
  S &s, const void *o, const ZtVField *field, const ZtFieldVFmt &fmt
) const {
  ZuDecimal v = get_.decimal(o);
  auto ndp = field->ndp;
  if (!ZuCmp<decltype(ndp)>::null(ndp))
    s << v.vfmt(fmt.scalar).fp(ndp);
  else
    s << v.vfmt(fmt.scalar);
}
template <unsigned Code, typename S>
inline ZuIfT<Code == ZtFieldTypeCode::Time> MGet::print(
  S &s, const void *o, const ZtVField *, const ZtFieldVFmt &fmt
) const {
  ZuDateTime v{get_.time(o)};
  s << v.fmt(fmt.datePrint);
}
template <unsigned Code, typename S>
inline ZuIfT<Code == ZtFieldTypeCode::DateTime> MGet::print(
  S &s, const void *o, const ZtVField *, const ZtFieldVFmt &fmt
) const {
  ZuDateTime v{get_.dateTime(o)};
  s << v.fmt(fmt.datePrint);
}
template <unsigned Code, typename S>
inline ZuIfT<Code == ZtFieldTypeCode::UDT> MGet::print(
  S &s_, const void *o, const ZtVField *field, const ZtFieldVFmt &fmt
) const {
  ZuVStream s{s_};
  field->type->info.udt()->print(get_.udt(o), s, fmt);
}

template <unsigned Code, typename S>
inline ZuIfT<Code == ZtFieldTypeCode::CStringVec> MGet::print(
  S &s, const void *o, const ZtVField *, const ZtFieldVFmt &fmt
) const {
  s << fmt.vecPrefix;
  bool first = true;
  CStringVec vec{get_.cstringVec(o)};
  vec.all([&s, &first, &fmt](const char *v) {
    if (!first)
      s << fmt.vecDelim;
    else
      first = false;
    s << Print::CString{v};
  });
  s << fmt.vecSuffix;
}
template <unsigned Code, typename S>
inline ZuIfT<Code == ZtFieldTypeCode::StringVec> MGet::print(
  S &s, const void *o, const ZtVField *, const ZtFieldVFmt &fmt
) const {
  s << fmt.vecPrefix;
  bool first = true;
  StringVec vec{get_.stringVec(o)};
  vec.all([&s, &first, &fmt](ZuCSpan v) {
    if (!first)
      s << fmt.vecDelim;
    else
      first = false;
    s << Print::String{v};
  });
  s << fmt.vecSuffix;
}
template <unsigned Code, typename S>
inline ZuIfT<Code == ZtFieldTypeCode::BytesVec> MGet::print(
  S &s, const void *o, const ZtVField *, const ZtFieldVFmt &fmt
) const {
  s << fmt.vecPrefix;
  bool first = true;
  BytesVec vec{get_.bytesVec(o)};
  vec.all([&s, &fmt, &first](ZuBytes v) {
    if (!first)
      s << fmt.vecDelim;
    else
      first = false;
    s << Print::Bytes{v};
  });
  s << fmt.vecSuffix;
}

template <unsigned Code, typename S>
inline ZuIfT<Code == ZtFieldTypeCode::Int8Vec> MGet::print(
  S &s, const void *o, const ZtVField *field, const ZtFieldVFmt &fmt
) const {
  s << fmt.vecPrefix;
  Int8Vec vec{get_.int8Vec(o)};
  bool first = true;
  vec.all([&s, field, &fmt, &first](ZuBox<int8_t> v) {
    if (!first)
      s << fmt.vecDelim;
    else
      first = false;
    ZtVField_printInt_(s, v, field, fmt);
  });
  s << fmt.vecSuffix;
}
template <unsigned Code, typename S>
inline ZuIfT<Code == ZtFieldTypeCode::UInt8Vec> MGet::print(
  S &s, const void *o, const ZtVField *field, const ZtFieldVFmt &fmt
) const {
  s << fmt.vecPrefix;
  UInt8Vec vec{get_.uint8Vec(o)};
  bool first = true;
  vec.all([&s, field, &fmt, &first](ZuBox<uint8_t> v) {
    if (!first)
      s << fmt.vecDelim;
    else
      first = false;
    ZtVField_printInt_(s, v, field, fmt);
  });
  s << fmt.vecSuffix;
}
template <unsigned Code, typename S>
inline ZuIfT<Code == ZtFieldTypeCode::Int16Vec> MGet::print(
  S &s, const void *o, const ZtVField *field, const ZtFieldVFmt &fmt
) const {
  s << fmt.vecPrefix;
  Int16Vec vec{get_.int16Vec(o)};
  bool first = true;
  vec.all([&s, field, &fmt, &first](ZuBox<int16_t> v) {
    if (!first)
      s << fmt.vecDelim;
    else
      first = false;
    ZtVField_printInt_(s, v, field, fmt);
  });
  s << fmt.vecSuffix;
}
template <unsigned Code, typename S>
inline ZuIfT<Code == ZtFieldTypeCode::UInt16Vec> MGet::print(
  S &s, const void *o, const ZtVField *field, const ZtFieldVFmt &fmt
) const {
  s << fmt.vecPrefix;
  UInt16Vec vec{get_.uint16Vec(o)};
  bool first = true;
  vec.all([&s, field, &fmt, &first](ZuBox<uint16_t> v) {
    if (!first)
      s << fmt.vecDelim;
    else
      first = false;
    ZtVField_printInt_(s, v, field, fmt);
  });
  s << fmt.vecSuffix;
}
template <unsigned Code, typename S>
inline ZuIfT<Code == ZtFieldTypeCode::Int32Vec> MGet::print(
  S &s, const void *o, const ZtVField *field, const ZtFieldVFmt &fmt
) const {
  s << fmt.vecPrefix;
  Int32Vec vec{get_.int32Vec(o)};
  bool first = true;
  vec.all([&s, field, &fmt, &first](ZuBox<int32_t> v) {
    if (!first)
      s << fmt.vecDelim;
    else
      first = false;
    ZtVField_printInt_(s, v, field, fmt);
  });
  s << fmt.vecSuffix;
}
template <unsigned Code, typename S>
inline ZuIfT<Code == ZtFieldTypeCode::UInt32Vec> MGet::print(
  S &s, const void *o, const ZtVField *field, const ZtFieldVFmt &fmt
) const {
  s << fmt.vecPrefix;
  UInt32Vec vec{get_.uint32Vec(o)};
  bool first = true;
  vec.all([&s, field, &fmt, &first](ZuBox<uint32_t> v) {
    if (!first)
      s << fmt.vecDelim;
    else
      first = false;
    ZtVField_printInt_(s, v, field, fmt);
  });
  s << fmt.vecSuffix;
}
template <unsigned Code, typename S>
inline ZuIfT<Code == ZtFieldTypeCode::Int64Vec> MGet::print(
  S &s, const void *o, const ZtVField *field, const ZtFieldVFmt &fmt
) const {
  s << fmt.vecPrefix;
  Int64Vec vec{get_.int64Vec(o)};
  bool first = true;
  vec.all([&s, field, &fmt, &first](ZuBox<int64_t> v) {
    if (!first)
      s << fmt.vecDelim;
    else
      first = false;
    ZtVField_printInt_(s, v, field, fmt);
  });
  s << fmt.vecSuffix;
}
template <unsigned Code, typename S>
inline ZuIfT<Code == ZtFieldTypeCode::UInt64Vec> MGet::print(
  S &s, const void *o, const ZtVField *field, const ZtFieldVFmt &fmt
) const {
  s << fmt.vecPrefix;
  UInt64Vec vec{get_.uint64Vec(o)};
  bool first = true;
  vec.all([&s, field, &fmt, &first](ZuBox<uint64_t> v) {
    if (!first)
      s << fmt.vecDelim;
    else
      first = false;
    ZtVField_printInt_(s, v, field, fmt);
  });
  s << fmt.vecSuffix;
}
template <unsigned Code, typename S>
inline ZuIfT<Code == ZtFieldTypeCode::Int128Vec> MGet::print(
  S &s, const void *o, const ZtVField *field, const ZtFieldVFmt &fmt
) const {
  s << fmt.vecPrefix;
  Int128Vec vec{get_.int128Vec(o)};
  bool first = true;
  vec.all([&s, field, &fmt, &first](ZuBox<int128_t> v) {
    if (!first)
      s << fmt.vecDelim;
    else
      first = false;
    ZtVField_printInt_(s, v, field, fmt);
  });
  s << fmt.vecSuffix;
}
template <unsigned Code, typename S>
inline ZuIfT<Code == ZtFieldTypeCode::UInt128Vec> MGet::print(
  S &s, const void *o, const ZtVField *field, const ZtFieldVFmt &fmt
) const {
  s << fmt.vecPrefix;
  UInt128Vec vec{get_.uint128Vec(o)};
  bool first = true;
  vec.all([&s, field, &fmt, &first](ZuBox<uint128_t> v) {
    if (!first)
      s << fmt.vecDelim;
    else
      first = false;
    ZtVField_printInt_(s, v, field, fmt);
  });
  s << fmt.vecSuffix;
}

template <unsigned Code, typename S>
inline ZuIfT<Code == ZtFieldTypeCode::FloatVec> MGet::print(
  S &s, const void *o, const ZtVField *field, const ZtFieldVFmt &fmt
) const {
  s << fmt.vecPrefix;
  FloatVec vec{get_.floatVec(o)};
  auto ndp = field->ndp;
  bool first = true;
  if (!ZuCmp<decltype(ndp)>::null(ndp))
    vec.all([&s, &fmt, ndp, &first](ZuBox<double> v) {
      if (!first)
	s << fmt.vecDelim;
      else
	first = false;
      s << v.vfmt(fmt.scalar).fp(ndp);
    });
  else
    vec.all([&s, &first, &fmt](ZuBox<double> v) {
      if (!first)
	s << fmt.vecDelim;
      else
	first = false;
      s << v.vfmt(fmt.scalar);
    });
  s << fmt.vecSuffix;
}
template <unsigned Code, typename S>
inline ZuIfT<Code == ZtFieldTypeCode::FixedVec> MGet::print(
  S &s, const void *o, const ZtVField *field, const ZtFieldVFmt &fmt
) const {
  s << fmt.vecPrefix;
  bool first = true;
  FixedVec vec{get_.fixedVec(o)};
  auto ndp = field->ndp;
  if (!ZuCmp<decltype(ndp)>::null(ndp))
    vec.all([&s, &fmt, ndp, &first](const ZuFixed &v) {
      if (!first)
	s << fmt.vecDelim;
      else
	first = false;
      s << v.vfmt(fmt.scalar).fp(ndp);
    });
  else
    vec.all([&s, &first, &fmt](const ZuFixed &v) {
      if (!first)
	s << fmt.vecDelim;
      else
	first = false;
      s << v.vfmt(fmt.scalar);
    });
  s << fmt.vecSuffix;
}
template <unsigned Code, typename S>
inline ZuIfT<Code == ZtFieldTypeCode::DecimalVec> MGet::print(
  S &s, const void *o, const ZtVField *field, const ZtFieldVFmt &fmt
) const {
  s << fmt.vecPrefix;
  DecimalVec vec{get_.decimalVec(o)};
  auto ndp = field->ndp;
  bool first = true;
  if (!ZuCmp<decltype(ndp)>::null(ndp))
    vec.all([&s, &fmt, ndp, &first](const ZuDecimal &v) {
      if (!first)
	s << fmt.vecDelim;
      else
	first = false;
      s << v.vfmt(fmt.scalar).fp(ndp);
    });
  else
    vec.all([&s, &first, &fmt](const ZuDecimal &v) {
      if (!first)
	s << fmt.vecDelim;
      else
	first = false;
      s << v.vfmt(fmt.scalar);
    });
  s << fmt.vecSuffix;
}
template <unsigned Code, typename S>
inline ZuIfT<Code == ZtFieldTypeCode::TimeVec> MGet::print(
  S &s, const void *o, const ZtVField *field, const ZtFieldVFmt &fmt
) const {
  s << fmt.vecPrefix;
  bool first = true;
  TimeVec vec{get_.timeVec(o)};
  vec.all([&s, &fmt, &first](const ZuTime &v_) {
    ZuDateTime v{v_};
    if (!first)
      s << fmt.vecDelim;
    else
      first = false;
    s << v.fmt(fmt.datePrint);
  });
  s << fmt.vecSuffix;
}
template <unsigned Code, typename S>
inline ZuIfT<Code == ZtFieldTypeCode::DateTimeVec> MGet::print(
  S &s, const void *o, const ZtVField *field, const ZtFieldVFmt &fmt
) const {
  s << fmt.vecPrefix;
  bool first = true;
  DateTimeVec vec{get_.dateTimeVec(o)};
  vec.all([&s, &fmt, &first](const ZuDateTime &v) {
    if (!first)
      s << fmt.vecDelim;
    else
      first = false;
    s << v.fmt(fmt.datePrint);
  });
  s << fmt.vecSuffix;
}

template <unsigned Code>
inline ZuIfT<Code == ZtFieldTypeCode::CString>
MSet::scan(void *o, ZuCSpan s, const ZtVField *, const ZtFieldVFmt &) const {
  if (!s) {
    set_.cstring(o, nullptr);
    return;
  }
  unsigned n = s.length() + 1;
  auto buf_ = ZmAlloc_<char>{static_cast<char *>(
    !(n) ?
      nullptr :
      (((ZmStackAvail() >> 1) < ((n) * sizeof(char))) ?
	 Zm::alignedAlloc<alignof(char)>((n) * sizeof(char)) :
	 __builtin_alloca_with_align((n) * sizeof(char), (alignof(char)) << 3))
  )};
  ZuSpan<char> buf(&buf_[0], n);
  buf[Scan::string(buf, s)] = 0;
  set_.cstring(o, &buf[0]);
}
template <unsigned Code>
inline ZuIfT<Code == ZtFieldTypeCode::String>
MSet::scan(void *o, ZuCSpan s, const ZtVField *, const ZtFieldVFmt &) const {
  if (!s) {
    set_.string(o, s);
    return;
  }
  unsigned n = s.length();
  auto buf_ = ZmAlloc_<char>{static_cast<char *>(
    !(n) ?
      nullptr :
      (((ZmStackAvail() >> 1) < ((n) * sizeof(char))) ?
	 Zm::alignedAlloc<alignof(char)>((n) * sizeof(char)) :
	 __builtin_alloca_with_align((n) * sizeof(char), (alignof(char)) << 3))
  )};
  ZuSpan<char> buf(&buf_[0], n);
  buf.trunc(Scan::string(buf, s));
  set_.string(o, buf);
}
template <unsigned Code>
inline ZuIfT<Code == ZtFieldTypeCode::Bytes>
MSet::scan(void *o, ZuCSpan s, const ZtVField *, const ZtFieldVFmt &) const {
  auto n = ZuBase64::declen(s.length());
  auto buf_ = ZmAlloc_<uint8_t>{static_cast<uint8_t *>(
    !(n) ? nullptr :
	   (((ZmStackAvail() >> 1) < ((n) * sizeof(uint8_t))) ?
	      Zm::alignedAlloc<alignof(uint8_t)>((n) * sizeof(uint8_t)) :
	      __builtin_alloca_with_align(
		(n) * sizeof(uint8_t), (alignof(uint8_t)) << 3
	      ))
  )};
  ZuSpan<uint8_t> buf(&buf_[0], n);
  buf.trunc(ZuBase64::decode(buf, ZuBytes{s}));
  set_.bytes(o, buf);
}
template <unsigned Code>
inline ZuIfT<Code == ZtFieldTypeCode::Bool>
MSet::scan(void *o, ZuCSpan s, const ZtVField *, const ZtFieldVFmt &) const {
  set_.bool_(o, ZtScanBool(s));
}

template <typename T>
T ZtVField_scanInt_(ZuCSpan s, const ZtVField *field, const ZtFieldVFmt &fmt) {
  if (__builtin_expect(!!(field->props & ZtVFieldProp::Enum()), 0))
    return field->type->info.enum_()->scan(s);
  if (__builtin_expect(!!(field->props & ZtVFieldProp::Flags()), 0))
    return field->type->info.flags()->scan(s, fmt);
  if (field->props & ZtVFieldProp::Hex()) return ZuBox<T>{ZuFmt::Hex<>{}, s};
  return ZuBox<T>{s};
}

template <unsigned Code>
inline ZuIfT<Code == ZtFieldTypeCode::Int8> MSet::scan(
  void *o, ZuCSpan s, const ZtVField *field, const ZtFieldVFmt &fmt
) const {
  set_.int8(o, ZtVField_scanInt_<int8_t>(s, field, fmt));
}
template <unsigned Code>
inline ZuIfT<Code == ZtFieldTypeCode::UInt8> MSet::scan(
  void *o, ZuCSpan s, const ZtVField *field, const ZtFieldVFmt &fmt
) const {
  set_.uint8(o, ZtVField_scanInt_<uint8_t>(s, field, fmt));
}
template <unsigned Code>
inline ZuIfT<Code == ZtFieldTypeCode::Int16> MSet::scan(
  void *o, ZuCSpan s, const ZtVField *field, const ZtFieldVFmt &fmt
) const {
  set_.int16(o, ZtVField_scanInt_<int16_t>(s, field, fmt));
}
template <unsigned Code>
inline ZuIfT<Code == ZtFieldTypeCode::UInt16> MSet::scan(
  void *o, ZuCSpan s, const ZtVField *field, const ZtFieldVFmt &fmt
) const {
  set_.uint16(o, ZtVField_scanInt_<uint16_t>(s, field, fmt));
}
template <unsigned Code>
inline ZuIfT<Code == ZtFieldTypeCode::Int32> MSet::scan(
  void *o, ZuCSpan s, const ZtVField *field, const ZtFieldVFmt &fmt
) const {
  set_.int32(o, ZtVField_scanInt_<int32_t>(s, field, fmt));
}
template <unsigned Code>
inline ZuIfT<Code == ZtFieldTypeCode::UInt32> MSet::scan(
  void *o, ZuCSpan s, const ZtVField *field, const ZtFieldVFmt &fmt
) const {
  set_.uint32(o, ZtVField_scanInt_<uint32_t>(s, field, fmt));
}
template <unsigned Code>
inline ZuIfT<Code == ZtFieldTypeCode::Int64> MSet::scan(
  void *o, ZuCSpan s, const ZtVField *field, const ZtFieldVFmt &fmt
) const {
  set_.int64(o, ZtVField_scanInt_<int64_t>(s, field, fmt));
}
template <unsigned Code>
inline ZuIfT<Code == ZtFieldTypeCode::UInt64> MSet::scan(
  void *o, ZuCSpan s, const ZtVField *field, const ZtFieldVFmt &fmt
) const {
  set_.uint64(o, ZtVField_scanInt_<uint64_t>(s, field, fmt));
}
template <unsigned Code>
inline ZuIfT<Code == ZtFieldTypeCode::Int128> MSet::scan(
  void *o, ZuCSpan s, const ZtVField *field, const ZtFieldVFmt &fmt
) const {
  set_.int128(o, ZtVField_scanInt_<int128_t>(s, field, fmt));
}
template <unsigned Code>
inline ZuIfT<Code == ZtFieldTypeCode::UInt128> MSet::scan(
  void *o, ZuCSpan s, const ZtVField *field, const ZtFieldVFmt &fmt
) const {
  set_.uint128(o, ZtVField_scanInt_<uint128_t>(s, field, fmt));
}

template <unsigned Code>
inline ZuIfT<Code == ZtFieldTypeCode::Float>
MSet::scan(void *o, ZuCSpan s, const ZtVField *, const ZtFieldVFmt &) const {
  set_.float_(o, ZuBox<double>{s});
}
template <unsigned Code>
inline ZuIfT<Code == ZtFieldTypeCode::Fixed>
MSet::scan(void *o, ZuCSpan s, const ZtVField *, const ZtFieldVFmt &) const {
  set_.fixed(o, ZuFixed{s});
}
template <unsigned Code>
inline ZuIfT<Code == ZtFieldTypeCode::Decimal>
MSet::scan(void *o, ZuCSpan s, const ZtVField *, const ZtFieldVFmt &) const {
  set_.decimal(o, ZuDecimal{s});
}
template <unsigned Code>
inline ZuIfT<Code == ZtFieldTypeCode::Time>
MSet::scan(void *o, ZuCSpan s, const ZtVField *, const ZtFieldVFmt &fmt) const {
  set_.time(o, ZuDateTime{fmt.dateScan, s}.as_time());
}
template <unsigned Code>
inline ZuIfT<Code == ZtFieldTypeCode::DateTime>
MSet::scan(void *o, ZuCSpan s, const ZtVField *, const ZtFieldVFmt &fmt) const {
  set_.dateTime(o, ZuDateTime{fmt.dateScan, s});
}
template <unsigned Code>
inline ZuIfT<Code == ZtFieldTypeCode::UDT> MSet::scan(
  void *o, ZuCSpan s, const ZtVField *field, const ZtFieldVFmt &fmt
) const {
  field->type->info.udt()->scan(field->set.set_.udt, o, s, fmt);
}

namespace VecScan {

using namespace Scan;

inline bool match(ZuCSpan &s, ZuCSpan m) {
  unsigned n = m.length();
  if (s.length() < n || memcmp(&s[0], &m[0], n)) return false;
  s.offset(n);
  return true;
}
inline void skip(ZuCSpan &s) {
  while (s.length() && isspace__(s[0])) s.offset(1);
}

template <typename L>
inline unsigned scan(ZuCSpan &s, const ZtFieldVFmt &fmt, L l) {
  auto begin = &s[0];
  skip(s);
  if (!match(s, fmt.vecPrefix)) return 0;
  skip(s);
  while (l(s)) {
    skip(s);
    if (!match(s, fmt.vecDelim)) {
      match(s, fmt.vecSuffix);
      break;
    }
  }
  return &s[0] - begin;
}

} // namespace VecScan

template <unsigned Code>
inline ZuIfT<Code == ZtFieldTypeCode::CStringVec>
MSet::scan(void *o, ZuCSpan s, const ZtVField *, const ZtFieldVFmt &fmt) const {
  VecScan::scan(s, fmt, [this, o, &fmt](ZuCSpan &s) {
    auto m = s.length();
    auto buf_ = ZmAlloc_<char>{static_cast<char *>(
      !(m + 1) ? nullptr :
		 (((ZmStackAvail() >> 1) < ((m + 1) * sizeof(char))) ?
		    Zm::alignedAlloc<alignof(char)>((m + 1) * sizeof(char)) :
		    __builtin_alloca_with_align(
		      (m + 1) * sizeof(char), (alignof(char)) << 3
		    ))
    )};
    ZuSpan<char> buf(&buf_[0], m + 1);
    unsigned n = Scan::strElem(buf, s, fmt.vecDelim, fmt.vecSuffix);
    if (n) {
      buf[n] = 0;
      set_.cstring(o, &buf[0]);
      return true;
    }
    return false;
  });
}
template <unsigned Code>
inline ZuIfT<Code == ZtFieldTypeCode::StringVec>
MSet::scan(void *o, ZuCSpan s, const ZtVField *, const ZtFieldVFmt &fmt) const {
  VecScan::scan(s, fmt, [this, o, &fmt](ZuCSpan &s) {
    auto m = s.length();
    auto buf_ = ZmAlloc_<char>{static_cast<char *>(
      !(m) ?
	nullptr :
	(((ZmStackAvail() >> 1) < ((m) * sizeof(char))) ?
	   Zm::alignedAlloc<alignof(char)>((m) * sizeof(char)) :
	   __builtin_alloca_with_align((m) * sizeof(char), (alignof(char)) << 3)
	)
    )};
    ZuSpan<char> buf(&buf_[0], m);
    unsigned n = Scan::strElem(buf, s, fmt.vecDelim, fmt.vecSuffix);
    if (n) {
      buf.trunc(n);
      set_.string(o, ZuCSpan{&buf[0], buf.length()});
      return true;
    }
    return false;
  });
}
template <unsigned Code>
inline ZuIfT<Code == ZtFieldTypeCode::BytesVec>
MSet::scan(void *o, ZuCSpan s, const ZtVField *, const ZtFieldVFmt &fmt) const {
  VecScan::scan(s, fmt, [this, o](ZuCSpan &s) {
    unsigned n = 0;
    auto m = s.length();
    while (n < m && ZuBase64::is(s[n])) n++;
    n = ZuBase64::declen(m = n);
    if (n) {
      auto buf_ = ZmAlloc_<uint8_t>{static_cast<uint8_t *>(
	!(n) ? nullptr :
	       (((ZmStackAvail() >> 1) < ((n) * sizeof(uint8_t))) ?
		  Zm::alignedAlloc<alignof(uint8_t)>((n) * sizeof(uint8_t)) :
		  __builtin_alloca_with_align(
		    (n) * sizeof(uint8_t), (alignof(uint8_t)) << 3
		  ))
      )};
      ZuSpan<uint8_t> buf(&buf_[0], n);
      buf.trunc(ZuBase64::decode(buf, ZuBytes{s}));
      set_.bytes(o, ZuBytes{&buf[0], buf.length()});
      s.offset(m);
      return true;
    }
    return false;
  });
}

inline ZuCSpan ZtVField_scanVecElem(ZuCSpan s, const ZtFieldVFmt &fmt) {
  unsigned delim = 0, suffix = 0;
  unsigned i = 0, n = s.length();
  for (i = 0; i < n; i++) {
    if (s[i] == fmt.vecDelim[delim]) {
      if (++delim == fmt.vecDelim.length()) break;
    } else
      delim = 0;
    if (s[i] == fmt.vecSuffix[suffix]) {
      if (++suffix == fmt.vecSuffix.length()) break;
    } else
      suffix = 0;
  }
  s.trunc(i);
  return s;
}

template <typename T>
unsigned ZtVField_scanIntVec_(
  T &v, ZuCSpan s, const ZtVField *field, const ZtFieldVFmt &fmt
) {
  if (__builtin_expect(!!(field->props & ZtVFieldProp::Enum()), 0)) {
    auto s_ = ZtVField_scanVecElem(s, fmt);
    auto v_ = field->type->info.enum_()->scan(s_);
    v = v_;
    if (v_ < 0) return 0;
    return s_.length();
  }
  if (__builtin_expect(!!(field->props & ZtVFieldProp::Flags()), 0)) {
    auto s_ = ZtVField_scanVecElem(s, fmt);
    auto v_ = field->type->info.flags()->scan(s_, fmt);
    v = v_;
    if (!v_) return 0;
    return s_.length();
  }
  if (field->props & ZtVFieldProp::Hex())
    return v.template scan<ZuFmt::Hex<>>(s);
  return v.scan(s);
}

template <unsigned Code>
inline ZuIfT<Code == ZtFieldTypeCode::Int8Vec> MSet::scan(
  void *o, ZuCSpan s, const ZtVField *field, const ZtFieldVFmt &fmt
) const {
  VecScan::scan(s, fmt, [this, o, field, fmt](ZuCSpan &s) {
    ZuBox<int8_t> v;
    unsigned n = ZtVField_scanIntVec_(v, s, field, fmt);
    if (n) {
      set_.int8(o, v);
      s.offset(n);
      return true;
    }
    return false;
  });
}
template <unsigned Code>
inline ZuIfT<Code == ZtFieldTypeCode::UInt8Vec> MSet::scan(
  void *o, ZuCSpan s, const ZtVField *field, const ZtFieldVFmt &fmt
) const {
  VecScan::scan(s, fmt, [this, o, field, fmt](ZuCSpan &s) {
    ZuBox<uint8_t> v;
    unsigned n = ZtVField_scanIntVec_(v, s, field, fmt);
    if (n) {
      set_.uint8(o, v);
      s.offset(n);
      return true;
    }
    return false;
  });
}
template <unsigned Code>
inline ZuIfT<Code == ZtFieldTypeCode::Int16Vec> MSet::scan(
  void *o, ZuCSpan s, const ZtVField *field, const ZtFieldVFmt &fmt
) const {
  VecScan::scan(s, fmt, [this, o, field, fmt](ZuCSpan &s) {
    ZuBox<int16_t> v;
    unsigned n = ZtVField_scanIntVec_(v, s, field, fmt);
    if (n) {
      set_.int16(o, v);
      s.offset(n);
      return true;
    }
    return false;
  });
}
template <unsigned Code>
inline ZuIfT<Code == ZtFieldTypeCode::UInt16Vec> MSet::scan(
  void *o, ZuCSpan s, const ZtVField *field, const ZtFieldVFmt &fmt
) const {
  VecScan::scan(s, fmt, [this, o, field, fmt](ZuCSpan &s) {
    ZuBox<uint16_t> v;
    unsigned n = ZtVField_scanIntVec_(v, s, field, fmt);
    if (n) {
      set_.uint16(o, v);
      s.offset(n);
      return true;
    }
    return false;
  });
}
template <unsigned Code>
inline ZuIfT<Code == ZtFieldTypeCode::Int32Vec> MSet::scan(
  void *o, ZuCSpan s, const ZtVField *field, const ZtFieldVFmt &fmt
) const {
  VecScan::scan(s, fmt, [this, o, field, fmt](ZuCSpan &s) {
    ZuBox<int32_t> v;
    unsigned n = ZtVField_scanIntVec_(v, s, field, fmt);
    if (n) {
      set_.int32(o, v);
      s.offset(n);
      return true;
    }
    return false;
  });
}
template <unsigned Code>
inline ZuIfT<Code == ZtFieldTypeCode::UInt32Vec> MSet::scan(
  void *o, ZuCSpan s, const ZtVField *field, const ZtFieldVFmt &fmt
) const {
  VecScan::scan(s, fmt, [this, o, field, fmt](ZuCSpan &s) {
    ZuBox<uint32_t> v;
    unsigned n = ZtVField_scanIntVec_(v, s, field, fmt);
    if (n) {
      set_.uint32(o, v);
      s.offset(n);
      return true;
    }
    return false;
  });
}
template <unsigned Code>
inline ZuIfT<Code == ZtFieldTypeCode::Int64Vec> MSet::scan(
  void *o, ZuCSpan s, const ZtVField *field, const ZtFieldVFmt &fmt
) const {
  VecScan::scan(s, fmt, [this, o, field, fmt](ZuCSpan &s) {
    ZuBox<int64_t> v;
    unsigned n = ZtVField_scanIntVec_(v, s, field, fmt);
    if (n) {
      set_.int64(o, v);
      s.offset(n);
      return true;
    }
    return false;
  });
}
template <unsigned Code>
inline ZuIfT<Code == ZtFieldTypeCode::UInt64Vec> MSet::scan(
  void *o, ZuCSpan s, const ZtVField *field, const ZtFieldVFmt &fmt
) const {
  VecScan::scan(s, fmt, [this, o, field, fmt](ZuCSpan &s) {
    ZuBox<uint64_t> v;
    unsigned n = ZtVField_scanIntVec_(v, s, field, fmt);
    if (n) {
      set_.uint64(o, v);
      s.offset(n);
      return true;
    }
    return false;
  });
}
template <unsigned Code>
inline ZuIfT<Code == ZtFieldTypeCode::Int128Vec> MSet::scan(
  void *o, ZuCSpan s, const ZtVField *field, const ZtFieldVFmt &fmt
) const {
  VecScan::scan(s, fmt, [this, o, field, fmt](ZuCSpan &s) {
    ZuBox<int128_t> v;
    unsigned n = ZtVField_scanIntVec_(v, s, field, fmt);
    if (n) {
      set_.int128(o, v);
      s.offset(n);
      return true;
    }
    return false;
  });
}
template <unsigned Code>
inline ZuIfT<Code == ZtFieldTypeCode::UInt128Vec> MSet::scan(
  void *o, ZuCSpan s, const ZtVField *field, const ZtFieldVFmt &fmt
) const {
  VecScan::scan(s, fmt, [this, o, field, fmt](ZuCSpan &s) {
    ZuBox<uint128_t> v;
    unsigned n = ZtVField_scanIntVec_(v, s, field, fmt);
    if (n) {
      set_.uint128(o, v);
      s.offset(n);
      return true;
    }
    return false;
  });
}

template <unsigned Code>
inline ZuIfT<Code == ZtFieldTypeCode::FloatVec>
MSet::scan(void *o, ZuCSpan s, const ZtVField *, const ZtFieldVFmt &fmt) const {
  VecScan::scan(s, fmt, [this, o](ZuCSpan &s) {
    ZuBox<double> v;
    unsigned n = v.scan(s);
    if (n) {
      set_.float_(o, v);
      s.offset(n);
      return true;
    }
    return false;
  });
}
template <unsigned Code>
inline ZuIfT<Code == ZtFieldTypeCode::FixedVec>
MSet::scan(void *o, ZuCSpan s, const ZtVField *, const ZtFieldVFmt &fmt) const {
  VecScan::scan(s, fmt, [this, o](ZuCSpan &s) {
    ZuFixed v;
    unsigned n = v.scan(s);
    if (n) {
      set_.fixed(o, v);
      s.offset(n);
      return true;
    }
    return false;
  });
}
template <unsigned Code>
inline ZuIfT<Code == ZtFieldTypeCode::DecimalVec>
MSet::scan(void *o, ZuCSpan s, const ZtVField *, const ZtFieldVFmt &fmt) const {
  VecScan::scan(s, fmt, [this, o](ZuCSpan &s) {
    ZuDecimal v;
    unsigned n = v.scan(s);
    if (n) {
      set_.decimal(o, v);
      s.offset(n);
      return true;
    }
    return false;
  });
}
template <unsigned Code>
inline ZuIfT<Code == ZtFieldTypeCode::TimeVec>
MSet::scan(void *o, ZuCSpan s, const ZtVField *, const ZtFieldVFmt &fmt) const {
  VecScan::scan(s, fmt, [this, o, &fmt](ZuCSpan &s) {
    ZuDateTime v;
    unsigned n = v.scan(fmt.dateScan, s);
    if (n) {
      set_.time(o, v.as_time());
      s.offset(n);
      return true;
    }
    return false;
  });
}
template <unsigned Code>
inline ZuIfT<Code == ZtFieldTypeCode::DateTimeVec>
MSet::scan(void *o, ZuCSpan s, const ZtVField *, const ZtFieldVFmt &fmt) const {
  VecScan::scan(s, fmt, [this, o, &fmt](ZuCSpan &s) {
    ZuDateTime v;
    unsigned n = v.scan(fmt.dateScan, s);
    if (n) {
      set_.dateTime(o, ZuMv(v));
      s.offset(n);
      return true;
    }
    return false;
  });
}

} // namespace ZtField_

template <typename Base_> struct ZtField : public Base_ {
  using Base = Base_;
  using Orig = Base;
  using O = typename Base::O;
  using T = typename Base::T;
  using Props = typename Base::Props;
  static constexpr ZtVFieldProp::T mprops() {
    return ZtVFieldProp::Value<Props>{};
  }
};

template <typename T, typename Props> struct ZtFieldType_CString;
template <typename Props_>
struct ZtFieldType_CString<char *, Props_> : public ZtFieldType_<Props_> {
  enum { Code = ZtFieldTypeCode::CString };
  using T = char *;
  using Props = Props_;
  template <typename = ZtFieldFmt::Default>
  using Print = ZtField_::Print::CString;
  inline static ZtVFieldType *mtype();
};
template <typename T, typename Props>
struct ZtFieldType<ZtFieldTypeCode::CString, T, Props> :
  public ZtFieldType_CString<T, Props> { };

template <typename T, typename Props> struct ZtVFieldType_CString;
template <typename Props>
struct ZtVFieldType_CString<char *, Props> : public ZtVFieldType {
  using T = char *;
  ZtVFieldType_CString() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::CString,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.null = nullptr}
    } { }
};
template <typename Props>
ZtVFieldType *ZtFieldType_CString<char *, Props>::mtype() {
  return ZmSingleton<ZtVFieldType_CString<char *, Props>>::instance();
}

inline const char *ZtField_CString_Def() { return nullptr; }
template <typename Base, auto Def = ZtField_CString_Def, bool = Base::ReadOnly>
struct ZtField_CString : public ZtField<Base> {
  template <template <typename> typename Override>
  using Adapt = ZtField_CString<Override<Base>>;
  using O = typename Base::O;
  using T = char *;
  using Props = typename Base::Props;
  using Type =
    ZtFieldType_CString<char *, ZuTypeGrep<ZtFieldType_Props, Props>>;
  enum { Code = Type::Code };
  static ZtVFieldGet getFn() {
    return {.get_ = {.cstring = [](const void *o) -> const char * {
      return Base::get(*static_cast<const O *>(o));
    }}};
  }
  static ZtVFieldSet setFn() {
    return {.set_ = {.cstring = [](void *, const char *) {}}};
  }
  static const char *deflt() { return Def(); }
  static ZtVFieldGet constantFn() {
    using namespace ZtVFieldConstant;
    return {.get_ = {.cstring = [](const void *o) -> const char * {
      switch (int(reinterpret_cast<uintptr_t>(o))) {
      case Deflt:
	return Def();
      default:
	return nullptr;
      }
    }}};
  }
};
template <typename Base, auto Def>
struct ZtField_CString<Base, Def, false> :
  public ZtField_CString<Base, Def, true> {
  using O = typename Base::O;
  static ZtVFieldSet setFn() {
    return {.set_ = {.cstring = [](void *o_, unsigned, const char *s) {
      O &o = *static_cast<const O *>(o_);
      auto ptr = Base::get(o);
      if (ptr) ::free(ptr);
      Base::set(o, s ? strdup(s) : static_cast<const char *>(nullptr));
    }}};
  }
};

template <typename T_, typename Props_>
struct ZtFieldType_String : public ZtFieldType_<Props_> {
  enum { Code = ZtFieldTypeCode::String };
  using T = T_;
  using Props = Props_;
  template <typename = ZtFieldFmt::Default>
  using Print = ZtField_::Print::String;
  inline static ZtVFieldType *mtype();
};
template <typename T, typename Props>
struct ZtFieldType<ZtFieldTypeCode::String, T, Props> :
  public ZtFieldType_String<T, Props> { };

template <typename T, typename Props>
struct ZtVFieldType_String : public ZtVFieldType {
  ZtVFieldType_String() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::String,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.null = nullptr}
    } { }
};
template <typename T, typename Props>
ZtVFieldType *ZtFieldType_String<T, Props>::mtype() {
  return ZmSingleton<ZtVFieldType_String<T, Props>>::instance();
}

inline ZuCSpan ZtField_String_Def() { return {}; }
template <typename Base, typename = void> struct ZtField_String_Get {
  static ZtVFieldGet getFn() {
    using O = typename Base::O;

    return {.get_ = {.string = [](const void *o) -> ZuCSpan {
      auto &v = ZmTLS<ZtString, getFn>();
      v = Base::get(*static_cast<const O *>(o));
      return v;
    }}};
  }
};
template <typename Base>
struct ZtField_String_Get<
  Base, decltype(&Base::get(ZuDeclVal<const typename Base::O &>()), void())> {
  static ZtVFieldGet getFn() {
    using O = typename Base::O;

    return {.get_ = {.string = [](const void *o) -> ZuCSpan {
      return Base::get(*static_cast<const O *>(o));
    }}};
  }
};
template <typename Base, auto Def = ZtField_String_Def, bool = Base::ReadOnly>
struct ZtField_String : public ZtField<Base>, public ZtField_String_Get<Base> {
  template <template <typename> typename Override>
  using Adapt = ZtField_String<Override<Base>>;
  using O = typename Base::O;
  using T = typename Base::T;
  using Props = typename Base::Props;
  using Type = ZtFieldType_String<T, ZuTypeGrep<ZtFieldType_Props, Props>>;
  enum { Code = Type::Code };
  static ZtVFieldSet setFn() {
    return {.set_ = {.string = [](void *, ZuCSpan) {}}};
  }
  static ZuCSpan deflt() { return Def(); }
  static ZtVFieldGet constantFn() {
    using namespace ZtVFieldConstant;
    return {.get_ = {.string = [](const void *o) -> ZuCSpan {
      switch (int(reinterpret_cast<uintptr_t>(o))) {
      case Deflt:
	return Def();
      default:
	return {};
      }
    }}};
  }
};
template <typename Base, auto Def>
struct ZtField_String<Base, Def, false> :
  public ZtField_String<Base, Def, true> {
  using O = typename Base::O;
  static ZtVFieldSet setFn() {
    return {.set_ = {.string = [](void *o, ZuCSpan s) {
      Base::set(*static_cast<O *>(o), s);
    }}};
  }
};

template <typename T_, typename Props_>
struct ZtFieldType_Bytes : public ZtFieldType_<Props_> {
  enum { Code = ZtFieldTypeCode::Bytes };
  using T = T_;
  using Props = Props_;
  template <typename = ZtFieldFmt::Default>
  using Print = ZtField_::Print::Bytes;
  inline static ZtVFieldType *mtype();
};
template <typename T, typename Props>
struct ZtFieldType<ZtFieldTypeCode::Bytes, T, Props> :
  public ZtFieldType_Bytes<T, Props> { };

template <typename T, typename Props>
struct ZtVFieldType_Bytes : public ZtVFieldType {
  ZtVFieldType_Bytes() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::Bytes,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.null = nullptr}
    } { }
};
template <typename T, typename Props>
ZtVFieldType *ZtFieldType_Bytes<T, Props>::mtype() {
  return ZmSingleton<ZtVFieldType_Bytes<T, Props>>::instance();
}

inline ZuBytes ZtField_Bytes_Def() { return {}; }
template <typename Base, typename = void> struct ZtField_Bytes_Get {
  static ZtVFieldGet getFn() {
    using O = typename Base::O;

    return {.get_ = {.bytes = [](const void *o) -> ZuBytes {
      auto &v = ZmTLS<ZtBytes, getFn>();
      v = Base::get(*static_cast<const O *>(o));
      return v;
    }}};
  }
};
template <typename Base>
struct ZtField_Bytes_Get<
  Base, decltype(&Base::get(ZuDeclVal<const typename Base::O &>()), void())> {
  static ZtVFieldGet getFn() {
    using O = typename Base::O;

    return {.get_ = {.bytes = [](const void *o) -> ZuBytes {
      return Base::get(*static_cast<const O *>(o));
    }}};
  }
};
template <typename Base, auto Def = ZtField_Bytes_Def, bool = Base::ReadOnly>
struct ZtField_Bytes : public ZtField<Base>, public ZtField_Bytes_Get<Base> {
  template <template <typename> typename Override>
  using Adapt = ZtField_Bytes<Override<Base>>;
  using O = typename Base::O;
  using T = typename Base::T;
  using Props = typename Base::Props;
  using Type = ZtFieldType_Bytes<T, ZuTypeGrep<ZtFieldType_Props, Props>>;
  enum { Code = Type::Code };
  static ZtVFieldSet setFn() {
    return {.set_ = {.bytes = [](void *, ZuBytes) {}}};
  }
  static ZuBytes deflt() { return Def(); }
  static ZtVFieldGet constantFn() {
    using namespace ZtVFieldConstant;
    return {.get_ = {.bytes = [](const void *o) -> ZuBytes {
      switch (int(reinterpret_cast<uintptr_t>(o))) {
      case Deflt:
	return Def();
      default:
	return {};
      }
    }}};
  }
};
template <typename Base, auto Def>
struct ZtField_Bytes<Base, Def, false> : public ZtField_Bytes<Base, Def, true> {
  using O = typename Base::O;
  static ZtVFieldSet setFn() {
    return {.set_ = {.bytes = [](void *o, ZuBytes v) {
      Base::set(*static_cast<O *>(o), v);
    }}};
  }
};

template <typename T_, typename Props_>
struct ZtFieldType_Bool : public ZtFieldType_<Props_> {
  enum { Code = ZtFieldTypeCode::Bool };
  using T = T_;
  using Props = Props_;
  template <typename = ZtFieldFmt::Default> struct Print {
    bool v;
    template <typename S> friend S &operator<<(S &s, const Print &print) {
      return s << (print.v ? '1' : '0');
    }
  };
  inline static ZtVFieldType *mtype();
};
template <typename T, typename Props>
struct ZtFieldType<ZtFieldTypeCode::Bool, T, Props> :
  public ZtFieldType_Bool<T, Props> { };

template <typename T, typename Props>
struct ZtVFieldType_Bool : public ZtVFieldType {
  ZtVFieldType_Bool() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::Bool,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.null = nullptr}
    } { }
};
template <typename T, typename Props>
ZtVFieldType *ZtFieldType_Bool<T, Props>::mtype() {
  return ZmSingleton<ZtVFieldType_Bool<T, Props>>::instance();
}

inline constexpr bool ZtField_Bool_Def() { return false; }
template <typename Base, auto Def = ZtField_Bool_Def, bool = Base::ReadOnly>
struct ZtField_Bool : public ZtField<Base> {
  template <template <typename> typename Override>
  using Adapt = ZtField_Bool<Override<Base>>;
  using O = typename Base::O;
  using T = typename Base::T;
  using Props = typename Base::Props;
  using Type = ZtFieldType_Bool<T, ZuTypeGrep<ZtFieldType_Props, Props>>;
  enum { Code = Type::Code };
  static ZtVFieldGet getFn() {
    return {.get_ = {.bool_ = [](const void *o) -> bool {
      return Base::get(*static_cast<const O *>(o));
    }}};
  }
  static ZtVFieldSet setFn() {
    return {.set_ = {.bool_ = [](void *, bool) {}}};
  }
  static constexpr auto deflt() { return Def(); }
  static ZtVFieldGet constantFn() {
    using namespace ZtVFieldConstant;
    return {.get_ = {.bool_ = [](const void *o) -> bool {
      switch (int(reinterpret_cast<uintptr_t>(o))) {
      case Deflt:
	return Def();
      case Minimum:
	return false;
      case Maximum:
	return true;
      default:
	return false;
      }
    }}};
  }
};
template <typename Base, auto Def>
struct ZtField_Bool<Base, Def, false> : public ZtField_Bool<Base, Def, true> {
  using O = typename Base::O;
  static ZtVFieldSet setFn() {
    return {.set_ = {.bool_ = [](void *o, bool v) {
      Base::set(*static_cast<O *>(o), v);
    }}};
  }
};

template <typename Props, typename Fmt, typename S, typename T>
S &ZtField_printInt(S &s, const T &v) {
  using namespace ZuFieldProp;
  if constexpr (ZuFieldProp::HasEnum<Props>{})
    return s << GetEnum<Props>::v2s(v);
  else if constexpr (ZuFieldProp::HasFlags<Props>{})
    return s << GetFlags<Props>::print(v, Fmt::FlagsDelim());
  else if constexpr (ZuTypeIn<ZuFieldProp::Hex, Props>{})
    return s << v.template hex<false, Fmt>();
  else
    return s << v.template fmt<Fmt>();
}

template <typename T_, typename Props_>
struct ZtFieldType_Int8 : public ZtFieldType_<Props_> {
  enum { Code = ZtFieldTypeCode::Int8 };
  using T = T_;
  using Props = Props_;
  template <typename Fmt = ZtFieldFmt::Default> struct Print {
    ZuBox<int8_t> v;
    template <typename S> friend S &operator<<(S &s, const Print &print) {
      return ZtField_printInt<Props, Fmt>(s, print.v);
    }
  };
  inline static ZtVFieldType *mtype();
};
template <typename T, typename Props>
struct ZtFieldType<ZtFieldTypeCode::Int8, T, Props> :
  public ZtFieldType_Int8<T, Props> { };
template <
  typename T, typename Props, bool = ZuFieldProp::HasEnum<Props>{},
  bool = ZuFieldProp::HasFlags<Props>{}>
struct ZtVFieldType_Int8;
template <typename T, typename Props>
struct ZtVFieldType_Int8<T, Props, false, false> : public ZtVFieldType {
  ZtVFieldType_Int8() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::Int8,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.null = nullptr}
    } { }
};
template <typename T, typename Props>
struct ZtVFieldType_Int8<T, Props, true, false> : public ZtVFieldType {
  ZtVFieldType_Int8() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::Int8,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.enum_ = []() -> ZtVFieldEnum * {
	return ZtVFieldEnum_<ZuFieldProp::GetEnum<Props>>::instance();
      }}
    } { }
};
template <typename T, typename Props>
struct ZtVFieldType_Int8<T, Props, false, true> : public ZtVFieldType {
  ZtVFieldType_Int8() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::Int8,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.flags = []() -> ZtVFieldFlags * {
	return ZtVFieldFlags_<ZuFieldProp::GetFlags<Props>>::instance();
      }}
    } { }
};
template <typename T, typename Props>
ZtVFieldType *ZtFieldType_Int8<T, Props>::mtype() {
  return ZmSingleton<ZtVFieldType_Int8<T, Props>>::instance();
}
template <typename T> struct ZtFieldType_Int8_Def {
  static constexpr auto deflt() { return ZuCmp<T>::null(); }
  static constexpr auto minimum() { return ZuCmp<T>::minimum(); }
  static constexpr auto maximum() { return ZuCmp<T>::maximum(); }
};
template <
  typename Base, auto Def = ZtFieldType_Int8_Def<typename Base::T>::deflt,
  auto Min = ZtFieldType_Int8_Def<typename Base::T>::minimum,
  auto Max = ZtFieldType_Int8_Def<typename Base::T>::maximum,
  bool = Base::ReadOnly>
struct ZtField_Int8 : public ZtField<Base> {
  template <template <typename> typename Override>
  using Adapt = ZtField_Int8<Override<Base>>;
  using O = typename Base::O;
  using T = typename Base::T;
  using Props = typename Base::Props;
  using Type = ZtFieldType_Int8<T, ZuTypeGrep<ZtFieldType_Props, Props>>;
  enum { Code = Type::Code };
  static ZtVFieldGet getFn() {
    return {.get_ = {.int8 = [](const void *o) -> int8_t {
      return Base::get(*static_cast<const O *>(o));
    }}};
  }
  static ZtVFieldSet setFn() {
    return {.set_ = {.int8 = [](void *, int8_t) {}}};
  }
  static constexpr auto deflt() { return Def(); }
  static ZtVFieldGet constantFn() {
    using namespace ZtVFieldConstant;
    return {.get_ = {.int8 = [](const void *o) -> int8_t {
      switch (int(reinterpret_cast<uintptr_t>(o))) {
      case Deflt:
	return Def();
      case Minimum:
	return Min();
      case Maximum:
	return Max();
      default:
	return ZuCmp<int8_t>::null();
      }
    }}};
  }
};
template <typename Base, auto Def, auto Min, auto Max>
struct ZtField_Int8<Base, Def, Min, Max, false> :
  public ZtField_Int8<Base, Def, Min, Max, true> {
  using O = typename Base::O;
  using T = typename Base::T;
  static ZtVFieldSet setFn() {
    return {.set_ = {.int8 = [](void *o, int8_t v) {
      Base::set(*static_cast<O *>(o), v);
    }}};
  }
};
;
template <typename T_, typename Props_>
struct ZtFieldType_UInt8 : public ZtFieldType_<Props_> {
  enum { Code = ZtFieldTypeCode::UInt8 };
  using T = T_;
  using Props = Props_;
  template <typename Fmt = ZtFieldFmt::Default> struct Print {
    ZuBox<uint8_t> v;
    template <typename S> friend S &operator<<(S &s, const Print &print) {
      return ZtField_printInt<Props, Fmt>(s, print.v);
    }
  };
  inline static ZtVFieldType *mtype();
};
template <typename T, typename Props>
struct ZtFieldType<ZtFieldTypeCode::UInt8, T, Props> :
  public ZtFieldType_UInt8<T, Props> { };
template <
  typename T, typename Props, bool = ZuFieldProp::HasEnum<Props>{},
  bool = ZuFieldProp::HasFlags<Props>{}>
struct ZtVFieldType_UInt8;
template <typename T, typename Props>
struct ZtVFieldType_UInt8<T, Props, false, false> : public ZtVFieldType {
  ZtVFieldType_UInt8() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::UInt8,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.null = nullptr}
    } { }
};
template <typename T, typename Props>
struct ZtVFieldType_UInt8<T, Props, true, false> : public ZtVFieldType {
  ZtVFieldType_UInt8() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::UInt8,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.enum_ = []() -> ZtVFieldEnum * {
	return ZtVFieldEnum_<ZuFieldProp::GetEnum<Props>>::instance();
      }}
    } { }
};
template <typename T, typename Props>
struct ZtVFieldType_UInt8<T, Props, false, true> : public ZtVFieldType {
  ZtVFieldType_UInt8() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::UInt8,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.flags = []() -> ZtVFieldFlags * {
	return ZtVFieldFlags_<ZuFieldProp::GetFlags<Props>>::instance();
      }}
    } { }
};
template <typename T, typename Props>
ZtVFieldType *ZtFieldType_UInt8<T, Props>::mtype() {
  return ZmSingleton<ZtVFieldType_UInt8<T, Props>>::instance();
}
template <typename T> struct ZtFieldType_UInt8_Def {
  static constexpr auto deflt() { return ZuCmp<T>::null(); }
  static constexpr auto minimum() { return ZuCmp<T>::minimum(); }
  static constexpr auto maximum() { return ZuCmp<T>::maximum(); }
};
template <
  typename Base, auto Def = ZtFieldType_UInt8_Def<typename Base::T>::deflt,
  auto Min = ZtFieldType_UInt8_Def<typename Base::T>::minimum,
  auto Max = ZtFieldType_UInt8_Def<typename Base::T>::maximum,
  bool = Base::ReadOnly>
struct ZtField_UInt8 : public ZtField<Base> {
  template <template <typename> typename Override>
  using Adapt = ZtField_UInt8<Override<Base>>;
  using O = typename Base::O;
  using T = typename Base::T;
  using Props = typename Base::Props;
  using Type = ZtFieldType_UInt8<T, ZuTypeGrep<ZtFieldType_Props, Props>>;
  enum { Code = Type::Code };
  static ZtVFieldGet getFn() {
    return {.get_ = {.uint8 = [](const void *o) -> uint8_t {
      return Base::get(*static_cast<const O *>(o));
    }}};
  }
  static ZtVFieldSet setFn() {
    return {.set_ = {.uint8 = [](void *, uint8_t) {}}};
  }
  static constexpr auto deflt() { return Def(); }
  static ZtVFieldGet constantFn() {
    using namespace ZtVFieldConstant;
    return {.get_ = {.uint8 = [](const void *o) -> uint8_t {
      switch (int(reinterpret_cast<uintptr_t>(o))) {
      case Deflt:
	return Def();
      case Minimum:
	return Min();
      case Maximum:
	return Max();
      default:
	return ZuCmp<uint8_t>::null();
      }
    }}};
  }
};
template <typename Base, auto Def, auto Min, auto Max>
struct ZtField_UInt8<Base, Def, Min, Max, false> :
  public ZtField_UInt8<Base, Def, Min, Max, true> {
  using O = typename Base::O;
  using T = typename Base::T;
  static ZtVFieldSet setFn() {
    return {.set_ = {.uint8 = [](void *o, uint8_t v) {
      Base::set(*static_cast<O *>(o), v);
    }}};
  }
};
;
template <typename T_, typename Props_>
struct ZtFieldType_Int16 : public ZtFieldType_<Props_> {
  enum { Code = ZtFieldTypeCode::Int16 };
  using T = T_;
  using Props = Props_;
  template <typename Fmt = ZtFieldFmt::Default> struct Print {
    ZuBox<int16_t> v;
    template <typename S> friend S &operator<<(S &s, const Print &print) {
      return ZtField_printInt<Props, Fmt>(s, print.v);
    }
  };
  inline static ZtVFieldType *mtype();
};
template <typename T, typename Props>
struct ZtFieldType<ZtFieldTypeCode::Int16, T, Props> :
  public ZtFieldType_Int16<T, Props> { };
template <
  typename T, typename Props, bool = ZuFieldProp::HasEnum<Props>{},
  bool = ZuFieldProp::HasFlags<Props>{}>
struct ZtVFieldType_Int16;
template <typename T, typename Props>
struct ZtVFieldType_Int16<T, Props, false, false> : public ZtVFieldType {
  ZtVFieldType_Int16() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::Int16,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.null = nullptr}
    } { }
};
template <typename T, typename Props>
struct ZtVFieldType_Int16<T, Props, true, false> : public ZtVFieldType {
  ZtVFieldType_Int16() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::Int16,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.enum_ = []() -> ZtVFieldEnum * {
	return ZtVFieldEnum_<ZuFieldProp::GetEnum<Props>>::instance();
      }}
    } { }
};
template <typename T, typename Props>
struct ZtVFieldType_Int16<T, Props, false, true> : public ZtVFieldType {
  ZtVFieldType_Int16() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::Int16,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.flags = []() -> ZtVFieldFlags * {
	return ZtVFieldFlags_<ZuFieldProp::GetFlags<Props>>::instance();
      }}
    } { }
};
template <typename T, typename Props>
ZtVFieldType *ZtFieldType_Int16<T, Props>::mtype() {
  return ZmSingleton<ZtVFieldType_Int16<T, Props>>::instance();
}
template <typename T> struct ZtFieldType_Int16_Def {
  static constexpr auto deflt() { return ZuCmp<T>::null(); }
  static constexpr auto minimum() { return ZuCmp<T>::minimum(); }
  static constexpr auto maximum() { return ZuCmp<T>::maximum(); }
};
template <
  typename Base, auto Def = ZtFieldType_Int16_Def<typename Base::T>::deflt,
  auto Min = ZtFieldType_Int16_Def<typename Base::T>::minimum,
  auto Max = ZtFieldType_Int16_Def<typename Base::T>::maximum,
  bool = Base::ReadOnly>
struct ZtField_Int16 : public ZtField<Base> {
  template <template <typename> typename Override>
  using Adapt = ZtField_Int16<Override<Base>>;
  using O = typename Base::O;
  using T = typename Base::T;
  using Props = typename Base::Props;
  using Type = ZtFieldType_Int16<T, ZuTypeGrep<ZtFieldType_Props, Props>>;
  enum { Code = Type::Code };
  static ZtVFieldGet getFn() {
    return {.get_ = {.int16 = [](const void *o) -> int16_t {
      return Base::get(*static_cast<const O *>(o));
    }}};
  }
  static ZtVFieldSet setFn() {
    return {.set_ = {.int16 = [](void *, int16_t) {}}};
  }
  static constexpr auto deflt() { return Def(); }
  static ZtVFieldGet constantFn() {
    using namespace ZtVFieldConstant;
    return {.get_ = {.int16 = [](const void *o) -> int16_t {
      switch (int(reinterpret_cast<uintptr_t>(o))) {
      case Deflt:
	return Def();
      case Minimum:
	return Min();
      case Maximum:
	return Max();
      default:
	return ZuCmp<int16_t>::null();
      }
    }}};
  }
};
template <typename Base, auto Def, auto Min, auto Max>
struct ZtField_Int16<Base, Def, Min, Max, false> :
  public ZtField_Int16<Base, Def, Min, Max, true> {
  using O = typename Base::O;
  using T = typename Base::T;
  static ZtVFieldSet setFn() {
    return {.set_ = {.int16 = [](void *o, int16_t v) {
      Base::set(*static_cast<O *>(o), v);
    }}};
  }
};
;
template <typename T_, typename Props_>
struct ZtFieldType_UInt16 : public ZtFieldType_<Props_> {
  enum { Code = ZtFieldTypeCode::UInt16 };
  using T = T_;
  using Props = Props_;
  template <typename Fmt = ZtFieldFmt::Default> struct Print {
    ZuBox<uint16_t> v;
    template <typename S> friend S &operator<<(S &s, const Print &print) {
      return ZtField_printInt<Props, Fmt>(s, print.v);
    }
  };
  inline static ZtVFieldType *mtype();
};
template <typename T, typename Props>
struct ZtFieldType<ZtFieldTypeCode::UInt16, T, Props> :
  public ZtFieldType_UInt16<T, Props> { };
template <
  typename T, typename Props, bool = ZuFieldProp::HasEnum<Props>{},
  bool = ZuFieldProp::HasFlags<Props>{}>
struct ZtVFieldType_UInt16;
template <typename T, typename Props>
struct ZtVFieldType_UInt16<T, Props, false, false> : public ZtVFieldType {
  ZtVFieldType_UInt16() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::UInt16,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.null = nullptr}
    } { }
};
template <typename T, typename Props>
struct ZtVFieldType_UInt16<T, Props, true, false> : public ZtVFieldType {
  ZtVFieldType_UInt16() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::UInt16,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.enum_ = []() -> ZtVFieldEnum * {
	return ZtVFieldEnum_<ZuFieldProp::GetEnum<Props>>::instance();
      }}
    } { }
};
template <typename T, typename Props>
struct ZtVFieldType_UInt16<T, Props, false, true> : public ZtVFieldType {
  ZtVFieldType_UInt16() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::UInt16,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.flags = []() -> ZtVFieldFlags * {
	return ZtVFieldFlags_<ZuFieldProp::GetFlags<Props>>::instance();
      }}
    } { }
};
template <typename T, typename Props>
ZtVFieldType *ZtFieldType_UInt16<T, Props>::mtype() {
  return ZmSingleton<ZtVFieldType_UInt16<T, Props>>::instance();
}
template <typename T> struct ZtFieldType_UInt16_Def {
  static constexpr auto deflt() { return ZuCmp<T>::null(); }
  static constexpr auto minimum() { return ZuCmp<T>::minimum(); }
  static constexpr auto maximum() { return ZuCmp<T>::maximum(); }
};
template <
  typename Base, auto Def = ZtFieldType_UInt16_Def<typename Base::T>::deflt,
  auto Min = ZtFieldType_UInt16_Def<typename Base::T>::minimum,
  auto Max = ZtFieldType_UInt16_Def<typename Base::T>::maximum,
  bool = Base::ReadOnly>
struct ZtField_UInt16 : public ZtField<Base> {
  template <template <typename> typename Override>
  using Adapt = ZtField_UInt16<Override<Base>>;
  using O = typename Base::O;
  using T = typename Base::T;
  using Props = typename Base::Props;
  using Type = ZtFieldType_UInt16<T, ZuTypeGrep<ZtFieldType_Props, Props>>;
  enum { Code = Type::Code };
  static ZtVFieldGet getFn() {
    return {.get_ = {.uint16 = [](const void *o) -> uint16_t {
      return Base::get(*static_cast<const O *>(o));
    }}};
  }
  static ZtVFieldSet setFn() {
    return {.set_ = {.uint16 = [](void *, uint16_t) {}}};
  }
  static constexpr auto deflt() { return Def(); }
  static ZtVFieldGet constantFn() {
    using namespace ZtVFieldConstant;
    return {.get_ = {.uint16 = [](const void *o) -> uint16_t {
      switch (int(reinterpret_cast<uintptr_t>(o))) {
      case Deflt:
	return Def();
      case Minimum:
	return Min();
      case Maximum:
	return Max();
      default:
	return ZuCmp<uint16_t>::null();
      }
    }}};
  }
};
template <typename Base, auto Def, auto Min, auto Max>
struct ZtField_UInt16<Base, Def, Min, Max, false> :
  public ZtField_UInt16<Base, Def, Min, Max, true> {
  using O = typename Base::O;
  using T = typename Base::T;
  static ZtVFieldSet setFn() {
    return {.set_ = {.uint16 = [](void *o, uint16_t v) {
      Base::set(*static_cast<O *>(o), v);
    }}};
  }
};
;
template <typename T_, typename Props_>
struct ZtFieldType_Int32 : public ZtFieldType_<Props_> {
  enum { Code = ZtFieldTypeCode::Int32 };
  using T = T_;
  using Props = Props_;
  template <typename Fmt = ZtFieldFmt::Default> struct Print {
    ZuBox<int32_t> v;
    template <typename S> friend S &operator<<(S &s, const Print &print) {
      return ZtField_printInt<Props, Fmt>(s, print.v);
    }
  };
  inline static ZtVFieldType *mtype();
};
template <typename T, typename Props>
struct ZtFieldType<ZtFieldTypeCode::Int32, T, Props> :
  public ZtFieldType_Int32<T, Props> { };
template <
  typename T, typename Props, bool = ZuFieldProp::HasEnum<Props>{},
  bool = ZuFieldProp::HasFlags<Props>{}>
struct ZtVFieldType_Int32;
template <typename T, typename Props>
struct ZtVFieldType_Int32<T, Props, false, false> : public ZtVFieldType {
  ZtVFieldType_Int32() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::Int32,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.null = nullptr}
    } { }
};
template <typename T, typename Props>
struct ZtVFieldType_Int32<T, Props, true, false> : public ZtVFieldType {
  ZtVFieldType_Int32() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::Int32,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.enum_ = []() -> ZtVFieldEnum * {
	return ZtVFieldEnum_<ZuFieldProp::GetEnum<Props>>::instance();
      }}
    } { }
};
template <typename T, typename Props>
struct ZtVFieldType_Int32<T, Props, false, true> : public ZtVFieldType {
  ZtVFieldType_Int32() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::Int32,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.flags = []() -> ZtVFieldFlags * {
	return ZtVFieldFlags_<ZuFieldProp::GetFlags<Props>>::instance();
      }}
    } { }
};
template <typename T, typename Props>
ZtVFieldType *ZtFieldType_Int32<T, Props>::mtype() {
  return ZmSingleton<ZtVFieldType_Int32<T, Props>>::instance();
}
template <typename T> struct ZtFieldType_Int32_Def {
  static constexpr auto deflt() { return ZuCmp<T>::null(); }
  static constexpr auto minimum() { return ZuCmp<T>::minimum(); }
  static constexpr auto maximum() { return ZuCmp<T>::maximum(); }
};
template <
  typename Base, auto Def = ZtFieldType_Int32_Def<typename Base::T>::deflt,
  auto Min = ZtFieldType_Int32_Def<typename Base::T>::minimum,
  auto Max = ZtFieldType_Int32_Def<typename Base::T>::maximum,
  bool = Base::ReadOnly>
struct ZtField_Int32 : public ZtField<Base> {
  template <template <typename> typename Override>
  using Adapt = ZtField_Int32<Override<Base>>;
  using O = typename Base::O;
  using T = typename Base::T;
  using Props = typename Base::Props;
  using Type = ZtFieldType_Int32<T, ZuTypeGrep<ZtFieldType_Props, Props>>;
  enum { Code = Type::Code };
  static ZtVFieldGet getFn() {
    return {.get_ = {.int32 = [](const void *o) -> int32_t {
      return Base::get(*static_cast<const O *>(o));
    }}};
  }
  static ZtVFieldSet setFn() {
    return {.set_ = {.int32 = [](void *, int32_t) {}}};
  }
  static constexpr auto deflt() { return Def(); }
  static ZtVFieldGet constantFn() {
    using namespace ZtVFieldConstant;
    return {.get_ = {.int32 = [](const void *o) -> int32_t {
      switch (int(reinterpret_cast<uintptr_t>(o))) {
      case Deflt:
	return Def();
      case Minimum:
	return Min();
      case Maximum:
	return Max();
      default:
	return ZuCmp<int32_t>::null();
      }
    }}};
  }
};
template <typename Base, auto Def, auto Min, auto Max>
struct ZtField_Int32<Base, Def, Min, Max, false> :
  public ZtField_Int32<Base, Def, Min, Max, true> {
  using O = typename Base::O;
  using T = typename Base::T;
  static ZtVFieldSet setFn() {
    return {.set_ = {.int32 = [](void *o, int32_t v) {
      Base::set(*static_cast<O *>(o), v);
    }}};
  }
};
;
template <typename T_, typename Props_>
struct ZtFieldType_UInt32 : public ZtFieldType_<Props_> {
  enum { Code = ZtFieldTypeCode::UInt32 };
  using T = T_;
  using Props = Props_;
  template <typename Fmt = ZtFieldFmt::Default> struct Print {
    ZuBox<uint32_t> v;
    template <typename S> friend S &operator<<(S &s, const Print &print) {
      return ZtField_printInt<Props, Fmt>(s, print.v);
    }
  };
  inline static ZtVFieldType *mtype();
};
template <typename T, typename Props>
struct ZtFieldType<ZtFieldTypeCode::UInt32, T, Props> :
  public ZtFieldType_UInt32<T, Props> { };
template <
  typename T, typename Props, bool = ZuFieldProp::HasEnum<Props>{},
  bool = ZuFieldProp::HasFlags<Props>{}>
struct ZtVFieldType_UInt32;
template <typename T, typename Props>
struct ZtVFieldType_UInt32<T, Props, false, false> : public ZtVFieldType {
  ZtVFieldType_UInt32() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::UInt32,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.null = nullptr}
    } { }
};
template <typename T, typename Props>
struct ZtVFieldType_UInt32<T, Props, true, false> : public ZtVFieldType {
  ZtVFieldType_UInt32() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::UInt32,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.enum_ = []() -> ZtVFieldEnum * {
	return ZtVFieldEnum_<ZuFieldProp::GetEnum<Props>>::instance();
      }}
    } { }
};
template <typename T, typename Props>
struct ZtVFieldType_UInt32<T, Props, false, true> : public ZtVFieldType {
  ZtVFieldType_UInt32() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::UInt32,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.flags = []() -> ZtVFieldFlags * {
	return ZtVFieldFlags_<ZuFieldProp::GetFlags<Props>>::instance();
      }}
    } { }
};
template <typename T, typename Props>
ZtVFieldType *ZtFieldType_UInt32<T, Props>::mtype() {
  return ZmSingleton<ZtVFieldType_UInt32<T, Props>>::instance();
}
template <typename T> struct ZtFieldType_UInt32_Def {
  static constexpr auto deflt() { return ZuCmp<T>::null(); }
  static constexpr auto minimum() { return ZuCmp<T>::minimum(); }
  static constexpr auto maximum() { return ZuCmp<T>::maximum(); }
};
template <
  typename Base, auto Def = ZtFieldType_UInt32_Def<typename Base::T>::deflt,
  auto Min = ZtFieldType_UInt32_Def<typename Base::T>::minimum,
  auto Max = ZtFieldType_UInt32_Def<typename Base::T>::maximum,
  bool = Base::ReadOnly>
struct ZtField_UInt32 : public ZtField<Base> {
  template <template <typename> typename Override>
  using Adapt = ZtField_UInt32<Override<Base>>;
  using O = typename Base::O;
  using T = typename Base::T;
  using Props = typename Base::Props;
  using Type = ZtFieldType_UInt32<T, ZuTypeGrep<ZtFieldType_Props, Props>>;
  enum { Code = Type::Code };
  static ZtVFieldGet getFn() {
    return {.get_ = {.uint32 = [](const void *o) -> uint32_t {
      return Base::get(*static_cast<const O *>(o));
    }}};
  }
  static ZtVFieldSet setFn() {
    return {.set_ = {.uint32 = [](void *, uint32_t) {}}};
  }
  static constexpr auto deflt() { return Def(); }
  static ZtVFieldGet constantFn() {
    using namespace ZtVFieldConstant;
    return {.get_ = {.uint32 = [](const void *o) -> uint32_t {
      switch (int(reinterpret_cast<uintptr_t>(o))) {
      case Deflt:
	return Def();
      case Minimum:
	return Min();
      case Maximum:
	return Max();
      default:
	return ZuCmp<uint32_t>::null();
      }
    }}};
  }
};
template <typename Base, auto Def, auto Min, auto Max>
struct ZtField_UInt32<Base, Def, Min, Max, false> :
  public ZtField_UInt32<Base, Def, Min, Max, true> {
  using O = typename Base::O;
  using T = typename Base::T;
  static ZtVFieldSet setFn() {
    return {.set_ = {.uint32 = [](void *o, uint32_t v) {
      Base::set(*static_cast<O *>(o), v);
    }}};
  }
};
;
template <typename T_, typename Props_>
struct ZtFieldType_Int64 : public ZtFieldType_<Props_> {
  enum { Code = ZtFieldTypeCode::Int64 };
  using T = T_;
  using Props = Props_;
  template <typename Fmt = ZtFieldFmt::Default> struct Print {
    ZuBox<int64_t> v;
    template <typename S> friend S &operator<<(S &s, const Print &print) {
      return ZtField_printInt<Props, Fmt>(s, print.v);
    }
  };
  inline static ZtVFieldType *mtype();
};
template <typename T, typename Props>
struct ZtFieldType<ZtFieldTypeCode::Int64, T, Props> :
  public ZtFieldType_Int64<T, Props> { };
template <
  typename T, typename Props, bool = ZuFieldProp::HasEnum<Props>{},
  bool = ZuFieldProp::HasFlags<Props>{}>
struct ZtVFieldType_Int64;
template <typename T, typename Props>
struct ZtVFieldType_Int64<T, Props, false, false> : public ZtVFieldType {
  ZtVFieldType_Int64() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::Int64,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.null = nullptr}
    } { }
};
template <typename T, typename Props>
struct ZtVFieldType_Int64<T, Props, true, false> : public ZtVFieldType {
  ZtVFieldType_Int64() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::Int64,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.enum_ = []() -> ZtVFieldEnum * {
	return ZtVFieldEnum_<ZuFieldProp::GetEnum<Props>>::instance();
      }}
    } { }
};
template <typename T, typename Props>
struct ZtVFieldType_Int64<T, Props, false, true> : public ZtVFieldType {
  ZtVFieldType_Int64() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::Int64,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.flags = []() -> ZtVFieldFlags * {
	return ZtVFieldFlags_<ZuFieldProp::GetFlags<Props>>::instance();
      }}
    } { }
};
template <typename T, typename Props>
ZtVFieldType *ZtFieldType_Int64<T, Props>::mtype() {
  return ZmSingleton<ZtVFieldType_Int64<T, Props>>::instance();
}
template <typename T> struct ZtFieldType_Int64_Def {
  static constexpr auto deflt() { return ZuCmp<T>::null(); }
  static constexpr auto minimum() { return ZuCmp<T>::minimum(); }
  static constexpr auto maximum() { return ZuCmp<T>::maximum(); }
};
template <
  typename Base, auto Def = ZtFieldType_Int64_Def<typename Base::T>::deflt,
  auto Min = ZtFieldType_Int64_Def<typename Base::T>::minimum,
  auto Max = ZtFieldType_Int64_Def<typename Base::T>::maximum,
  bool = Base::ReadOnly>
struct ZtField_Int64 : public ZtField<Base> {
  template <template <typename> typename Override>
  using Adapt = ZtField_Int64<Override<Base>>;
  using O = typename Base::O;
  using T = typename Base::T;
  using Props = typename Base::Props;
  using Type = ZtFieldType_Int64<T, ZuTypeGrep<ZtFieldType_Props, Props>>;
  enum { Code = Type::Code };
  static ZtVFieldGet getFn() {
    return {.get_ = {.int64 = [](const void *o) -> int64_t {
      return Base::get(*static_cast<const O *>(o));
    }}};
  }
  static ZtVFieldSet setFn() {
    return {.set_ = {.int64 = [](void *, int64_t) {}}};
  }
  static constexpr auto deflt() { return Def(); }
  static ZtVFieldGet constantFn() {
    using namespace ZtVFieldConstant;
    return {.get_ = {.int64 = [](const void *o) -> int64_t {
      switch (int(reinterpret_cast<uintptr_t>(o))) {
      case Deflt:
	return Def();
      case Minimum:
	return Min();
      case Maximum:
	return Max();
      default:
	return ZuCmp<int64_t>::null();
      }
    }}};
  }
};
template <typename Base, auto Def, auto Min, auto Max>
struct ZtField_Int64<Base, Def, Min, Max, false> :
  public ZtField_Int64<Base, Def, Min, Max, true> {
  using O = typename Base::O;
  using T = typename Base::T;
  static ZtVFieldSet setFn() {
    return {.set_ = {.int64 = [](void *o, int64_t v) {
      Base::set(*static_cast<O *>(o), v);
    }}};
  }
};
;
template <typename T_, typename Props_>
struct ZtFieldType_UInt64 : public ZtFieldType_<Props_> {
  enum { Code = ZtFieldTypeCode::UInt64 };
  using T = T_;
  using Props = Props_;
  template <typename Fmt = ZtFieldFmt::Default> struct Print {
    ZuBox<uint64_t> v;
    template <typename S> friend S &operator<<(S &s, const Print &print) {
      return ZtField_printInt<Props, Fmt>(s, print.v);
    }
  };
  inline static ZtVFieldType *mtype();
};
template <typename T, typename Props>
struct ZtFieldType<ZtFieldTypeCode::UInt64, T, Props> :
  public ZtFieldType_UInt64<T, Props> { };
template <
  typename T, typename Props, bool = ZuFieldProp::HasEnum<Props>{},
  bool = ZuFieldProp::HasFlags<Props>{}>
struct ZtVFieldType_UInt64;
template <typename T, typename Props>
struct ZtVFieldType_UInt64<T, Props, false, false> : public ZtVFieldType {
  ZtVFieldType_UInt64() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::UInt64,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.null = nullptr}
    } { }
};
template <typename T, typename Props>
struct ZtVFieldType_UInt64<T, Props, true, false> : public ZtVFieldType {
  ZtVFieldType_UInt64() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::UInt64,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.enum_ = []() -> ZtVFieldEnum * {
	return ZtVFieldEnum_<ZuFieldProp::GetEnum<Props>>::instance();
      }}
    } { }
};
template <typename T, typename Props>
struct ZtVFieldType_UInt64<T, Props, false, true> : public ZtVFieldType {
  ZtVFieldType_UInt64() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::UInt64,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.flags = []() -> ZtVFieldFlags * {
	return ZtVFieldFlags_<ZuFieldProp::GetFlags<Props>>::instance();
      }}
    } { }
};
template <typename T, typename Props>
ZtVFieldType *ZtFieldType_UInt64<T, Props>::mtype() {
  return ZmSingleton<ZtVFieldType_UInt64<T, Props>>::instance();
}
template <typename T> struct ZtFieldType_UInt64_Def {
  static constexpr auto deflt() { return ZuCmp<T>::null(); }
  static constexpr auto minimum() { return ZuCmp<T>::minimum(); }
  static constexpr auto maximum() { return ZuCmp<T>::maximum(); }
};
template <
  typename Base, auto Def = ZtFieldType_UInt64_Def<typename Base::T>::deflt,
  auto Min = ZtFieldType_UInt64_Def<typename Base::T>::minimum,
  auto Max = ZtFieldType_UInt64_Def<typename Base::T>::maximum,
  bool = Base::ReadOnly>
struct ZtField_UInt64 : public ZtField<Base> {
  template <template <typename> typename Override>
  using Adapt = ZtField_UInt64<Override<Base>>;
  using O = typename Base::O;
  using T = typename Base::T;
  using Props = typename Base::Props;
  using Type = ZtFieldType_UInt64<T, ZuTypeGrep<ZtFieldType_Props, Props>>;
  enum { Code = Type::Code };
  static ZtVFieldGet getFn() {
    return {.get_ = {.uint64 = [](const void *o) -> uint64_t {
      return Base::get(*static_cast<const O *>(o));
    }}};
  }
  static ZtVFieldSet setFn() {
    return {.set_ = {.uint64 = [](void *, uint64_t) {}}};
  }
  static constexpr auto deflt() { return Def(); }
  static ZtVFieldGet constantFn() {
    using namespace ZtVFieldConstant;
    return {.get_ = {.uint64 = [](const void *o) -> uint64_t {
      switch (int(reinterpret_cast<uintptr_t>(o))) {
      case Deflt:
	return Def();
      case Minimum:
	return Min();
      case Maximum:
	return Max();
      default:
	return ZuCmp<uint64_t>::null();
      }
    }}};
  }
};
template <typename Base, auto Def, auto Min, auto Max>
struct ZtField_UInt64<Base, Def, Min, Max, false> :
  public ZtField_UInt64<Base, Def, Min, Max, true> {
  using O = typename Base::O;
  using T = typename Base::T;
  static ZtVFieldSet setFn() {
    return {.set_ = {.uint64 = [](void *o, uint64_t v) {
      Base::set(*static_cast<O *>(o), v);
    }}};
  }
};
;
template <typename T_, typename Props_>
struct ZtFieldType_Int128 : public ZtFieldType_<Props_> {
  enum { Code = ZtFieldTypeCode::Int128 };
  using T = T_;
  using Props = Props_;
  template <typename Fmt = ZtFieldFmt::Default> struct Print {
    ZuBox<int128_t> v;
    template <typename S> friend S &operator<<(S &s, const Print &print) {
      return ZtField_printInt<Props, Fmt>(s, print.v);
    }
  };
  inline static ZtVFieldType *mtype();
};
template <typename T, typename Props>
struct ZtFieldType<ZtFieldTypeCode::Int128, T, Props> :
  public ZtFieldType_Int128<T, Props> { };
template <
  typename T, typename Props, bool = ZuFieldProp::HasEnum<Props>{},
  bool = ZuFieldProp::HasFlags<Props>{}>
struct ZtVFieldType_Int128;
template <typename T, typename Props>
struct ZtVFieldType_Int128<T, Props, false, false> : public ZtVFieldType {
  ZtVFieldType_Int128() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::Int128,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.null = nullptr}
    } { }
};
template <typename T, typename Props>
struct ZtVFieldType_Int128<T, Props, true, false> : public ZtVFieldType {
  ZtVFieldType_Int128() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::Int128,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.enum_ = []() -> ZtVFieldEnum * {
	return ZtVFieldEnum_<ZuFieldProp::GetEnum<Props>>::instance();
      }}
    } { }
};
template <typename T, typename Props>
struct ZtVFieldType_Int128<T, Props, false, true> : public ZtVFieldType {
  ZtVFieldType_Int128() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::Int128,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.flags = []() -> ZtVFieldFlags * {
	return ZtVFieldFlags_<ZuFieldProp::GetFlags<Props>>::instance();
      }}
    } { }
};
template <typename T, typename Props>
ZtVFieldType *ZtFieldType_Int128<T, Props>::mtype() {
  return ZmSingleton<ZtVFieldType_Int128<T, Props>>::instance();
}
template <typename T> struct ZtFieldType_Int128_Def {
  static constexpr auto deflt() { return ZuCmp<T>::null(); }
  static constexpr auto minimum() { return ZuCmp<T>::minimum(); }
  static constexpr auto maximum() { return ZuCmp<T>::maximum(); }
};
template <
  typename Base, auto Def = ZtFieldType_Int128_Def<typename Base::T>::deflt,
  auto Min = ZtFieldType_Int128_Def<typename Base::T>::minimum,
  auto Max = ZtFieldType_Int128_Def<typename Base::T>::maximum,
  bool = Base::ReadOnly>
struct ZtField_Int128 : public ZtField<Base> {
  template <template <typename> typename Override>
  using Adapt = ZtField_Int128<Override<Base>>;
  using O = typename Base::O;
  using T = typename Base::T;
  using Props = typename Base::Props;
  using Type = ZtFieldType_Int128<T, ZuTypeGrep<ZtFieldType_Props, Props>>;
  enum { Code = Type::Code };
  static ZtVFieldGet getFn() {
    return {.get_ = {.int128 = [](const void *o) -> int128_t {
      return Base::get(*static_cast<const O *>(o));
    }}};
  }
  static ZtVFieldSet setFn() {
    return {.set_ = {.int128 = [](void *, int128_t) {}}};
  }
  static constexpr auto deflt() { return Def(); }
  static ZtVFieldGet constantFn() {
    using namespace ZtVFieldConstant;
    return {.get_ = {.int128 = [](const void *o) -> int128_t {
      switch (int(reinterpret_cast<uintptr_t>(o))) {
      case Deflt:
	return Def();
      case Minimum:
	return Min();
      case Maximum:
	return Max();
      default:
	return ZuCmp<int128_t>::null();
      }
    }}};
  }
};
template <typename Base, auto Def, auto Min, auto Max>
struct ZtField_Int128<Base, Def, Min, Max, false> :
  public ZtField_Int128<Base, Def, Min, Max, true> {
  using O = typename Base::O;
  using T = typename Base::T;
  static ZtVFieldSet setFn() {
    return {.set_ = {.int128 = [](void *o, int128_t v) {
      Base::set(*static_cast<O *>(o), v);
    }}};
  }
};
;
template <typename T_, typename Props_>
struct ZtFieldType_UInt128 : public ZtFieldType_<Props_> {
  enum { Code = ZtFieldTypeCode::UInt128 };
  using T = T_;
  using Props = Props_;
  template <typename Fmt = ZtFieldFmt::Default> struct Print {
    ZuBox<uint128_t> v;
    template <typename S> friend S &operator<<(S &s, const Print &print) {
      return ZtField_printInt<Props, Fmt>(s, print.v);
    }
  };
  inline static ZtVFieldType *mtype();
};
template <typename T, typename Props>
struct ZtFieldType<ZtFieldTypeCode::UInt128, T, Props> :
  public ZtFieldType_UInt128<T, Props> { };
template <
  typename T, typename Props, bool = ZuFieldProp::HasEnum<Props>{},
  bool = ZuFieldProp::HasFlags<Props>{}>
struct ZtVFieldType_UInt128;
template <typename T, typename Props>
struct ZtVFieldType_UInt128<T, Props, false, false> : public ZtVFieldType {
  ZtVFieldType_UInt128() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::UInt128,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.null = nullptr}
    } { }
};
template <typename T, typename Props>
struct ZtVFieldType_UInt128<T, Props, true, false> : public ZtVFieldType {
  ZtVFieldType_UInt128() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::UInt128,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.enum_ = []() -> ZtVFieldEnum * {
	return ZtVFieldEnum_<ZuFieldProp::GetEnum<Props>>::instance();
      }}
    } { }
};
template <typename T, typename Props>
struct ZtVFieldType_UInt128<T, Props, false, true> : public ZtVFieldType {
  ZtVFieldType_UInt128() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::UInt128,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.flags = []() -> ZtVFieldFlags * {
	return ZtVFieldFlags_<ZuFieldProp::GetFlags<Props>>::instance();
      }}
    } { }
};
template <typename T, typename Props>
ZtVFieldType *ZtFieldType_UInt128<T, Props>::mtype() {
  return ZmSingleton<ZtVFieldType_UInt128<T, Props>>::instance();
}
template <typename T> struct ZtFieldType_UInt128_Def {
  static constexpr auto deflt() { return ZuCmp<T>::null(); }
  static constexpr auto minimum() { return ZuCmp<T>::minimum(); }
  static constexpr auto maximum() { return ZuCmp<T>::maximum(); }
};
template <
  typename Base, auto Def = ZtFieldType_UInt128_Def<typename Base::T>::deflt,
  auto Min = ZtFieldType_UInt128_Def<typename Base::T>::minimum,
  auto Max = ZtFieldType_UInt128_Def<typename Base::T>::maximum,
  bool = Base::ReadOnly>
struct ZtField_UInt128 : public ZtField<Base> {
  template <template <typename> typename Override>
  using Adapt = ZtField_UInt128<Override<Base>>;
  using O = typename Base::O;
  using T = typename Base::T;
  using Props = typename Base::Props;
  using Type = ZtFieldType_UInt128<T, ZuTypeGrep<ZtFieldType_Props, Props>>;
  enum { Code = Type::Code };
  static ZtVFieldGet getFn() {
    return {.get_ = {.uint128 = [](const void *o) -> uint128_t {
      return Base::get(*static_cast<const O *>(o));
    }}};
  }
  static ZtVFieldSet setFn() {
    return {.set_ = {.uint128 = [](void *, uint128_t) {}}};
  }
  static constexpr auto deflt() { return Def(); }
  static ZtVFieldGet constantFn() {
    using namespace ZtVFieldConstant;
    return {.get_ = {.uint128 = [](const void *o) -> uint128_t {
      switch (int(reinterpret_cast<uintptr_t>(o))) {
      case Deflt:
	return Def();
      case Minimum:
	return Min();
      case Maximum:
	return Max();
      default:
	return ZuCmp<uint128_t>::null();
      }
    }}};
  }
};
template <typename Base, auto Def, auto Min, auto Max>
struct ZtField_UInt128<Base, Def, Min, Max, false> :
  public ZtField_UInt128<Base, Def, Min, Max, true> {
  using O = typename Base::O;
  using T = typename Base::T;
  static ZtVFieldSet setFn() {
    return {.set_ = {.uint128 = [](void *o, uint128_t v) {
      Base::set(*static_cast<O *>(o), v);
    }}};
  }
};
;

template <typename T_, typename Props_>
struct ZtFieldType_Float : public ZtFieldType_<Props_> {
  enum { Code = ZtFieldTypeCode::Float };
  using T = T_;
  using Props = Props_;
  template <typename Fmt = ZtFieldFmt::Default> struct Print {
    ZuBox<double> v;
    template <typename S> friend S &operator<<(S &s, const Print &print) {
      if constexpr (ZuFieldProp::HasNDP<Props>{})
	return s
	  << print.v.template fp<ZuFieldProp::GetNDP<Props>{}, '\0', Fmt>();
      else
	return s << print.v.template fmt<Fmt>();
    }
  };
  inline static ZtVFieldType *mtype();
};
template <typename T, typename Props>
struct ZtFieldType<ZtFieldTypeCode::Float, T, Props> :
  public ZtFieldType_Float<T, Props> { };

template <typename T, typename Props>
struct ZtVFieldType_Float : public ZtVFieldType {
  ZtVFieldType_Float() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::Float,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.null = nullptr}
    } { }
};
template <typename T, typename Props>
ZtVFieldType *ZtFieldType_Float<T, Props>::mtype() {
  return ZmSingleton<ZtVFieldType_Float<T, Props>>::instance();
}

template <typename T> struct ZtField_Float_Def {
  static constexpr auto deflt() { return ZuCmp<T>::null(); }
  static constexpr auto minimum() { return T{-ZuFP<ZuUnder<T>>::inf()}; }
  static constexpr auto maximum() { return T{ZuFP<ZuUnder<T>>::inf()}; }
};
template <
  typename Base, auto Def = ZtField_Float_Def<typename Base::T>::deflt,
  auto Min = ZtField_Float_Def<typename Base::T>::minimum,
  auto Max = ZtField_Float_Def<typename Base::T>::maximum,
  bool = Base::ReadOnly>
struct ZtField_Float : public ZtField<Base> {
  template <template <typename> typename Override>
  using Adapt = ZtField_Float<Override<Base>>;
  using O = typename Base::O;
  using T = typename Base::T;
  using Props = typename Base::Props;
  using Type = ZtFieldType_Float<T, ZuTypeGrep<ZtFieldType_Props, Props>>;
  enum { Code = Type::Code };
  static ZtVFieldGet getFn() {
    return {.get_ = {.float_ = [](const void *o) -> double {
      return Base::get(*static_cast<const O *>(o));
    }}};
  }
  static ZtVFieldSet setFn() {
    return {.set_ = {.float_ = [](void *, double) {}}};
  }
  static constexpr auto deflt() { return Def(); }
  static ZtVFieldGet constantFn() {
    using namespace ZtVFieldConstant;
    return {.get_ = {.float_ = [](const void *o) -> double {
      switch (int(reinterpret_cast<uintptr_t>(o))) {
      case Deflt:
	return Def();
      case Minimum:
	return Min();
      case Maximum:
	return Max();
      default:
	return ZuCmp<double>::null();
      }
    }}};
  }
};
template <typename Base, auto Def, auto Min, auto Max>
struct ZtField_Float<Base, Def, Min, Max, false> :
  public ZtField_Float<Base, Def, Min, Max, true> {
  using O = typename Base::O;
  using T = typename Base::T;
  static ZtVFieldSet setFn() {
    return {.set_ = {.float_ = [](void *o, double v) {
      Base::set(*static_cast<O *>(o), v);
    }}};
  }
};

template <typename T_, typename Props_>
struct ZtFieldType_Fixed : public ZtFieldType_<Props_> {
  enum { Code = ZtFieldTypeCode::Fixed };
  using T = T_;
  using Props = Props_;
  template <typename Fmt = ZtFieldFmt::Default> struct Print {
    ZuFixed v;
    template <typename S> friend S &operator<<(S &s, const Print &print) {
      if constexpr (ZuFieldProp::HasNDP<Props>{})
	return s
	  << print.v.template fp<ZuFieldProp::GetNDP<Props>{}, '\0', Fmt>();
      else
	return s << print.v.template fmt<Fmt>();
    }
  };
  inline static ZtVFieldType *mtype();
};
template <typename T, typename Props>
struct ZtFieldType<ZtFieldTypeCode::Fixed, T, Props> :
  public ZtFieldType_Fixed<T, Props> { };

template <typename T, typename Props>
struct ZtVFieldType_Fixed : public ZtVFieldType {
  ZtVFieldType_Fixed() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::Fixed,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.null = nullptr}
    } { }
};
template <typename T, typename Props>
ZtVFieldType *ZtFieldType_Fixed<T, Props>::mtype() {
  return ZmSingleton<ZtVFieldType_Fixed<T, Props>>::instance();
}

struct ZtField_Fixed_Def {
  static constexpr ZuFixed deflt() { return {}; }
  static constexpr ZuFixed minimum() {
    return {(int64_t(-999999999999999999LL)), 0};
  }
  static constexpr ZuFixed maximum() {
    return {(int64_t(999999999999999999LL)), 0};
  }
};
template <
  typename Base, auto Def = ZtField_Fixed_Def::deflt,
  auto Min = ZtField_Fixed_Def::minimum, auto Max = ZtField_Fixed_Def::maximum,
  bool = Base::ReadOnly>
struct ZtField_Fixed : public ZtField<Base> {
  template <template <typename> typename Override>
  using Adapt = ZtField_Fixed<Override<Base>>;
  using O = typename Base::O;
  using T = typename Base::T;
  using Props = typename Base::Props;
  using Type = ZtFieldType_Fixed<T, ZuTypeGrep<ZtFieldType_Props, Props>>;
  enum { Code = Type::Code };
  static ZtVFieldGet getFn() {
    return {.get_ = {.fixed = [](const void *o) -> ZuFixed {
      return Base::get(*static_cast<const O *>(o));
    }}};
  }
  static ZtVFieldSet setFn() {
    return {.set_ = {.fixed = [](void *, ZuFixed) {}}};
  }
  static constexpr auto deflt() { return Def(); }
  static ZtVFieldGet constantFn() {
    using namespace ZtVFieldConstant;
    return {.get_ = {.fixed = [](const void *o) -> ZuFixed {
      switch (int(reinterpret_cast<uintptr_t>(o))) {
      case Deflt:
	return Def();
      case Minimum:
	return Min();
      case Maximum:
	return Max();
      default:
	return {};
      }
    }}};
  }
};
template <typename Base, auto Def, auto Min, auto Max>
struct ZtField_Fixed<Base, Def, Min, Max, false> :
  public ZtField_Fixed<Base, Def, Min, Max, true> {
  using O = typename Base::O;
  using T = typename Base::T;
  static ZtVFieldSet setFn() {
    return {.set_ = {.fixed = [](void *o, ZuFixed v) {
      Base::set(*static_cast<O *>(o), ZuMv(v));
    }}};
  }
};

template <typename T_, typename Props_>
struct ZtFieldType_Decimal : public ZtFieldType_<Props_> {
  enum { Code = ZtFieldTypeCode::Decimal };
  using T = T_;
  using Props = Props_;
  template <typename Fmt = ZtFieldFmt::Default> struct Print {
    ZuDecimal v;
    template <typename S> friend S &operator<<(S &s, const Print &print) {
      if constexpr (ZuFieldProp::HasNDP<Props>{})
	return s
	  << print.v.template fp<ZuFieldProp::GetNDP<Props>{}, '\0', Fmt>();
      else
	return s << print.v.template fmt<Fmt>();
    }
  };
  inline static ZtVFieldType *mtype();
};
template <typename T, typename Props>
struct ZtFieldType<ZtFieldTypeCode::Decimal, T, Props> :
  public ZtFieldType_Decimal<T, Props> { };

template <typename T, typename Props>
struct ZtVFieldType_Decimal : public ZtVFieldType {
  ZtVFieldType_Decimal() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::Decimal,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.null = nullptr}
    } { }
};
template <typename T, typename Props>
ZtVFieldType *ZtFieldType_Decimal<T, Props>::mtype() {
  return ZmSingleton<ZtVFieldType_Decimal<T, Props>>::instance();
}

struct ZtField_Decimal_Def {
  static constexpr ZuDecimal deflt() { return ZuCmp<ZuDecimal>::null(); }
  static constexpr ZuDecimal minimum() {
    return {ZuDecimal::Unscaled{ZuDecimal::minimum()}};
  }
  static constexpr ZuDecimal maximum() {
    return {ZuDecimal::Unscaled{ZuDecimal::maximum()}};
  }
};
template <
  typename Base, auto Def = ZtField_Decimal_Def::deflt,
  auto Min = ZtField_Decimal_Def::minimum,
  auto Max = ZtField_Decimal_Def::maximum, bool = Base::ReadOnly>
struct ZtField_Decimal : public ZtField<Base> {
  template <template <typename> typename Override>
  using Adapt = ZtField_Decimal<Override<Base>>;
  using O = typename Base::O;
  using T = typename Base::T;
  using Props = typename Base::Props;
  using Type = ZtFieldType_Decimal<T, ZuTypeGrep<ZtFieldType_Props, Props>>;
  enum { Code = Type::Code };
  static ZtVFieldGet getFn() {
    return {.get_ = {.decimal = [](const void *o) -> ZuDecimal {
      return Base::get(*static_cast<const O *>(o));
    }}};
  }
  static ZtVFieldSet setFn() {
    return {.set_ = {.decimal = [](void *, ZuDecimal) {}}};
  }
  static constexpr auto deflt() { return Def(); }
  static ZtVFieldGet constantFn() {
    using namespace ZtVFieldConstant;
    return {.get_ = {.decimal = [](const void *o) -> ZuDecimal {
      switch (int(reinterpret_cast<uintptr_t>(o))) {
      case Deflt:
	return Def();
      case Minimum:
	return Min();
      case Maximum:
	return Max();
      default:
	return {};
      }
    }}};
  }
};
template <typename Base, auto Def, auto Min, auto Max>
struct ZtField_Decimal<Base, Def, Min, Max, false> :
  public ZtField_Decimal<Base, Def, Min, Max, true> {
  using O = typename Base::O;
  static ZtVFieldSet setFn() {
    return {.set_ = {.decimal = [](void *o, ZuDecimal v) {
      Base::set(*static_cast<O *>(o), ZuMv(v));
    }}};
  }
};

template <typename T_, typename Props_>
struct ZtFieldType_Time : public ZtFieldType_<Props_> {
  enum { Code = ZtFieldTypeCode::Time };
  using T = T_;
  using Props = Props_;
  template <typename Fmt = ZtFieldFmt::Default> struct Print {
    ZuTime v;
    template <typename S> friend S &operator<<(S &s, const Print &print) {
      ZuDateTime v{print.v};
      return s << v.fmt(Fmt::DatePrint_());
    }
  };
  inline static ZtVFieldType *mtype();
};
template <typename T, typename Props>
struct ZtFieldType<ZtFieldTypeCode::Time, T, Props> :
  public ZtFieldType_Time<T, Props> { };

template <typename T, typename Props>
struct ZtVFieldType_Time : public ZtVFieldType {
  ZtVFieldType_Time() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::Time,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.null = nullptr}
    } { }
};
template <typename T, typename Props>
ZtVFieldType *ZtFieldType_Time<T, Props>::mtype() {
  return ZmSingleton<ZtVFieldType_Time<T, Props>>::instance();
}

inline constexpr ZuTime ZtField_Time_Def() { return {}; }
template <typename Base, auto Def = ZtField_Time_Def, bool = Base::ReadOnly>
struct ZtField_Time : public ZtField<Base> {
  template <template <typename> typename Override>
  using Adapt = ZtField_Time<Override<Base>>;
  using O = typename Base::O;
  using T = typename Base::T;
  using Props = typename Base::Props;
  using Type = ZtFieldType_Time<T, ZuTypeGrep<ZtFieldType_Props, Props>>;
  enum { Code = Type::Code };
  static ZtVFieldGet getFn() {
    return {.get_ = {.time = [](const void *o) -> ZuTime {
      return Base::get(*static_cast<const O *>(o));
    }}};
  }
  static ZtVFieldSet setFn() {
    return {.set_ = {.time = [](void *, ZuTime) {}}};
  }
  static constexpr auto deflt() { return Def(); }
  static ZtVFieldGet constantFn() {
    using namespace ZtVFieldConstant;
    return {.get_ = {.time = [](const void *o) -> ZuTime {
      switch (int(reinterpret_cast<uintptr_t>(o))) {
      case Deflt:
	return Def();
      default:
	return {};
      }
    }}};
  }
};
template <typename Base, auto Def>
struct ZtField_Time<Base, Def, false> : public ZtField_Time<Base, Def, true> {
  using O = typename Base::O;
  static ZtVFieldSet setFn() {
    return {.set_ = {.time = [](void *o, ZuTime v) {
      Base::set(*static_cast<O *>(o), ZuMv(v));
    }}};
  }
};

template <typename T_, typename Props_>
struct ZtFieldType_DateTime : public ZtFieldType_<Props_> {
  enum { Code = ZtFieldTypeCode::DateTime };
  using T = T_;
  using Props = Props_;
  template <typename Fmt = ZtFieldFmt::Default> struct Print {
    ZuDateTime v;
    template <typename S> friend S &operator<<(S &s, const Print &print) {
      return s << print.v.fmt(Fmt::DatePrint_());
    }
  };
  inline static ZtVFieldType *mtype();
};
template <typename T, typename Props>
struct ZtFieldType<ZtFieldTypeCode::DateTime, T, Props> :
  public ZtFieldType_DateTime<T, Props> { };

template <typename T, typename Props>
struct ZtVFieldType_DateTime : public ZtVFieldType {
  ZtVFieldType_DateTime() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::DateTime,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.null = nullptr}
    } { }
};
template <typename T, typename Props>
ZtVFieldType *ZtFieldType_DateTime<T, Props>::mtype() {
  return ZmSingleton<ZtVFieldType_DateTime<T, Props>>::instance();
}

inline constexpr ZuDateTime ZtField_DateTime_Def() { return {}; }
template <typename Base, auto Def = ZtField_DateTime_Def, bool = Base::ReadOnly>
struct ZtField_DateTime : public ZtField<Base> {
  template <template <typename> typename Override>
  using Adapt = ZtField_DateTime<Override<Base>>;
  using O = typename Base::O;
  using T = typename Base::T;
  using Props = typename Base::Props;
  using Type = ZtFieldType_DateTime<T, ZuTypeGrep<ZtFieldType_Props, Props>>;
  enum { Code = Type::Code };
  static ZtVFieldGet getFn() {
    return {.get_ = {.dateTime = [](const void *o) -> ZuDateTime {
      return Base::get(*static_cast<const O *>(o));
    }}};
  }
  static ZtVFieldSet setFn() {
    return {.set_ = {.dateTime = [](void *, ZuDateTime) {}}};
  }
  static constexpr auto deflt() { return Def(); }
  static ZtVFieldGet constantFn() {
    using namespace ZtVFieldConstant;
    return {.get_ = {.dateTime = [](const void *o) -> ZuDateTime {
      switch (int(reinterpret_cast<uintptr_t>(o))) {
      case Deflt:
	return Def();
      default:
	return {};
      }
    }}};
  }
};
template <typename Base, auto Def>
struct ZtField_DateTime<Base, Def, false> :
  public ZtField_DateTime<Base, Def, true> {
  using O = typename Base::O;
  static ZtVFieldSet setFn() {
    return {.set_ = {.dateTime = [](void *o, ZuDateTime v) {
      Base::set(*static_cast<O *>(o), ZuMv(v));
    }}};
  }
};

template <typename T, typename Fmt, typename = void>
struct ZtFieldType_UDT_HasFmt : public ZuFalse { };
template <typename T, typename Fmt>
struct ZtFieldType_UDT_HasFmt<
  T, Fmt, decltype(ZuDeclVal<const T &>().template fmt<Fmt>(), void())> :
  public ZuTrue { };

template <typename T_, typename Props_>
struct ZtFieldType_UDT : public ZtFieldType_<Props_> {
  enum { Code = ZtFieldTypeCode::UDT };
  using T = T_;
  using Props = Props_;
  template <typename Fmt = ZtFieldFmt::Default> struct Print {
    const T &v;
    template <typename S, typename U = T>
    friend ZuIfT<ZtFieldType_UDT_HasFmt<U, Fmt>{}, S &>
    operator<<(S &s, const Print &print) {
      return s << print.v.template fmt<Fmt>();
    }
    template <typename S, typename U = T>
    friend ZuIfT<!ZtFieldType_UDT_HasFmt<U, Fmt>{}, S &>
    operator<<(S &s, const Print &print) {
      return s << print.v;
    }
  };
  inline static ZtVFieldType *mtype();
};
template <typename T, typename Props>
struct ZtFieldType<ZtFieldTypeCode::UDT, T, Props> :
  public ZtFieldType_UDT<T, Props> { };

template <typename T, typename = void> struct ZtVFieldType_UDT_Print {
  static auto printFn() {
    return [](const void *, ZuVStream &, const ZtFieldVFmt &) {};
  }
};
template <typename T>
struct ZtVFieldType_UDT_Print<
  T, decltype((ZuDeclVal<ZuVStream &>() << ZuDeclVal<const T &>()), void())> {
  static auto printFn() {
    return [](const void *v, ZuVStream &s, const ZtFieldVFmt &) {
      s << *reinterpret_cast<const T *>(v);
    };
  }
};
template <typename T, typename = void> struct ZtVFieldType_UDT_Scan {
  static auto scanFn() {
    return
      [](void (*)(void *, const void *), void *, ZuCSpan, const ZtFieldVFmt &) {
    };
  }
};
template <typename T>
struct ZtVFieldType_UDT_Scan<
  T, decltype((ZuDeclVal<T &>() = ZuCSpan{}), void())> {
  static auto scanFn() {
    return
      [](void (*set)(void *, const void *), void *o, ZuCSpan s, const ZtFieldVFmt &) {
      T v{s};
      set(o, reinterpret_cast<const void *>(&v));
    };
  }
};
template <typename T, typename Props>
struct ZtVFieldType_UDT : public ZtVFieldType {
  ZtVFieldType_UDT() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::UDT,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.udt = []() -> ZtVFieldUDT * {
	static ZtVFieldUDT info{
	  .id = ZtVFieldTypeID(static_cast<T *>(nullptr)),
	  .info = &typeid(T),
	  .print = ZtVFieldType_UDT_Print<T>::printFn(),
	  .scan = ZtVFieldType_UDT_Scan<T>::scanFn()
	};
	return &info;
      }}
    } { }
};
template <typename T, typename Props>
ZtVFieldType *ZtFieldType_UDT<T, Props>::mtype() {
  return ZmSingleton<ZtVFieldType_UDT<T, Props>>::instance();
}

template <typename T, typename = void> struct ZtField_UDT_Def {
  static constexpr void value() { }
};
template <typename T> struct ZtField_UDT_Def<T, decltype(T{}, void())> {
  static constexpr T value() { return {}; }
};
template <typename T, typename = void> struct ZtField_UDT_Null {
  static const void *value() { return nullptr; }
};
template <typename T> struct ZtField_UDT_Null<T, decltype(T{}, void())> {
  static const void *value() {
    static T null_;
    return static_cast<const void *>(&null_);
  }
};
template <typename, auto, typename = void> struct ZtField_UDT_Constant {
  static ZtVFieldGet constantFn() {
    using namespace ZtVFieldConstant;
    return {.get_ = {.udt = [](const void *o) -> const void * {
      return nullptr;
    }}};
  }
};
template <typename Base, auto Def>
struct ZtField_UDT_Constant<
  Base, Def, decltype(typename Base::T{Def()}, void())> {
  static ZtVFieldGet constantFn() {
    using T = typename Base::T;
    using namespace ZtVFieldConstant;
    return {.get_ = {.udt = [](const void *o) -> const void * {
      static T deflt_{Def()};
      switch (int(reinterpret_cast<uintptr_t>(o))) {
      case Deflt:
	return static_cast<const void *>(&deflt_);
      default:
	return ZtField_UDT_Null<T>::value();
      }
    }}};
  }
};
template <typename Base, typename = void> struct ZtField_UDT_Get {
  static ZtVFieldGet getFn() {
    using O = typename Base::O;
    using T = typename Base::T;

    return {.get_ = {.udt = [](const void *o) -> const void * {
      auto &v = ZmTLS<T, getFn>();
      v = Base::get(*static_cast<const O *>(o));
      return static_cast<const void *>(&v);
    }}};
  }
};
template <typename Base>
struct ZtField_UDT_Get<
  Base, decltype(&Base::get(ZuDeclVal<const typename Base::O &>()), void())> {
  static ZtVFieldGet getFn() {
    using O = typename Base::O;

    return {.get_ = {.udt = [](const void *o) -> const void * {
      return static_cast<const void *>(&Base::get(*static_cast<const O *>(o)));
    }}};
  }
};
template <
  typename Base, auto Def = ZtField_UDT_Def<typename Base::T>::value,
  bool = Base::ReadOnly>
struct ZtField_UDT :
  public ZtField<Base>,
  public ZtField_UDT_Constant<Base, Def>,
  public ZtField_UDT_Get<Base> {
  template <template <typename> typename Override>
  using Adapt = ZtField_UDT<Override<Base>>;
  using O = typename Base::O;
  using T = typename Base::T;
  using Props = typename Base::Props;
  using Type = ZtFieldType_UDT<T, ZuTypeGrep<ZtFieldType_Props, Props>>;
  enum { Code = Type::Code };
  static ZtVFieldSet setFn() {
    return {.set_ = {.udt = [](void *, const void *) {}}};
  }
  static auto deflt() { return Def(); }
};
template <typename Base, auto Def>
struct ZtField_UDT<Base, Def, false> : public ZtField_UDT<Base, Def, true> {
  using O = typename Base::O;
  using T = typename Base::T;
  static ZtVFieldSet setFn() {
    return {.set_ = {.udt = [](void *o, const void *p) {
      Base::set(*static_cast<O *>(o), *static_cast<const T *>(p));
    }}};
  }
};

template <typename T_, typename Props_>
struct ZtFieldType_CStringVec : public ZtFieldType_<Props_> {
  enum { Code = ZtFieldTypeCode::CStringVec };
  using T = T_;
  using Props = Props_;
  template <typename Fmt = ZtFieldFmt::Default> struct Print {
    ZtField_::CStringVec vec;
    template <typename S> friend S &operator<<(S &s, const Print &print) {
      s << Fmt::VecPrefix();
      bool first = true;
      print.vec.all([&s, &first](const char *v) {
	if (!first)
	  s << Fmt::VecDelim();
	else
	  first = false;
	s << ZtField_::Print::CString{v};
      });
      return s << Fmt::VecSuffix();
    }
  };
  inline static ZtVFieldType *mtype();
};
template <typename T, typename Props>
struct ZtFieldType<ZtFieldTypeCode::CStringVec, T, Props> :
  public ZtFieldType_CStringVec<T, Props> { };

template <typename T, typename Props>
struct ZtVFieldType_CStringVec : public ZtVFieldType {
  ZtVFieldType_CStringVec() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::CStringVec,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.null = nullptr}
    } { }
};
template <typename T, typename Props>
ZtVFieldType *ZtFieldType_CStringVec<T, Props>::mtype() {
  return ZmSingleton<ZtVFieldType_CStringVec<T, Props>>::instance();
}

inline ZtField_::CStringVec ZtField_CStringVec_Def() { return {}; }
template <
  typename Base, auto Def = ZtField_CStringVec_Def, bool = Base::ReadOnly>
struct ZtField_CStringVec : public ZtField<Base> {
  template <template <typename> typename Override>
  using Adapt = ZtField_CStringVec<Override<Base>>;
  using O = typename Base::O;
  using T = typename Base::T;
  using Elem = typename ZuTraits<T>::Elem;
  using Props = typename Base::Props;
  using Type = ZtFieldType_CStringVec<T, ZuTypeGrep<ZtFieldType_Props, Props>>;
  using CStringVec = ZtField_::CStringVec;
  enum { Code = Type::Code };
  static ZtVFieldGet getFn() {
    return {.get_ = {.cstringVec = [](const void *o) -> CStringVec {
      return Base::get(*static_cast<const O *>(o));
    }}};
  }
  static ZtVFieldSet setFn() {
    return {.set_ = {.cstringVec = [](void *, CStringVec) {}}};
  }
  static constexpr auto deflt() { return Def(); }
  static ZtVFieldGet constantFn() {
    using namespace ZtVFieldConstant;
    return {.get_ = {.cstringVec = [](const void *o) -> CStringVec {
      switch (int(reinterpret_cast<uintptr_t>(o))) {
      case Deflt:
	return Def();
      default:
	return {};
      }
    }}};
  }
};
template <typename Base, auto Def>
struct ZtField_CStringVec<Base, Def, false> :
  public ZtField_CStringVec<Base, Def, true> {
  using O = typename Base::O;
  static ZtVFieldSet setFn() {
    using namespace ZtField_;
    return {.set_ = {.cstringVec = [](void *o, CStringVec v) {
      Base::set(*static_cast<O *>(o), ZuMv(v));
    }}};
  }
};

template <typename T_, typename Props_>
struct ZtFieldType_StringVec : public ZtFieldType_<Props_> {
  enum { Code = ZtFieldTypeCode::StringVec };
  using T = T_;
  using Props = Props_;
  template <typename Fmt = ZtFieldFmt::Default> struct Print {
    ZtField_::StringVec vec;
    template <typename S> friend S &operator<<(S &s, const Print &print) {
      s << Fmt::VecPrefix();
      bool first = true;
      print.vec.all([&s, &first](ZuCSpan v) {
	if (!first)
	  s << Fmt::VecDelim();
	else
	  first = false;
	s << ZtField_::Print::String{v};
      });
      return s << Fmt::VecSuffix();
    }
  };
  inline static ZtVFieldType *mtype();
};
template <typename T, typename Props>
struct ZtFieldType<ZtFieldTypeCode::StringVec, T, Props> :
  public ZtFieldType_StringVec<T, Props> { };

template <typename T, typename Props>
struct ZtVFieldType_StringVec : public ZtVFieldType {
  ZtVFieldType_StringVec() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::StringVec,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.null = nullptr}
    } { }
};
template <typename T, typename Props>
ZtVFieldType *ZtFieldType_StringVec<T, Props>::mtype() {
  return ZmSingleton<ZtVFieldType_StringVec<T, Props>>::instance();
}

inline ZtField_::StringVec ZtField_StringVec_Def() { return {}; }
template <
  typename Base, auto Def = ZtField_StringVec_Def, bool = Base::ReadOnly>
struct ZtField_StringVec : public ZtField<Base> {
  template <template <typename> typename Override>
  using Adapt = ZtField_StringVec<Override<Base>>;
  using O = typename Base::O;
  using T = typename Base::T;
  using Props = typename Base::Props;
  using Type = ZtFieldType_StringVec<T, ZuTypeGrep<ZtFieldType_Props, Props>>;
  using StringVec = ZtField_::StringVec;
  enum { Code = Type::Code };
  static ZtVFieldGet getFn() {
    return {.get_ = {.stringVec = [](const void *o) -> StringVec {
      return Base::get(*static_cast<const O *>(o));
    }}};
  }
  static ZtVFieldSet setFn() {
    using namespace ZtField_;
    return {.set_ = {.stringVec = [](void *, StringVec) {}}};
  }
  static constexpr auto deflt() { return Def(); }
  static ZtVFieldGet constantFn() {
    using namespace ZtVFieldConstant;
    return {.get_ = {.stringVec = [](const void *o) -> StringVec {
      switch (int(reinterpret_cast<uintptr_t>(o))) {
      case Deflt:
	return Def();
      default:
	return {};
      }
    }}};
  }
};
template <typename Base, auto Def>
struct ZtField_StringVec<Base, Def, false> :
  public ZtField_StringVec<Base, Def, true> {
  using O = typename Base::O;
  static ZtVFieldSet setFn() {
    using namespace ZtField_;
    return {.set_ = {.stringVec = [](void *o, StringVec v) {
      Base::set(*static_cast<O *>(o), ZuMv(v));
    }}};
  }
};

template <typename T_, typename Props_>
struct ZtFieldType_BytesVec : public ZtFieldType_<Props_> {
  enum { Code = ZtFieldTypeCode::BytesVec };
  using T = T_;
  using Props = Props_;
  template <typename Fmt = ZtFieldFmt::Default> struct Print {
    ZtField_::BytesVec vec;
    template <typename S> friend S &operator<<(S &s, const Print &print) {
      s << Fmt::VecPrefix();
      bool first = true;
      print.vec.all([&s, &first](ZuBytes v) {
	if (!first)
	  s << Fmt::VecDelim();
	else
	  first = false;
	s << ZtField_::Print::Bytes{v};
      });
      return s << Fmt::VecSuffix();
    }
  };
  inline static ZtVFieldType *mtype();
};
template <typename T, typename Props>
struct ZtFieldType<ZtFieldTypeCode::BytesVec, T, Props> :
  public ZtFieldType_BytesVec<T, Props> { };

template <typename T, typename Props>
struct ZtVFieldType_BytesVec : public ZtVFieldType {
  ZtVFieldType_BytesVec() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::BytesVec,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.null = nullptr}
    } { }
};
template <typename T, typename Props>
ZtVFieldType *ZtFieldType_BytesVec<T, Props>::mtype() {
  return ZmSingleton<ZtVFieldType_BytesVec<T, Props>>::instance();
}

inline ZtField_::BytesVec ZtField_BytesVec_Def() { return {}; }
template <typename Base, auto Def = ZtField_BytesVec_Def, bool = Base::ReadOnly>
struct ZtField_BytesVec : public ZtField<Base> {
  template <template <typename> typename Override>
  using Adapt = ZtField_BytesVec<Override<Base>>;
  using O = typename Base::O;
  using T = typename Base::T;
  using Props = typename Base::Props;
  using Type = ZtFieldType_BytesVec<T, ZuTypeGrep<ZtFieldType_Props, Props>>;
  using BytesVec = ZtField_::BytesVec;
  enum { Code = Type::Code };
  static ZtVFieldGet getFn() {
    return {.get_ = {.bytesVec = [](const void *o) -> BytesVec {
      return Base::get(*static_cast<const O *>(o));
    }}};
  }
  static ZtVFieldSet setFn() {
    using namespace ZtField_;
    return {.set_ = {.bytesVec = [](void *, BytesVec) {}}};
  }
  static constexpr auto deflt() { return Def(); }
  static ZtVFieldGet constantFn() {
    using namespace ZtVFieldConstant;
    return {.get_ = {.bytesVec = [](const void *o) -> BytesVec {
      switch (int(reinterpret_cast<uintptr_t>(o))) {
      case Deflt:
	return Def();
      default:
	return {};
      }
    }}};
  }
};
template <typename Base, auto Def>
struct ZtField_BytesVec<Base, Def, false> :
  public ZtField_BytesVec<Base, Def, true> {
  using O = typename Base::O;
  static ZtVFieldSet setFn() {
    using namespace ZtField_;
    return {.set_ = {.bytesVec = [](void *o, BytesVec v) {
      Base::set(*static_cast<O *>(o), ZuMv(v));
    }}};
  }
};

template <typename T_, typename Props_>
struct ZtFieldType_Int8Vec : public ZtFieldType_<Props_> {
  enum { Code = ZtFieldTypeCode::Int8Vec };
  using T = T_;
  using Props = Props_;
  template <typename Fmt = ZtFieldFmt::Default> struct Print {
    ZtField_::Int8Vec vec;
    template <typename S> friend S &operator<<(S &s, const Print &print) {
      s << Fmt::VecPrefix();
      bool first = true;
      print.vec.all([&s, &first](ZuBox<int8_t> v) {
	if (!first)
	  s << Fmt::VecDelim();
	else
	  first = false;
	ZtField_printInt<Props, Fmt>(s, v);
      });
      return s << Fmt::VecSuffix();
    }
  };
  inline static ZtVFieldType *mtype();
};
template <typename T, typename Props>
struct ZtFieldType<ZtFieldTypeCode::Int8Vec, T, Props> :
  public ZtFieldType_Int8Vec<T, Props> { };
template <
  typename T, typename Props, bool = ZuFieldProp::HasEnum<Props>{},
  bool = ZuFieldProp::HasFlags<Props>{}>
struct ZtVFieldType_Int8Vec;
template <typename T, typename Props>
struct ZtVFieldType_Int8Vec<T, Props, false, false> : public ZtVFieldType {
  ZtVFieldType_Int8Vec() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::Int8Vec,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.null = nullptr}
    } { }
};
template <typename T, typename Props>
struct ZtVFieldType_Int8Vec<T, Props, true, false> : public ZtVFieldType {
  ZtVFieldType_Int8Vec() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::Int8Vec,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.enum_ = []() -> ZtVFieldEnum * {
	return ZtVFieldEnum_<ZuFieldProp::GetEnum<Props>>::instance();
      }}
    } { }
};
template <typename T, typename Props>
struct ZtVFieldType_Int8Vec<T, Props, false, true> : public ZtVFieldType {
  ZtVFieldType_Int8Vec() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::Int8Vec,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.flags = []() -> ZtVFieldFlags * {
	return ZtVFieldFlags_<ZuFieldProp::GetFlags<Props>>::instance();
      }}
    } { }
};
template <typename T, typename Props>
ZtVFieldType *ZtFieldType_Int8Vec<T, Props>::mtype() {
  return ZmSingleton<ZtVFieldType_Int8Vec<T, Props>>::instance();
}
inline ZtField_::Int8Vec ZtFieldType_Int8Vec_Def() { return {}; }
template <
  typename Base, auto Def = ZtFieldType_Int8Vec_Def, bool = Base::ReadOnly>
struct ZtField_Int8Vec : public ZtField<Base> {
  template <template <typename> typename Override>
  using Adapt = ZtField_Int8Vec<Override<Base>>;
  using O = typename Base::O;
  using T = typename Base::T;
  using Props = typename Base::Props;
  using Type = ZtFieldType_Int8Vec<T, ZuTypeGrep<ZtFieldType_Props, Props>>;
  using Int8Vec = ZtField_::Int8Vec;
  enum { Code = Type::Code };
  static ZtVFieldGet getFn() {
    return {.get_ = {.int8Vec = [](const void *o) -> Int8Vec {
      return Base::get(*static_cast<const O *>(o));
    }}};
  }
  static ZtVFieldSet setFn() {
    using namespace ZtField_;
    return {.set_ = {.int8Vec = [](void *, Int8Vec) {}}};
  }
  static constexpr auto deflt() { return Def(); }
  static ZtVFieldGet constantFn() {
    using namespace ZtVFieldConstant;
    return {.get_ = {.int8Vec = [](const void *o) -> Int8Vec {
      switch (int(reinterpret_cast<uintptr_t>(o))) {
      case Deflt:
	return Def();
      default:
	return {};
      }
    }}};
  }
};
template <typename Base, auto Def>
struct ZtField_Int8Vec<Base, Def, false> :
  public ZtField_Int8Vec<Base, Def, true> {
  using O = typename Base::O;
  static ZtVFieldSet setFn() {
    using namespace ZtField_;
    return {.set_ = {.int8Vec = [](void *o, Int8Vec v) {
      Base::set(*static_cast<O *>(o), ZuMv(v));
    }}};
  }
};
;
template <typename T_, typename Props_>
struct ZtFieldType_UInt8Vec : public ZtFieldType_<Props_> {
  enum { Code = ZtFieldTypeCode::UInt8Vec };
  using T = T_;
  using Props = Props_;
  template <typename Fmt = ZtFieldFmt::Default> struct Print {
    ZtField_::UInt8Vec vec;
    template <typename S> friend S &operator<<(S &s, const Print &print) {
      s << Fmt::VecPrefix();
      bool first = true;
      print.vec.all([&s, &first](ZuBox<uint8_t> v) {
	if (!first)
	  s << Fmt::VecDelim();
	else
	  first = false;
	ZtField_printInt<Props, Fmt>(s, v);
      });
      return s << Fmt::VecSuffix();
    }
  };
  inline static ZtVFieldType *mtype();
};
template <typename T, typename Props>
struct ZtFieldType<ZtFieldTypeCode::UInt8Vec, T, Props> :
  public ZtFieldType_UInt8Vec<T, Props> { };
template <
  typename T, typename Props, bool = ZuFieldProp::HasEnum<Props>{},
  bool = ZuFieldProp::HasFlags<Props>{}>
struct ZtVFieldType_UInt8Vec;
template <typename T, typename Props>
struct ZtVFieldType_UInt8Vec<T, Props, false, false> : public ZtVFieldType {
  ZtVFieldType_UInt8Vec() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::UInt8Vec,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.null = nullptr}
    } { }
};
template <typename T, typename Props>
struct ZtVFieldType_UInt8Vec<T, Props, true, false> : public ZtVFieldType {
  ZtVFieldType_UInt8Vec() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::UInt8Vec,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.enum_ = []() -> ZtVFieldEnum * {
	return ZtVFieldEnum_<ZuFieldProp::GetEnum<Props>>::instance();
      }}
    } { }
};
template <typename T, typename Props>
struct ZtVFieldType_UInt8Vec<T, Props, false, true> : public ZtVFieldType {
  ZtVFieldType_UInt8Vec() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::UInt8Vec,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.flags = []() -> ZtVFieldFlags * {
	return ZtVFieldFlags_<ZuFieldProp::GetFlags<Props>>::instance();
      }}
    } { }
};
template <typename T, typename Props>
ZtVFieldType *ZtFieldType_UInt8Vec<T, Props>::mtype() {
  return ZmSingleton<ZtVFieldType_UInt8Vec<T, Props>>::instance();
}
inline ZtField_::UInt8Vec ZtFieldType_UInt8Vec_Def() { return {}; }
template <
  typename Base, auto Def = ZtFieldType_UInt8Vec_Def, bool = Base::ReadOnly>
struct ZtField_UInt8Vec : public ZtField<Base> {
  template <template <typename> typename Override>
  using Adapt = ZtField_UInt8Vec<Override<Base>>;
  using O = typename Base::O;
  using T = typename Base::T;
  using Props = typename Base::Props;
  using Type = ZtFieldType_UInt8Vec<T, ZuTypeGrep<ZtFieldType_Props, Props>>;
  using UInt8Vec = ZtField_::UInt8Vec;
  enum { Code = Type::Code };
  static ZtVFieldGet getFn() {
    return {.get_ = {.uint8Vec = [](const void *o) -> UInt8Vec {
      return Base::get(*static_cast<const O *>(o));
    }}};
  }
  static ZtVFieldSet setFn() {
    using namespace ZtField_;
    return {.set_ = {.uint8Vec = [](void *, UInt8Vec) {}}};
  }
  static constexpr auto deflt() { return Def(); }
  static ZtVFieldGet constantFn() {
    using namespace ZtVFieldConstant;
    return {.get_ = {.uint8Vec = [](const void *o) -> UInt8Vec {
      switch (int(reinterpret_cast<uintptr_t>(o))) {
      case Deflt:
	return Def();
      default:
	return {};
      }
    }}};
  }
};
template <typename Base, auto Def>
struct ZtField_UInt8Vec<Base, Def, false> :
  public ZtField_UInt8Vec<Base, Def, true> {
  using O = typename Base::O;
  static ZtVFieldSet setFn() {
    using namespace ZtField_;
    return {.set_ = {.uint8Vec = [](void *o, UInt8Vec v) {
      Base::set(*static_cast<O *>(o), ZuMv(v));
    }}};
  }
};
;
template <typename T_, typename Props_>
struct ZtFieldType_Int16Vec : public ZtFieldType_<Props_> {
  enum { Code = ZtFieldTypeCode::Int16Vec };
  using T = T_;
  using Props = Props_;
  template <typename Fmt = ZtFieldFmt::Default> struct Print {
    ZtField_::Int16Vec vec;
    template <typename S> friend S &operator<<(S &s, const Print &print) {
      s << Fmt::VecPrefix();
      bool first = true;
      print.vec.all([&s, &first](ZuBox<int16_t> v) {
	if (!first)
	  s << Fmt::VecDelim();
	else
	  first = false;
	ZtField_printInt<Props, Fmt>(s, v);
      });
      return s << Fmt::VecSuffix();
    }
  };
  inline static ZtVFieldType *mtype();
};
template <typename T, typename Props>
struct ZtFieldType<ZtFieldTypeCode::Int16Vec, T, Props> :
  public ZtFieldType_Int16Vec<T, Props> { };
template <
  typename T, typename Props, bool = ZuFieldProp::HasEnum<Props>{},
  bool = ZuFieldProp::HasFlags<Props>{}>
struct ZtVFieldType_Int16Vec;
template <typename T, typename Props>
struct ZtVFieldType_Int16Vec<T, Props, false, false> : public ZtVFieldType {
  ZtVFieldType_Int16Vec() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::Int16Vec,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.null = nullptr}
    } { }
};
template <typename T, typename Props>
struct ZtVFieldType_Int16Vec<T, Props, true, false> : public ZtVFieldType {
  ZtVFieldType_Int16Vec() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::Int16Vec,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.enum_ = []() -> ZtVFieldEnum * {
	return ZtVFieldEnum_<ZuFieldProp::GetEnum<Props>>::instance();
      }}
    } { }
};
template <typename T, typename Props>
struct ZtVFieldType_Int16Vec<T, Props, false, true> : public ZtVFieldType {
  ZtVFieldType_Int16Vec() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::Int16Vec,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.flags = []() -> ZtVFieldFlags * {
	return ZtVFieldFlags_<ZuFieldProp::GetFlags<Props>>::instance();
      }}
    } { }
};
template <typename T, typename Props>
ZtVFieldType *ZtFieldType_Int16Vec<T, Props>::mtype() {
  return ZmSingleton<ZtVFieldType_Int16Vec<T, Props>>::instance();
}
inline ZtField_::Int16Vec ZtFieldType_Int16Vec_Def() { return {}; }
template <
  typename Base, auto Def = ZtFieldType_Int16Vec_Def, bool = Base::ReadOnly>
struct ZtField_Int16Vec : public ZtField<Base> {
  template <template <typename> typename Override>
  using Adapt = ZtField_Int16Vec<Override<Base>>;
  using O = typename Base::O;
  using T = typename Base::T;
  using Props = typename Base::Props;
  using Type = ZtFieldType_Int16Vec<T, ZuTypeGrep<ZtFieldType_Props, Props>>;
  using Int16Vec = ZtField_::Int16Vec;
  enum { Code = Type::Code };
  static ZtVFieldGet getFn() {
    return {.get_ = {.int16Vec = [](const void *o) -> Int16Vec {
      return Base::get(*static_cast<const O *>(o));
    }}};
  }
  static ZtVFieldSet setFn() {
    using namespace ZtField_;
    return {.set_ = {.int16Vec = [](void *, Int16Vec) {}}};
  }
  static constexpr auto deflt() { return Def(); }
  static ZtVFieldGet constantFn() {
    using namespace ZtVFieldConstant;
    return {.get_ = {.int16Vec = [](const void *o) -> Int16Vec {
      switch (int(reinterpret_cast<uintptr_t>(o))) {
      case Deflt:
	return Def();
      default:
	return {};
      }
    }}};
  }
};
template <typename Base, auto Def>
struct ZtField_Int16Vec<Base, Def, false> :
  public ZtField_Int16Vec<Base, Def, true> {
  using O = typename Base::O;
  static ZtVFieldSet setFn() {
    using namespace ZtField_;
    return {.set_ = {.int16Vec = [](void *o, Int16Vec v) {
      Base::set(*static_cast<O *>(o), ZuMv(v));
    }}};
  }
};
;
template <typename T_, typename Props_>
struct ZtFieldType_UInt16Vec : public ZtFieldType_<Props_> {
  enum { Code = ZtFieldTypeCode::UInt16Vec };
  using T = T_;
  using Props = Props_;
  template <typename Fmt = ZtFieldFmt::Default> struct Print {
    ZtField_::UInt16Vec vec;
    template <typename S> friend S &operator<<(S &s, const Print &print) {
      s << Fmt::VecPrefix();
      bool first = true;
      print.vec.all([&s, &first](ZuBox<uint16_t> v) {
	if (!first)
	  s << Fmt::VecDelim();
	else
	  first = false;
	ZtField_printInt<Props, Fmt>(s, v);
      });
      return s << Fmt::VecSuffix();
    }
  };
  inline static ZtVFieldType *mtype();
};
template <typename T, typename Props>
struct ZtFieldType<ZtFieldTypeCode::UInt16Vec, T, Props> :
  public ZtFieldType_UInt16Vec<T, Props> { };
template <
  typename T, typename Props, bool = ZuFieldProp::HasEnum<Props>{},
  bool = ZuFieldProp::HasFlags<Props>{}>
struct ZtVFieldType_UInt16Vec;
template <typename T, typename Props>
struct ZtVFieldType_UInt16Vec<T, Props, false, false> : public ZtVFieldType {
  ZtVFieldType_UInt16Vec() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::UInt16Vec,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.null = nullptr}
    } { }
};
template <typename T, typename Props>
struct ZtVFieldType_UInt16Vec<T, Props, true, false> : public ZtVFieldType {
  ZtVFieldType_UInt16Vec() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::UInt16Vec,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.enum_ = []() -> ZtVFieldEnum * {
	return ZtVFieldEnum_<ZuFieldProp::GetEnum<Props>>::instance();
      }}
    } { }
};
template <typename T, typename Props>
struct ZtVFieldType_UInt16Vec<T, Props, false, true> : public ZtVFieldType {
  ZtVFieldType_UInt16Vec() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::UInt16Vec,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.flags = []() -> ZtVFieldFlags * {
	return ZtVFieldFlags_<ZuFieldProp::GetFlags<Props>>::instance();
      }}
    } { }
};
template <typename T, typename Props>
ZtVFieldType *ZtFieldType_UInt16Vec<T, Props>::mtype() {
  return ZmSingleton<ZtVFieldType_UInt16Vec<T, Props>>::instance();
}
inline ZtField_::UInt16Vec ZtFieldType_UInt16Vec_Def() { return {}; }
template <
  typename Base, auto Def = ZtFieldType_UInt16Vec_Def, bool = Base::ReadOnly>
struct ZtField_UInt16Vec : public ZtField<Base> {
  template <template <typename> typename Override>
  using Adapt = ZtField_UInt16Vec<Override<Base>>;
  using O = typename Base::O;
  using T = typename Base::T;
  using Props = typename Base::Props;
  using Type = ZtFieldType_UInt16Vec<T, ZuTypeGrep<ZtFieldType_Props, Props>>;
  using UInt16Vec = ZtField_::UInt16Vec;
  enum { Code = Type::Code };
  static ZtVFieldGet getFn() {
    return {.get_ = {.uint16Vec = [](const void *o) -> UInt16Vec {
      return Base::get(*static_cast<const O *>(o));
    }}};
  }
  static ZtVFieldSet setFn() {
    using namespace ZtField_;
    return {.set_ = {.uint16Vec = [](void *, UInt16Vec) {}}};
  }
  static constexpr auto deflt() { return Def(); }
  static ZtVFieldGet constantFn() {
    using namespace ZtVFieldConstant;
    return {.get_ = {.uint16Vec = [](const void *o) -> UInt16Vec {
      switch (int(reinterpret_cast<uintptr_t>(o))) {
      case Deflt:
	return Def();
      default:
	return {};
      }
    }}};
  }
};
template <typename Base, auto Def>
struct ZtField_UInt16Vec<Base, Def, false> :
  public ZtField_UInt16Vec<Base, Def, true> {
  using O = typename Base::O;
  static ZtVFieldSet setFn() {
    using namespace ZtField_;
    return {.set_ = {.uint16Vec = [](void *o, UInt16Vec v) {
      Base::set(*static_cast<O *>(o), ZuMv(v));
    }}};
  }
};
;
template <typename T_, typename Props_>
struct ZtFieldType_Int32Vec : public ZtFieldType_<Props_> {
  enum { Code = ZtFieldTypeCode::Int32Vec };
  using T = T_;
  using Props = Props_;
  template <typename Fmt = ZtFieldFmt::Default> struct Print {
    ZtField_::Int32Vec vec;
    template <typename S> friend S &operator<<(S &s, const Print &print) {
      s << Fmt::VecPrefix();
      bool first = true;
      print.vec.all([&s, &first](ZuBox<int32_t> v) {
	if (!first)
	  s << Fmt::VecDelim();
	else
	  first = false;
	ZtField_printInt<Props, Fmt>(s, v);
      });
      return s << Fmt::VecSuffix();
    }
  };
  inline static ZtVFieldType *mtype();
};
template <typename T, typename Props>
struct ZtFieldType<ZtFieldTypeCode::Int32Vec, T, Props> :
  public ZtFieldType_Int32Vec<T, Props> { };
template <
  typename T, typename Props, bool = ZuFieldProp::HasEnum<Props>{},
  bool = ZuFieldProp::HasFlags<Props>{}>
struct ZtVFieldType_Int32Vec;
template <typename T, typename Props>
struct ZtVFieldType_Int32Vec<T, Props, false, false> : public ZtVFieldType {
  ZtVFieldType_Int32Vec() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::Int32Vec,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.null = nullptr}
    } { }
};
template <typename T, typename Props>
struct ZtVFieldType_Int32Vec<T, Props, true, false> : public ZtVFieldType {
  ZtVFieldType_Int32Vec() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::Int32Vec,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.enum_ = []() -> ZtVFieldEnum * {
	return ZtVFieldEnum_<ZuFieldProp::GetEnum<Props>>::instance();
      }}
    } { }
};
template <typename T, typename Props>
struct ZtVFieldType_Int32Vec<T, Props, false, true> : public ZtVFieldType {
  ZtVFieldType_Int32Vec() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::Int32Vec,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.flags = []() -> ZtVFieldFlags * {
	return ZtVFieldFlags_<ZuFieldProp::GetFlags<Props>>::instance();
      }}
    } { }
};
template <typename T, typename Props>
ZtVFieldType *ZtFieldType_Int32Vec<T, Props>::mtype() {
  return ZmSingleton<ZtVFieldType_Int32Vec<T, Props>>::instance();
}
inline ZtField_::Int32Vec ZtFieldType_Int32Vec_Def() { return {}; }
template <
  typename Base, auto Def = ZtFieldType_Int32Vec_Def, bool = Base::ReadOnly>
struct ZtField_Int32Vec : public ZtField<Base> {
  template <template <typename> typename Override>
  using Adapt = ZtField_Int32Vec<Override<Base>>;
  using O = typename Base::O;
  using T = typename Base::T;
  using Props = typename Base::Props;
  using Type = ZtFieldType_Int32Vec<T, ZuTypeGrep<ZtFieldType_Props, Props>>;
  using Int32Vec = ZtField_::Int32Vec;
  enum { Code = Type::Code };
  static ZtVFieldGet getFn() {
    return {.get_ = {.int32Vec = [](const void *o) -> Int32Vec {
      return Base::get(*static_cast<const O *>(o));
    }}};
  }
  static ZtVFieldSet setFn() {
    using namespace ZtField_;
    return {.set_ = {.int32Vec = [](void *, Int32Vec) {}}};
  }
  static constexpr auto deflt() { return Def(); }
  static ZtVFieldGet constantFn() {
    using namespace ZtVFieldConstant;
    return {.get_ = {.int32Vec = [](const void *o) -> Int32Vec {
      switch (int(reinterpret_cast<uintptr_t>(o))) {
      case Deflt:
	return Def();
      default:
	return {};
      }
    }}};
  }
};
template <typename Base, auto Def>
struct ZtField_Int32Vec<Base, Def, false> :
  public ZtField_Int32Vec<Base, Def, true> {
  using O = typename Base::O;
  static ZtVFieldSet setFn() {
    using namespace ZtField_;
    return {.set_ = {.int32Vec = [](void *o, Int32Vec v) {
      Base::set(*static_cast<O *>(o), ZuMv(v));
    }}};
  }
};
;
template <typename T_, typename Props_>
struct ZtFieldType_UInt32Vec : public ZtFieldType_<Props_> {
  enum { Code = ZtFieldTypeCode::UInt32Vec };
  using T = T_;
  using Props = Props_;
  template <typename Fmt = ZtFieldFmt::Default> struct Print {
    ZtField_::UInt32Vec vec;
    template <typename S> friend S &operator<<(S &s, const Print &print) {
      s << Fmt::VecPrefix();
      bool first = true;
      print.vec.all([&s, &first](ZuBox<uint32_t> v) {
	if (!first)
	  s << Fmt::VecDelim();
	else
	  first = false;
	ZtField_printInt<Props, Fmt>(s, v);
      });
      return s << Fmt::VecSuffix();
    }
  };
  inline static ZtVFieldType *mtype();
};
template <typename T, typename Props>
struct ZtFieldType<ZtFieldTypeCode::UInt32Vec, T, Props> :
  public ZtFieldType_UInt32Vec<T, Props> { };
template <
  typename T, typename Props, bool = ZuFieldProp::HasEnum<Props>{},
  bool = ZuFieldProp::HasFlags<Props>{}>
struct ZtVFieldType_UInt32Vec;
template <typename T, typename Props>
struct ZtVFieldType_UInt32Vec<T, Props, false, false> : public ZtVFieldType {
  ZtVFieldType_UInt32Vec() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::UInt32Vec,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.null = nullptr}
    } { }
};
template <typename T, typename Props>
struct ZtVFieldType_UInt32Vec<T, Props, true, false> : public ZtVFieldType {
  ZtVFieldType_UInt32Vec() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::UInt32Vec,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.enum_ = []() -> ZtVFieldEnum * {
	return ZtVFieldEnum_<ZuFieldProp::GetEnum<Props>>::instance();
      }}
    } { }
};
template <typename T, typename Props>
struct ZtVFieldType_UInt32Vec<T, Props, false, true> : public ZtVFieldType {
  ZtVFieldType_UInt32Vec() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::UInt32Vec,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.flags = []() -> ZtVFieldFlags * {
	return ZtVFieldFlags_<ZuFieldProp::GetFlags<Props>>::instance();
      }}
    } { }
};
template <typename T, typename Props>
ZtVFieldType *ZtFieldType_UInt32Vec<T, Props>::mtype() {
  return ZmSingleton<ZtVFieldType_UInt32Vec<T, Props>>::instance();
}
inline ZtField_::UInt32Vec ZtFieldType_UInt32Vec_Def() { return {}; }
template <
  typename Base, auto Def = ZtFieldType_UInt32Vec_Def, bool = Base::ReadOnly>
struct ZtField_UInt32Vec : public ZtField<Base> {
  template <template <typename> typename Override>
  using Adapt = ZtField_UInt32Vec<Override<Base>>;
  using O = typename Base::O;
  using T = typename Base::T;
  using Props = typename Base::Props;
  using Type = ZtFieldType_UInt32Vec<T, ZuTypeGrep<ZtFieldType_Props, Props>>;
  using UInt32Vec = ZtField_::UInt32Vec;
  enum { Code = Type::Code };
  static ZtVFieldGet getFn() {
    return {.get_ = {.uint32Vec = [](const void *o) -> UInt32Vec {
      return Base::get(*static_cast<const O *>(o));
    }}};
  }
  static ZtVFieldSet setFn() {
    using namespace ZtField_;
    return {.set_ = {.uint32Vec = [](void *, UInt32Vec) {}}};
  }
  static constexpr auto deflt() { return Def(); }
  static ZtVFieldGet constantFn() {
    using namespace ZtVFieldConstant;
    return {.get_ = {.uint32Vec = [](const void *o) -> UInt32Vec {
      switch (int(reinterpret_cast<uintptr_t>(o))) {
      case Deflt:
	return Def();
      default:
	return {};
      }
    }}};
  }
};
template <typename Base, auto Def>
struct ZtField_UInt32Vec<Base, Def, false> :
  public ZtField_UInt32Vec<Base, Def, true> {
  using O = typename Base::O;
  static ZtVFieldSet setFn() {
    using namespace ZtField_;
    return {.set_ = {.uint32Vec = [](void *o, UInt32Vec v) {
      Base::set(*static_cast<O *>(o), ZuMv(v));
    }}};
  }
};
;
template <typename T_, typename Props_>
struct ZtFieldType_Int64Vec : public ZtFieldType_<Props_> {
  enum { Code = ZtFieldTypeCode::Int64Vec };
  using T = T_;
  using Props = Props_;
  template <typename Fmt = ZtFieldFmt::Default> struct Print {
    ZtField_::Int64Vec vec;
    template <typename S> friend S &operator<<(S &s, const Print &print) {
      s << Fmt::VecPrefix();
      bool first = true;
      print.vec.all([&s, &first](ZuBox<int64_t> v) {
	if (!first)
	  s << Fmt::VecDelim();
	else
	  first = false;
	ZtField_printInt<Props, Fmt>(s, v);
      });
      return s << Fmt::VecSuffix();
    }
  };
  inline static ZtVFieldType *mtype();
};
template <typename T, typename Props>
struct ZtFieldType<ZtFieldTypeCode::Int64Vec, T, Props> :
  public ZtFieldType_Int64Vec<T, Props> { };
template <
  typename T, typename Props, bool = ZuFieldProp::HasEnum<Props>{},
  bool = ZuFieldProp::HasFlags<Props>{}>
struct ZtVFieldType_Int64Vec;
template <typename T, typename Props>
struct ZtVFieldType_Int64Vec<T, Props, false, false> : public ZtVFieldType {
  ZtVFieldType_Int64Vec() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::Int64Vec,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.null = nullptr}
    } { }
};
template <typename T, typename Props>
struct ZtVFieldType_Int64Vec<T, Props, true, false> : public ZtVFieldType {
  ZtVFieldType_Int64Vec() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::Int64Vec,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.enum_ = []() -> ZtVFieldEnum * {
	return ZtVFieldEnum_<ZuFieldProp::GetEnum<Props>>::instance();
      }}
    } { }
};
template <typename T, typename Props>
struct ZtVFieldType_Int64Vec<T, Props, false, true> : public ZtVFieldType {
  ZtVFieldType_Int64Vec() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::Int64Vec,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.flags = []() -> ZtVFieldFlags * {
	return ZtVFieldFlags_<ZuFieldProp::GetFlags<Props>>::instance();
      }}
    } { }
};
template <typename T, typename Props>
ZtVFieldType *ZtFieldType_Int64Vec<T, Props>::mtype() {
  return ZmSingleton<ZtVFieldType_Int64Vec<T, Props>>::instance();
}
inline ZtField_::Int64Vec ZtFieldType_Int64Vec_Def() { return {}; }
template <
  typename Base, auto Def = ZtFieldType_Int64Vec_Def, bool = Base::ReadOnly>
struct ZtField_Int64Vec : public ZtField<Base> {
  template <template <typename> typename Override>
  using Adapt = ZtField_Int64Vec<Override<Base>>;
  using O = typename Base::O;
  using T = typename Base::T;
  using Props = typename Base::Props;
  using Type = ZtFieldType_Int64Vec<T, ZuTypeGrep<ZtFieldType_Props, Props>>;
  using Int64Vec = ZtField_::Int64Vec;
  enum { Code = Type::Code };
  static ZtVFieldGet getFn() {
    return {.get_ = {.int64Vec = [](const void *o) -> Int64Vec {
      return Base::get(*static_cast<const O *>(o));
    }}};
  }
  static ZtVFieldSet setFn() {
    using namespace ZtField_;
    return {.set_ = {.int64Vec = [](void *, Int64Vec) {}}};
  }
  static constexpr auto deflt() { return Def(); }
  static ZtVFieldGet constantFn() {
    using namespace ZtVFieldConstant;
    return {.get_ = {.int64Vec = [](const void *o) -> Int64Vec {
      switch (int(reinterpret_cast<uintptr_t>(o))) {
      case Deflt:
	return Def();
      default:
	return {};
      }
    }}};
  }
};
template <typename Base, auto Def>
struct ZtField_Int64Vec<Base, Def, false> :
  public ZtField_Int64Vec<Base, Def, true> {
  using O = typename Base::O;
  static ZtVFieldSet setFn() {
    using namespace ZtField_;
    return {.set_ = {.int64Vec = [](void *o, Int64Vec v) {
      Base::set(*static_cast<O *>(o), ZuMv(v));
    }}};
  }
};
;
template <typename T_, typename Props_>
struct ZtFieldType_UInt64Vec : public ZtFieldType_<Props_> {
  enum { Code = ZtFieldTypeCode::UInt64Vec };
  using T = T_;
  using Props = Props_;
  template <typename Fmt = ZtFieldFmt::Default> struct Print {
    ZtField_::UInt64Vec vec;
    template <typename S> friend S &operator<<(S &s, const Print &print) {
      s << Fmt::VecPrefix();
      bool first = true;
      print.vec.all([&s, &first](ZuBox<uint64_t> v) {
	if (!first)
	  s << Fmt::VecDelim();
	else
	  first = false;
	ZtField_printInt<Props, Fmt>(s, v);
      });
      return s << Fmt::VecSuffix();
    }
  };
  inline static ZtVFieldType *mtype();
};
template <typename T, typename Props>
struct ZtFieldType<ZtFieldTypeCode::UInt64Vec, T, Props> :
  public ZtFieldType_UInt64Vec<T, Props> { };
template <
  typename T, typename Props, bool = ZuFieldProp::HasEnum<Props>{},
  bool = ZuFieldProp::HasFlags<Props>{}>
struct ZtVFieldType_UInt64Vec;
template <typename T, typename Props>
struct ZtVFieldType_UInt64Vec<T, Props, false, false> : public ZtVFieldType {
  ZtVFieldType_UInt64Vec() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::UInt64Vec,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.null = nullptr}
    } { }
};
template <typename T, typename Props>
struct ZtVFieldType_UInt64Vec<T, Props, true, false> : public ZtVFieldType {
  ZtVFieldType_UInt64Vec() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::UInt64Vec,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.enum_ = []() -> ZtVFieldEnum * {
	return ZtVFieldEnum_<ZuFieldProp::GetEnum<Props>>::instance();
      }}
    } { }
};
template <typename T, typename Props>
struct ZtVFieldType_UInt64Vec<T, Props, false, true> : public ZtVFieldType {
  ZtVFieldType_UInt64Vec() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::UInt64Vec,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.flags = []() -> ZtVFieldFlags * {
	return ZtVFieldFlags_<ZuFieldProp::GetFlags<Props>>::instance();
      }}
    } { }
};
template <typename T, typename Props>
ZtVFieldType *ZtFieldType_UInt64Vec<T, Props>::mtype() {
  return ZmSingleton<ZtVFieldType_UInt64Vec<T, Props>>::instance();
}
inline ZtField_::UInt64Vec ZtFieldType_UInt64Vec_Def() { return {}; }
template <
  typename Base, auto Def = ZtFieldType_UInt64Vec_Def, bool = Base::ReadOnly>
struct ZtField_UInt64Vec : public ZtField<Base> {
  template <template <typename> typename Override>
  using Adapt = ZtField_UInt64Vec<Override<Base>>;
  using O = typename Base::O;
  using T = typename Base::T;
  using Props = typename Base::Props;
  using Type = ZtFieldType_UInt64Vec<T, ZuTypeGrep<ZtFieldType_Props, Props>>;
  using UInt64Vec = ZtField_::UInt64Vec;
  enum { Code = Type::Code };
  static ZtVFieldGet getFn() {
    return {.get_ = {.uint64Vec = [](const void *o) -> UInt64Vec {
      return Base::get(*static_cast<const O *>(o));
    }}};
  }
  static ZtVFieldSet setFn() {
    using namespace ZtField_;
    return {.set_ = {.uint64Vec = [](void *, UInt64Vec) {}}};
  }
  static constexpr auto deflt() { return Def(); }
  static ZtVFieldGet constantFn() {
    using namespace ZtVFieldConstant;
    return {.get_ = {.uint64Vec = [](const void *o) -> UInt64Vec {
      switch (int(reinterpret_cast<uintptr_t>(o))) {
      case Deflt:
	return Def();
      default:
	return {};
      }
    }}};
  }
};
template <typename Base, auto Def>
struct ZtField_UInt64Vec<Base, Def, false> :
  public ZtField_UInt64Vec<Base, Def, true> {
  using O = typename Base::O;
  static ZtVFieldSet setFn() {
    using namespace ZtField_;
    return {.set_ = {.uint64Vec = [](void *o, UInt64Vec v) {
      Base::set(*static_cast<O *>(o), ZuMv(v));
    }}};
  }
};
;
template <typename T_, typename Props_>
struct ZtFieldType_Int128Vec : public ZtFieldType_<Props_> {
  enum { Code = ZtFieldTypeCode::Int128Vec };
  using T = T_;
  using Props = Props_;
  template <typename Fmt = ZtFieldFmt::Default> struct Print {
    ZtField_::Int128Vec vec;
    template <typename S> friend S &operator<<(S &s, const Print &print) {
      s << Fmt::VecPrefix();
      bool first = true;
      print.vec.all([&s, &first](ZuBox<int128_t> v) {
	if (!first)
	  s << Fmt::VecDelim();
	else
	  first = false;
	ZtField_printInt<Props, Fmt>(s, v);
      });
      return s << Fmt::VecSuffix();
    }
  };
  inline static ZtVFieldType *mtype();
};
template <typename T, typename Props>
struct ZtFieldType<ZtFieldTypeCode::Int128Vec, T, Props> :
  public ZtFieldType_Int128Vec<T, Props> { };
template <
  typename T, typename Props, bool = ZuFieldProp::HasEnum<Props>{},
  bool = ZuFieldProp::HasFlags<Props>{}>
struct ZtVFieldType_Int128Vec;
template <typename T, typename Props>
struct ZtVFieldType_Int128Vec<T, Props, false, false> : public ZtVFieldType {
  ZtVFieldType_Int128Vec() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::Int128Vec,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.null = nullptr}
    } { }
};
template <typename T, typename Props>
struct ZtVFieldType_Int128Vec<T, Props, true, false> : public ZtVFieldType {
  ZtVFieldType_Int128Vec() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::Int128Vec,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.enum_ = []() -> ZtVFieldEnum * {
	return ZtVFieldEnum_<ZuFieldProp::GetEnum<Props>>::instance();
      }}
    } { }
};
template <typename T, typename Props>
struct ZtVFieldType_Int128Vec<T, Props, false, true> : public ZtVFieldType {
  ZtVFieldType_Int128Vec() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::Int128Vec,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.flags = []() -> ZtVFieldFlags * {
	return ZtVFieldFlags_<ZuFieldProp::GetFlags<Props>>::instance();
      }}
    } { }
};
template <typename T, typename Props>
ZtVFieldType *ZtFieldType_Int128Vec<T, Props>::mtype() {
  return ZmSingleton<ZtVFieldType_Int128Vec<T, Props>>::instance();
}
inline ZtField_::Int128Vec ZtFieldType_Int128Vec_Def() { return {}; }
template <
  typename Base, auto Def = ZtFieldType_Int128Vec_Def, bool = Base::ReadOnly>
struct ZtField_Int128Vec : public ZtField<Base> {
  template <template <typename> typename Override>
  using Adapt = ZtField_Int128Vec<Override<Base>>;
  using O = typename Base::O;
  using T = typename Base::T;
  using Props = typename Base::Props;
  using Type = ZtFieldType_Int128Vec<T, ZuTypeGrep<ZtFieldType_Props, Props>>;
  using Int128Vec = ZtField_::Int128Vec;
  enum { Code = Type::Code };
  static ZtVFieldGet getFn() {
    return {.get_ = {.int128Vec = [](const void *o) -> Int128Vec {
      return Base::get(*static_cast<const O *>(o));
    }}};
  }
  static ZtVFieldSet setFn() {
    using namespace ZtField_;
    return {.set_ = {.int128Vec = [](void *, Int128Vec) {}}};
  }
  static constexpr auto deflt() { return Def(); }
  static ZtVFieldGet constantFn() {
    using namespace ZtVFieldConstant;
    return {.get_ = {.int128Vec = [](const void *o) -> Int128Vec {
      switch (int(reinterpret_cast<uintptr_t>(o))) {
      case Deflt:
	return Def();
      default:
	return {};
      }
    }}};
  }
};
template <typename Base, auto Def>
struct ZtField_Int128Vec<Base, Def, false> :
  public ZtField_Int128Vec<Base, Def, true> {
  using O = typename Base::O;
  static ZtVFieldSet setFn() {
    using namespace ZtField_;
    return {.set_ = {.int128Vec = [](void *o, Int128Vec v) {
      Base::set(*static_cast<O *>(o), ZuMv(v));
    }}};
  }
};
;
template <typename T_, typename Props_>
struct ZtFieldType_UInt128Vec : public ZtFieldType_<Props_> {
  enum { Code = ZtFieldTypeCode::UInt128Vec };
  using T = T_;
  using Props = Props_;
  template <typename Fmt = ZtFieldFmt::Default> struct Print {
    ZtField_::UInt128Vec vec;
    template <typename S> friend S &operator<<(S &s, const Print &print) {
      s << Fmt::VecPrefix();
      bool first = true;
      print.vec.all([&s, &first](ZuBox<uint128_t> v) {
	if (!first)
	  s << Fmt::VecDelim();
	else
	  first = false;
	ZtField_printInt<Props, Fmt>(s, v);
      });
      return s << Fmt::VecSuffix();
    }
  };
  inline static ZtVFieldType *mtype();
};
template <typename T, typename Props>
struct ZtFieldType<ZtFieldTypeCode::UInt128Vec, T, Props> :
  public ZtFieldType_UInt128Vec<T, Props> { };
template <
  typename T, typename Props, bool = ZuFieldProp::HasEnum<Props>{},
  bool = ZuFieldProp::HasFlags<Props>{}>
struct ZtVFieldType_UInt128Vec;
template <typename T, typename Props>
struct ZtVFieldType_UInt128Vec<T, Props, false, false> : public ZtVFieldType {
  ZtVFieldType_UInt128Vec() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::UInt128Vec,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.null = nullptr}
    } { }
};
template <typename T, typename Props>
struct ZtVFieldType_UInt128Vec<T, Props, true, false> : public ZtVFieldType {
  ZtVFieldType_UInt128Vec() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::UInt128Vec,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.enum_ = []() -> ZtVFieldEnum * {
	return ZtVFieldEnum_<ZuFieldProp::GetEnum<Props>>::instance();
      }}
    } { }
};
template <typename T, typename Props>
struct ZtVFieldType_UInt128Vec<T, Props, false, true> : public ZtVFieldType {
  ZtVFieldType_UInt128Vec() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::UInt128Vec,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.flags = []() -> ZtVFieldFlags * {
	return ZtVFieldFlags_<ZuFieldProp::GetFlags<Props>>::instance();
      }}
    } { }
};
template <typename T, typename Props>
ZtVFieldType *ZtFieldType_UInt128Vec<T, Props>::mtype() {
  return ZmSingleton<ZtVFieldType_UInt128Vec<T, Props>>::instance();
}
inline ZtField_::UInt128Vec ZtFieldType_UInt128Vec_Def() { return {}; }
template <
  typename Base, auto Def = ZtFieldType_UInt128Vec_Def, bool = Base::ReadOnly>
struct ZtField_UInt128Vec : public ZtField<Base> {
  template <template <typename> typename Override>
  using Adapt = ZtField_UInt128Vec<Override<Base>>;
  using O = typename Base::O;
  using T = typename Base::T;
  using Props = typename Base::Props;
  using Type = ZtFieldType_UInt128Vec<T, ZuTypeGrep<ZtFieldType_Props, Props>>;
  using UInt128Vec = ZtField_::UInt128Vec;
  enum { Code = Type::Code };
  static ZtVFieldGet getFn() {
    return {.get_ = {.uint128Vec = [](const void *o) -> UInt128Vec {
      return Base::get(*static_cast<const O *>(o));
    }}};
  }
  static ZtVFieldSet setFn() {
    using namespace ZtField_;
    return {.set_ = {.uint128Vec = [](void *, UInt128Vec) {}}};
  }
  static constexpr auto deflt() { return Def(); }
  static ZtVFieldGet constantFn() {
    using namespace ZtVFieldConstant;
    return {.get_ = {.uint128Vec = [](const void *o) -> UInt128Vec {
      switch (int(reinterpret_cast<uintptr_t>(o))) {
      case Deflt:
	return Def();
      default:
	return {};
      }
    }}};
  }
};
template <typename Base, auto Def>
struct ZtField_UInt128Vec<Base, Def, false> :
  public ZtField_UInt128Vec<Base, Def, true> {
  using O = typename Base::O;
  static ZtVFieldSet setFn() {
    using namespace ZtField_;
    return {.set_ = {.uint128Vec = [](void *o, UInt128Vec v) {
      Base::set(*static_cast<O *>(o), ZuMv(v));
    }}};
  }
};
;

template <typename T_, typename Props_>
struct ZtFieldType_FloatVec : public ZtFieldType_<Props_> {
  enum { Code = ZtFieldTypeCode::FloatVec };
  using T = T_;
  using Props = Props_;
  template <typename Fmt = ZtFieldFmt::Default> struct Print {
    ZtField_::FloatVec vec;
    template <typename S> friend S &operator<<(S &s, const Print &print) {
      s << Fmt::VecPrefix();
      bool first = true;
      print.vec.all([&s, &first](ZuBox<double> v) {
	if (!first)
	  s << Fmt::VecDelim();
	else
	  first = false;
	s << v.template fmt<Fmt>();
      });
      return s << Fmt::VecSuffix();
    }
  };
  inline static ZtVFieldType *mtype();
};
template <typename T, typename Props>
struct ZtFieldType<ZtFieldTypeCode::FloatVec, T, Props> :
  public ZtFieldType_FloatVec<T, Props> { };

template <typename T, typename Props>
struct ZtVFieldType_FloatVec : public ZtVFieldType {
  ZtVFieldType_FloatVec() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::FloatVec,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.null = nullptr}
    } { }
};
template <typename T, typename Props>
ZtVFieldType *ZtFieldType_FloatVec<T, Props>::mtype() {
  return ZmSingleton<ZtVFieldType_FloatVec<T, Props>>::instance();
}

inline ZtField_::FloatVec ZtField_FloatVec_Def() { return {}; }
template <typename Base, auto Def = ZtField_FloatVec_Def, bool = Base::ReadOnly>
struct ZtField_FloatVec : public ZtField<Base> {
  template <template <typename> typename Override>
  using Adapt = ZtField_FloatVec<Override<Base>>;
  using O = typename Base::O;
  using T = typename Base::T;
  using Props = typename Base::Props;
  using Type = ZtFieldType_FloatVec<T, ZuTypeGrep<ZtFieldType_Props, Props>>;
  using FloatVec = ZtField_::FloatVec;
  enum { Code = Type::Code };
  static ZtVFieldGet getFn() {
    return {.get_ = {.floatVec = [](const void *o) -> FloatVec {
      return Base::get(*static_cast<const O *>(o));
    }}};
  }
  static ZtVFieldSet setFn() {
    using namespace ZtField_;
    return {.set_ = {.floatVec = [](void *, FloatVec) {}}};
  }
  static constexpr auto deflt() { return Def(); }
  static ZtVFieldGet constantFn() {
    using namespace ZtVFieldConstant;
    return {.get_ = {.floatVec = [](const void *o) -> FloatVec {
      switch (int(reinterpret_cast<uintptr_t>(o))) {
      case Deflt:
	return Def();
      default:
	return {};
      }
    }}};
  }
};
template <typename Base, auto Def>
struct ZtField_FloatVec<Base, Def, false> :
  public ZtField_FloatVec<Base, Def, true> {
  using O = typename Base::O;
  static ZtVFieldSet setFn() {
    using namespace ZtField_;
    return {.set_ = {.floatVec = [](void *o, FloatVec v) {
      Base::set(*static_cast<O *>(o), ZuMv(v));
    }}};
  }
};

template <typename T_, typename Props_>
struct ZtFieldType_FixedVec : public ZtFieldType_<Props_> {
  enum { Code = ZtFieldTypeCode::FixedVec };
  using T = T_;
  using Props = Props_;
  template <typename Fmt = ZtFieldFmt::Default> struct Print {
    ZtField_::FixedVec vec;
    template <typename S> friend S &operator<<(S &s, const Print &print) {
      s << Fmt::VecPrefix();
      bool first = true;
      print.vec.all([&s, &first](const auto &v) {
	if (!first)
	  s << Fmt::VecDelim();
	else
	  first = false;
	s << v.template fmt<Fmt>();
      });
      return s << Fmt::VecSuffix();
    }
  };
  inline static ZtVFieldType *mtype();
};
template <typename T, typename Props>
struct ZtFieldType<ZtFieldTypeCode::FixedVec, T, Props> :
  public ZtFieldType_FixedVec<T, Props> { };

template <typename T, typename Props>
struct ZtVFieldType_FixedVec : public ZtVFieldType {
  ZtVFieldType_FixedVec() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::FixedVec,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.null = nullptr}
    } { }
};
template <typename T, typename Props>
ZtVFieldType *ZtFieldType_FixedVec<T, Props>::mtype() {
  return ZmSingleton<ZtVFieldType_FixedVec<T, Props>>::instance();
}

inline ZtField_::FixedVec ZtField_FixedVec_Def() { return {}; }
template <typename Base, auto Def = ZtField_FixedVec_Def, bool = Base::ReadOnly>
struct ZtField_FixedVec : public ZtField<Base> {
  template <template <typename> typename Override>
  using Adapt = ZtField_FixedVec<Override<Base>>;
  using O = typename Base::O;
  using T = typename Base::T;
  using Props = typename Base::Props;
  using Type = ZtFieldType_FixedVec<T, ZuTypeGrep<ZtFieldType_Props, Props>>;
  using FixedVec = ZtField_::FixedVec;
  enum { Code = Type::Code };
  static ZtVFieldGet getFn() {
    return {.get_ = {.fixedVec = [](const void *o) -> FixedVec {
      return Base::get(*static_cast<const O *>(o));
    }}};
  }
  static ZtVFieldSet setFn() {
    using namespace ZtField_;
    return {.set_ = {.fixedVec = [](void *, FixedVec) {}}};
  }
  static constexpr auto deflt() { return Def(); }
  static ZtVFieldGet constantFn() {
    using namespace ZtVFieldConstant;
    return {.get_ = {.fixedVec = [](const void *o) -> FixedVec {
      switch (int(reinterpret_cast<uintptr_t>(o))) {
      case Deflt:
	return Def();
      default:
	return {};
      }
    }}};
  }
};
template <typename Base, auto Def>
struct ZtField_FixedVec<Base, Def, false> :
  public ZtField_FixedVec<Base, Def, true> {
  using O = typename Base::O;
  static ZtVFieldSet setFn() {
    using namespace ZtField_;
    return {.set_ = {.fixedVec = [](void *o, FixedVec v) {
      Base::set(*static_cast<O *>(o), ZuMv(v));
    }}};
  }
};

template <typename T_, typename Props_>
struct ZtFieldType_DecimalVec : public ZtFieldType_<Props_> {
  enum { Code = ZtFieldTypeCode::DecimalVec };
  using T = T_;
  using Props = Props_;
  template <typename Fmt = ZtFieldFmt::Default> struct Print {
    ZtField_::DecimalVec vec;
    template <typename S> friend S &operator<<(S &s, const Print &print) {
      s << Fmt::VecPrefix();
      bool first = true;
      print.vec.all([&s, &first](const auto &v) {
	if (!first)
	  s << Fmt::VecDelim();
	else
	  first = false;
	s << v.template fmt<Fmt>();
      });
      return s << Fmt::VecSuffix();
    }
  };
  inline static ZtVFieldType *mtype();
};
template <typename T, typename Props>
struct ZtFieldType<ZtFieldTypeCode::DecimalVec, T, Props> :
  public ZtFieldType_DecimalVec<T, Props> { };

template <typename T, typename Props>
struct ZtVFieldType_DecimalVec : public ZtVFieldType {
  ZtVFieldType_DecimalVec() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::DecimalVec,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.null = nullptr}
    } { }
};
template <typename T, typename Props>
ZtVFieldType *ZtFieldType_DecimalVec<T, Props>::mtype() {
  return ZmSingleton<ZtVFieldType_DecimalVec<T, Props>>::instance();
}

inline ZtField_::DecimalVec ZtField_DecimalVec_Def() { return {}; }
template <
  typename Base, auto Def = ZtField_DecimalVec_Def, bool = Base::ReadOnly>
struct ZtField_DecimalVec : public ZtField<Base> {
  template <template <typename> typename Override>
  using Adapt = ZtField_DecimalVec<Override<Base>>;
  using O = typename Base::O;
  using T = typename Base::T;
  using Props = typename Base::Props;
  using Type = ZtFieldType_DecimalVec<T, ZuTypeGrep<ZtFieldType_Props, Props>>;
  using DecimalVec = ZtField_::DecimalVec;
  enum { Code = Type::Code };
  static ZtVFieldGet getFn() {
    return {.get_ = {.decimalVec = [](const void *o) -> DecimalVec {
      return Base::get(*static_cast<const O *>(o));
    }}};
  }
  static ZtVFieldSet setFn() {
    using namespace ZtField_;
    return {.set_ = {.decimalVec = [](void *, DecimalVec) {}}};
  }
  static constexpr auto deflt() { return Def(); }
  static ZtVFieldGet constantFn() {
    using namespace ZtVFieldConstant;
    return {.get_ = {.decimalVec = [](const void *o) -> DecimalVec {
      switch (int(reinterpret_cast<uintptr_t>(o))) {
      case Deflt:
	return Def();
      default:
	return {};
      }
    }}};
  }
};
template <typename Base, auto Def>
struct ZtField_DecimalVec<Base, Def, false> :
  public ZtField_DecimalVec<Base, Def, true> {
  using O = typename Base::O;
  static ZtVFieldSet setFn() {
    using namespace ZtField_;
    return {.set_ = {.decimalVec = [](void *o, DecimalVec v) {
      Base::set(*static_cast<O *>(o), ZuMv(v));
    }}};
  }
};

template <typename T_, typename Props_>
struct ZtFieldType_TimeVec : public ZtFieldType_<Props_> {
  enum { Code = ZtFieldTypeCode::TimeVec };
  using T = T_;
  using Props = Props_;
  template <typename Fmt = ZtFieldFmt::Default> struct Print {
    ZtField_::TimeVec vec;
    template <typename S> friend S &operator<<(S &s, const Print &print) {
      s << Fmt::VecPrefix();
      bool first = true;
      print.vec.all([&s, &first](ZuDateTime v) {
	if (!first)
	  s << Fmt::VecDelim();
	else
	  first = false;
	s << v.fmt(Fmt::DatePrint_());
      });
      return s << Fmt::VecSuffix();
    }
  };
  inline static ZtVFieldType *mtype();
};
template <typename T, typename Props>
struct ZtFieldType<ZtFieldTypeCode::TimeVec, T, Props> :
  public ZtFieldType_TimeVec<T, Props> { };

template <typename T, typename Props>
struct ZtVFieldType_TimeVec : public ZtVFieldType {
  ZtVFieldType_TimeVec() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::TimeVec,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.null = nullptr}
    } { }
};
template <typename T, typename Props>
ZtVFieldType *ZtFieldType_TimeVec<T, Props>::mtype() {
  return ZmSingleton<ZtVFieldType_TimeVec<T, Props>>::instance();
}

inline ZtField_::TimeVec ZtField_TimeVec_Def() { return {}; }
template <typename Base, auto Def = ZtField_TimeVec_Def, bool = Base::ReadOnly>
struct ZtField_TimeVec : public ZtField<Base> {
  template <template <typename> typename Override>
  using Adapt = ZtField_TimeVec<Override<Base>>;
  using O = typename Base::O;
  using T = typename Base::T;
  using Props = typename Base::Props;
  using Type = ZtFieldType_TimeVec<T, ZuTypeGrep<ZtFieldType_Props, Props>>;
  using TimeVec = ZtField_::TimeVec;
  enum { Code = Type::Code };
  static ZtVFieldGet getFn() {
    return {.get_ = {.timeVec = [](const void *o) -> TimeVec {
      return Base::get(*static_cast<const O *>(o));
    }}};
  }
  static ZtVFieldSet setFn() {
    using namespace ZtField_;
    return {.set_ = {.timeVec = [](void *, TimeVec) {}}};
  }
  static constexpr auto deflt() { return Def(); }
  static ZtVFieldGet constantFn() {
    using namespace ZtVFieldConstant;
    return {.get_ = {.timeVec = [](const void *o) -> TimeVec {
      switch (int(reinterpret_cast<uintptr_t>(o))) {
      case Deflt:
	return Def();
      default:
	return {};
      }
    }}};
  }
};
template <typename Base, auto Def>
struct ZtField_TimeVec<Base, Def, false> :
  public ZtField_TimeVec<Base, Def, true> {
  using O = typename Base::O;
  static ZtVFieldSet setFn() {
    using namespace ZtField_;
    return {.set_ = {.timeVec = [](void *o, TimeVec v) {
      Base::set(*static_cast<O *>(o), ZuMv(v));
    }}};
  }
};

template <typename T_, typename Props_>
struct ZtFieldType_DateTimeVec : public ZtFieldType_<Props_> {
  enum { Code = ZtFieldTypeCode::DateTimeVec };
  using T = T_;
  using Props = Props_;
  template <typename Fmt = ZtFieldFmt::Default> struct Print {
    ZtField_::DateTimeVec vec;
    template <typename S> friend S &operator<<(S &s, const Print &print) {
      s << Fmt::VecPrefix();
      bool first = true;
      print.vec.all([&s, &first](const auto &v) {
	if (!first)
	  s << Fmt::VecDelim();
	else
	  first = false;
	s << v.fmt(Fmt::DatePrint_());
      });
      return s << Fmt::VecSuffix();
    }
  };
  inline static ZtVFieldType *mtype();
};
template <typename T, typename Props>
struct ZtFieldType<ZtFieldTypeCode::DateTimeVec, T, Props> :
  public ZtFieldType_DateTimeVec<T, Props> { };

template <typename T, typename Props>
struct ZtVFieldType_DateTimeVec : public ZtVFieldType {
  ZtVFieldType_DateTimeVec() :
    ZtVFieldType{
      .code = ZtFieldTypeCode::DateTimeVec,
      .props = ZtVFieldProp::Value<Props>{},
      .info = {.null = nullptr}
    } { }
};
template <typename T, typename Props>
ZtVFieldType *ZtFieldType_DateTimeVec<T, Props>::mtype() {
  return ZmSingleton<ZtVFieldType_DateTimeVec<T, Props>>::instance();
}

inline ZtField_::DateTimeVec ZtField_DateTimeVec_Def() { return {}; }
template <
  typename Base, auto Def = ZtField_DateTimeVec_Def, bool = Base::ReadOnly>
struct ZtField_DateTimeVec : public ZtField<Base> {
  template <template <typename> typename Override>
  using Adapt = ZtField_DateTimeVec<Override<Base>>;
  using O = typename Base::O;
  using T = typename Base::T;
  using Props = typename Base::Props;
  using Type = ZtFieldType_DateTimeVec<T, ZuTypeGrep<ZtFieldType_Props, Props>>;
  using DateTimeVec = ZtField_::DateTimeVec;
  enum { Code = Type::Code };
  static ZtVFieldGet getFn() {
    return {.get_ = {.dateTimeVec = [](const void *o) -> DateTimeVec {
      return Base::get(*static_cast<const O *>(o));
    }}};
  }
  static ZtVFieldSet setFn() {
    using namespace ZtField_;
    return {.set_ = {.dateTimeVec = [](void *, DateTimeVec) {}}};
  }
  static constexpr auto deflt() { return Def(); }
  static ZtVFieldGet constantFn() {
    using namespace ZtVFieldConstant;
    return {.get_ = {.dateTimeVec = [](const void *o) -> DateTimeVec {
      switch (int(reinterpret_cast<uintptr_t>(o))) {
      case Deflt:
	return Def();
      default:
	return {};
      }
    }}};
  }
};
template <typename Base, auto Def>
struct ZtField_DateTimeVec<Base, Def, false> :
  public ZtField_DateTimeVec<Base, Def, true> {
  using O = typename Base::O;
  static ZtVFieldSet setFn() {
    using namespace ZtField_;
    return {.set_ = {.dateTimeVec = [](void *o, DateTimeVec v) {
      Base::set(*static_cast<O *>(o), ZuMv(v));
    }}};
  }
};

template <typename Field> struct ZtFieldPrint_ {
  using O = typename Field::O;
  using Print = typename Field::Type::template Print<ZtFieldFmt::Default>;
  const O &o;
  template <typename S> friend S &operator<<(S &s, const ZtFieldPrint_ &print) {
    return s << Field::id() << '=' << Print{Field::get(print.o)};
  }
};

struct ZtFieldPrint : public ZuPrintDelegate {
  template <typename U>
  struct Print_Filter :
    public ZuBool<!ZuTypeIn<ZuFieldProp::Hidden, typename U::Props>{}> { };
  template <typename S, typename O> static void print(S &s, const O &o) {
    using Fields = ZuTypeGrep<Print_Filter, ZuFields<O>>;
    s << '{';
    ZuUnroll::all<Fields>([&s, &o]<typename Field>() {
      if constexpr (ZuTypeIndex<Field, Fields>{}) s << ' ';
      s << ZtFieldPrint_<Field>{o};
    });
    s << '}';
  }
};

using ZtVFieldArray = ZuSpan<const ZtVField *>;

template <typename VField, typename... Fields> struct ZtVFieldFactory {
  enum { N = sizeof...(Fields) };

  ZtVFieldArray fields;

  static ZtVFieldFactory *instance() {
    return ZmSingleton<ZtVFieldFactory>::instance();
  }

  ZtVFieldFactory() {
    static const VField fields_[N] =

      {VField{Fields{}}...};
    static const ZtVField *ptr_[N];
    ZuUnroll::all<N>([](auto i) {
      ptr_[i] = static_cast<const ZtVField *>(&fields_[i]);
    });
    fields = {&ptr_[0], N};
  }
};
template <typename Fields, typename VField = ZtVField>
inline ZtVFieldArray ZtVFields_() {
  using Factory =
    ZuTypeApply<ZtVFieldFactory, typename Fields::template Unshift<VField>>;
  return Factory::instance()->fields;
}
template <typename O, typename VField = ZtVField>
inline ZtVFieldArray ZtVFields() {
  return ZtVFields_<ZuFields<O>, VField>();
}

using ZtVKeyFieldArray = ZuSpan<const ZtVFieldArray>;

template <typename O, typename VField> struct ZtVKeyFields_ {
  ZtVKeyFieldArray keys;

  static ZtVKeyFields_ *instance() {
    return ZmSingleton<ZtVKeyFields_>::instance();
  }

  ZtVKeyFields_() {
    using KeyIDs = ZuFieldKeyIDs<O>;
    static ZtVFieldArray data_[KeyIDs::N];
    ZuUnroll::all<KeyIDs>([](auto i) {
      data_[i] = ZtVFields<ZuFieldKeyT<O, i>, VField>();
    });
    keys = {&data_[0], KeyIDs::N};
  }
};
template <typename O, typename VField = ZtVField>
inline ZtVKeyFieldArray ZtVKeyFields() {
  return ZtVKeyFields_<O, VField>::instance()->keys;
}

namespace Zu {

namespace IO {
enum { OK = 0, EndOfFile = -1, IOError = -2, NotReady = -3 };

inline const char *ioResult(int i) {
  static const char *names[] = {"OK", "EndOfFile", "IOError", "NotReady"};
  if (i > 0) i = 0;
  i = -i;
  if (i > (sizeof(names) / sizeof(names[0]))) return "Unknown";
  return names[i];
}

struct IOResult {
  int code;
  IOResult(int code_) : code{code_} { }
  template <typename S> void print(S &s) const { s << ioResult(code); }
  friend ZuPrintFn ZuPrintType(IOResult *);
};
} // namespace IO

using namespace IO;

} // namespace Zu

namespace Zi {
using namespace Zu::IO;
};

extern "C" {

  struct iovec {
    void *iov_base;
    size_t iov_len;
  };

  enum __socket_type {
    SOCK_STREAM = 1,

    SOCK_DGRAM = 2,

    SOCK_RAW = 3,

    SOCK_RDM = 4,

    SOCK_SEQPACKET = 5,

    SOCK_DCCP = 6,

    SOCK_PACKET = 10,

    SOCK_CLOEXEC = 02000000,

    SOCK_NONBLOCK = 00004000

  };

  typedef unsigned short int sa_family_t;

  struct __attribute__((__may_alias__)) sockaddr {
    sa_family_t sa_family;
    char sa_data[14];
  };

  struct __attribute__((__may_alias__)) sockaddr_storage {
    sa_family_t ss_family;
    char __ss_padding[(
      128 - (sizeof(unsigned short int)) - sizeof(unsigned long int)
    )];
    unsigned long int __ss_align;
  };

  enum {
    MSG_OOB = 0x01,

    MSG_PEEK = 0x02,

    MSG_DONTROUTE = 0x04,

    MSG_TRYHARD = MSG_DONTROUTE,

    MSG_CTRUNC = 0x08,

    MSG_PROXY = 0x10,

    MSG_TRUNC = 0x20,

    MSG_DONTWAIT = 0x40,

    MSG_EOR = 0x80,

    MSG_WAITALL = 0x100,

    MSG_FIN = 0x200,

    MSG_SYN = 0x400,

    MSG_CONFIRM = 0x800,

    MSG_RST = 0x1000,

    MSG_ERRQUEUE = 0x2000,

    MSG_NOSIGNAL = 0x4000,

    MSG_MORE = 0x8000,

    MSG_WAITFORONE = 0x10000,

    MSG_BATCH = 0x40000,

    MSG_ZEROCOPY = 0x4000000,

    MSG_FASTOPEN = 0x20000000,

    MSG_CMSG_CLOEXEC = 0x40000000

  };

  struct msghdr {
    void *msg_name;
    socklen_t msg_namelen;

    struct iovec *msg_iov;
    size_t msg_iovlen;

    void *msg_control;
    size_t msg_controllen;

    int msg_flags;
  };

  struct cmsghdr {
    size_t cmsg_len;

    int cmsg_level;
    int cmsg_type;

    __extension__ unsigned char __cmsg_data[];
  };

  extern struct cmsghdr *
  __cmsg_nxthdr(struct msghdr *__mhdr, struct cmsghdr *__cmsg) noexcept(true);

  enum {
    SCM_RIGHTS = 0x01

    ,
    SCM_CREDENTIALS = 0x02

    ,
    SCM_SECURITY = 0x03

    ,
    SCM_PIDFD = 0x04

  };

  struct ucred {
    pid_t pid;
    uid_t uid;
    gid_t gid;
  };

  typedef struct {
    unsigned long fds_bits[1024 / (8 * sizeof(long))];
  } __kernel_fd_set;

  typedef void (*__kernel_sighandler_t)(int);

  typedef int __kernel_key_t;
  typedef int __kernel_mqd_t;

  typedef unsigned short __kernel_old_uid_t;
  typedef unsigned short __kernel_old_gid_t;

  typedef unsigned long __kernel_old_dev_t;

  typedef long __kernel_long_t;
  typedef unsigned long __kernel_ulong_t;

  typedef __kernel_ulong_t __kernel_ino_t;

  typedef unsigned int __kernel_mode_t;

  typedef int __kernel_pid_t;

  typedef int __kernel_ipc_pid_t;

  typedef unsigned int __kernel_uid_t;
  typedef unsigned int __kernel_gid_t;

  typedef __kernel_long_t __kernel_suseconds_t;

  typedef int __kernel_daddr_t;

  typedef unsigned int __kernel_uid32_t;
  typedef unsigned int __kernel_gid32_t;

  typedef __kernel_ulong_t __kernel_size_t;
  typedef __kernel_long_t __kernel_ssize_t;
  typedef __kernel_long_t __kernel_ptrdiff_t;

  typedef struct {
    int val[2];
  } __kernel_fsid_t;

  typedef __kernel_long_t __kernel_off_t;
  typedef long long __kernel_loff_t;
  typedef __kernel_long_t __kernel_old_time_t;
  typedef __kernel_long_t __kernel_time_t;
  typedef long long __kernel_time64_t;
  typedef __kernel_long_t __kernel_clock_t;
  typedef int __kernel_timer_t;
  typedef int __kernel_clockid_t;
  typedef char *__kernel_caddr_t;
  typedef unsigned short __kernel_uid16_t;
  typedef unsigned short __kernel_gid16_t;

  struct linger {
    int l_onoff;
    int l_linger;
  };

  struct osockaddr {
    unsigned short int sa_family;
    unsigned char sa_data[14];
  };

  enum {
    SHUT_RD = 0,

    SHUT_WR,

    SHUT_RDWR

  };

  struct mmsghdr {
    struct msghdr msg_hdr;
    unsigned int msg_len;
  };

  extern int socket(int __domain, int __type, int __protocol) noexcept(true);

  extern int socketpair(
    int __domain, int __type, int __protocol, int __fds[2]
  ) noexcept(true);

  extern int
  bind(int __fd, const struct sockaddr *__addr, socklen_t __len) noexcept(true);

  extern int getsockname(
    int __fd, struct sockaddr *__restrict __addr, socklen_t *__restrict __len
  ) noexcept(true);

  extern int connect(int __fd, const struct sockaddr *__addr, socklen_t __len);

  extern int getpeername(
    int __fd, struct sockaddr *__restrict __addr, socklen_t *__restrict __len
  ) noexcept(true);

  extern ssize_t send(int __fd, const void *__buf, size_t __n, int __flags);

  extern ssize_t recv(int __fd, void *__buf, size_t __n, int __flags);

  extern ssize_t sendto(
    int __fd, const void *__buf, size_t __n, int __flags,
    const struct sockaddr *__addr, socklen_t __addr_len
  );

  extern ssize_t recvfrom(
    int __fd, void *__restrict __buf, size_t __n, int __flags,
    struct sockaddr *__restrict __addr, socklen_t *__restrict __addr_len
  );

  extern ssize_t sendmsg(int __fd, const struct msghdr *__message, int __flags);

  extern int sendmmsg(
    int __fd, struct mmsghdr *__vmessages, unsigned int __vlen, int __flags
  );

  extern ssize_t recvmsg(int __fd, struct msghdr *__message, int __flags);

  extern int recvmmsg(
    int __fd, struct mmsghdr *__vmessages, unsigned int __vlen, int __flags,
    struct timespec *__tmo
  );

  extern int getsockopt(
    int __fd, int __level, int __optname, void *__restrict __optval,
    socklen_t *__restrict __optlen
  ) noexcept(true);

  extern int setsockopt(
    int __fd, int __level, int __optname, const void *__optval,
    socklen_t __optlen
  ) noexcept(true);

  extern int listen(int __fd, int __n) noexcept(true);

  extern int accept(
    int __fd, struct sockaddr *__restrict __addr,
    socklen_t *__restrict __addr_len
  );

  extern int accept4(
    int __fd, struct sockaddr *__restrict __addr,
    socklen_t *__restrict __addr_len, int __flags
  );

  extern int shutdown(int __fd, int __how) noexcept(true);

  extern int sockatmark(int __fd) noexcept(true);

  extern int isfdtype(int __fd, int __fdtype) noexcept(true);
}

extern "C" {

  typedef uint32_t in_addr_t;
  struct in_addr {
    in_addr_t s_addr;
  };

  struct ip_opts {
    struct in_addr ip_dst;
    char ip_opts[40];
  };

  struct in_pktinfo {
    int ipi_ifindex;
    struct in_addr ipi_spec_dst;
    struct in_addr ipi_addr;
  };

  enum {
    IPPROTO_IP = 0,

    IPPROTO_ICMP = 1,

    IPPROTO_IGMP = 2,

    IPPROTO_IPIP = 4,

    IPPROTO_TCP = 6,

    IPPROTO_EGP = 8,

    IPPROTO_PUP = 12,

    IPPROTO_UDP = 17,

    IPPROTO_IDP = 22,

    IPPROTO_TP = 29,

    IPPROTO_DCCP = 33,

    IPPROTO_IPV6 = 41,

    IPPROTO_RSVP = 46,

    IPPROTO_GRE = 47,

    IPPROTO_ESP = 50,

    IPPROTO_AH = 51,

    IPPROTO_MTP = 92,

    IPPROTO_BEETPH = 94,

    IPPROTO_ENCAP = 98,

    IPPROTO_PIM = 103,

    IPPROTO_COMP = 108,

    IPPROTO_L2TP = 115,

    IPPROTO_SCTP = 132,

    IPPROTO_UDPLITE = 136,

    IPPROTO_MPLS = 137,

    IPPROTO_ETHERNET = 143,

    IPPROTO_RAW = 255,

    IPPROTO_MPTCP = 262,

    IPPROTO_MAX
  };

  enum {
    IPPROTO_HOPOPTS = 0,

    IPPROTO_ROUTING = 43,

    IPPROTO_FRAGMENT = 44,

    IPPROTO_ICMPV6 = 58,

    IPPROTO_NONE = 59,

    IPPROTO_DSTOPTS = 60,

    IPPROTO_MH = 135

  };

  typedef uint16_t in_port_t;

  enum {
    IPPORT_ECHO = 7,
    IPPORT_DISCARD = 9,
    IPPORT_SYSTAT = 11,
    IPPORT_DAYTIME = 13,
    IPPORT_NETSTAT = 15,
    IPPORT_FTP = 21,
    IPPORT_TELNET = 23,
    IPPORT_SMTP = 25,
    IPPORT_TIMESERVER = 37,
    IPPORT_NAMESERVER = 42,
    IPPORT_WHOIS = 43,
    IPPORT_MTP = 57,

    IPPORT_TFTP = 69,
    IPPORT_RJE = 77,
    IPPORT_FINGER = 79,
    IPPORT_TTYLINK = 87,
    IPPORT_SUPDUP = 95,

    IPPORT_EXECSERVER = 512,
    IPPORT_LOGINSERVER = 513,
    IPPORT_CMDSERVER = 514,
    IPPORT_EFSSERVER = 520,

    IPPORT_BIFFUDP = 512,
    IPPORT_WHOSERVER = 513,
    IPPORT_ROUTESERVER = 520,

    IPPORT_RESERVED = 1024,

    IPPORT_USERRESERVED = 5000
  };

  struct in6_addr {
    union {
      uint8_t __u6_addr8[16];
      uint16_t __u6_addr16[8];
      uint32_t __u6_addr32[4];
    } __in6_u;
  };

  extern const struct in6_addr in6addr_any;
  extern const struct in6_addr in6addr_loopback;

  struct __attribute__((__may_alias__)) sockaddr_in {
    sa_family_t sin_family;
    in_port_t sin_port;
    struct in_addr sin_addr;

    unsigned char sin_zero
      [sizeof(struct sockaddr) - (sizeof(unsigned short int)) -
       sizeof(in_port_t) - sizeof(struct in_addr)];
  };

  struct __attribute__((__may_alias__)) sockaddr_in6 {
    sa_family_t sin6_family;
    in_port_t sin6_port;
    uint32_t sin6_flowinfo;
    struct in6_addr sin6_addr;
    uint32_t sin6_scope_id;
  };

  struct ip_mreq {
    struct in_addr imr_multiaddr;

    struct in_addr imr_interface;
  };

  struct ip_mreqn {
    struct in_addr imr_multiaddr;

    struct in_addr imr_address;

    int imr_ifindex;
  };

  struct ip_mreq_source {
    struct in_addr imr_multiaddr;

    struct in_addr imr_interface;

    struct in_addr imr_sourceaddr;
  };

  struct ipv6_mreq {
    struct in6_addr ipv6mr_multiaddr;

    unsigned int ipv6mr_interface;
  };

  struct group_req {
    uint32_t gr_interface;

    struct sockaddr_storage gr_group;
  };

  struct group_source_req {
    uint32_t gsr_interface;

    struct sockaddr_storage gsr_group;

    struct sockaddr_storage gsr_source;
  };

  struct ip_msfilter {
    struct in_addr imsf_multiaddr;

    struct in_addr imsf_interface;

    uint32_t imsf_fmode;

    uint32_t imsf_numsrc;

    struct in_addr imsf_slist[1];
  };

  struct group_filter {
    uint32_t gf_interface;

    struct sockaddr_storage gf_group;

    uint32_t gf_fmode;

    uint32_t gf_numsrc;

    struct sockaddr_storage gf_slist[1];
  };

  extern uint32_t ntohl(uint32_t __netlong) noexcept(true)
    __attribute__((__const__));
  extern uint16_t ntohs(uint16_t __netshort) noexcept(true)
    __attribute__((__const__));
  extern uint32_t htonl(uint32_t __hostlong) noexcept(true)
    __attribute__((__const__));
  extern uint16_t htons(uint16_t __hostshort) noexcept(true)
    __attribute__((__const__));

  extern int
  bindresvport(int __sockfd, struct sockaddr_in *__sock_in) noexcept(true);

  extern int
  bindresvport6(int __sockfd, struct sockaddr_in6 *__sock_in) noexcept(true);

  struct cmsghdr;

  struct in6_pktinfo {
    struct in6_addr ipi6_addr;
    unsigned int ipi6_ifindex;
  };

  struct ip6_mtuinfo {
    struct sockaddr_in6 ip6m_addr;
    uint32_t ip6m_mtu;
  };

  extern int inet6_option_space(int __nbytes) noexcept(true)
    __attribute__((__deprecated__));
  extern int inet6_option_init(
    void *__bp, struct cmsghdr **__cmsgp, int __type
  ) noexcept(true) __attribute__((__deprecated__));
  extern int inet6_option_append(
    struct cmsghdr *__cmsg, const uint8_t *__typep, int __multx, int __plusy
  ) noexcept(true) __attribute__((__deprecated__));
  extern uint8_t *inet6_option_alloc(
    struct cmsghdr *__cmsg, int __datalen, int __multx, int __plusy
  ) noexcept(true) __attribute__((__deprecated__));
  extern int inet6_option_next(
    const struct cmsghdr *__cmsg, uint8_t **__tptrp
  ) noexcept(true) __attribute__((__deprecated__));
  extern int inet6_option_find(
    const struct cmsghdr *__cmsg, uint8_t **__tptrp, int __type
  ) noexcept(true) __attribute__((__deprecated__));

  extern int inet6_opt_init(void *__extbuf, socklen_t __extlen) noexcept(true);
  extern int inet6_opt_append(
    void *__extbuf, socklen_t __extlen, int __offset, uint8_t __type,
    socklen_t __len, uint8_t __align, void **__databufp
  ) noexcept(true);
  extern int inet6_opt_finish(
    void *__extbuf, socklen_t __extlen, int __offset
  ) noexcept(true);
  extern int inet6_opt_set_val(
    void *__databuf, int __offset, void *__val, socklen_t __vallen
  ) noexcept(true);
  extern int inet6_opt_next(
    void *__extbuf, socklen_t __extlen, int __offset, uint8_t *__typep,
    socklen_t *__lenp, void **__databufp
  ) noexcept(true);
  extern int inet6_opt_find(
    void *__extbuf, socklen_t __extlen, int __offset, uint8_t __type,
    socklen_t *__lenp, void **__databufp
  ) noexcept(true);
  extern int inet6_opt_get_val(
    void *__databuf, int __offset, void *__val, socklen_t __vallen
  ) noexcept(true);

  extern socklen_t inet6_rth_space(int __type, int __segments) noexcept(true);
  extern void *inet6_rth_init(
    void *__bp, socklen_t __bp_len, int __type, int __segments
  ) noexcept(true);
  extern int
  inet6_rth_add(void *__bp, const struct in6_addr *__addr) noexcept(true);
  extern int inet6_rth_reverse(const void *__in, void *__out) noexcept(true);
  extern int inet6_rth_segments(const void *__bp) noexcept(true);
  extern struct in6_addr *
  inet6_rth_getaddr(const void *__bp, int __index) noexcept(true);

  extern int getipv4sourcefilter(
    int __s, struct in_addr __interface_addr, struct in_addr __group,
    uint32_t *__fmode, uint32_t *__numsrc, struct in_addr *__slist
  ) noexcept(true);

  extern int setipv4sourcefilter(
    int __s, struct in_addr __interface_addr, struct in_addr __group,
    uint32_t __fmode, uint32_t __numsrc, const struct in_addr *__slist
  ) noexcept(true);

  extern int getsourcefilter(
    int __s, uint32_t __interface_addr, const struct sockaddr *__group,
    socklen_t __grouplen, uint32_t *__fmode, uint32_t *__numsrc,
    struct sockaddr_storage *__slist
  ) noexcept(true);

  extern int setsourcefilter(
    int __s, uint32_t __interface_addr, const struct sockaddr *__group,
    socklen_t __grouplen, uint32_t __fmode, uint32_t __numsrc,
    const struct sockaddr_storage *__slist
  ) noexcept(true);
}

extern "C" {

  struct rpcent {
    char *r_name;
    char **r_aliases;
    int r_number;
  };

  extern void setrpcent(int __stayopen) noexcept(true);
  extern void endrpcent(void) noexcept(true);
  extern struct rpcent *getrpcbyname(const char *__name) noexcept(true);
  extern struct rpcent *getrpcbynumber(int __number) noexcept(true);
  extern struct rpcent *getrpcent(void) noexcept(true);

  extern int getrpcbyname_r(
    const char *__name, struct rpcent *__result_buf, char *__buffer,
    size_t __buflen, struct rpcent **__result
  ) noexcept(true);

  extern int getrpcbynumber_r(
    int __number, struct rpcent *__result_buf, char *__buffer, size_t __buflen,
    struct rpcent **__result
  ) noexcept(true);

  extern int getrpcent_r(
    struct rpcent *__result_buf, char *__buffer, size_t __buflen,
    struct rpcent **__result
  ) noexcept(true);
}

struct netent {
  char *n_name;
  char **n_aliases;
  int n_addrtype;
  uint32_t n_net;
};

extern "C" {

  extern int *__h_errno_location(void) noexcept(true)
    __attribute__((__const__));

  extern void herror(const char *__str) noexcept(true);

  extern const char *hstrerror(int __err_num) noexcept(true);

  struct hostent {
    char *h_name;
    char **h_aliases;
    int h_addrtype;
    int h_length;
    char **h_addr_list;
  };

  extern void sethostent(int __stay_open);

  extern void endhostent(void);

  extern struct hostent *gethostent(void);

  extern struct hostent *
  gethostbyaddr(const void *__addr, __socklen_t __len, int __type);

  extern struct hostent *gethostbyname(const char *__name);

  extern struct hostent *gethostbyname2(const char *__name, int __af);

  extern int gethostent_r(
    struct hostent *__restrict __result_buf, char *__restrict __buf,
    size_t __buflen, struct hostent **__restrict __result,
    int *__restrict __h_errnop
  );

  extern int gethostbyaddr_r(
    const void *__restrict __addr, __socklen_t __len, int __type,
    struct hostent *__restrict __result_buf, char *__restrict __buf,
    size_t __buflen, struct hostent **__restrict __result,
    int *__restrict __h_errnop
  );

  extern int gethostbyname_r(
    const char *__restrict __name, struct hostent *__restrict __result_buf,
    char *__restrict __buf, size_t __buflen,
    struct hostent **__restrict __result, int *__restrict __h_errnop
  );

  extern int gethostbyname2_r(
    const char *__restrict __name, int __af,
    struct hostent *__restrict __result_buf, char *__restrict __buf,
    size_t __buflen, struct hostent **__restrict __result,
    int *__restrict __h_errnop
  );

  extern void setnetent(int __stay_open);

  extern void endnetent(void);

  extern struct netent *getnetent(void);

  extern struct netent *getnetbyaddr(uint32_t __net, int __type);

  extern struct netent *getnetbyname(const char *__name);

  extern int getnetent_r(
    struct netent *__restrict __result_buf, char *__restrict __buf,
    size_t __buflen, struct netent **__restrict __result,
    int *__restrict __h_errnop
  );

  extern int getnetbyaddr_r(
    uint32_t __net, int __type, struct netent *__restrict __result_buf,
    char *__restrict __buf, size_t __buflen,
    struct netent **__restrict __result, int *__restrict __h_errnop
  );

  extern int getnetbyname_r(
    const char *__restrict __name, struct netent *__restrict __result_buf,
    char *__restrict __buf, size_t __buflen,
    struct netent **__restrict __result, int *__restrict __h_errnop
  );

  struct servent {
    char *s_name;
    char **s_aliases;
    int s_port;
    char *s_proto;
  };

  extern void setservent(int __stay_open);

  extern void endservent(void);

  extern struct servent *getservent(void);

  extern struct servent *getservbyname(const char *__name, const char *__proto);

  extern struct servent *getservbyport(int __port, const char *__proto);

  extern int getservent_r(
    struct servent *__restrict __result_buf, char *__restrict __buf,
    size_t __buflen, struct servent **__restrict __result
  );

  extern int getservbyname_r(
    const char *__restrict __name, const char *__restrict __proto,
    struct servent *__restrict __result_buf, char *__restrict __buf,
    size_t __buflen, struct servent **__restrict __result
  );

  extern int getservbyport_r(
    int __port, const char *__restrict __proto,
    struct servent *__restrict __result_buf, char *__restrict __buf,
    size_t __buflen, struct servent **__restrict __result
  );

  struct protoent {
    char *p_name;
    char **p_aliases;
    int p_proto;
  };

  extern void setprotoent(int __stay_open);

  extern void endprotoent(void);

  extern struct protoent *getprotoent(void);

  extern struct protoent *getprotobyname(const char *__name);

  extern struct protoent *getprotobynumber(int __proto);

  extern int getprotoent_r(
    struct protoent *__restrict __result_buf, char *__restrict __buf,
    size_t __buflen, struct protoent **__restrict __result
  );

  extern int getprotobyname_r(
    const char *__restrict __name, struct protoent *__restrict __result_buf,
    char *__restrict __buf, size_t __buflen,
    struct protoent **__restrict __result
  );

  extern int getprotobynumber_r(
    int __proto, struct protoent *__restrict __result_buf,
    char *__restrict __buf, size_t __buflen,
    struct protoent **__restrict __result
  );

  extern int setnetgrent(const char *__netgroup);

  extern void endnetgrent(void);

  extern int getnetgrent(
    char **__restrict __hostp, char **__restrict __userp,
    char **__restrict __domainp
  );

  extern int innetgr(
    const char *__netgroup, const char *__host, const char *__user,
    const char *__domain
  );

  extern int getnetgrent_r(
    char **__restrict __hostp, char **__restrict __userp,
    char **__restrict __domainp, char *__restrict __buffer, size_t __buflen
  );

  extern int rcmd(
    char **__restrict __ahost, unsigned short int __rport,
    const char *__restrict __locuser, const char *__restrict __remuser,
    const char *__restrict __cmd, int *__restrict __fd2p
  );

  extern int rcmd_af(
    char **__restrict __ahost, unsigned short int __rport,
    const char *__restrict __locuser, const char *__restrict __remuser,
    const char *__restrict __cmd, int *__restrict __fd2p, sa_family_t __af
  );

  extern int rexec(
    char **__restrict __ahost, int __rport, const char *__restrict __name,
    const char *__restrict __pass, const char *__restrict __cmd,
    int *__restrict __fd2p
  );

  extern int rexec_af(
    char **__restrict __ahost, int __rport, const char *__restrict __name,
    const char *__restrict __pass, const char *__restrict __cmd,
    int *__restrict __fd2p, sa_family_t __af
  );

  extern int ruserok(
    const char *__rhost, int __suser, const char *__remuser,
    const char *__locuser
  );

  extern int ruserok_af(
    const char *__rhost, int __suser, const char *__remuser,
    const char *__locuser, sa_family_t __af
  );

  extern int iruserok(
    uint32_t __raddr, int __suser, const char *__remuser, const char *__locuser
  );

  extern int iruserok_af(
    const void *__raddr, int __suser, const char *__remuser,
    const char *__locuser, sa_family_t __af
  );

  extern int rresvport(int *__alport);

  extern int rresvport_af(int *__alport, sa_family_t __af);

  struct addrinfo {
    int ai_flags;
    int ai_family;
    int ai_socktype;
    int ai_protocol;
    socklen_t ai_addrlen;
    struct sockaddr *ai_addr;
    char *ai_canonname;
    struct addrinfo *ai_next;
  };

  struct gaicb {
    const char *ar_name;
    const char *ar_service;
    const struct addrinfo *ar_request;
    struct addrinfo *ar_result;

    int __return;
    int __glibc_reserved[5];
  };

  extern int getaddrinfo(
    const char *__restrict __name, const char *__restrict __service,
    const struct addrinfo *__restrict __req, struct addrinfo **__restrict __pai
  );

  extern void freeaddrinfo(struct addrinfo *__ai) noexcept(true);

  extern const char *gai_strerror(int __ecode) noexcept(true);

  extern int getnameinfo(
    const struct sockaddr *__restrict __sa, socklen_t __salen,
    char *__restrict __host, socklen_t __hostlen, char *__restrict __serv,
    socklen_t __servlen, int __flags
  );

  extern int getaddrinfo_a(
    int __mode, struct gaicb *__list[], int __ent,
    struct sigevent *__restrict __sig
  );

  extern int gai_suspend(
    const struct gaicb *const __list[], int __ent,
    const struct timespec *__timeout
  );

  extern int gai_error(struct gaicb *__req) noexcept(true);

  extern int gai_cancel(struct gaicb *__gaicbp) noexcept(true);
}

extern "C" {

  extern void closelog(void);

  extern void openlog(const char *__ident, int __option, int __facility);

  extern int setlogmask(int __mask) noexcept(true);

  extern void syslog(int __pri, const char *__fmt, ...)
    __attribute__((__format__(__printf__, 2, 3)));

  extern void vsyslog(int __pri, const char *__fmt, __gnuc_va_list __ap)
    __attribute__((__format__(__printf__, 2, 0)));
}

namespace Ze {
using T = int8_t;
enum { Invalid = -1, Debug, Info, Warning, Error, Fatal, N };
static_assert((N <= 1024), "N <= 1024");
enum {
  Bits = N <= 2 ? 1 :
    N <= 4      ? 2 :
    N <= 8      ? 3 :
    N <= 16     ? 4 :
    N <= 32     ? 5 :
    N <= 64     ? 6 :
    N <= 128    ? 7 :
    N <= 256    ? 8 :
    N <= 512    ? 9 :
		  10
};
template <typename Impl> struct Map_ : public ZuObject {
private:
  using V2S = ZmLHashKV<T, ZuCSpan, ZmLHashStatic<Bits, ZmLHashLocal<>>>;
  using S2V = ZmLHashKV<ZuCSpan, T, ZmLHashStatic<Bits, ZmLHashLocal<>>>;

protected:
  void init(const char *s, int v, ...) {
    if (__builtin_expect(!!(!s), 0)) return;
    add(s, v);
    va_list args;

    __builtin_va_start(

      args

      ,

      v

    );
    while (s =

	     __builtin_va_arg(

	       args

	       ,

	       const char *

	     )

    )
      add(
	s,
	v =

	  __builtin_va_arg(

	    args

	    ,

	    int

	  )

      );

    __builtin_va_end(

      args

    );
  }
  void add(ZuCSpan s, T v) {
    m_s2v.add(s, v);
    m_v2s.add(v, s);
  }
  static Impl *instance() { return ZmSingleton<Impl>::instance(); }

private:
  T s2v_(ZuCSpan s) const { return m_s2v.findVal(s); }
  ZuCSpan v2s_(T v) const { return m_v2s.findVal(v); }
  template <typename L> void all_(L l) const {
    auto i = m_s2v.readIterator();
    while (auto kv = i.iterate()) {
      l(kv->template p<0>(), kv->template p<1>());
    }
  }

public:
  Map_() = default;
  static T s2v(ZuCSpan s) { return instance()->s2v_(s); }
  static ZuCSpan v2s(T v) { return instance()->v2s_(v); }
  template <typename L> static void all(L l) { instance()->all_(ZuMv(l)); }

private:
  S2V m_s2v;
  V2S m_v2s;
};
inline ZuTuple<const char *const *const, unsigned> names() {
  static const char *names[] = {"Debug", "Info", "Warning", "Error", "Fatal"};
  return ZuTuple<const char *const *const, unsigned>{
    names, static_cast<unsigned>(sizeof(names) / sizeof(names[0]))
  };
}
inline const char *name(int i) {
  ZuTuple<const char *const *const, unsigned> names_ = names();
  if (i >= (int)names_.p<1>()) return "Unknown";
  if (i < 0) return "";
  return names_.p<0>()[i];
}
struct Map : public Map_<Map> {
  static constexpr const char *id() { return "Ze"; }
  Map() {
    for (unsigned i = 0; i < N; i++) this->add(name(i), i);
  }
};
template <typename S> inline T lookup(const S &s) { return Map::s2v(s); };
} // namespace Ze

namespace Ze {

using ErrNo = int;
inline constexpr ErrNo OK() { return 0; }

inline ErrNo errNo() {
  return

    (*__errno_location());
}
inline ErrNo sockErrNo() {
  return

    (*__errno_location());
}
inline const char *strerror(ErrNo e) {
  return e >= 0 ? ::strerror(e) : gai_strerror(e);
}

} // namespace Ze

class ZeError {
public:
  using ErrNo = Ze::ErrNo;

  ZeError() : m_errNo(Ze::OK()) { }

  ZeError(const ZeError &) = default;
  ZeError &operator=(const ZeError &) = default;
  ZeError(ZeError &&) = default;
  ZeError &operator=(ZeError &&) = default;

  ZeError(ErrNo e) : m_errNo(e) { }
  ZeError &operator=(ErrNo e) {
    m_errNo = e;
    return *this;
  }

  ErrNo errNo() const { return m_errNo; }
  const char *message() const { return Ze::strerror(m_errNo); }

  bool operator!() const { return m_errNo == Ze::OK(); }
  operator const void *() const {
    return !*this ? reinterpret_cast<const void *>(0) :
		    static_cast<const void *>(this);
  }

  template <typename S> void print(S &s) const { s << message(); }
  friend ZuPrintFn ZuPrintType(ZeError *);

  struct Traits : public ZuBaseTraits<ZeError> {
    enum { IsPOD = 1 };
  };
  friend Traits ZuTraitsType(ZeError *);

private:
  ErrNo m_errNo;
};

inline ZeError Ze_OK() { return ZeError{}; }

inline ZeError Ze_LastError() { return ZeError{Ze::errNo()}; }

inline ZeError Ze_LastSockError() { return ZeError{Ze::sockErrNo()}; }

struct ZeEventInfo {
  using ThreadID = Zm::ThreadID;

  ZuTime time;
  ThreadID tid = 0;
  int severity = -1;
  const char *file = nullptr;
  int line = -1;
  const char *function = nullptr;

  ZeEventInfo() = default;

  ZeEventInfo(
    int severity_, const char *file_, int line_, const char *function_
  ) :
    time{Zm::now()}, tid{Zm::getTID()}, severity{severity_}, file{file_},
    line{line_}, function{function_} { }

  ZeEventInfo(const ZeEventInfo &) = default;
  ZeEventInfo &operator=(const ZeEventInfo &) = default;

  ZeEventInfo(ZeEventInfo &&) = default;
  ZeEventInfo &operator=(ZeEventInfo &&) = default;

  ~ZeEventInfo() = default;

  bool operator!() const { return !*time; }
  operator const void *() const {
    return !*this ? reinterpret_cast<const void *>(0) :
		    static_cast<const void *>(this);
  }
};

using ZeLogBuf = ZuCArray<(32 << 10)>;

using ZeMsgFn = ZmFn<void(ZeLogBuf &, const ZeEventInfo &)>;

struct ZeAnyEvent : public ZeEventInfo {
  ZeAnyEvent(
    int severity_, const char *file_, int line_, const char *function_
  ) : ZeEventInfo(severity_, file_, line_, function_) { }

  virtual ZeMsgFn fn() const = 0;

  ZeAnyEvent() = default;

  ZeAnyEvent(const ZeAnyEvent &) = default;
  ZeAnyEvent &operator=(const ZeAnyEvent &) = default;

  ZeAnyEvent(ZeAnyEvent &&) = default;
  ZeAnyEvent &operator=(ZeAnyEvent &&) = default;

protected:
  ~ZeAnyEvent() = default;

public:
  template <typename S> void print(S &s) const {
    auto buf = ZmAlloc_<ZeLogBuf>{static_cast<ZeLogBuf *>(
      !(1) ? nullptr :
	     (((ZmStackAvail() >> 1) < ((1) * sizeof(ZeLogBuf))) ?
		Zm::alignedAlloc<alignof(ZeLogBuf)>((1) * sizeof(ZeLogBuf)) :
		__builtin_alloca_with_align(
		  (1) * sizeof(ZeLogBuf), (alignof(ZeLogBuf)) << 3
		))
    )};
    new (&buf[0]) ZeLogBuf{};
    fn()(buf[0], *this);
    s << buf[0];
  }
  friend ZuPrintFn ZuPrintType(ZeAnyEvent *);
};

template <typename L> struct ZeEvent final : public ZeAnyEvent {
  mutable L l;

  template <typename L_>
  ZeEvent(
    int severity_, const char *file_, int line_, const char *function_, L_ &&l_
  ) : ZeAnyEvent(severity_, file_, line_, function_), l{ZuFwd<L_>(l_)} { }

  template <typename S, typename L_ = L>
  friend decltype(ZuDeclVal<L_ &>()(ZuDeclVal<S &>()), ZuDeclVal<S &>())
  operator<<(S &s, const ZeEvent &e) {
    e.l(s);
    return s;
  }
  template <typename S, typename L_ = L>
  friend decltype(ZuDeclVal<L_ &>()(ZuDeclVal<S &>(), ZuDeclVal<const ZeEventInfo &>()), ZuDeclVal<S &>())
  operator<<(S &s, const ZeEvent &e) {
    e.l(s, e);
    return s;
  }

  template <typename L_ = L>
  decltype(ZuDeclVal<L_ &>()(ZuDeclVal<ZeLogBuf &>()), ZeMsgFn()) fn_() const {
    return {[l_ = ZuMv(l)](auto &s, const auto &) mutable { l_(s); }};
  }
  template <typename L_ = L>
  decltype(ZuDeclVal<L_ &>()(ZuDeclVal<ZeLogBuf &>(), ZuDeclVal<const ZeEventInfo &>()), ZeMsgFn())
  fn_() const {
    return {ZuMv(l)};
  }
  ZeMsgFn fn() const { return fn_(); }

  ZeEvent() = delete;

  ZeEvent(const ZeEvent &) = delete;
  ZeEvent &operator=(const ZeEvent &) = delete;

  ZeEvent(ZeEvent &&) = default;
  ZeEvent &operator=(ZeEvent &&) = default;

  ~ZeEvent() = default;
};

template <> struct ZeEvent<ZeMsgFn> final : public ZeAnyEvent {
  using L = ZeMsgFn;

  mutable L l;

  template <
    typename L_,
    decltype(ZuDeclVal<L_ &>()(ZuDeclVal<ZeLogBuf &>()), int()) = 0>
  ZeEvent(
    int severity_, const char *file_, int line_, const char *function_, L_ l_
  ) :
    ZeAnyEvent(severity_, file_, line_, function_),
    l{[l_ = ZuMv(l_)](auto &s, const auto &) mutable { l_(s); }} { }
  template <
    typename L_,
    decltype(ZuDeclVal<L_ &>()(ZuDeclVal<ZeLogBuf &>(), ZuDeclVal<const ZeEventInfo &>()), int()) =
      0>
  ZeEvent(
    int severity_, const char *file_, int line_, const char *function_, L_ l_
  ) : ZeAnyEvent(severity_, file_, line_, function_), l{ZuMv(l_)} { }

  ZeEvent() = default;

  ZeEvent(const ZeEvent &) = delete;
  ZeEvent &operator=(const ZeEvent &) = delete;

  ZeEvent(ZeEvent &&) = default;
  ZeEvent &operator=(ZeEvent &&) = default;

  ~ZeEvent() = default;

  ZeMsgFn fn() const { return {ZuMv(l)}; }

  ZeEvent(const ZeAnyEvent &e) : ZeAnyEvent{e}, l{e.fn()} {};
  ZeEvent &operator=(const ZeAnyEvent &e) {
    this->~ZeEvent();
    new (this) ZeEvent{e};
    return *this;
  }

  template <
    typename L_,
    decltype(ZuDeclVal<L_ &>()(ZuDeclVal<ZeLogBuf &>()), int()) = 0>
  ZeEvent(ZeEvent<L_> &&e) :
    ZeAnyEvent{static_cast<ZeAnyEvent &&>(e)},
    l{[l_ = ZuMv(e.l)](auto &s, auto) mutable { l_(s); }} { }
  template <
    typename L_,
    decltype(ZuDeclVal<L_ &>()(ZuDeclVal<ZeLogBuf &>(), ZuDeclVal<const ZeEventInfo &>()), int()) =
      0>
  ZeEvent(ZeEvent<L_> &&e) :
    ZeAnyEvent{static_cast<ZeAnyEvent &&>(e)}, l{ZuMv(e.l)} { }

  template <typename L_> ZeEvent &operator=(ZeEvent<L> &&e) {
    this->~ZeEvent();
    new (this) ZeEvent{ZuMv(e)};
    return *this;
  }
};
using ZeVEvent = ZeEvent<ZeMsgFn>;

template <typename L>
ZeEvent(int, const char *, int, const char *, L) -> ZeEvent<ZuDecay<L>>;

namespace ZeMsg_ {
template <typename U>
struct IsLiteral_ :
  public ZuBool<ZuIsExact<U, const char (&)[sizeof(U)]>{}> { };
template <typename U> struct IsLiteral : public IsLiteral_<U> { };
template <typename U, typename R = void>
using MatchLiteral = ZuIfT<IsLiteral<U>{}, R>;

template <typename U>
struct IsPrint_ :
  public ZuBool<!IsLiteral_<U>{} && (ZuTraits<U>::IsString || ZuPrint<U>::OK)> {
};
template <typename U> struct IsPrint : public IsPrint_<U> { };
template <typename U, typename R = void>
using MatchPrint = ZuIfT<IsPrint<U>{}, R>;

template <typename U>
struct IsOther_ : public ZuBool<!IsLiteral_<U>{} && !IsPrint_<U>{}> { };
template <typename U> struct IsOther : public IsOther_<ZuDecay<U>> { };
template <typename U, typename R = void>
using MatchOther = ZuIfT<IsOther<U>{}, R>;

template <typename Msg, decltype(MatchOther<Msg>(), int()) = 0>
inline decltype(auto) fn(Msg &&msg) {
  return ZuFwd<Msg>(msg);
}
template <typename Msg, decltype(MatchLiteral<Msg>(), int()) = 0>
inline auto fn(Msg &&msg) {
  return [msg = static_cast<const char *>(msg)](auto &s) mutable { s << msg; };
}
template <typename Msg, decltype(MatchPrint<Msg>(), int()) = 0>
inline auto fn(Msg &&msg) {
  return [msg = ZuFwd<Msg>(msg)](auto &s) mutable { s << ZuMv(msg); };
}
} // namespace ZeMsg_

template <typename Msg>
auto ZeMkEvent(
  int severity_, const char *file_, int line_, const char *function_, Msg &&msg
) {
  return ZeEvent(
    severity_, file_, line_, function_, ZeMsg_::fn(ZuFwd<Msg>(msg))
  );
}

template <typename Msg>
ZeVEvent ZeMkVEvent(
  int severity_, const char *file_, int line_, const char *function_, Msg &&msg
) {
  return ZeVEvent(
    severity_, file_, line_, function_, ZeMsg_::fn(ZuFwd<Msg>(msg))
  );
}

namespace Ze {

extern ZuCSpan severity(unsigned i);
extern ZuCSpan file(ZuCSpan s);
extern ZuCSpan function(ZuCSpan s);

}

extern "C" {

  int memfd_create(const char *__name, unsigned int __flags) noexcept(true);

  int mlock2(
    const void *__addr, size_t __length, unsigned int __flags
  ) noexcept(true);

  int pkey_alloc(unsigned int __flags, unsigned int __access_rights) noexcept(
    true
  );

  int pkey_set(int __key, unsigned int __access_rights) noexcept(true);

  int pkey_get(int __key) noexcept(true);

  int pkey_free(int __key) noexcept(true);

  int pkey_mprotect(
    void *__addr, size_t __len, int __prot, int __pkey
  ) noexcept(true);
}

extern "C" {

  extern void *mmap(
    void *__addr, size_t __len, int __prot, int __flags, int __fd,
    __off_t __offset
  ) noexcept(true);

  extern void *mmap64(
    void *__addr, size_t __len, int __prot, int __flags, int __fd,
    __off64_t __offset
  ) noexcept(true);

  extern int munmap(void *__addr, size_t __len) noexcept(true);

  extern int mprotect(void *__addr, size_t __len, int __prot) noexcept(true);

  extern int msync(void *__addr, size_t __len, int __flags);

  extern int madvise(void *__addr, size_t __len, int __advice) noexcept(true);

  extern int
  posix_madvise(void *__addr, size_t __len, int __advice) noexcept(true);

  extern int mlock(const void *__addr, size_t __len) noexcept(true);

  extern int munlock(const void *__addr, size_t __len) noexcept(true);

  extern int mlockall(int __flags) noexcept(true);

  extern int munlockall(void) noexcept(true);

  extern int
  mincore(void *__start, size_t __len, unsigned char *__vec) noexcept(true);

  extern void *mremap(
    void *__addr, size_t __old_len, size_t __new_len, int __flags, ...
  ) noexcept(true);

  extern int remap_file_pages(
    void *__start, size_t __size, int __prot, size_t __pgoff, int __flags
  ) noexcept(true);

  extern int shm_open(const char *__name, int __oflag, mode_t __mode);

  extern int shm_unlink(const char *__name);

  struct iovec;
  extern __ssize_t process_madvise(
    int __pid_fd, const struct iovec *__iov, size_t __count, int __advice,
    unsigned __flags
  ) noexcept(true);

  extern int process_mrelease(int pidfd, unsigned int flags) noexcept(true);
}

extern "C" {

  struct stat {
    __dev_t st_dev;

    __ino_t st_ino;

    __nlink_t st_nlink;
    __mode_t st_mode;

    __uid_t st_uid;
    __gid_t st_gid;

    int __pad0;

    __dev_t st_rdev;

    __off_t st_size;

    __blksize_t st_blksize;

    __blkcnt_t st_blocks;

    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;

    __syscall_slong_t __glibc_reserved[3];
  };

  struct stat64 {
    __dev_t st_dev;

    __ino64_t st_ino;
    __nlink_t st_nlink;
    __mode_t st_mode;

    __uid_t st_uid;
    __gid_t st_gid;

    int __pad0;
    __dev_t st_rdev;
    __off_t st_size;

    __blksize_t st_blksize;
    __blkcnt64_t st_blocks;

    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;

    __syscall_slong_t __glibc_reserved[3];
  };

  extern int stat(
    const char *__restrict __file, struct stat *__restrict __buf
  ) noexcept(true) __attribute__((__nonnull__(1, 2)));

  extern int fstat(int __fd, struct stat *__buf) noexcept(true)
    __attribute__((__nonnull__(2)));

  extern int stat64(
    const char *__restrict __file, struct stat64 *__restrict __buf
  ) noexcept(true) __attribute__((__nonnull__(1, 2)));
  extern int fstat64(int __fd, struct stat64 *__buf) noexcept(true)
    __attribute__((__nonnull__(2)));

  extern int fstatat(
    int __fd, const char *__restrict __file, struct stat *__restrict __buf,
    int __flag
  ) noexcept(true) __attribute__((__nonnull__(2, 3)));

  extern int fstatat64(
    int __fd, const char *__restrict __file, struct stat64 *__restrict __buf,
    int __flag
  ) noexcept(true) __attribute__((__nonnull__(2, 3)));

  extern int lstat(
    const char *__restrict __file, struct stat *__restrict __buf
  ) noexcept(true) __attribute__((__nonnull__(1, 2)));

  extern int lstat64(
    const char *__restrict __file, struct stat64 *__restrict __buf
  ) noexcept(true) __attribute__((__nonnull__(1, 2)));

  extern int chmod(const char *__file, __mode_t __mode) noexcept(true)
    __attribute__((__nonnull__(1)));

  extern int lchmod(const char *__file, __mode_t __mode) noexcept(true)
    __attribute__((__nonnull__(1)));

  extern int fchmod(int __fd, __mode_t __mode) noexcept(true);

  extern int fchmodat(
    int __fd, const char *__file, __mode_t __mode, int __flag
  ) noexcept(true) __attribute__((__nonnull__(2)));

  extern __mode_t umask(__mode_t __mask) noexcept(true);

  extern __mode_t getumask(void) noexcept(true);

  extern int mkdir(const char *__path, __mode_t __mode) noexcept(true)
    __attribute__((__nonnull__(1)));

  extern int
  mkdirat(int __fd, const char *__path, __mode_t __mode) noexcept(true)
    __attribute__((__nonnull__(2)));

  extern int
  mknod(const char *__path, __mode_t __mode, __dev_t __dev) noexcept(true)
    __attribute__((__nonnull__(1)));

  extern int mknodat(
    int __fd, const char *__path, __mode_t __mode, __dev_t __dev
  ) noexcept(true) __attribute__((__nonnull__(2)));

  extern int mkfifo(const char *__path, __mode_t __mode) noexcept(true)
    __attribute__((__nonnull__(1)));

  extern int
  mkfifoat(int __fd, const char *__path, __mode_t __mode) noexcept(true)
    __attribute__((__nonnull__(2)));

  extern int utimensat(
    int __fd, const char *__path, const struct timespec __times[2], int __flags
  ) noexcept(true) __attribute__((__nonnull__(2)));

  extern int
  futimens(int __fd, const struct timespec __times[2]) noexcept(true);

  typedef __signed__ char __s8;
  typedef unsigned char __u8;

  typedef __signed__ short __s16;
  typedef unsigned short __u16;

  typedef __signed__ int __s32;
  typedef unsigned int __u32;

  __extension__ typedef __signed__ long long __s64;
  __extension__ typedef unsigned long long __u64;

  typedef __signed__ __int128 __s128 __attribute__((aligned(16)));
  typedef unsigned __int128 __u128 __attribute__((aligned(16)));

  typedef __u16 __le16;
  typedef __u16 __be16;
  typedef __u32 __le32;
  typedef __u32 __be32;
  typedef __u64 __le64;
  typedef __u64 __be64;

  typedef __u16 __sum16;
  typedef __u32 __wsum;

  typedef unsigned __poll_t;

  struct statx_timestamp {
    __s64 tv_sec;
    __u32 tv_nsec;
    __s32 __reserved;
  };

  struct statx {
    __u32 stx_mask;
    __u32 stx_blksize;
    __u64 stx_attributes;

    __u32 stx_nlink;
    __u32 stx_uid;
    __u32 stx_gid;
    __u16 stx_mode;
    __u16 __spare0[1];

    __u64 stx_ino;
    __u64 stx_size;
    __u64 stx_blocks;
    __u64 stx_attributes_mask;

    struct statx_timestamp stx_atime;
    struct statx_timestamp stx_btime;
    struct statx_timestamp stx_ctime;
    struct statx_timestamp stx_mtime;

    __u32 stx_rdev_major;
    __u32 stx_rdev_minor;
    __u32 stx_dev_major;
    __u32 stx_dev_minor;

    __u64 stx_mnt_id;
    __u32 stx_dio_mem_align;
    __u32 stx_dio_offset_align;

    __u64 stx_subvol;
    __u64 __spare3[11];
  };

  extern "C" {

    int statx(
      int __dirfd, const char *__restrict __path, int __flags,
      unsigned int __mask, struct statx *__restrict __buf
    ) noexcept(true) __attribute__((__nonnull__(2, 5)));
  }
}

typedef uint32_t tcp_seq;

struct tcphdr {
  __extension__ union {
    struct {
      uint16_t th_sport;
      uint16_t th_dport;
      tcp_seq th_seq;
      tcp_seq th_ack;

      uint8_t th_x2:4;
      uint8_t th_off:4;

      uint8_t th_flags;

      uint16_t th_win;
      uint16_t th_sum;
      uint16_t th_urp;
    };
    struct {
      uint16_t source;
      uint16_t dest;
      uint32_t seq;
      uint32_t ack_seq;

      uint16_t res1:4;
      uint16_t doff:4;
      uint16_t fin:1;
      uint16_t syn:1;
      uint16_t rst:1;
      uint16_t psh:1;
      uint16_t ack:1;
      uint16_t urg:1;
      uint16_t res2:2;

      uint16_t window;
      uint16_t check;
      uint16_t urg_ptr;
    };
  };
};

enum {
  TCP_ESTABLISHED = 1,
  TCP_SYN_SENT,
  TCP_SYN_RECV,
  TCP_FIN_WAIT1,
  TCP_FIN_WAIT2,
  TCP_TIME_WAIT,
  TCP_CLOSE,
  TCP_CLOSE_WAIT,
  TCP_LAST_ACK,
  TCP_LISTEN,
  TCP_CLOSING
};

enum tcp_ca_state {
  TCP_CA_Open = 0,
  TCP_CA_Disorder = 1,
  TCP_CA_CWR = 2,
  TCP_CA_Recovery = 3,
  TCP_CA_Loss = 4
};

struct tcp_info {
  uint8_t tcpi_state;
  uint8_t tcpi_ca_state;
  uint8_t tcpi_retransmits;
  uint8_t tcpi_probes;
  uint8_t tcpi_backoff;
  uint8_t tcpi_options;
  uint8_t tcpi_snd_wscale:4, tcpi_rcv_wscale:4;

  uint32_t tcpi_rto;
  uint32_t tcpi_ato;
  uint32_t tcpi_snd_mss;
  uint32_t tcpi_rcv_mss;

  uint32_t tcpi_unacked;
  uint32_t tcpi_sacked;
  uint32_t tcpi_lost;
  uint32_t tcpi_retrans;
  uint32_t tcpi_fackets;

  uint32_t tcpi_last_data_sent;
  uint32_t tcpi_last_ack_sent;
  uint32_t tcpi_last_data_recv;
  uint32_t tcpi_last_ack_recv;

  uint32_t tcpi_pmtu;
  uint32_t tcpi_rcv_ssthresh;
  uint32_t tcpi_rtt;
  uint32_t tcpi_rttvar;
  uint32_t tcpi_snd_ssthresh;
  uint32_t tcpi_snd_cwnd;
  uint32_t tcpi_advmss;
  uint32_t tcpi_reordering;

  uint32_t tcpi_rcv_rtt;
  uint32_t tcpi_rcv_space;

  uint32_t tcpi_total_retrans;
};

struct tcp_md5sig {
  struct sockaddr_storage tcpm_addr;
  uint8_t tcpm_flags;
  uint8_t tcpm_prefixlen;
  uint16_t tcpm_keylen;
  int tcpm_ifindex;
  uint8_t tcpm_key[80];
};

struct tcp_repair_opt {
  uint32_t opt_code;
  uint32_t opt_val;
};

enum {
  TCP_NO_QUEUE,
  TCP_RECV_QUEUE,
  TCP_SEND_QUEUE,
  TCP_QUEUES_NR,
};

struct tcp_cookie_transactions {
  uint16_t tcpct_flags;
  uint8_t __tcpct_pad1;
  uint8_t tcpct_cookie_desired;
  uint16_t tcpct_s_data_desired;
  uint16_t tcpct_used;
  uint8_t tcpct_value[536U];
};

struct tcp_repair_window {
  uint32_t snd_wl1;
  uint32_t snd_wnd;
  uint32_t max_window;
  uint32_t rcv_wnd;
  uint32_t rcv_wup;
};

struct tcp_zerocopy_receive {
  uint64_t address;
  uint32_t length;
  uint32_t recv_skip_hint;
};

extern "C" {

  extern in_addr_t inet_addr(const char *__cp) noexcept(true);

  extern in_addr_t inet_lnaof(struct in_addr __in) noexcept(true);

  extern struct in_addr
  inet_makeaddr(in_addr_t __net, in_addr_t __host) noexcept(true);

  extern in_addr_t inet_netof(struct in_addr __in) noexcept(true);

  extern in_addr_t inet_network(const char *__cp) noexcept(true);

  extern char *inet_ntoa(struct in_addr __in) noexcept(true);

  extern int inet_pton(
    int __af, const char *__restrict __cp, void *__restrict __buf
  ) noexcept(true);

  extern const char *inet_ntop(
    int __af, const void *__restrict __cp, char *__restrict __buf,
    socklen_t __len
  ) noexcept(true);

  extern int inet_aton(const char *__cp, struct in_addr *__inp) noexcept(true);

  extern char *
  inet_neta(in_addr_t __net, char *__buf, size_t __len) noexcept(true)
    __attribute__((__deprecated__("Use inet_ntop instead")));

  extern char *inet_net_ntop(
    int __af, const void *__cp, int __bits, char *__buf, size_t __len
  ) noexcept(true);

  extern int inet_net_pton(
    int __af, const char *__cp, void *__buf, size_t __len
  ) noexcept(true);

  extern unsigned int inet_nsap_addr(
    const char *__cp, unsigned char *__buf, int __len
  ) noexcept(true);

  extern char *inet_nsap_ntoa(
    int __len, const unsigned char *__cp, char *__buf
  ) noexcept(true);
}

extern "C" {

  struct flock {
    short int l_type;
    short int l_whence;

    __off_t l_start;
    __off_t l_len;

    __pid_t l_pid;
  };

  struct flock64 {
    short int l_type;
    short int l_whence;
    __off64_t l_start;
    __off64_t l_len;
    __pid_t l_pid;
  };

  enum __pid_type {
    F_OWNER_TID = 0,
    F_OWNER_PID,
    F_OWNER_PGRP,
    F_OWNER_GID = F_OWNER_PGRP
  };

  struct f_owner_ex {
    enum __pid_type type;
    __pid_t pid;
  };

  struct file_handle {
    unsigned int handle_bytes;
    int handle_type;

    unsigned char f_handle[0];
  };

  extern "C" {

    extern __ssize_t
    readahead(int __fd, __off64_t __offset, size_t __count) noexcept(true);

    extern int sync_file_range(
      int __fd, __off64_t __offset, __off64_t __count, unsigned int __flags
    );

    extern __ssize_t vmsplice(
      int __fdout, const struct iovec *__iov, size_t __count,
      unsigned int __flags
    );

    extern __ssize_t splice(
      int __fdin, __off64_t *__offin, int __fdout, __off64_t *__offout,
      size_t __len, unsigned int __flags
    );

    extern __ssize_t
    tee(int __fdin, int __fdout, size_t __len, unsigned int __flags);

    extern int fallocate(int __fd, int __mode, __off_t __offset, __off_t __len);

    extern int
    fallocate64(int __fd, int __mode, __off64_t __offset, __off64_t __len);

    extern int name_to_handle_at(
      int __dfd, const char *__name, struct file_handle *__handle,
      int *__mnt_id, int __flags
    ) noexcept(true);

    extern int open_by_handle_at(
      int __mountdirfd, struct file_handle *__handle, int __flags
    );
  }

  extern int fcntl(int __fd, int __cmd, ...);

  extern int fcntl64(int __fd, int __cmd, ...);

  extern int open(const char *__file, int __oflag, ...)
    __attribute__((__nonnull__(1)));

  extern int open64(const char *__file, int __oflag, ...)
    __attribute__((__nonnull__(1)));

  extern int openat(int __fd, const char *__file, int __oflag, ...)
    __attribute__((__nonnull__(2)));

  extern int openat64(int __fd, const char *__file, int __oflag, ...)
    __attribute__((__nonnull__(2)));

  extern int creat(const char *__file, mode_t __mode)
    __attribute__((__nonnull__(1)));

  extern int creat64(const char *__file, mode_t __mode)
    __attribute__((__nonnull__(1)));

  extern int posix_fadvise(
    int __fd, off_t __offset, off_t __len, int __advise
  ) noexcept(true);

  extern int posix_fadvise64(
    int __fd, off64_t __offset, off64_t __len, int __advise
  ) noexcept(true);

  extern int posix_fallocate(int __fd, off_t __offset, off_t __len);

  extern int posix_fallocate64(int __fd, off64_t __offset, off64_t __len);
}

namespace Zi {

using Handle = int;
inline constexpr const Handle nullHandle() { return -1; }
inline constexpr bool nullHandle(Handle i) { return i < 0; }
using Socket = int;
inline constexpr const Socket nullSocket() { return -1; }
inline constexpr bool nullSocket(Socket i) { return i < 0; }
inline void closeSocket(Socket s) { ::close(s); }
using MMapPtr = void *;
using Path = ZtString;
using Offset = off_t;
using Hostname = ZtString;
using Username = ZtString;
enum {
  PathMax =

    4096

  ,
  NameMax =

    255

  ,
  NVecMax =

    1024

};

enum {
  HostnameMax =

    1025

  ,
  ServicenameMax =

    32

};

extern Username username(ZeError *e = 0);
extern Hostname hostname(ZeError *e = 0);

} // namespace Zi

using ZiVec = struct iovec;
using ZiVecPtr = void *;
using ZiVecLen = size_t;

inline void ZiVec_init(ZiVec &vec, void *ptr, size_t len) {
  (vec).iov_base = static_cast<ZiVecPtr>(ptr);
  (vec).iov_len = len;
}

extern "C" {

  extern void _dl_mcount_wrapper_check(void *__selfpc) noexcept(true);
}

typedef long int Lmid_t;

extern "C" {

  extern void *dlopen(const char *__file, int __mode) noexcept(true);

  extern int dlclose(void *__handle) noexcept(true)
    __attribute__((__nonnull__(1)));

  extern void *
  dlsym(void *__restrict __handle, const char *__restrict __name) noexcept(true)
    __attribute__((__nonnull__(2)));

  extern void *
  dlmopen(Lmid_t __nsid, const char *__file, int __mode) noexcept(true);

  extern void *dlvsym(
    void *__restrict __handle, const char *__restrict __name,
    const char *__restrict __version
  ) noexcept(true) __attribute__((__nonnull__(2, 3)));

  extern char *dlerror(void) noexcept(true);

  typedef struct {
    const char *dli_fname;
    void *dli_fbase;
    const char *dli_sname;
    void *dli_saddr;
  } Dl_info;

  extern int dladdr(const void *__address, Dl_info *__info) noexcept(true)
    __attribute__((__nonnull__(2)));

  extern int dladdr1(
    const void *__address, Dl_info *__info, void **__extra_info, int __flags
  ) noexcept(true) __attribute__((__nonnull__(2)));

  enum {

    RTLD_DL_SYMENT = 1,

    RTLD_DL_LINKMAP = 2
  };

  extern int dlinfo(
    void *__restrict __handle, int __request, void *__restrict __arg
  ) noexcept(true) __attribute__((__nonnull__(1, 3)));

  enum {

    RTLD_DI_LMID = 1,

    RTLD_DI_LINKMAP = 2,

    RTLD_DI_CONFIGADDR = 3,

    RTLD_DI_SERINFO = 4,
    RTLD_DI_SERINFOSIZE = 5,

    RTLD_DI_ORIGIN = 6,

    RTLD_DI_PROFILENAME = 7,
    RTLD_DI_PROFILEOUT = 8,

    RTLD_DI_TLS_MODID = 9,

    RTLD_DI_TLS_DATA = 10,

    RTLD_DI_PHDR = 11,

    RTLD_DI_MAX = 11
  };

  typedef struct {
    char *dls_name;
    unsigned int dls_flags;
  } Dl_serpath;

  typedef struct {
    size_t dls_size;
    unsigned int dls_cnt;

    __extension__ union {
      Dl_serpath dls_serpath[0];
      Dl_serpath __dls_serpath_pad[1];
    };

  } Dl_serinfo;

  struct dl_find_object {
    __extension__ unsigned long long int dlfo_flags;
    void *dlfo_map_start;
    void *dlfo_map_end;
    struct link_map *dlfo_link_map;
    void *dlfo_eh_frame;

    __extension__ unsigned long long int __dflo_reserved[7];
  };

  int _dl_find_object(
    void *__address, struct dl_find_object *__result
  ) noexcept(true);
}

class ZiFile {
public:
  using Handle = Zi::Handle;
  using Path = Zi::Path;
  using Offset = Zi::Offset;
  using MMapPtr = Zi::MMapPtr;

  using Lock = ZmLock;
  using Guard = ZmGuard<Lock>;
  using ReadGuard = ZmReadGuard<Lock>;

  enum Flags {
    ReadOnly = 0x0001,
    WriteOnly = 0x0002,
    Create = 0x0004,
    Exclusive = 0x0008,
    Truncate = 0x0010,
    Append = 0x0020,
    Direct = 0x0040,
    Sync = 0x0080,
    GC = 0x0100,
    MMap = 0x0200,
    Shm = 0x0400,
    ShmGC = 0x0800,
    ShmMirror = 0x1000,
    MMPopulate = 0x2000,
    Shadow = 0x4000
  };

  ZiFile() { }

  ZiFile(const ZiFile &file) :
    m_handle{file.m_handle}, m_flags{file.m_flags | Shadow},
    m_offset{file.m_offset}, m_blkSize{file.m_blkSize}, m_addr{file.m_addr},
    m_mmapLength{file.m_mmapLength},

    m_shmName{file.m_shmName}

  { }
  ZiFile &operator=(const ZiFile &file) {
    if (this != &file) {
      this->~ZiFile();
      new (this) ZiFile{file};
    }
    return *this;
  }

  ~ZiFile() { final(); }

  inline Handle handle() const { return m_handle; }
  inline void *addr() const { return m_addr; }
  inline Offset mmapLength() const { return m_mmapLength; }

  inline unsigned flags() { return m_flags; }
  void setFlags(int f) {
    Guard guard(m_lock);
    m_flags |= f;
  }
  void clrFlags(int f) {
    Guard guard(m_lock);
    m_flags &= ~f;
  }

  int init(Handle handle, unsigned flags, ZeError *e = nullptr);
  void final() {
    Guard guard(m_lock);

    if (m_flags & GC) {
      close();
    } else {
      m_handle = Zi::nullHandle();
    }
  }

  bool operator!() const {
    ReadGuard guard(m_lock);
    return Zi::nullHandle(m_handle);
  }
  operator const void *() const {
    return !*this ? reinterpret_cast<const void *>(0) :
		    static_cast<const void *>(this);
  }

  int open(
    const Path &name, unsigned flags, unsigned mode = 0666, ZeError *e = nullptr
  );
  int open(
    const Path &name, unsigned flags, unsigned mode, Offset length,
    ZeError *e = nullptr
  );
  int mmap(
    const Path &name, unsigned flags, Offset length, bool shared = true,
    int mmapFlags = 0, unsigned mode = 0666, ZeError *e = nullptr
  );
  void close();

  Offset size();
  int blkSize() { return m_blkSize; }

  Offset offset() {
    ReadGuard guard(m_lock);
    return m_offset;
  }
  void seek(Offset offset) {
    Guard guard(m_lock);
    m_offset = offset;
  }

  int sync(ZeError *e = nullptr);
  int msync(void *addr = 0, Offset length = 0, ZeError *e = nullptr);

  int read(void *ptr, unsigned len, ZeError *e = nullptr);
  int readv(const ZiVec *vecs, unsigned nVecs, ZeError *e = nullptr);

  int write(const void *ptr, unsigned len, ZeError *e = nullptr);
  int writev(const ZiVec *vecs, unsigned nVecs, ZeError *e = nullptr);

  int pread(Offset offset, void *ptr, unsigned len, ZeError *e = nullptr);
  int preadv(
    Offset offset, const ZiVec *vecs, unsigned nVecs, ZeError *e = nullptr
  );

  int pwrite(
    Offset offset, const void *ptr, unsigned len, ZeError *e = nullptr
  );
  int pwritev(
    Offset offset, const ZiVec *vecs, unsigned nVecs, ZeError *e = nullptr
  );

  int truncate(Offset offset, ZeError *e = nullptr);

  template <typename V> ZiFile &operator<<(V &&v) {
    append_(ZuFwd<V>(v));
    return *this;
  }

  static ZuTime mtime(const Path &name, ZeError *e = nullptr);
  static bool isdir(const Path &name, ZeError *e = nullptr);

  static int remove(const Path &name, ZeError *e = nullptr);
  static int
  rename(const Path &oldName, const Path &newName, ZeError *e = nullptr);
  static int
  copy(const Path &oldName, const Path &newName, ZeError *e = nullptr);
  static int mkdir(const Path &name, ZeError *e = nullptr);
  static int rmdir(const Path &name, ZeError *e = nullptr);

  static Path cwd();

  static bool absolute(const Path &name);

  static Path leafname(const Path &name);
  static Path dirname(const Path &name);
  static Path append(const Path &dir, const Path &name);

  static void age(const Path &name, unsigned max);

private:
  int open_(
    const Path &name, unsigned flags, unsigned mode, Offset length, ZeError *e
  );

  void init_(Handle handle, unsigned flags, int blkSize, Offset mmapLength = 0);

  template <typename U, typename R = void>
  using MatchPDelegate =
    ZuIfT<ZuPrint<U>::Delegate && !ZuTraits<U>::IsString, R>;
  template <typename U, typename R = void>
  using MatchPBuffer = ZuIfT<ZuPrint<U>::Buffer && !ZuTraits<U>::IsString, R>;

  template <typename S> ZuMatchString<S> append_(S &&s_) {
    ZuCSpan s(ZuFwd<S>(s_));
    if (__builtin_expect(!!(!s), 0)) return;
    ZeError e;
    if (__builtin_expect(!!(write(s.data(), s.length(), &e) != Zi::OK), 0))
      throw e;
  }
  template <typename P> MatchPDelegate<P> append_(P &&p) {
    ZuPrint<P>::print(*this, ZuFwd<P>(p));
  }
  template <typename P> MatchPBuffer<P> append_(const P &p) {
    unsigned len = ZuPrint<P>::length(p);
    auto buf = ZmAlloc_<char>{static_cast<char *>(
      !(len) ? nullptr :
	       (((ZmStackAvail() >> 1) < ((len) * sizeof(char))) ?
		  Zm::alignedAlloc<alignof(char)>((len) * sizeof(char)) :
		  __builtin_alloca_with_align(
		    (len) * sizeof(char), (alignof(char)) << 3
		  ))
    )};
    if (!buf)
      throw ZeError{

	12

      };
    ZeError e;
    if (__builtin_expect(
	  !!(write(buf, ZuPrint<P>::print(buf, len, p), e) != Zi::OK), 0
	))
      throw e;
  }

  Lock m_lock;
  Handle m_handle = Zi::nullHandle();
  unsigned m_flags = 0;
  Offset m_offset = 0;
  int m_blkSize = 0;
  void *m_addr = nullptr;
  Offset m_mmapLength = 0;

  ZtString m_shmName;
};

class ZvError {
public:
  virtual ~ZvError() { }
  virtual void print_(ZuVStream &) const = 0;
  template <typename S> void print(S &s_) const {
    ZuVStream s{s_};
    print_(s);
  }
  void print(ZuVStream &s) const { print_(s); }
  friend ZuPrintFn ZuPrintType(ZvError *);
};

namespace ZvEnum {

class Invalid : public ZvError {
public:
  template <typename Key, typename Value>
  Invalid(Key &&key, Value &&value) :
    m_key(ZuFwd<Key>(key)), m_value(ZuFwd<Value>(value)) { }

  const ZtString &key() const { return m_key; }
  const ZtString &value() const { return m_value; }

private:
  ZtString m_key;
  ZtString m_value;
};
template <typename Map> class InvalidT : public Invalid {
public:
  template <typename Key, typename Value>
  InvalidT(Key &&key, Value &&value) :
    Invalid{ZuFwd<Key>(key), ZuFwd<Value>(value)} { }

  void print_(ZuVStream &s) const;
};

template <typename Map, bool Throw = true, decltype(ZuIfT<Throw>(), int()) = 0>
inline auto s2v(ZuCSpan key, ZuCSpan s) {
  auto v = Map::s2v(s);
  if (!ZuCmp<decltype(v)>::null(v)) return v;
  throw InvalidT<Map>{key, s};
}
template <typename Map, bool Throw = true, decltype(ZuIfT<!Throw>(), int()) = 0>
inline auto s2v(ZuCSpan key, ZuCSpan s, int deflt = -1) {
  auto v = Map::s2v(s);
  if (!ZuCmp<decltype(v)>::null(v)) return v;
  return decltype(v)(deflt);
}

template <typename Map, typename V> inline const char *v2s(ZuCSpan key, V v) {
  const char *s = Map::v2s(v);
  if (__builtin_expect(!!(s), 1)) return s;
  throw InvalidT<Map>{key, v};
}

template <typename Map, typename Key, typename Value>
inline void errorMessage(ZuVStream &s, Key &&key, Value &&value) {
  s << ZuFwd<Key>(key) << ": \"" << ZuFwd<Value>(value)
    << "\" did not match { ";
  bool first = true;
  Map::all([&s, &first](ZuCSpan s_, auto v) {
    if (__builtin_expect(!!(!first), 1)) s << ", ";
    first = false;
    s << s_ << "=" << v;
  });
  s << " }";
}

template <typename Map> inline void InvalidT<Map>::print_(ZuVStream &s) const {
  errorMessage<Map>(s, this->key(), this->value());
}

template <typename Map, typename S, typename Flags>
inline unsigned
print(ZuCSpan key, S &s, const Flags &v, const char *delim = "|") {
  if (!v) return 0;
  return Map::print(s, v, delim);
}

template <typename Map, typename Flags>
inline Flags scan(ZuCSpan key, ZuCSpan s, const char *delim = "|") {
  if (!s) return 0;
  if (Flags v = Map::template scan<Flags>(s, delim)) return v;
  throw InvalidT<Map>{key, s};
}

} // namespace ZvEnum

using ZvInvalidEnum = ZvEnum::Invalid;

namespace ZvOptType {
using T = int8_t;
enum { Invalid = -1, Flag, Param, Array, N };
static_assert((N <= 1024), "N <= 1024");
enum {
  Bits = N <= 2 ? 1 :
    N <= 4      ? 2 :
    N <= 8      ? 3 :
    N <= 16     ? 4 :
    N <= 32     ? 5 :
    N <= 64     ? 6 :
    N <= 128    ? 7 :
    N <= 256    ? 8 :
    N <= 512    ? 9 :
		  10
};
template <typename Impl> struct Map_ : public ZuObject {
private:
  using V2S = ZmLHashKV<T, ZuCSpan, ZmLHashStatic<Bits, ZmLHashLocal<>>>;
  using S2V = ZmLHashKV<ZuCSpan, T, ZmLHashStatic<Bits, ZmLHashLocal<>>>;

protected:
  void init(const char *s, int v, ...) {
    if (__builtin_expect(!!(!s), 0)) return;
    add(s, v);
    va_list args;

    __builtin_va_start(

      args

      ,

      v

    );
    while (s =

	     __builtin_va_arg(

	       args

	       ,

	       const char *

	     )

    )
      add(
	s,
	v =

	  __builtin_va_arg(

	    args

	    ,

	    int

	  )

      );

    __builtin_va_end(

      args

    );
  }
  void add(ZuCSpan s, T v) {
    m_s2v.add(s, v);
    m_v2s.add(v, s);
  }
  static Impl *instance() { return ZmSingleton<Impl>::instance(); }

private:
  T s2v_(ZuCSpan s) const { return m_s2v.findVal(s); }
  ZuCSpan v2s_(T v) const { return m_v2s.findVal(v); }
  template <typename L> void all_(L l) const {
    auto i = m_s2v.readIterator();
    while (auto kv = i.iterate()) {
      l(kv->template p<0>(), kv->template p<1>());
    }
  }

public:
  Map_() = default;
  static T s2v(ZuCSpan s) { return instance()->s2v_(s); }
  static ZuCSpan v2s(T v) { return instance()->v2s_(v); }
  template <typename L> static void all(L l) { instance()->all_(ZuMv(l)); }

private:
  S2V m_s2v;
  V2S m_v2s;
};
struct Map : public Map_<Map> {
  static constexpr const char *id() { return "ZvOptTypes"; }
  Map() {
    this->init("flag", Flag, "param", Param, "array", Array, (const char *)0);
  }
};
} // namespace ZvOptType

struct ZvOpt {
  char short_;
  const char *long_;
  int type;
  const char *key;
};

namespace ZvCf_ {

class Cf;

ZtString fullKey(const Cf *cf, ZtString key);

}

namespace ZvCfError {

using Cf = ZvCf_::Cf;

class Required : public ZvError {
public:
  Required(const Cf *cf, ZuCSpan key) : m_key{fullKey(cf, key)}, m_bt{1} { }

  const ZtString &key() const { return m_key; }

  void print_(ZuVStream &s) const {
    s << '"' << m_key << "\" missing at:\n" << m_bt;
  }

private:
  ZtString m_key;
  ZmBackTrace m_bt;
};

class BadBool : public ZvError {
public:
  BadBool(ZtString key, ZtString value) :
    m_key{ZuMv(key)}, m_value{ZuMv(value)} { }
  void print_(ZuVStream &s) const {
    s << '"' << m_key << "\": invalid bool value \"" << m_value << '"';
  }

private:
  ZtString m_key;
  ZtString m_value;
};

template <typename T> class Range_ : public ZvError {
public:
  Range_(ZtString key, T minimum, T maximum, T value) :
    m_key{ZuMv(key)}, m_minimum{minimum}, m_maximum{maximum}, m_value{value} { }

  const ZtString &key() const { return m_key; }
  T minimum() const { return m_minimum; }
  T maximum() const { return m_maximum; }
  T value() const { return m_value; }

protected:
  void print__(ZuVStream &s, ZuCSpan msg) const {
    s << '"' << m_key << "\" " << msg << ' ' << "min(" << m_minimum
      << ") <= " << m_value << " <= max(" << m_maximum << ")";
  }

private:
  ZtString m_key;
  T m_minimum;
  T m_maximum;
  T m_value;
};

template <typename T> class Range : public Range_<T> {
  using Base = Range_<T>;

public:
  Range(const Cf *cf, ZuCSpan key, T minimum, T maximum, T value) :
    Base{fullKey(cf, key), minimum, maximum, value} { }
  void print_(ZuVStream &s) const { Base::print__(s, "out of range"); }
};

class NElems : public Range_<unsigned> {
  using T = unsigned;
  using Base = Range_<T>;

public:
  NElems(const Cf *cf, ZuCSpan key, T minimum, T maximum, T value) :
    Base{fullKey(cf, key), minimum, maximum, value} { }
  void print_(ZuVStream &s) const {
    Base::print__(s, "invalid number of values");
  }
};

class Usage : public ZvError {
public:
  Usage(ZuCSpan cmd, ZuCSpan option) : m_cmd(cmd), m_option(option) { }
  void print_(ZuVStream &s) const {
    s << '"' << m_cmd << "\": invalid option \"" << m_option << '"';
  }

private:
  ZtString m_cmd;
  ZtString m_option;
};

class Syntax : public ZvError {
public:
  Syntax(unsigned line, char ch, ZuCSpan fileName) :
    m_line(line), m_ch(ch), m_fileName(fileName) { }
  void print_(ZuVStream &s) const {
    if (m_fileName)
      s << '"' << m_fileName << "\":" << ZuBoxed(m_line) << " syntax error";
    else
      s << "syntax error at line " << ZuBoxed(m_line);
    s << " near '";
    if (m_ch >= 0x20 && m_ch < 0x7f)
      s << m_ch;
    else
      s << '\\'
	<< ZuBoxed(static_cast<unsigned>(m_ch) & 0xff)
	     .fmt<ZuFmt::Hex<0, ZuFmt::Alt<ZuFmt::Right<2>>>>();
    s << '\'';
  }

private:
  unsigned m_line;
  char m_ch;
  ZtString m_fileName;
};

class FileOpenError : public ZvError {
public:
  FileOpenError(ZuCSpan fileName, ZeError e) :
    m_fileName{fileName}, m_err{e} { }

  void print_(ZuVStream &s) const { s << '"' << m_fileName << "\" " << m_err; }

private:
  ZtString m_fileName;
  ZeError m_err;
};

class File2Big : public ZvError {
public:
  File2Big(ZuCSpan fileName) : m_fileName{fileName} { }
  void print_(ZuVStream &s) const {
    s << '"' << m_fileName << " file too big";
  };

private:
  ZtString m_fileName;
};

class EnvSyntax : public ZvError {
public:
  EnvSyntax(unsigned pos, char ch) : m_pos{pos}, m_ch{ch} { }
  void print_(ZuVStream &s) const {
    s << "syntax error at position " << ZuBoxed(m_pos) << " near '";
    if (m_ch >= 0x20 && m_ch < 0x7f)
      s << m_ch;
    else
      s << '\\'
	<< ZuBoxed(static_cast<unsigned>(m_ch) & 0xff)
	     .fmt<ZuFmt::Hex<0, ZuFmt::Alt<ZuFmt::Right<2>>>>();
    s << '\'';
  }

private:
  unsigned m_pos;
  char m_ch;
};

class BadDefine : public ZvError {
public:
  template <typename Define, typename FileName>
  BadDefine(Define &&define, FileName &&fileName) :
    m_define{ZuFwd<Define>(define)}, m_fileName{ZuFwd<FileName>(fileName)} { }
  void print_(ZuVStream &s) const {
    if (m_fileName) s << '"' << m_fileName << "\": ";
    s << "bad %%define \"" << m_define << '"';
  }

private:
  ZtString m_define;
  ZtString m_fileName;
};

} // namespace ZvCfError

namespace ZvCf_ {

using namespace ZvCfError;

template <typename T, bool = ZuTraits<T>::IsPrimitive> struct Scan_;
template <typename T_> struct Scan_<T_, true> {
  using T = ZuBox<T_>;
};
template <typename T_, typename NTP_> struct Scan_<ZuBox<T_, NTP_>, false> {
  using T = ZuBox<T_, NTP_>;
};
template <> struct Scan_<ZuFixed, false> {
  using T = ZuFixed;
};
template <> struct Scan_<ZuDecimal, false> {
  using T = ZuDecimal;
};
template <typename T> using Scan = typename Scan_<T>::T;

template <bool Required_ = false>
inline bool
scanBool(const Cf *cf, ZuCSpan key, ZuCSpan value, bool deflt = false) {
  if (!value) {
    if constexpr (Required_) throw Required{cf, key};
    return deflt;
  }
  try {
    return ZtScanBool<true>(value);
  } catch (...) { throw BadBool{key, value}; }
}

template <typename T, bool Required_ = false>
inline T scanScalar(
  const Cf *cf, ZuCSpan key, ZuCSpan value, T minimum, T maximum,
  T deflt = ZuCmp<T>::null()
) {
  if (!value) {
    if constexpr (Required_) throw Required{cf, key};
    return deflt;
  }
  Scan<T> v{value};
  if (v < minimum || v > maximum) throw Range<T>{cf, key, minimum, maximum, v};
  return v;
}

template <bool Required_ = false, typename... Args>
inline auto scanInt(Args &&...args) {
  return scanScalar<int, Required_>(ZuFwd<Args>(args)...);
}
template <bool Required_ = false, typename... Args>
inline auto scanInt64(Args &&...args) {
  return scanScalar<int64_t, Required_>(ZuFwd<Args>(args)...);
}
template <bool Required_ = false, typename... Args>
inline auto scanDbl(Args &&...args) {
  return scanScalar<double, Required_>(ZuFwd<Args>(args)...);
}

template <typename Map, bool Required_ = false>
inline int scanEnum(const Cf *cf, ZuCSpan key, ZuCSpan value, int deflt = -1) {
  if (!value) {
    if constexpr (Required_) throw Required{cf, key};
    return deflt;
  }
  if constexpr (Required_)
    return ZvEnum::s2v<Map, true>(key, value);
  else
    return ZvEnum::s2v<Map, false>(key, value, deflt);
}

template <typename Map, typename Flags, bool Required_ = false>
inline Flags
scanFlags(const Cf *cf, ZuCSpan key, ZuCSpan value, Flags deflt = 0) {
  if (!value) {
    if constexpr (Required_) throw Required{cf, key};
    return deflt;
  }
  return ZvEnum::scan<Map, Flags>(key, value);
}

namespace Quoting {
enum {
  Mask = 0x003,
  File = 0x000,
  Env = 0x001,
  CLI = 0x002,
  Raw = 0x003,

  Key = 0x004
};
}

using StrArray = ZtArray<ZtString>;
using CfArray = ZtArray<ZmRef<Cf>>;
using Data = ZuUnion<void, ZtString, StrArray, ZmRef<Cf>, CfArray>;

class Cf;

struct CfNode {
  Cf *const owner = nullptr;
  const ZtString key;
  Data data;

  friend Cf;

private:
  CfNode() = delete;
  CfNode(const CfNode &) = delete;
  CfNode &operator=(const CfNode &) = delete;
  CfNode(CfNode &&) = delete;
  CfNode &operator=(CfNode &&) = delete;

protected:
  template <typename Key>
  CfNode(Cf *owner_, Key &&key_) : owner{owner_}, key{ZuFwd<Key>(key_)} { }

public:
  static const ZtString &KeyAxor(const CfNode &node) { return node.key; }

  void null() { data = {}; }

  auto type() const { return data.type(); }

  template <typename T, typename P> void set_(P &&v) { data.p<T>(ZuFwd<P>(v)); }

  template <typename P> void set(P &&v) { set_<ZtString>(ZuFwd<P>(v)); }
  template <typename P> void setCf(P &&v) { set_<ZmRef<Cf>>(ZuFwd<P>(v)); }

  template <typename T, bool Required_ = false> const T &get_() const {
    if (!data.is<T>()) {
      if constexpr (Required_) throw Required{owner, key};
      return ZuNullRef<T>();
    }
    return data.p<T>();
  }
  template <typename T> T get_(T deflt) const {
    if (!data.is<T>()) return deflt;
    return data.p<T>();
  }

  template <typename T, typename L> const T &assure_(L l) {
    if (!data.is<T>()) data.p<T>(l());
    return data.p<T>();
  }

  template <bool Required_ = false> const ZtString &get() const {
    return get_<ZtString, Required_>();
  }
  ZtString get(ZtString deflt) const { return get_<ZtString>(ZuMv(deflt)); }
  template <typename L> const ZtString &assure(L l) {
    return assure_<ZtString>(ZuMv(l));
  }

  template <bool Required_ = false> const StrArray &getStrArray() const {
    return get_<StrArray, Required_>();
  }
  template <typename L> const StrArray &assureStrArray(L l) {
    return assure_<StrArray>(ZuMv(l));
  }

  template <bool Required_ = false> const ZmRef<Cf> &getCf() const {
    return get_<ZmRef<Cf>, Required_>();
  }
  template <typename L> const ZmRef<Cf> &assureCf(L l) {
    return assure_<ZmRef<Cf>>(ZuMv(l));
  }

  template <bool Required_ = false> const CfArray &getCfArray() const {
    return get_<CfArray, Required_>();
  }
  template <typename L> const CfArray &assureCfArray(L l) {
    return assure_<CfArray>(ZuMv(l));
  }

  template <typename T, typename P> void setElem(unsigned i, P &&v) {
    using Elem = typename T::T;
    if (!data.is<T>()) new (data.new_<T>()) T{};
    new (data.p<T>().set(i)) Elem{ZuFwd<P>(v)};
  }
  template <typename T, bool Required_ = false>
  const typename T::T &getElem(unsigned i) const {
    if (!data.is<T>()) {
      if constexpr (Required_) throw Required{owner, key};
      return ZuNullRef<typename T::T>();
    }
    const auto &elems = data.p<T>();
    if (i >= elems.length()) return ZuNullRef<typename T::T>();
    return elems.get(i);
  }
  template <typename T>
  typename T::T getElem(unsigned i, typename T::T deflt) const {
    if (!data.is<T>()) return deflt;
    const auto &elems = data.p<T>();
    if (i >= elems.length()) return deflt;
    return elems.get(i);
  }
  template <typename T, typename L>
  const typename T::T &assureElem(unsigned i, L l) {
    if (!data.is<T>()) new (data.new_<T>()) T{};
    if (i >= data.p<T>().length()) data.p<T>().set(i, l());
    return data.p<T>().get(i);
  }

  template <bool Required_ = false> bool getBool() const {
    return scanBool<Required_>(owner, key, get<Required_>());
  }
  bool getBool(bool deflt) const { return scanBool(owner, key, get(), deflt); }
  bool assureBool(bool deflt) {
    return scanBool(
      owner, key, assure([deflt]() { return deflt ? "1" : "0"; }), deflt
    );
  }

  template <typename T, bool Required_ = false>
  T getScalar(T minimum, T maximum) const {
    return scanScalar<T, Required_>(
      owner, key, get<Required_>(), minimum, maximum
    );
  }
  template <typename T> T getScalar(T minimum, T maximum, T deflt) const {
    return scanScalar<T>(owner, key, get(), minimum, maximum, deflt);
  }
  template <typename T> T assureScalar(T minimum, T maximum, T deflt) {
    return scanScalar<T>(
      owner, key,
      assure([deflt = ZuMv(deflt)]() { return ZtString{} << deflt; }), minimum,
      maximum, deflt
    );
  }

  template <bool Required_ = false> int getInt(int minimum, int maximum) const {
    return getScalar<int, Required_>(minimum, maximum);
  }
  int getInt(int minimum, int maximum, int deflt) const {
    return getScalar<int>(minimum, maximum, deflt);
  }
  int assureInt(int minimum, int maximum, int deflt) {
    return assureScalar<int>(minimum, maximum, deflt);
  }

  template <bool Required_ = false>
  int64_t getInt64(int64_t minimum, int64_t maximum) const {
    return getScalar<int64_t, Required_>(minimum, maximum);
  }
  int64_t getInt64(int64_t minimum, int64_t maximum, int64_t deflt) const {
    return getScalar<int64_t>(minimum, maximum, deflt);
  }
  int64_t assureInt64(int64_t minimum, int64_t maximum, int64_t deflt) {
    return assureScalar<int64_t>(minimum, maximum, deflt);
  }

  template <bool Required_ = false>
  double getDbl(double minimum, double maximum) const {
    return getScalar<double, Required_>(minimum, maximum);
  }
  double getDbl(double minimum, double maximum, double deflt) const {
    return getScalar<double>(minimum, maximum, deflt);
  }
  double assureDbl(double minimum, double maximum, double deflt) {
    return assureScalar<double>(minimum, maximum, deflt);
  }

  template <typename Map, bool Required_ = false> int getEnum() const {
    return scanEnum<Map, Required_>(owner, key, get<Required_>(), -1);
  }
  template <typename Map> int getEnum(int deflt) const {
    return scanEnum<Map>(owner, key, get(), deflt);
  }
  template <typename Map> int assureEnum(int deflt) {
    return scanEnum<Map>(
      owner, key, assure([deflt]() { return Map::v2s(deflt); }), deflt
    );
  }

  template <typename Map, typename T, bool Required_ = false>
  T getFlags() const {
    return scanFlags<Map, T, Required_>(owner, key, get<Required_>(), 0);
  }
  template <typename Map, typename T> T getFlags(T deflt) const {
    return scanFlags<Map, T>(owner, key, get(), deflt);
  }
  template <typename Map, typename T> T assureFlags(T deflt) {
    using Print = typename Map::Print;
    return scanFlags<Map, T>(
      owner, key, assure([deflt]() { return ZtString{} << Print{deflt}; }),
      deflt
    );
  }
};

template <typename O, typename Cf_> struct Handler_ {
  using Fields = ZuFields<O>;

  template <typename U> struct AllFilter : public ZuBool<!U::ReadOnly> { };
  using AllFields = ZuTypeGrep<AllFilter, Fields>;

  template <typename U>
  struct UpdateFilter :
    public ZuTypeIn<ZuFieldProp::Mutable, typename U::Props> { };
  using UpdateFields = ZuTypeGrep<UpdateFilter, AllFields>;

  template <typename U>
  using CtorFilter = ZuFieldProp::HasCtor<typename U::Props>;
  template <typename U>
  using CtorIndex = ZuFieldProp::GetCtor<typename U::Props>;
  using CtorFields = ZuTypeSort<CtorIndex, ZuTypeGrep<CtorFilter, AllFields>>;

  template <typename U>
  using InitFilter = ZuBool<!ZuFieldProp::HasCtor<typename U::Props>{}>;
  using InitFields = ZuTypeGrep<InitFilter, AllFields>;

  template <typename... Fields_> struct Ctor {
    static O ctor(const Cf_ *cf) {
      return O{cf->template getField<Fields_>()...};
    }
    static void ctor(void *ptr, const Cf_ *cf) {
      new (ptr) O{cf->template getField<Fields_>()...};
    }
  };
  static O ctor(const Cf_ *cf) {
    O o = ZuTypeApply<Ctor, CtorFields>::ctor(cf);
    ZuUnroll::all<InitFields>([&o, cf]<typename Field>() {
      Field::set(o, cf->template getField<Field>());
    });
    return o;
  }
  static void ctor(void *ptr, const Cf_ *cf) {
    ZuTypeApply<Ctor, CtorFields>::ctor(ptr, cf);
    O &o = *reinterpret_cast<O *>(ptr);
    ZuUnroll::all<InitFields>([&o, cf]<typename Field>() {
      Field::set(o, cf->template getField<Field>());
    });
  }

  template <typename... Fields_> struct Load__ : public O {
    Load__() = default;
    Load__(const Cf_ *cf) : O{cf->template getField<Fields_>()...} { }
    template <typename... Args>
    Load__(Args &&...args) : O{ZuFwd<Args>(args)...} { }
  };
  using Load_ = ZuTypeApply<Load__, CtorFields>;
  struct Load : public Load_ {
    Load() = default;
    Load(const Cf_ *cf) : Load_{cf} {
      ZuUnroll::all<InitFields>([this, cf]<typename Field>() {
	Field::set(*this, cf->template getField<Field>());
      });
    }
    template <typename... Args>
    Load(Args &&...args) : Load_{ZuFwd<Args>(args)...} { }
  };

  static void load(O &o, const Cf_ *cf) {
    ZuUnroll::all<AllFields>([&o, cf]<typename Field>() {
      Field::set(o, cf->template getField<Field>());
    });
  }
  static void update(O &o, const Cf_ *cf) {
    ZuUnroll::all<UpdateFields>([&o, cf]<typename Field>() {
      Field::set(o, cf->template getField<Field>());
    });
  }
};
template <typename O, typename Cf_ = Cf>
using Handler = Handler_<ZuFielded<O>, Cf_>;

class Cf : public ZuObject {
  Cf(const Cf &);
  Cf &operator=(const Cf &);

public:
  Cf() = default;

private:
  Cf(CfNode *node) : m_node{node} { }

public:
  static ZtArray<ZtString> parseCLI(ZuCSpan line);
  static ZtArray<ZtString> args(int argc, char **argv);
  static ZmRef<Cf> options(const ZvOpt *opts);

  unsigned fromCLI(Cf *syntax, ZuCSpan line);
  unsigned fromArgs(Cf *options, const ZtArray<ZtString> &args);

  using Defines_ = ZmRBTreeKV<ZtString, ZtString, ZmRBTreeUnique<true>>;
  struct Defines : public ZuObject, public Defines_ { };

  void fromString(ZuCSpan in, ZmRef<Defines> defines = new Defines{}) {
    fromString(in, {}, defines);
  }

  template <typename Path>
  void fromFile(const Path &path, ZmRef<Defines> defines = new Defines{}) {
    ZtString in;
    {
      ZiFile file;
      ZeError e;
      if (file.open(path, ZiFile::ReadOnly, 0, &e) < 0)
	throw FileOpenError{path, e};
      int n = static_cast<int>(file.size());
      if (n >= (1 << 20)) throw File2Big{path};
      in.length(n);
      if (file.read(in.data(), n, &e) < 0) throw e;
      file.close();
    }
    ZtString dir = ZiFile::dirname(path);
    if (!defines->find("TOPDIR")) defines->add("TOPDIR", dir);
    defines->del("CURDIR");
    defines->add("CURDIR", ZuMv(dir));
    fromString(in, path, defines);
  }

  void fromEnv(const char *name, ZmRef<Defines> defines = new Defines{});

  void toArgs(int &argc, char **&argv) const;
  static void freeArgs(int argc, char **argv);

  void print(ZuVStream &s, ZtString &indent) const;

  template <typename S> void print(S &s_) const {
    ZuVStream s{s_};
    ZtString indent;
    print(s, indent);
  }
  void print(ZuVStream &s) const {
    ZtString indent;
    print(s, indent);
  }
  friend ZuPrintFn ZuPrintType(Cf *);

  template <typename Path> void toFile(const Path &path) {
    ZiFile file;
    ZeError e;
    if (file.open(path, ZiFile::Create | ZiFile::Truncate, 0777, &e) < 0)
      throw e;
    toFile_(file);
  }

private:
  void toFile_(ZiFile &file);

private:
  static const char *HeapID() { return "ZvCf"; }
  using Tree = ZmRBTree<
    CfNode,
    ZmRBTreeNode<
      CfNode,
      ZmRBTreeKey<
	CfNode::KeyAxor, ZmRBTreeUnique<true, ZmRBTreeHeapID<HeapID>>>>>;
  using Node = Tree::Node;

  ZuTuple<Cf *, ZtString> getScope(ZuCSpan fullKey) const;

public:
  template <bool Required_ = false>
  const CfNode *getNode(ZuCSpan fullKey) const {
    auto [this_, key] = getScope(fullKey);
    if (!this_) {
      if constexpr (Required_) throw Required{this, fullKey};
      return nullptr;
    }
    Node *node = this_->m_tree.find(key);
    if (!node)
      if constexpr (Required_) throw Required{this, fullKey};
    return node;
  }

private:
  CfNode *mkNode(ZuCSpan fullKey);

public:
  bool exists(ZuCSpan fullKey) const { return getNode(fullKey); }

  void set(ZuCSpan key, ZtString value);
  template <bool Required_ = false> const ZtString &get(ZuCSpan key) const {
    if (auto node = getNode<Required_>(key))
      return node->template get<Required_>();
    if constexpr (Required_) throw Required{this, key};
    return ZuNullRef<ZtString>();
  }
  ZtString get(ZuCSpan key, ZtString deflt) const {
    if (auto node = getNode(key)) return node->get(deflt);
    return deflt;
  }
  template <typename L> const ZtString &assure(ZuCSpan key, L l) {
    return mkNode(key)->assure(ZuMv(l));
  }

  void setStrArray(ZuCSpan key, StrArray value);
  template <bool Required_ = false>
  const StrArray &getStrArray(ZuCSpan key) const {
    if (auto node = getNode<Required_>(key))
      return node->template getStrArray<Required_>();
    if constexpr (Required_) throw Required{this, key};
    return ZuNullRef<StrArray>();
  }
  template <typename L> const StrArray &assureStrArray(ZuCSpan key, L l) {
    return mkNode(key)->assureStrArray(ZuMv(l));
  }

  ZmRef<Cf> mkCf(ZuCSpan key);
  void setCf(ZuCSpan key, ZmRef<Cf> cf);
  template <bool Required_ = false> const ZmRef<Cf> &getCf(ZuCSpan key) const {
    if (auto node = getNode<Required_>(key))
      return node->template getCf<Required_>();
    if constexpr (Required_) throw Required{this, key};
    return ZuNullRef<ZmRef<Cf>>();
  }
  template <typename L> const ZmRef<Cf> &assureCf(ZuCSpan key, L l) {
    return mkNode(key)->assureCf(ZuMv(l));
  }

  void setCfArray(ZuCSpan key, CfArray value);
  template <bool Required_ = false>
  const CfArray &getCfArray(ZuCSpan key) const {
    if (auto node = getNode<Required_>(key))
      return node->template getCfArray<Required_>();
    if constexpr (Required_) throw Required{this, key};
    return ZuNullRef<CfArray>();
  }
  template <typename L> const CfArray &assureCfArray(ZuCSpan key, L l) {
    return mkNode(key)->assureCfArray(ZuMv(l));
  }

  void unset(ZuCSpan key);

  template <typename L> void all(L l) {
    auto i = m_tree.iterator();
    while (auto node = i.iterate()) l(node);
  }

  void clean();

  void merge(const Cf *cf);

  template <bool Required_ = false> bool getBool(ZuCSpan key) const {
    if (auto node = getNode<Required_>(key))
      return node->template getBool<Required_>();
    if constexpr (Required_) throw Required{this, key};
    return false;
  }
  bool getBool(ZuCSpan key, bool deflt) const {
    if (auto node = getNode(key)) return node->getBool(deflt);
    return deflt;
  }
  bool assureBool(ZuCSpan key, bool deflt) {
    return mkNode(key)->assureBool(deflt);
  }

  template <typename T, bool Required_ = false>
  T getScalar(ZuCSpan key, T minimum, T maximum) const {
    if (auto node = getNode<Required_>(key))
      return node->template getScalar<T, Required_>(minimum, maximum);
    if constexpr (Required_) throw Required{this, key};
    return 0;
  }
  template <typename T>
  T getScalar(ZuCSpan key, T minimum, T maximum, T deflt) const {
    if (auto node = getNode(key))
      return node->template getScalar<T>(minimum, maximum, deflt);
    return deflt;
  }
  template <typename T>
  T assureScalar(ZuCSpan key, T minimum, T maximum, T deflt) {
    return mkNode(key)->template assureScalar<T>(minimum, maximum, deflt);
  }

  template <bool Required_ = false>
  int getInt(ZuCSpan key, int minimum, int maximum) const {
    return getScalar<int, Required_>(key, minimum, maximum);
  }
  int getInt(ZuCSpan key, int minimum, int maximum, int deflt) const {
    return getScalar<int>(key, minimum, maximum, deflt);
  }
  int assureInt(ZuCSpan key, int minimum, int maximum, int deflt) {
    return assureScalar<int>(key, minimum, maximum, deflt);
  }

  template <bool Required_ = false>
  int64_t getInt64(ZuCSpan key, int64_t minimum, int64_t maximum) const {
    return getScalar<int64_t, Required_>(key, minimum, maximum);
  }
  int64_t
  getInt64(ZuCSpan key, int64_t minimum, int64_t maximum, int64_t deflt) const {
    return getScalar<int64_t>(key, minimum, maximum, deflt);
  }
  int64_t
  assureInt64(ZuCSpan key, int64_t minimum, int64_t maximum, int64_t deflt) {
    return assureScalar<int64_t>(key, minimum, maximum, deflt);
  }

  template <bool Required_ = false>
  double getDouble(ZuCSpan key, double minimum, double maximum) const {
    return getScalar<double, Required_>(key, minimum, maximum);
  }
  double
  getDouble(ZuCSpan key, double minimum, double maximum, double deflt) const {
    return getScalar<double>(key, minimum, maximum, deflt);
  }
  double
  assureDouble(ZuCSpan key, double minimum, double maximum, double deflt) {
    return assureScalar<double>(key, minimum, maximum, deflt);
  }

  template <typename Map, bool Required_ = false>
  int getEnum(ZuCSpan key) const {
    if (auto node = getNode<Required_>(key))
      return node->template getEnum<Map, Required_>();
    if constexpr (Required_) throw Required{this, key};
    return -1;
  }
  template <typename Map> int getEnum(ZuCSpan key, int deflt) const {
    if (auto node = getNode(key)) return node->template getEnum<Map>(deflt);
    return deflt;
  }
  template <typename Map> int assureEnum(ZuCSpan key, int deflt) {
    return mkNode(key)->template assureEnum<Map>(deflt);
  }

  template <typename Map, typename T, bool Required_ = false>
  T getFlags(ZuCSpan key) const {
    if (auto node = getNode<Required_>(key))
      return node->template getFlags<Map, T, Required_>();
    if constexpr (Required_) throw Required{this, key};
    return 0;
  }
  template <typename Map, typename T> T getFlags(ZuCSpan key, T deflt) const {
    if (auto node = getNode(key)) return node->template getFlags<Map, T>(deflt);
    return deflt;
  }
  template <typename Map, typename T> T assureFlags(ZuCSpan key, T deflt) {
    return mkNode(key)->template assureFlags<Map, T>(deflt);
  }

  template <typename Field>
  ZuIfT<Field::Type::Code == ZtFieldTypeCode::CString, typename Field::T>
  getField() {
    return get<ZuTypeIn<ZuFieldProp::Required, typename Field::Props>{}>(
	     Field::id(), Field::deflt()
    )
      .data();
  }
  template <typename Field>
  ZuIfT<Field::Type::Code == ZtFieldTypeCode::String, typename Field::T>
  getField() {
    return get<ZuTypeIn<ZuFieldProp::Required, typename Field::Props>{}>(
      Field::id(), Field::deflt()
    );
  }
  template <typename Field>
  ZuIfT<Field::Type::Code == ZtFieldTypeCode::Bytes, typename Field::T>
  getField() {
    auto s = get<ZuTypeIn<ZuFieldProp::Required, typename Field::Props>{}>(
      Field::id(), Field::deflt()
    );
    auto n = ZuBase64::declen(s.length());
    ZtArray<uint8_t> buf(n);
    buf.length(ZuBase64::decode(buf, ZuBytes{s}));
    return buf;
  }
  template <typename Field>
  ZuIfT<
    Field::Type::Code == ZtFieldTypeCode::UDT ||
      Field::Type::Code == ZtFieldTypeCode::Time ||
      Field::Type::Code == ZtFieldTypeCode::DateTime,
    typename Field::T>
  getField() {
    using T = typename Field::T;
    auto s = get<ZuTypeIn<ZuFieldProp::Required, typename Field::Props>{}>(
      Field::id(), ""
    );
    if (__builtin_expect(!!(!s), 0)) return Field::deflt();
    return T{s};
  }
  template <typename Field>
  ZuIfT<Field::Type::Code == ZtFieldTypeCode::Bool, typename Field::T>
  getField() {
    return getBool<ZuTypeIn<ZuFieldProp::Required, typename Field::Props>{}>(
      Field::id(), Field::deflt()
    );
  }
  template <typename Field>
  ZuIfT<
    Field::Type::Code == ZtFieldTypeCode::Int8 ||
      Field::Type::Code == ZtFieldTypeCode::UInt8 ||
      Field::Type::Code == ZtFieldTypeCode::Int16 ||
      Field::Type::Code == ZtFieldTypeCode::UInt16 ||
      Field::Type::Code == ZtFieldTypeCode::Int32 ||
      Field::Type::Code == ZtFieldTypeCode::UInt32 ||
      Field::Type::Code == ZtFieldTypeCode::Int64 ||
      Field::Type::Code == ZtFieldTypeCode::UInt64 ||
      Field::Type::Code == ZtFieldTypeCode::Int128 ||
      Field::Type::Code == ZtFieldTypeCode::UInt128,
    typename Field::T>
  getField() {
    using Props = typename Field::Props;
    if constexpr (ZuFieldProp::HasEnum<Props>{}) {
      using Map = ZuFieldProp::GetEnum<Props>;
      return getEnum<Map, ZuTypeIn<ZuFieldProp::Required, Props>{}>(
	Field::id(), Field::deflt()
      );
    } else if constexpr (ZuFieldProp::HasFlags<Props>{}) {
      using Map = ZuFieldProp::GetFlags<Props>;
      using T = typename Field::T;
      return getFlags<Map, T, ZuTypeIn<ZuFieldProp::Required, Props>{}>(
	Field::id(), Field::deflt()
      );
    } else {
      return getScalar<
	typename Field::T, ZuTypeIn<ZuFieldProp::Required, Props>{}>(
	Field::id(), Field::minimum(), Field::maximum(), Field::deflt()
      );
    }
  }
  template <typename Field>
  ZuIfT<
    Field::Type::Code == ZtFieldTypeCode::Float ||
      Field::Type::Code == ZtFieldTypeCode::Fixed ||
      Field::Type::Code == ZtFieldTypeCode::Decimal,
    typename Field::T>
  getField() {
    return getScalar<
      typename Field::T,
      ZuTypeIn<ZuFieldProp::Required, typename Field::Props>{}>(
      Field::id(), Field::minimum(), Field::maximum(), Field::deflt()
    );
  }
  template <typename Field>
  ZuIfT<Field::Type::Code == ZtFieldTypeCode::CStringVec, typename Field::T>
  getField() {
    using T = typename Field::T;
    CfNode *node = getNode(Field::id());
    if (!node || !node->data.is<StrArray>()) return {};
    const auto &elems = node->data.p<StrArray>();
    return T(ZuVArray<typename ZuTraits<T>::Elem>(
      elems, elems.length(),
      [](const void *ptr, unsigned i) {
      const auto &elems = *reinterpret_cast<const StrArray *>(ptr);
      return elems[i].data();
    }
    ));
  }
  template <typename Field>
  ZuIfT<Field::Type::Code == ZtFieldTypeCode::StringVec, typename Field::T>
  getField() {
    using T = typename Field::T;
    CfNode *node = getNode(Field::id());
    if (!node || !node->data.is<StrArray>()) return {};
    const auto &elems = node->data.p<StrArray>();
    return T(ZuVArray<typename ZuTraits<T>::Elem>(
      elems, elems.length(),
      [](const void *ptr, unsigned i) {
      const auto &elems = *reinterpret_cast<const StrArray *>(ptr);
      return elems[i];
    }
    ));
  }
  template <typename Field>
  ZuIfT<Field::Type::Code == ZtFieldTypeCode::BytesVec, typename Field::T>
  getField() {
    using T = typename Field::T;
    CfNode *node = getNode(Field::id());
    if (!node || !node->data.is<StrArray>()) return {};
    const auto &elems = node->data.p<StrArray>();
    return T(ZuVArray<typename ZuTraits<T>::Elem>(
      elems, elems.length(),
      [](const void *ptr, unsigned i) {
      const auto &elems = *reinterpret_cast<const StrArray *>(ptr);
      const auto &s = elems[i];
      auto n = ZuBase64::declen(s.length());
      ZtArray<uint8_t> buf(n);
      buf.length(ZuBase64::decode(buf, ZuBytes{s}));
      return buf;
    }
    ));
  }
  template <typename Field>
  ZuIfT<
    Field::Type::Code == ZtFieldTypeCode::Int8Vec ||
      Field::Type::Code == ZtFieldTypeCode::UInt8Vec ||
      Field::Type::Code == ZtFieldTypeCode::Int16Vec ||
      Field::Type::Code == ZtFieldTypeCode::UInt16Vec ||
      Field::Type::Code == ZtFieldTypeCode::Int32Vec ||
      Field::Type::Code == ZtFieldTypeCode::UInt32Vec ||
      Field::Type::Code == ZtFieldTypeCode::Int64Vec ||
      Field::Type::Code == ZtFieldTypeCode::UInt64Vec ||
      Field::Type::Code == ZtFieldTypeCode::Int128Vec ||
      Field::Type::Code == ZtFieldTypeCode::UInt128Vec ||
      Field::Type::Code == ZtFieldTypeCode::FloatVec ||
      Field::Type::Code == ZtFieldTypeCode::FixedVec ||
      Field::Type::Code == ZtFieldTypeCode::DecimalVec,
    typename Field::T>
  getField() {
    using T = typename Field::T;
    CfNode *node = getNode(Field::id());
    if (!node || !node->data.is<StrArray>()) return {};
    const auto &elems = node->data.p<StrArray>();
    using Elem = typename ZuTraits<T>::Elem;
    return T(ZuVArray<Elem>(
      elems, elems.length(),
      [](const void *ptr, unsigned i) {
      const auto &elems = *reinterpret_cast<const StrArray *>(ptr);
      return Scan<Elem>{elems[i]};
    }
    ));
  }
  template <typename Field>
  ZuIfT<
    Field::Type::Code == ZtFieldTypeCode::TimeVec ||
      Field::Type::Code == ZtFieldTypeCode::DateTimeVec,
    typename Field::T>
  getField() {
    using T = typename Field::T;
    CfNode *node = getNode(Field::id());
    if (!node || !node->data.is<StrArray>()) return {};
    const auto &elems = node->data.p<StrArray>();
    using Elem = typename ZuTraits<T>::Elem;
    return T(ZuVArray<Elem>(
      elems, elems.length(),
      [](const void *ptr, unsigned i) {
      const auto &elems = *reinterpret_cast<const StrArray *>(ptr);
      return Elem{elems[i]};
    }
    ));
  }

  template <typename O> inline O ctor() const { return Handler<O>::ctor(this); }
  template <typename O> inline void ctor(void *ptr) const {
    Handler<O>::ctor(ptr, this);
  }

  template <typename O> using Load = typename Handler<O>::Load;

  template <typename O> inline void load(O &o) const {
    Handler<O>::load(o, this);
  }
  template <typename O> inline void update(O &o) const {
    Handler<O>::update(o, this);
  }

  template <typename O, int KeyID = 0> inline auto key() const {
    return ctor<ZuFieldKeyT<O, KeyID>>();
  }

  unsigned count() const { return m_tree.count_(); }

  CfNode *node() const { return m_node; }

private:
  void fromArg(ZuCSpan key, int type, ZuCSpan in);
  void fromString(ZuCSpan in, ZuCSpan path, ZmRef<Defines> defines);

  void toArgs(ZtArray<ZtString> &args, ZuCSpan prefix = {}) const;

  template <unsigned Q = Quoting::File>
  ZuTuple<Cf *, ZtString, int, unsigned>
  getScope_(ZuCSpan in, Cf::Defines *defines = nullptr) const;
  template <unsigned Q = Quoting::File>
  ZuTuple<Cf *, ZtString, int, unsigned>
  mkScope_(ZuCSpan in, Cf::Defines *defines = nullptr);
  template <unsigned Q = Quoting::File>
  ZuTuple<Cf *, CfNode *, int, unsigned> mkNode_(ZuCSpan in);

  Tree m_tree;
  CfNode *m_node;
};

inline ZtString fullKey(const Cf *cf, ZtString key) {
  while (auto node = cf->node()) {
    key = ZtString{} << node->CfNode::key << '.' << key;
    if (!(cf = node->owner)) break;
  }
  return key;
}

} // namespace ZvCf_

using ZvCf = ZvCf_::Cf;
using ZvCfNode = ZvCf_::CfNode;

template <typename U, typename> struct ZuArray_CanAppend_;
template <typename U> struct ZuArray_CanAppend_<U, void> {
  using T = void;
};
template <typename U> struct ZuArray_CanAppend_<U, U &> {
  using T = void;
};
template <typename U, typename T, typename = void>
struct ZuArray_CanAppend : public ZuFalse { };
template <typename U, typename T>
struct ZuArray_CanAppend<
  U, T,
  typename ZuArray_CanAppend_<
    U, decltype(ZuDeclVal<U>().append(ZuDeclVal<const T *>(), 1))>::T> :
  public ZuTrue { };

template <typename> struct ZuArray___ { };
template <> struct ZuArray___<char> {
  friend ZuPrintString ZuPrintType(ZuArray___ *);
};

template <typename T> struct ZuArray__ : public ZuArray___<ZuStrip<T>> {
protected:
  struct Nop { };

  ZuArray__(Nop) { }

  ZuArray__() : m_length{0} { }

  ZuArray__(unsigned length) : m_length{length} { }

  uint32_t m_length;
};

template <typename T_> struct ZuArray_Char2 {
  using T = void;
};
template <> struct ZuArray_Char2<char> {
  using T = wchar_t;
};
template <> struct ZuArray_Char2<wchar_t> {
  using T = char;
};

template <typename T_, unsigned N_, typename Cmp_, typename ArrayN>
class ZuArray_ : public ZuArray__<T_>, public ZuArrayFn<T_, Cmp_> {
  template <typename, typename> friend struct ZuInspect_::Convertible;

  ZuArray_(const ZuArray_ &);
  ZuArray_ &operator=(const ZuArray_ &);
  bool operator*() const;

  using Base = ZuArray__<T_>;
  using Base::m_length;

public:
  using T = T_;
  enum { N = N_ };
  using Char2 = typename ZuArray_Char2<T>::T;
  using Cmp = Cmp_;

  using Nop = Base::Nop;

protected:
  template <typename U, typename V = T>
  struct IsString :
    public ZuBool<
      (ZuTraits<U>::IsSpan || ZuTraits<U>::IsString) &&
      bool{ZuEquiv<typename ZuTraits<U>::Elem, V>{}}> { };
  template <typename U, typename R = void>
  using MatchString = ZuIfT<IsString<U>{}, R>;

  template <typename U, typename V = Char2>
  struct IsChar2String :
    public ZuBool<
      !ZuIsExact<void, V>{} && (ZuTraits<U>::IsSpan || ZuTraits<U>::IsString) &&
      bool{ZuEquiv<typename ZuTraits<U>::Elem, V>{}}> { };
  template <typename U, typename R = void>
  using MatchChar2String = ZuIfT<IsChar2String<U>{}, R>;

  template <typename U, typename V = T>
  struct IsSpan :
    public ZuBool<
      !IsString<U>{} && !IsChar2String<U>{} && !ZuIsExact<U, V>{} &&
      ZuTraits<U>::IsSpan &&
      ZuInspect<typename ZuTraits<U>::Elem, V>::Converts> { };
  template <typename U, typename R = void>
  using MatchArray = ZuIfT<IsSpan<U>{}, R>;

  template <typename U, typename = void>
  struct IsIterable_ : public ZuFalse { };
  template <typename U>
  struct IsIterable_<
    U,
    decltype(ZuDeclVal<const U &>().end() - ZuDeclVal<const U &>().begin(), void())> :
    public ZuTrue { };
  template <typename U, typename V = T>
  struct IsIterable :
    public ZuBool<
      !IsString<U>{} && !IsChar2String<U>{} && !ZuIsExact<U, V>{} &&
      !ZuTraits<U>::IsSpan && bool(IsIterable_<ZuDecay<U>>{}) &&
      ZuInspect<typename ZuTraits<U>::Elem, V>::Constructs> { };
  template <typename U, typename R = void>
  using MatchIterable = ZuIfT<IsIterable<U>{}, R>;

  template <typename U, typename V = Char2>
  struct IsChar2 :
    public ZuBool<
      !ZuIsExact<void, V>{} && bool(ZuIsExact<U, V>{}) &&
      !ZuIsExact<U, wchar_t>{}> { };
  template <typename U, typename R = void>
  using MatchChar2 = ZuIfT<IsChar2<U>{}, R>;

  template <typename U, typename V = T>
  struct IsPDelegate :
    public ZuBool<bool{ZuEquiv<char, V>{}} && ZuPrint<U>::Delegate> { };
  template <typename U, typename R = void>
  using MatchPDelegate = ZuIfT<IsPDelegate<U>{}, R>;
  template <typename U, typename V = T>
  struct IsPBuffer :
    public ZuBool<bool{ZuEquiv<char, V>{}} && ZuPrint<U>::Buffer> { };
  template <typename U, typename R = void>
  using MatchPBuffer = ZuIfT<IsPBuffer<U>{}, R>;

  template <typename U, typename V = T>
  struct IsReal :
    public ZuBool<
      bool{ZuEquiv<char, V>{}} && !bool{ZuEquiv<U, V>{}} &&
      ZuTraits<U>::IsReal && ZuTraits<U>::IsPrimitive &&
      !ZuTraits<U>::IsArray> { };
  template <typename U, typename R = void>
  using MatchReal = ZuIfT<IsReal<U>{}, R>;

  template <typename U, typename V = T>
  struct IsElem :
    public ZuBool<
      bool(ZuIsExact<U, V>{}) ||
      (!IsString<U>{} && !ZuTraits<U>::IsArray && !IsChar2String<U>{} &&
       !IsChar2<U>{} && !IsPDelegate<U>{} && !IsPBuffer<U>{} && !IsReal<U>{} &&
       ZuInspect<U, V>::Converts)> { };
  template <typename U, typename R = void>
  using MatchElem = ZuIfT<IsElem<U>{}, R>;

  template <typename U>
  struct IsStreamable :
    public ZuBool<
      bool{IsString<U>{}} || bool{IsSpan<U>{}} || bool{IsIterable<U>{}} ||
      bool{IsChar2String<U>{}} || bool{IsChar2<U>{}} ||
      bool{IsPDelegate<U>{}} || bool{IsPBuffer<U>{}} || bool{IsReal<U>{}} ||
      bool{IsElem<U>{}}> { };
  template <typename U, typename R = void>
  using MatchStreamable = ZuIfT<IsStreamable<U>{}, R>;

  ~ZuArray_() { dtor(); }

  ZuArray_() { }

  ZuArray_(Nop) : Base{Nop{}} { }

  ZuArray_(unsigned length, bool initItems) : Base(length) {
    if (m_length > N) m_length = N;
    if (initItems) this->initItems(data(), m_length);
  }

  void dtor() { this->destroyItems(data(), m_length); }

  template <typename A> ZuConvertible<A, T> init(const A *a, unsigned length) {
    if (__builtin_expect(!!(length > N), 0)) length = N;
    if (__builtin_expect(!!(!a), 0))
      length = 0;
    else if (__builtin_expect(!!(length), 1))
      this->copyItems(data(), a, length);
    m_length = length;
  }
  template <typename A> ZuConvertible<A, T> init_mv(A *a, unsigned length) {
    if (__builtin_expect(!!(length > N), 0)) length = N;
    if (__builtin_expect(!!(!a), 0))
      length = 0;
    else if (__builtin_expect(!!(length), 1))
      this->moveItems(data(), a, length);
    m_length = length;
  }

  template <typename S> MatchString<S> init(S &&s_) {
    ZuSpan<const T> s(s_);
    init(s.data(), s.length());
  }

  template <typename A> MatchArray<A> init(A &&a) {
    ZuBind<A>::mvcp(ZuFwd<A>(a), [this](auto &&a_) {
      using Array = ZuDecay<decltype(a_)>;
      using Elem = typename ZuTraits<Array>::Elem;
      ZuSpan<Elem> a(a_);
      this->init_mv(a.data(), a.length());
    }, [this](const auto &a_) {
      using Array = ZuDecay<decltype(a_)>;
      using Elem = typename ZuTraits<Array>::Elem;
      ZuSpan<const Elem> a(a_);
      this->init(a.data(), a.length());
    });
  }

  template <typename A> MatchIterable<A> init(const A &a) {
    auto i = a.begin();
    unsigned n = a.end() - i;
    if (n > N) n = N;
    for (unsigned j = 0; j < n; j++) this->initItem(push(), *i++);
  }

  template <typename S> MatchChar2String<S> init(S &&s) {
    data()[m_length = ZuUTF<T, Char2>::cvt({data(), N}, s)] = 0;
  }
  template <typename C> MatchChar2<C> init(C c) {
    data()[m_length = ZuUTF<T, Char2>::cvt({data(), N}, {&c, 1})] = 0;
  }

  template <typename P> MatchPDelegate<P> init(const P &p) {
    ZuPrint<P>::print(*static_cast<ArrayN *>(this), p);
  }
  template <typename P> MatchPBuffer<P> init(const P &p) {
    unsigned length = ZuPrint<P>::length(p);
    if (length > N)
      m_length = 0;
    else
      m_length = ZuPrint<P>::print(reinterpret_cast<char *>(data()), length, p);
  }

  template <typename V> MatchReal<V> init(V v) { init(ZuBoxed(v)); }

  template <typename E> MatchElem<E> init(E &&e) {
    this->initItem(data(), ZuFwd<E>(e));
    m_length = 1;
  }

  template <typename A>
  ZuConvertible<A, T> append_(const A *a, unsigned length) {
    if (m_length + length > N) length = N - m_length;
    if (a && length) this->copyItems(data() + m_length, a, length);
    m_length += length;
  }
  template <typename A> ZuConvertible<A, T> append_mv_(A *a, unsigned length) {
    if (m_length + length > N) length = N - m_length;
    if (a && length) this->moveItems(data() + m_length, a, length);
    m_length += length;
  }

  template <typename S> MatchString<S> append_(S &&s_) {
    ZuSpan<const T> s(s_);
    this->append_(s.data(), s.length());
  }

  template <typename A> MatchArray<A> append_(A &&a) {
    ZuBind<A>::mvcp(ZuFwd<A>(a), [this](auto &&a_) {
      using Array = ZuDecay<decltype(a_)>;
      using Elem = typename ZuTraits<Array>::Elem;
      ZuSpan<Elem> a(a_);
      this->append_mv_(a.data(), a.length());
    }, [this](const auto &a_) {
      using Array = ZuDecay<decltype(a_)>;
      using Elem = typename ZuTraits<Array>::Elem;
      ZuSpan<const Elem> a(a_);
      this->append_(a.data(), a.length());
    });
  }

  template <typename A> MatchIterable<A> append_(const A &a) {
    auto i = a.begin();
    unsigned n = a.end() - i;
    if (n > N - m_length) n = N - m_length;
    for (unsigned j = 0; j < n; j++) new (push()) T(*i++);
  }

  template <typename S> MatchChar2String<S> append_(S &&s) {
    if (m_length < N)
      data(
      )[m_length = ZuUTF<T, Char2>::cvt({data() + m_length, N - m_length}, s)] =
	0;
  }

  template <typename C> MatchChar2<C> append_(C c) {
    if (m_length < N)
      data(
      )[m_length +=
	ZuUTF<T, Char2>::cvt({data() + m_length, N - m_length}, {&c, 1})] = 0;
  }

  template <typename P> MatchPDelegate<P> append_(const P &p) {
    ZuPrint<P>::print(*static_cast<ArrayN *>(this), p);
  }
  template <typename P> MatchPBuffer<P> append_(const P &p) {
    unsigned length = ZuPrint<P>::length(p);
    if (m_length + length > N) return;
    m_length +=
      ZuPrint<P>::print(reinterpret_cast<char *>(data()) + m_length, length, p);
  }

  template <typename V> MatchReal<V> append_(V v) { append_(ZuBoxed(v)); }

  template <typename E> MatchElem<E> append_(E &&e) {
    if (m_length >= N) return;
    this->initItem(data() + m_length, ZuFwd<E>(e));
    ++m_length;
  }

public:
  const T &operator[](unsigned i) const { return data()[i]; }
  T &operator[](unsigned i) { return data()[i]; }

  static constexpr unsigned size() { return N; }
  unsigned length() const { return m_length; }

  template <bool Mutable = false, typename L> ZuIfT<!Mutable> all(L l) const {
    auto data_ = data();
    for (unsigned i = 0, n = m_length; i < n; i++) l(data_[i]);
  }
  template <bool Mutable, typename L> ZuIfT<Mutable> all(L l) {
    auto data_ = data();
    for (unsigned i = 0, n = m_length; i < n; i++) l(data_[i]);
  }

  using iterator = T *;
  using const_iterator = const T *;
  const T *begin() const { return data(); }
  const T *end() const { return data() + m_length; }
  const T *cbegin() const { return data(); }
  const T *cend() const { return data() + m_length; }
  T *begin() { return data(); }
  T *end() { return data() + m_length; }

  void clear() { null(); }
  void null() { m_length = 0; }

  template <bool InitItems = !ZuTraits<T>::IsPrimitive>
  void length(unsigned length) {
    if (length > N) length = N;
    if constexpr (InitItems) {
      if (length > m_length) {
	this->initItems(data() + m_length, length - m_length);
      } else if (length < m_length) {
	this->destroyItems(data() + length, m_length - length);
      }
    }
    m_length = length;
  }

  void *push() {
    if (m_length >= N) return nullptr;
    return &(data()[m_length++]);
  }
  template <typename I> T *push(I &&i) {
    auto ptr = push();
    if (__builtin_expect(!!(ptr), 1)) this->initItem(ptr, ZuFwd<I>(i));
    return static_cast<T *>(ptr);
  }
  T pop() {
    if (!m_length) return ZuNullRef<T, Cmp>();
    T t = ZuMv(data()[--m_length]);
    this->destroyItem(data() + m_length);
    return t;
  }
  T shift() {
    if (!m_length) return ZuNullRef<T, Cmp>();
    T t = ZuMv(data()[0]);
    this->destroyItem(data());
    this->moveItems(data(), data() + 1, --m_length);
    return t;
  }
  template <typename I> T *unshift(I &&i) {
    if (m_length >= N) return 0;
    this->moveItems(data() + 1, data(), m_length++);
    T *ptr = data();
    this->initItem((void *)ptr, ZuFwd<I>(i));
    return ptr;
  }

  void splice(int offset, int length) { splice_(offset, length, (void *)0); }
  template <typename U> void splice(int offset, int length, U &removed) {
    splice_(offset, length, &removed);
  }

private:
  template <typename U> struct IsVoid : public ZuIsExact<void, U> { };
  template <typename U, typename R = void>
  using MatchVoid = ZuIfT<IsVoid<U>{}, R>;

  template <typename U, typename V = T>
  struct IsAppend : public ZuBool<ZuArray_CanAppend<U, V>{}> { };
  template <typename U, typename R = void>
  using MatchAppend = ZuIfT<IsAppend<U>{}, R>;

  template <typename U, typename V = T>
  struct IsSplice : public ZuBool<!IsVoid<U>{} && !IsAppend<U>{}> { };
  template <typename U, typename R = void>
  using MatchSplice = ZuIfT<IsSplice<U>{}, R>;

  template <typename U> void splice_(int offset, int length, U *removed) {
    if (__builtin_expect(!!(!length), 0)) return;
    if (offset < 0) {
      if ((offset += m_length) < 0) offset = 0;
    }
    if (offset >= (int)N) return;
    if (length < 0) {
      if ((length += (m_length - offset)) <= 0) return;
    }
    if (offset + length > (int)N)
      if (!(length = N - offset)) return;
    if (offset > (int)m_length) {
      this->initItems(data() + m_length, offset - m_length);
      m_length = offset;
      return;
    }
    if (offset + length > (int)m_length)
      if (!(length = m_length - offset)) return;
    if (removed) splice__(data() + offset, length, removed);
    this->destroyItems(data() + offset, length);
    this->moveItems(
      data() + offset, data() + offset + length, m_length - (offset + length)
    );
    m_length -= length;
  }
  template <typename U> MatchVoid<U> splice__(const T *, unsigned, U *) { }
  template <typename U>
  MatchAppend<U> splice__(const T *data, unsigned length, U *removed) {
    removed->append_(data, length);
  }
  template <typename U>
  MatchSplice<U> splice__(const T *data, unsigned length, U *removed) {
    for (unsigned i = 0; i < length; i++) *removed << data[i];
  }

public:
  auto buf() { return ZuSpan{data(), N}; }
  auto cbuf() const { return ZuSpan{data(), m_length}; }

  bool operator!() const { return !m_length; }
  operator const void *() const {
    return !*this ? reinterpret_cast<const void *>(0) :
		    static_cast<const void *>(this);
  }

protected:
  bool same(const ZuArray_ &a) const { return this == &a; }
  template <typename A> bool same(const A &a) const { return false; }

public:
  template <typename A> bool equals(const A &a) const {
    return same(a) || cbuf().equals(a);
  }
  template <typename A> int cmp(const A &a) const {
    if (same(a)) return 0;
    return cbuf().cmp(a);
  }
  template <typename L, typename R>
  friend inline ZuIfT<ZuInspect<ZuArray_, L>::Is, bool>
  operator==(const L &l, const R &r) {
    return l.equals(r);
  }
  template <typename L, typename R>
  friend inline ZuIfT<ZuInspect<ZuArray_, L>::Is, int>
  operator<=>(const L &l, const R &r) {
    return l.cmp(r);
  }

  uint32_t hash() const {
    return ZuHash<ArrayN>::hash(*static_cast<const ArrayN *>(this));
  }

private:
  struct Align : public Base {
    T m_data[1];
  };

public:
  T *data() { return reinterpret_cast<Align *>(this)->m_data; }
  const T *data() const {
    return reinterpret_cast<const Align *>(this)->m_data;
  }
};

namespace Zu_ {
template <typename T_, unsigned N_, class Cmp_ = ZuCmp<T_>>
class ArrayN : public ZuArray_<T_, N_, Cmp_, ArrayN<T_, N_, Cmp_>> {
  static_assert((N_ > 0), "N_ > 0");
  static_assert((N_ < (1U << 16) - 1U), "N_ < (1U<<16) - 1U");

public:
  using T = T_;
  enum { N = N_ };
  using Cmp = Cmp_;
  using Base = ZuArray_<T, N, Cmp, ArrayN>;

  using Nop = Base::Nop;

  struct Move { };

private:
  template <typename U, typename V = T>
  struct IsCtorLength :
    public ZuBool<
      ZuTraits<U>::IsIntegral &&
      (sizeof(U) > 2 || !ZuIsExact<ZuNormChar<V>, ZuNormChar<U>>{})> { };
  template <typename U, typename R = void>
  using MatchCtorLength = ZuIfT<IsCtorLength<U>{}, R>;

  template <typename U>
  struct IsCtorArg :
    public ZuBool<!IsCtorLength<U>{} && !ZuInspect<Base, U>::Base> { };
  template <typename U, typename R = void>
  using MatchCtorArg = ZuIfT<IsCtorArg<U>{}, R>;

public:
  ArrayN() { }

  ArrayN(const ArrayN &a) : Base{Nop{}} { this->init(a.data(), a.length()); }
  ArrayN &operator=(const ArrayN &a) {
    if (this != &a) {
      this->dtor();
      this->init(a.data(), a.length());
    }
    return *this;
  }

  ArrayN(ArrayN &&a) : Base{Nop{}} { this->init_mv(a.data(), a.length()); }
  ArrayN &operator=(ArrayN &&a) {
    if (this != &a) {
      this->dtor();
      this->init_mv(a.data(), a.length());
    }
    return *this;
  }

  ArrayN(std::initializer_list<T> a) : Base{Nop{}} {
    this->init(a.begin(), a.size());
  }

  template <typename A, decltype(MatchCtorArg<A>(), int()) = 0>
  ArrayN(A &&a) : Base{Nop{}} {
    this->init(ZuFwd<A>(a));
  }
  template <typename A> ArrayN &operator=(A &&a) {
    this->dtor();
    this->init(ZuFwd<A>(a));
    return *this;
  }
  template <typename U> ArrayN &operator+=(U &&v) {
    return *this << ZuFwd<U>(v);
  }
  template <typename U>
  Base::template MatchStreamable<U, ArrayN &> operator<<(U &&v) {
    this->append_(ZuFwd<U>(v));
    return *this;
  }

  template <typename V, decltype(MatchCtorLength<V>(), int()) = 0>
  ArrayN(V n, bool initItems = !ZuTraits<T>::IsPrimitive) :
    Base(n, initItems) { }

  template <typename A, decltype(ZuConvertible<A, T>(), int()) = 0>
  ArrayN(const A *a, unsigned length) : Base{Nop{}} {
    this->init(a, length);
  }
  ArrayN(Move, T *a, unsigned length) : Base{Nop{}} {
    this->init_mv(a, length);
  }

  template <typename A>
  ZuConvertible<A, T> append(const A *a, unsigned length) {
    this->append_(a, length);
  }
  template <typename A> ZuConvertible<A, T> append_mv(A *a, unsigned length) {
    this->append_mv_(a, length);
  }

  struct Traits : public ZuBaseTraits<ArrayN> {
    using Elem = T;
    enum {
      IsArray = 1,
      IsSpan = 1,
      IsPrimitive = 0,
      IsPOD = ZuTraits<T>::IsPOD,
      IsString = bool{ZuIsExact<char, ZuDecay<T>>{}} ||
	bool{ZuIsExact<wchar_t, ZuDecay<T>>{}},
      IsWString = bool{ZuIsExact<wchar_t, ZuDecay<T>>{}}
    };
    static Elem *data(ArrayN &a) { return a.data(); }
    static const Elem *data(const ArrayN &a) { return a.data(); }
    static unsigned length(const ArrayN &a) { return a.length(); }
  };
  friend Traits ZuTraitsType(ArrayN *);

private:
  char m_data[N * sizeof(T)];
};

} // namespace Zu_

template <typename T, unsigned N, typename Cmp = ZuCmp<T>>
using ZuArray = Zu_::ArrayN<T, N, Cmp>;

namespace std {
template <class> struct tuple_size;
template <typename T, unsigned N, typename Cmp>
struct tuple_size<ZuArray<T, N, Cmp>> : public integral_constant<size_t, N> { };

template <size_t, typename> struct tuple_element;
template <size_t I, typename T, unsigned N, typename Cmp>
struct tuple_element<I, ZuArray<T, N, Cmp>> {
  using type = T;
};
}
namespace Zu_ {
using size_t = std::size_t;
namespace {
template <size_t I, typename T>
using tuple_element_t = typename std::tuple_element<I, T>::type;
}
template <size_t I, typename T, unsigned N, typename Cmp>
constexpr tuple_element_t<I, ArrayN<T, N, Cmp>> &
get(ArrayN<T, N, Cmp> &a) noexcept {
  return a[I];
}
template <size_t I, typename T, unsigned N, typename Cmp>
constexpr const tuple_element_t<I, ArrayN<T, N, Cmp>> &
get(const ArrayN<T, N, Cmp> &a) noexcept {
  return a[I];
}
template <size_t I, typename T, unsigned N, typename Cmp>
constexpr tuple_element_t<I, ArrayN<T, N, Cmp>> &&
get(ArrayN<T, N, Cmp> &&a) noexcept {
  return static_cast<tuple_element_t<I, ArrayN<T, N, Cmp>> &&>(a[I]);
}
template <size_t I, typename T, unsigned N, typename Cmp>
constexpr const tuple_element_t<I, ArrayN<T, N, Cmp>> &&
get(const ArrayN<T, N, Cmp> &&a) noexcept {
  return static_cast<const tuple_element_t<I, ArrayN<T, N, Cmp>> &&>(a[I]);
}
} // namespace Zu_

template <typename T> struct ZuMvArray_ { };
template <> struct ZuMvArray_<char> {
  friend ZuPrintString ZuPrintType(ZuMvArray_ *);
};

template <typename T_, typename Cmp_ = ZuCmp<T_>>
class ZuMvArray : public ZuMvArray_<ZuStrip<T_>>, public ZuArrayFn<T_, Cmp_> {
  ZuMvArray(const ZuMvArray &) = delete;
  ZuMvArray &operator=(const ZuMvArray &) = delete;

public:
  using T = T_;
  using Cmp = Cmp_;

  ZuMvArray() = default;

  ZuMvArray(unsigned n) :
    m_length{n},
    m_data{
      !n ? static_cast<T *>(nullptr) : static_cast<T *>(::malloc(n * sizeof(T)))
    } {
    if (__builtin_expect(!!(n && !m_data), 0)) throw std::bad_alloc();
    this->initItems(m_data, n);
  }
  ZuMvArray(T *data, unsigned n) :
    m_length{n},
    m_data{
      !n ? static_cast<T *>(nullptr) : static_cast<T *>(::malloc(n * sizeof(T)))
    } {
    if (__builtin_expect(!!(n && !m_data), 0)) throw std::bad_alloc();
    this->moveItems(m_data, data, n);
  }
  ~ZuMvArray() {
    if (!m_data) return;
    this->destroyItems(m_data, m_length);
    ::free(m_data);
  }

  ZuMvArray(ZuMvArray &&a) noexcept {
    m_length = a.m_length;
    m_data = a.m_data;
    a.m_length = 0;
    a.m_data = nullptr;
  }
  ZuMvArray &operator=(ZuMvArray &&a) noexcept {
    m_length = a.m_length;
    m_data = a.m_data;
    a.m_length = 0;
    a.m_data = nullptr;
    return *this;
  }

  T &operator[](unsigned i) { return m_data[i]; }
  const T &operator[](unsigned i) const { return m_data[i]; }

  unsigned length() const { return m_length; }

  T *data() { return m_data; }
  const T *data() const { return m_data; }

  T *release() && {
    auto ptr = m_data;
    m_length = 0;
    m_data = nullptr;
    return ptr;
  }
  void free(const T *ptr) { ::free(ptr); }

  void null() {
    ::free(m_data);
    m_length = 0;
    m_data = nullptr;
  }

  void length(unsigned newLength) {
    T *oldData = m_data;
    unsigned oldLength = m_length;
    m_length = newLength;
    m_data = static_cast<T *>(::malloc(newLength * sizeof(T)));
    unsigned mvLength = oldLength < newLength ? oldLength : newLength;
    unsigned initLength = newLength - mvLength;
    if (mvLength) this->moveItems(m_data, oldData, mvLength);
    if (initLength) this->initItems(m_data + mvLength, initLength);
    ::free(oldData);
  }

  bool operator!() const { return !m_length; }
  operator const void *() const {
    return !*this ? reinterpret_cast<const void *>(0) :
		    static_cast<const void *>(this);
  }

  template <bool Mutable = false, typename L> ZuIfT<!Mutable> all(L l) const {
    for (unsigned i = 0, n = m_length; i < n; i++) l(m_data[i]);
  }
  template <bool Mutable, typename L> ZuIfT<Mutable> all(L l) {
    for (unsigned i = 0, n = m_length; i < n; i++) l(m_data[i]);
  }

  using iterator = T *;
  using const_iterator = const T *;
  const T *begin() const { return m_data; }
  const T *end() const { return m_data + m_length; }
  const T *cbegin() const { return m_data; }
  const T *cend() const { return m_data + m_length; }
  T *begin() { return m_data; }
  T *end() { return m_data + m_length; }

protected:
  bool same(const ZuMvArray &a) const { return this == &a; }
  template <typename A> constexpr bool same(const A &) const { return false; }

  auto buf() { return ZuSpan{data(), length()}; }
  auto cbuf() const { return ZuSpan{data(), length()}; }

  template <typename A> bool equals(const A &a) const {
    return same(a) || cbuf().equals(a);
  }
  template <typename A> int cmp(const A &a) const {
    if (same(a)) return 0;
    return cbuf().cmp(a);
  }
  template <typename L, typename R>
  friend inline ZuIfT<ZuInspect<ZuMvArray, L>::Is, bool>
  operator==(const L &l, const R &r) {
    return l.equals(r);
  }
  template <typename L, typename R>
  friend inline ZuIfT<ZuInspect<ZuMvArray, L>::Is, int>
  operator<=>(const L &l, const R &r) {
    return l.cmp(r);
  }

  uint32_t hash() const { return ZuHash<ZuMvArray>::hash(*this); }

  struct Traits : public ZuBaseTraits<ZuMvArray> {
    using Elem = T;
    enum {
      IsArray = 1,
      IsPrimitive = 0,
      IsPOD = 0,
      IsString = bool{ZuIsExact<char, ZuDecay<T>>{}} ||
	bool{ZuIsExact<wchar_t, ZuDecay<T>>{}},
      IsWString = bool{ZuIsExact<wchar_t, ZuDecay<T>>{}}
    };
    static T *data(ZuMvArray &a) { return a.data(); }
    static const T *data(const ZuMvArray &a) { return a.data(); }
    static unsigned length(const ZuMvArray &a) { return a.length(); }
  };
  friend Traits ZuTraitsType(ZuMvArray *);

private:
  uint32_t m_length = 0;
  T *m_data = nullptr;
};

class

  __attribute__((aligned(Zm::CacheLineSize)))

  ZmSemaphore {
  ZmSemaphore(const ZmSemaphore &) = delete;
  ZmSemaphore &operator=(const ZmSemaphore &) = delete;

  enum { CacheLineSize = Zm::CacheLineSize };

public:
  ZmSemaphore() { sem_init(&m_sem, 0, 0); }
  ~ZmSemaphore() { sem_destroy(&m_sem); }

  void wait() {
    int r;
    do {
      r = sem_wait(&m_sem);
    } while (r < 0 &&

	     (*__errno_location())

	       ==

	       4

    );
  }
  int trywait() { return sem_trywait(&m_sem); }
  int timedwait(ZuTime timeout) {
    timespec timeout_{timeout.sec(), timeout.nsec()};
    do {
      if (!sem_timedwait(&m_sem, &timeout_)) return 0;
    } while (

      (*__errno_location())

      ==

      4

    );
    return -1;
  }
  void post() { sem_post(&m_sem); }

  void reset() {
    this->~ZmSemaphore();
    new (this) ZmSemaphore();
  }

private:
  sem_t m_sem;

  char m_pad_1[CacheLineSize - sizeof(sem_t)];
};

struct ZmRingFn_Defaults {
  static const char *HeapID() { return "ZmRingFn"; }
  enum { Sharded = false };
};

template <auto HeapID_, typename NTP = ZmRingFn_Defaults>
struct ZmRingFnHeapID : public NTP {
  static constexpr auto HeapID = HeapID_;
};

template <bool Sharded_, typename NTP = ZmRingFn_Defaults>
struct ZmRingFnSharded : public NTP {
  enum { Sharded = Sharded_ };
};

template <typename NTP = ZmRingFn_Defaults, typename... Args> class ZmRingFn_ {
  static constexpr uintptr_t OnHeap = (static_cast<uintptr_t>(1) << 63);

  typedef unsigned (*InvokeFn)(void *ptr, Args...);
  typedef void (*MoveFn)(void *dst, void *src, bool onHeap);
  typedef uintptr_t (*AllocFn)(uintptr_t ptr);

  static constexpr auto HeapID = NTP::HeapID;
  enum { Sharded = NTP::Sharded };

public:
  ZmRingFn_() = default;

  ZmRingFn_(const ZmRingFn_ &) = delete;
  ZmRingFn_ &operator=(const ZmRingFn_ &) = delete;

  ZmRingFn_(ZmRingFn_ &&fn) :
    m_invokeFn{fn.m_invokeFn}, m_moveFn{fn.m_moveFn}, m_allocFn{fn.m_allocFn},
    m_ptr{fn.m_ptr} {
    fn.clear();
    heapAlloc();
  }
  ZmRingFn_ &operator=(ZmRingFn_ &&fn) {
    this->~ZmRingFn_();
    new (this) ZmRingFn_{ZuMv(fn)};
    return *this;
  }

  template <
    typename L,
    decltype(ZuStatelessLambda<L, ZuTypeList<Args...>>(), int()) = 0>
  ZmRingFn_(L &l) :
    m_invokeFn{[](void *, Args... args) -> unsigned {
      try {
	ZuInvokeLambda<L, ZuTypeList<Args...>>(ZuFwd<Args>(args)...);
      } catch (...) { }
      return 0;
    }},
    m_moveFn{nullptr}, m_allocFn{[](uintptr_t) -> uintptr_t { return 0; }},
    m_ptr{0} { }

  template <
    typename L,
    decltype(ZuNotStatelessLambda<L, ZuTypeList<Args...>>(), int()) = 0>
  ZmRingFn_(L &l) :
    m_invokeFn{[](void *ptr_, Args... args) -> unsigned {
      auto ptr = static_cast<L *>(ptr_);
      try {
	(*ptr)(ZuFwd<Args>(args)...);
      } catch (...) { }
      ptr->~L();
      return sizeof(L);
    }},
    m_moveFn{[](void *dst, void *src_, bool onHeap) {
      using Cache = ZmHeapCacheT<HeapID, sizeof(L), alignof(L), Sharded>;
      auto src = static_cast<L *>(src_);
      new (dst) L{ZuMv(*src)};
      src->~L();
      if (__builtin_expect(!!(onHeap), 0)) Cache::free(src);
    }},
    m_allocFn{[](uintptr_t ptr_) -> uintptr_t {
      using Cache = ZmHeapCacheT<HeapID, sizeof(L), alignof(L), Sharded>;

      if (__builtin_expect(!!(!ptr_), 1)) return sizeof(L);

      if (__builtin_expect(!!(ptr_ == 1), 1))
	return reinterpret_cast<uintptr_t>(Cache::alloc());

      auto ptr = reinterpret_cast<L *>(ptr_);
      ptr->~L();
      Cache::free(ptr);
      return 0;
    }},
    m_ptr{reinterpret_cast<uintptr_t>(&l)} { }

  template <typename L> ZmRingFn_ &operator=(L l) {
    this->~ZmRingFn_();
    new (this) ZmRingFn_{l};
    heapAlloc();
    return *this;
  }

  ~ZmRingFn_() {
    if (__builtin_expect(!!(m_invokeFn && (m_ptr & OnHeap)), 0))
      m_allocFn(m_ptr & ~OnHeap);
  }

  bool operator!() const { return !m_invokeFn; }
  operator const void *() const {
    return !*this ? reinterpret_cast<const void *>(0) :
		    static_cast<const void *>(this);
  }

  unsigned pushSize() const { return sizeof(InvokeFn) + m_allocFn(0); }
  void push(void *dst_) {
    auto dst = reinterpret_cast<InvokeFn *>(dst_);
    *dst = m_invokeFn;
    if (__builtin_expect(!!(m_ptr), 0)) m_moveFn(&dst[1], ptr(), onHeap());
    clear();
  }

  template <typename... Args_>
  inline static unsigned invoke(void *ptr_, Args_ &&...args) {
    auto ptr = reinterpret_cast<InvokeFn *>(ptr_);
    return (**ptr)(static_cast<void *>(&ptr[1]), ZuFwd<Args_>(args)...) +
      sizeof(InvokeFn);
  }

private:
  void *ptr() const { return reinterpret_cast<void *>(m_ptr & ~OnHeap); }

  bool onHeap() const { return m_ptr & OnHeap; }

  void clear() { m_invokeFn = nullptr; }

  void heapAlloc() {
    if (__builtin_expect(!!(onHeap()), 1)) return;
    if (auto stackPtr = ptr()) {
      auto heapPtr = reinterpret_cast<void *>(m_allocFn(1));
      if (__builtin_expect(!!(!heapPtr), 0)) throw std::bad_alloc{};
      m_moveFn(heapPtr, stackPtr, false);
      m_ptr = reinterpret_cast<uintptr_t>(heapPtr) | OnHeap;
    }
  }

private:
  InvokeFn m_invokeFn = nullptr;
  MoveFn m_moveFn = nullptr;
  AllocFn m_allocFn = nullptr;
  uintptr_t m_ptr = 0;
};

template <typename Args, unsigned N = Args::N> struct ZmRingFn_MapArgs {
  static constexpr ZuFalse match(...);
  static constexpr ZuTrue match(ZmRingFn_Defaults *);

  using T = ZuIf<
    !N, ZmRingFn_<ZmRingFn_Defaults>,
    ZuIf<
      !decltype(match(ZuDeclVal<ZuType<N - 1, Args> *>())){},
      ZuTypeApply<
	ZmRingFn_, typename Args::template Unshift<ZmRingFn_Defaults>>,
      ZuTypeApply<
	ZmRingFn_,
	typename ZuTypeHead<N - 1, Args>::template Unshift<
	  ZuType<N - 1, Args>>>>>;
};

template <typename... Args>
using ZmRingFn = typename ZmRingFn_MapArgs<ZuTypeList<Args...>>::T;

class ZmTopology {
  ZmTopology(const ZmTopology &) = delete;
  ZmTopology &operator=(const ZmTopology &) = delete;

  ZmTopology();

public:
  ~ZmTopology();

private:
  static ZmTopology *instance();

public:
  static hwloc_topology_t hwloc() { return instance()->m_hwloc; }

  typedef void (*ErrorFn)(int);
  static void errorFn(ErrorFn fn);
  static void error(int errNo);

private:
  ZmPLock_ m_lock;
  hwloc_topology_t m_hwloc;
  ZmAtomic<ErrorFn> m_errorFn;
};

namespace ZmRing_ {

inline constexpr auto Defaults_SizeAxor() {
  return [](const void *) { return 0; };
}
struct Defaults {
  using T = void;
  static constexpr auto SizeAxor = Defaults_SizeAxor();
  enum { MW = 0 };
  enum { MR = 0 };
};

}

template <typename T> struct ZmRingT_SizeAxor {
  static constexpr auto Fn() {
    return [](const void *) { return sizeof(T); };
  }
};
template <typename T_, typename NTP = ZmRing_::Defaults>
struct ZmRingT : public NTP {
  using T = T_;
  static constexpr auto SizeAxor = ZmRingT_SizeAxor<T>::Fn();
};
template <typename NTP> struct ZmRingT<void, NTP> : public NTP {
  using T = void;
  static constexpr auto SizeAxor = ZmRing_::Defaults_SizeAxor();
};

template <auto SizeAxor_, typename NTP = ZmRing_::Defaults>
struct ZmRingSizeAxor : public NTP {
  static constexpr auto SizeAxor = SizeAxor_;
};

template <bool MW_, typename NTP = ZmRing_::Defaults>
struct ZmRingMW : public NTP {
  enum { MW = MW_ };
};

template <bool MR_, typename NTP = ZmRing_::Defaults>
struct ZmRingMR : public NTP {
  enum { MR = MR_ };
};

namespace ZmRing_ {

struct ParamData {
  unsigned size = 0;
  bool ll = false;
  ZmBitmap cpuset;
  unsigned spin = 1000;
  unsigned timeout = 1;

  inline const ParamData &data() { return *this; }
};

template <typename Derived, typename Data = ParamData>
class Params_ : public Data {
  using Base = Data;

  Derived &&derived() { return ZuMv(*static_cast<Derived *>(this)); }

public:
  Params_() = default;
  Params_(const Params_ &) = default;
  Params_(Params_ &&) = default;
  template <
    typename Arg0, typename... Args, typename = ZuIsNot<ParamData, Arg0>>
  Params_(Arg0 &&arg0, Args &&...args) :
    Base{ZuFwd<Arg0>(arg0), ZuFwd<Args>(args)...} { }
  Params_ &operator=(const Params_ &) = default;
  Params_ &operator=(Params_ &&) = default;

  Derived &&size(unsigned n) {
    Data::size = n;
    return derived();
  }
  Derived &&ll(bool b) {
    Data::ll = b;
    return derived();
  }
  Derived &&cpuset(ZmBitmap b) {
    Data::cpuset = ZuMv(b);
    return derived();
  }
  Derived &&spin(unsigned n) {
    Data::spin = n;
    return derived();
  }
  Derived &&timeout(unsigned n) {
    Data::timeout = n;
    return derived();
  }
};

class Params : public Params_<Params> {
  using Base = Params_<Params>;

public:
  Params() = default;
  Params(const Params &) = default;
  Params(Params &&) = default;
  template <
    typename Arg0, typename... Args, typename = ZuIsNot<ParamData, Arg0>>
  Params(Arg0 &&arg0, Args &&...args) :
    Base{ZuFwd<Arg0>(arg0), ZuFwd<Args>(args)...} { }
  Params &operator=(const Params &) = default;
  Params &operator=(Params &&) = default;
};

class Blocker {
public:
  using Params = ParamData;

  Blocker();
  ~Blocker();

  Blocker(const Blocker &blocker);
  Blocker &operator=(const Blocker &blocker) {
    if (this != &blocker) {
      this->~Blocker();
      new (this) Blocker{blocker};
    }
    return *this;
  }

  bool open(bool head, const Params &);
  void close();

  int wait(ZmAtomic<uint32_t> &addr, uint32_t val, const Params &params);

  void wake(ZmAtomic<uint32_t> &addr);

protected:
};

inline constexpr uint64_t EndOfFile() { return static_cast<uint64_t>(1) << 62; }
inline constexpr uint64_t Waiting() { return static_cast<uint64_t>(2) << 62; }
inline constexpr uint64_t Mask() { return EndOfFile() | Waiting(); }
inline constexpr uint64_t RdrMask() {
  return ~(static_cast<uint64_t>(3) << 62);
}
enum { MaxRdrs = 62 };

enum { Flags32Offset = 1 };

inline constexpr uint32_t Wrapped32() { return static_cast<uint32_t>(1) << 28; }
inline constexpr uint32_t Locked32() { return static_cast<uint32_t>(2) << 28; }
inline constexpr uint32_t EndOfFile32() {
  return static_cast<uint32_t>(4) << 28;
}
inline constexpr uint32_t Waiting32() { return static_cast<uint32_t>(8) << 28; }
inline constexpr uint32_t Mask32() {
  return Locked32() | EndOfFile32() | Waiting32();
}

class CtrlMem {
public:
  using Params = ParamData;

  CtrlMem() = default;
  CtrlMem(const CtrlMem &mem) :
    m_addr{mem.m_addr}, m_size{mem.m_size}, m_shadow{true} { }
  ~CtrlMem() { close(); }

  bool open(unsigned size, const Params &params);
  void close();

  inline const void *addr() const { return m_addr; }
  inline void *addr() { return m_addr; }

protected:
  void *m_addr = nullptr;
  unsigned m_size = 0;
  bool m_shadow = false;
};

template <bool MR> struct Ctrl {
  ZmAtomic<uint32_t> head;
  uint32_t pad_1;
  ZmAtomic<uint64_t> inCount;
  ZmAtomic<uint64_t> inBytes;
  char pad_2[Zm::CacheLineSize - 24];

  ZmAtomic<uint32_t> tail;
  uint32_t pad_3;
  ZmAtomic<uint64_t> outCount;
  ZmAtomic<uint64_t> outBytes;
  char pad_4[Zm::CacheLineSize - 24];
};

template <> struct Ctrl<true> : public Ctrl<false> {
  ZmAtomic<uint32_t> rdrCount;
  uint32_t pad_5;
  ZmAtomic<uint64_t> rdrMask;
  ZmAtomic<uint64_t> attMask;
  ZmAtomic<uint64_t> attSeqNo;
};

template <typename CtrlMem_, typename Ctrl_, bool MR> class CtrlMgr_ {
protected:
  using CtrlMem = CtrlMem_;
  using Params = typename CtrlMem::Params;
  using Ctrl = Ctrl_;

  CtrlMgr_() = default;
  CtrlMgr_(const CtrlMgr_ &mgr) : m_ctrl{mgr.m_ctrl} { }

  bool openCtrl(const Params &params) {
    return m_ctrl.open(sizeof(Ctrl), params);
  }
  void closeCtrl() { m_ctrl.close(); }

public:
  constexpr unsigned ctrlSize() const { return sizeof(Ctrl); }

  inline const Ctrl *ctrl() const {
    return static_cast<const Ctrl *>(m_ctrl.addr());
  }
  inline Ctrl *ctrl() { return static_cast<Ctrl *>(m_ctrl.addr()); }

protected:
  inline const ZmAtomic<uint32_t> &head() const { return ctrl()->head; }
  inline ZmAtomic<uint32_t> &head() { return ctrl()->head; }

  inline const ZmAtomic<uint32_t> &tail() const { return ctrl()->tail; }
  inline ZmAtomic<uint32_t> &tail() { return ctrl()->tail; }

  inline const ZmAtomic<uint64_t> &inCount() const { return ctrl()->inCount; }
  inline ZmAtomic<uint64_t> &inCount() { return ctrl()->inCount; }
  inline const ZmAtomic<uint64_t> &inBytes() const { return ctrl()->inBytes; }
  inline ZmAtomic<uint64_t> &inBytes() { return ctrl()->inBytes; }
  inline const ZmAtomic<uint64_t> &outCount() const { return ctrl()->outCount; }
  inline ZmAtomic<uint64_t> &outCount() { return ctrl()->outCount; }
  inline const ZmAtomic<uint64_t> &outBytes() const { return ctrl()->outBytes; }
  inline ZmAtomic<uint64_t> &outBytes() { return ctrl()->outBytes; }

  ZmAtomic<uint32_t> &rdrCount();
  const ZmAtomic<uint32_t> &rdrCount() const;
  ZmAtomic<uint64_t> &rdrMask();
  const ZmAtomic<uint64_t> &rdrMask() const;
  ZmAtomic<uint64_t> &attMask();
  const ZmAtomic<uint64_t> &attMask() const;
  ZmAtomic<uint64_t> &attSeqNo();
  const ZmAtomic<uint64_t> &attSeqNo() const;

private:
  CtrlMem m_ctrl;
};
template <typename CtrlMem_, typename Ctrl_>
class CtrlMgr_<CtrlMem_, Ctrl_, true> :
  public CtrlMgr_<CtrlMem_, Ctrl_, false> {
protected:
  using CtrlMem = CtrlMem_;
  using Ctrl = Ctrl_;

private:
  using Base = CtrlMgr_<CtrlMem, Ctrl, false>;

public:
  using Base::ctrl;

  CtrlMgr_() = default;
  CtrlMgr_(const CtrlMgr_ &mgr) : Base{mgr} { }

protected:
  inline ZmAtomic<uint32_t> &rdrCount() { return ctrl()->rdrCount; }
  inline const ZmAtomic<uint32_t> &rdrCount() const { return ctrl()->rdrCount; }
  inline ZmAtomic<uint64_t> &rdrMask() { return ctrl()->rdrMask; }
  inline const ZmAtomic<uint64_t> &rdrMask() const { return ctrl()->rdrMask; }
  inline ZmAtomic<uint64_t> &attMask() { return ctrl()->attMask; }
  inline const ZmAtomic<uint64_t> &attMask() const { return ctrl()->attMask; }
  inline ZmAtomic<uint64_t> &attSeqNo() { return ctrl()->attSeqNo; }
  inline const ZmAtomic<uint64_t> &attSeqNo() const { return ctrl()->attSeqNo; }
};
template <typename CtrlMem, bool MR>
using CtrlMgr = CtrlMgr_<CtrlMem, Ctrl<MR>, MR>;

template <bool MW, bool MR> struct AlignFn {
  static constexpr unsigned align(unsigned n) { return (((n) + 8 + 15) & ~15); }
};
template <> struct AlignFn<false, false> {
  static constexpr unsigned align(unsigned n) { return (((n) + 15) & ~15); }
};

class DataMem {
public:
  using Params = ParamData;

  DataMem() = default;
  DataMem(const DataMem &mem) :
    m_addr{mem.m_addr}, m_size{mem.m_size}, m_shadow{true} { }
  ~DataMem() { close(); }

  bool open(unsigned size, const Params &params);
  void close();

  inline const void *addr() const { return m_addr; }
  inline void *addr() { return m_addr; }

private:
  void *m_addr = nullptr;
  unsigned m_size = 0;
  bool m_shadow = false;
};

class MirrorMem {
public:
  using Params = ParamData;

  MirrorMem() = default;
  MirrorMem(const MirrorMem &mem) :
    m_handle{nullHandle()}, m_addr{mem.m_addr}, m_size{mem.m_size} { }
  ~MirrorMem() { close(); }

  static unsigned alignSize(unsigned size);

  bool open(unsigned size, const Params &params);
  void close();

  inline const void *addr() const { return m_addr; }
  inline void *addr() { return m_addr; }

private:
  using Handle = int;
  static constexpr Handle nullHandle() { return -1; }
  bool nullHandle(Handle i) { return i < 0; }

  Handle m_handle = nullHandle();
  void *m_addr = nullptr;
  unsigned m_size = 0;
};

template <typename DataMem_> class DataMgr_ {
protected:
  using DataMem = DataMem_;
  using Params = typename DataMem::Params;

  DataMgr_() = default;
  DataMgr_(const DataMgr_ &ring) : m_data{ring.m_data} { }

  bool openData(unsigned size, const Params &params) {
    return m_data.open(size, params);
  }
  void closeData() { m_data.close(); }

public:
  inline const uint8_t *data() const {
    return reinterpret_cast<const uint8_t *>(m_data.addr());
  }
  inline uint8_t *data() { return reinterpret_cast<uint8_t *>(m_data.addr()); }

private:
  DataMem m_data;
};

template <typename DataMem_, typename MirrorMem_, typename T, bool MW, bool MR>
class DataMgr : public DataMgr_<DataMem_> {
protected:
  using DataMem = DataMem_;
  using Params = typename DataMem::Params;

private:
  using Base = DataMgr_<DataMem>;

public:
  enum { MsgSize = AlignFn<MW, MR>::align(sizeof(T)) };

protected:
  DataMgr() = default;
  DataMgr(const DataMgr &ring) : Base{ring} { }

  static constexpr unsigned alignSize(unsigned n) {
    return ((n + (MsgSize << 1) - 1) / MsgSize) * MsgSize;
  }
};
template <typename DataMem_, typename MirrorMem_, bool MW, bool MR>
class DataMgr<DataMem_, MirrorMem_, void, MW, MR> :
  public DataMgr_<MirrorMem_> {
protected:
  using DataMem = MirrorMem_;

private:
  using Base = DataMgr_<DataMem>;

protected:
  enum { MsgSize = 0 };

  DataMgr() = default;
  DataMgr(const DataMgr &ring) : Base{ring} { }

  static unsigned alignSize(unsigned n) { return DataMem::alignSize(n); }
};

template <typename Ring, bool MW, bool MR> class RingExt {
  Ring *ring() { return static_cast<Ring *>(this); }
  const Ring *ring() const { return static_cast<const Ring *>(this); }

public:
  using Friend = RingExt;

  RingExt() = default;

  RingExt(const RingExt &) = default;
  RingExt &operator=(const RingExt &ring) = default;

  RingExt(RingExt &&) = delete;
  RingExt &operator=(RingExt &&) = delete;

  int attach();
  void detach();

  int rdrID() const { return 0; }

protected:
  uint32_t openSize_(uint32_t size) { return size; }

  bool open_() { return true; }
  void close_() { }

  static constexpr unsigned gc() { return 0; }

  void rdrID(int);

  uint32_t rdrTail() const;
  void rdrTail(uint32_t);

  constexpr void attached(unsigned) { }
  constexpr void detached(unsigned) { }
};

template <typename Ring, bool MW> class RingExt<Ring, MW, true> {
  Ring *ring() { return static_cast<Ring *>(this); }
  const Ring *ring() const { return static_cast<const Ring *>(this); }

public:
  using Friend = RingExt;

  RingExt() = default;

  RingExt(const RingExt &) = default;
  RingExt &operator=(const RingExt &ring) = default;

  RingExt(RingExt &&) = delete;
  RingExt &operator=(RingExt &&) = delete;

  int attach();
  void detach();

  int rdrID() const { return m_rdrID; }

protected:
  uint32_t openSize_(uint32_t size) { return size; }

  bool open_();
  void close_();

  static constexpr unsigned gc() { return 0; }

  void rdrID(int v) { m_rdrID = v; }

  uint32_t rdrTail() const { return m_rdrTail; }
  void rdrTail(uint32_t v) { m_rdrTail = v; }

  constexpr void attached(unsigned) { }
  constexpr void detached(unsigned) { }

private:
  int m_rdrID = -1;
  uint32_t m_rdrTail = 0;
};

template <
  typename NTP = Defaults, typename ParamData_ = ParamData,
  typename Blocker_ = Blocker, typename CtrlMgr_ = CtrlMgr<CtrlMem, NTP::MR>,
  typename DataMgr_ =
    DataMgr<DataMem, MirrorMem, typename NTP::T, NTP::MW, NTP::MR>,
  template <typename, bool, bool> typename RingExt_ = RingExt>
class Ring :
  public AlignFn<NTP::MW, NTP::MR>,
  public CtrlMgr_,
  public DataMgr_,
  public RingExt_<
    Ring<NTP, ParamData_, Blocker_, CtrlMgr_, DataMgr_, RingExt_>, NTP::MW,
    NTP::MR> {
public:
  using T = typename NTP::T;
  enum { MW = NTP::MW };
  enum { MR = NTP::MR };

protected:
  using ParamData = ParamData_;
  using Blocker = Blocker_;
  using CtrlMgr = CtrlMgr_;
  using DataMgr = DataMgr_;
  using RingExt = RingExt_<Ring, MW, MR>;
  friend RingExt;
  friend typename RingExt::Friend;

private:
  using AlignFn = ZmRing_::AlignFn<MW, MR>;

public:
  static constexpr auto SizeAxor = NTP::SizeAxor;
  enum { V = ZuInspect<void, T>::Same };
  enum { MsgSize = DataMgr_::MsgSize };

  static_assert(
    ((!MR || !ZuInspect<decltype(Defaults::SizeAxor), decltype(SizeAxor)>::Same)
    ),
    "(!MR || !ZuInspect<decltype(Defaults::SizeAxor), "
    "decltype(SizeAxor)>::Same)"
  );

  enum { Read = 0x00000001, Write = 0x00000002, Shadow = 0x00000004 };

  Ring() = default;

  template <typename Params, typename... Args, typename = ZuIsNot<Ring, Params>>
  Ring(Params params, Args &&...args) : m_params{ZuMv(params)} { }

  Ring(const Ring &ring) :
    CtrlMgr{ring}, DataMgr{ring}, RingExt{ring}, m_params{ring.m_params},
    m_headBlocker{ring.m_headBlocker}, m_tailBlocker{ring.m_tailBlocker},
    m_flags{Shadow}, m_size{ring.m_size} { }
  Ring &operator=(const Ring &ring) {
    if (this != &ring) {
      this->~Ring();
      new (this) Ring{ring};
    }
    return *this;
  }

  Ring(Ring &&) = delete;
  Ring &operator=(Ring &&) = delete;

  ~Ring() { close(); }

  template <typename Params> void init(Params params) {
    m_params = ZuMv(params);
  }

  auto &params() { return m_params; }
  const auto &params() const { return m_params; }

  auto &headBlocker() { return m_headBlocker; }
  const auto &headBlocker() const { return m_headBlocker; }
  auto &tailBlocker() { return m_tailBlocker; }
  const auto &tailBlocker() const { return m_tailBlocker; }

  uint32_t flags() const { return m_flags; }

  unsigned size() const { return m_size; }
  static constexpr unsigned ctrlSize() { return sizeof(Ctrl); }

  unsigned full() const { return m_full; }

private:
  using AlignFn::align;

  using Ctrl = typename CtrlMgr_::Ctrl;

private:
  using CtrlMgr::openCtrl;
  using CtrlMgr::closeCtrl;

public:
  using CtrlMgr::ctrl;

private:
  using CtrlMgr::head;
  using CtrlMgr::tail;
  using CtrlMgr::inCount;
  using CtrlMgr::inBytes;
  using CtrlMgr::outCount;
  using CtrlMgr::outBytes;
  using CtrlMgr::rdrCount;
  using CtrlMgr::rdrMask;
  using CtrlMgr::attMask;
  using CtrlMgr::attSeqNo;

private:
  using DataMgr::openData;
  using DataMgr::closeData;
  using DataMgr::alignSize;

public:
  using DataMgr::data;

  using RingExt::attach;
  using RingExt::detach;
  using RingExt::rdrID;

private:
  using RingExt::rdrTail;
  using RingExt::openSize_;
  using RingExt::open_;
  using RingExt::close_;
  using RingExt::gc;

public:
  int open(unsigned flags) {
    flags &= (Read | Write);
    if (m_flags & Shadow) {
      if (m_flags & (Read | Write)) {
	if ((m_flags & (Read | Write)) == flags) return Zu::OK;
	return Zu::IOError;
      }
    } else {
      if (ctrl()) return Zu::OK;
      if (!m_headBlocker.open(true, m_params)) return Zu::IOError;
      if (!m_tailBlocker.open(false, m_params)) {
	m_headBlocker.close();
	return Zu::IOError;
      }
      m_flags = flags;
      if (!openCtrl(params())) {
	m_headBlocker.close();
	m_tailBlocker.close();
	m_flags = 0;
	return Zu::IOError;
      }
      m_size = openSize_(params().size ? alignSize(params().size) : 0);
      if (!m_size) return Zu::IOError;
      if (!openData(m_size, params())) {
	closeCtrl();
	m_headBlocker.close();
	m_tailBlocker.close();
	m_flags = 0;
	m_size = 0;
	return Zu::IOError;
      }
    }
    m_flags |= flags;
    if (!open_()) {
      m_flags &= ~(Read | Write);
      closeCtrl();
      closeData();
      m_headBlocker.close();
      m_tailBlocker.close();
      m_flags = 0;
      m_size = 0;
      return Zu::IOError;
    }
    if (flags & Write) {
      eof(false);
      gc();
    }
    return Zu::OK;
  }

  void close() {
    if (!ctrl()) return;
    close_();
    m_flags &= ~(Read | Write);
    closeCtrl();
    closeData();
    m_headBlocker.close();
    m_tailBlocker.close();
    m_flags = 0;
    m_size = 0;
  }

  int reset() {
    if (!ctrl()) return Zu::IOError;
    auto flags = (m_flags & (Read | Write));
    close_();
    m_flags &= ~(Read | Write);
    ZuGuard guard([this, flags]() {
      m_flags |= flags;
      open_();
    });
    if constexpr (MR) {
      if (rdrMask()) return Zu::NotReady;
    }
    memset(static_cast<void *>(ctrl()), 0, sizeof(Ctrl));
    memset(data(), 0, m_size);
    m_full = 0;
    return Zu::OK;
  }

  unsigned length() {
    uint32_t head = this->head().load_() & ~Mask32();
    uint32_t tail = this->tail().load_() & ~Mask32();
    if (head == tail) return 0;
    if ((head ^ tail) == Wrapped32()) return size();
    head &= ~Wrapped32();
    tail &= ~Wrapped32();
    if (head > tail) return head - tail;
    return size() - (tail - head);
  }

  uint32_t head_() const { return this->head().load_(); }
  uint32_t tail_() const {
    if constexpr (MR)
      return rdrTail();
    else
      return this->tail().load_();
  }

  template <bool V_ = V> inline ZuIfT<!V_, void *> push() { return push_<1>(); }
  template <bool V_ = V> inline ZuIfT<V_, void *> push(unsigned size) {
    return push_<1>(size);
  }
  template <bool V_ = V> inline ZuIfT<!V_, void *> tryPush() {
    return push_<0>();
  }
  template <bool V_ = V> inline ZuIfT<V_, void *> tryPush(unsigned size) {
    return push_<0>(size);
  }

private:
  template <bool V_ = V>
  ZuIfT<!V_, bool> pushFull(uint32_t head, uint32_t tail) {
    head &= ~Mask32();
    tail &= ~Mask32();
    if constexpr (MW || MR) {
      head += MsgSize;
      if (__builtin_expect(
	    !!((head & ~(Wrapped32() | Mask32())) >= this->size()), 0
	  ))
	head = (head ^ Wrapped32()) - this->size();
    }
    return __builtin_expect(!!((head ^ tail) == Wrapped32()), 0);
  }
  template <bool V_ = V>
  ZuIfT<V_, bool> pushFull(uint32_t head, uint32_t tail, unsigned size) {
    head &= ~Mask32();
    tail &= ~Mask32();
    if (__builtin_expect(!!(head == tail), 0)) return false;
    bool wrapped = (head ^ tail) & Wrapped32();
    head &= ~Wrapped32();
    tail &= ~Wrapped32();
    if (wrapped) head += this->size();
    if constexpr (MW || MR) size += 8;
    head += size;
    return (head - tail) >= this->size();
  }

  void writeAssert() {
    ((ctrl()) ?
       void() :
       ZmAssert_fail(
	 "ctrl()", "../../zm/src/zlib/ZmRing.hh", 846, __PRETTY_FUNCTION__
       ));
    ((m_flags & Write) ? void() :
			 ZmAssert_fail(
			   "m_flags & Write", "../../zm/src/zlib/ZmRing.hh",
			   847, __PRETTY_FUNCTION__
			 ));
  }

  unsigned alignAssert(unsigned size) {
    size = align(size);
    ((size < this->size()) ?
       void() :
       ZmAssert_fail(
	 "size < this->size()", "../../zm/src/zlib/ZmRing.hh", 852,
	 __PRETTY_FUNCTION__
       ));
    return size;
  }

  template <uint64_t Flags = 0, bool MW_ = MW, bool MR_ = MR>
  ZuIfT<!MW_ && !MR_> wakeReaders(uint32_t head) {
    head = (head & ~Waiting32()) | static_cast<uint32_t>(Flags >> 32);
    if (__builtin_expect(!!(this->head().xch(head) & Waiting32()), 0))
      m_headBlocker.wake(this->head());
  }

  template <uint64_t Flags = 0, bool MW_ = MW, bool MR_ = MR>
  ZuIfT<MW_ || MR_> wakeReaders(uint32_t head) {
    wakeReaders_<Flags>(reinterpret_cast<ZmAtomic<uint64_t> *>(&(data()
    )[head & ~(Wrapped32() | Mask32())]));
  }

  template <uint64_t Flags = 0, bool MR_ = MR>
  ZuIfT<MR_> wakeReaders_(ZmAtomic<uint64_t> *hdrPtr) {
    uint64_t rdrMask;
    if constexpr (Flags & EndOfFile())
      rdrMask = 0;
    else
      rdrMask = this->rdrMask().load_();
    if (__builtin_expect(!!((hdrPtr->xch(Flags | rdrMask)) & Waiting()), 0)) {
      auto &hdrPtr32 =
	reinterpret_cast<ZmAtomic<uint32_t> *>(hdrPtr)[Flags32Offset];
      m_headBlocker.wake(hdrPtr32);
    }
  }

  template <
    uint64_t Flags = 0, bool MR_ = MR,
    uint64_t RdrMask = !(Flags & EndOfFile())>
  ZuIfT<!MR_> wakeReaders_(ZmAtomic<uint64_t> *hdrPtr) {
    if (__builtin_expect(!!(hdrPtr->xch(Flags | RdrMask) & Waiting()), 0)) {
      auto &hdrPtr32 =
	reinterpret_cast<ZmAtomic<uint32_t> *>(hdrPtr)[Flags32Offset];
      m_headBlocker.wake(hdrPtr32);
    }
  }

  template <bool Wait, bool MW_ = MW, bool MR_ = MR, bool V_ = V>
  ZuIfT<!MW_ && !MR_ && !V_, void *> push_() {
    writeAssert();
retry:
    uint32_t head = this->head().load_();
    if (__builtin_expect(!!(head & EndOfFile32()), 0)) return nullptr;
    uint32_t tail = this->tail();
    if (pushFull(head, tail)) do {
	++m_full;
	if (gc() > 0) goto retry;
	if constexpr (!Wait) return nullptr;
	if (__builtin_expect(!!(!params().ll), 0)) {
	  if (this->tail().cmpXch(tail | Waiting32(), tail) != tail) goto retry;
	  tail |= Waiting32();
	  if (m_tailBlocker.wait(this->tail(), tail, params()) != Zu::OK)
	    return nullptr;
	}
	goto retry;
      } while (0);
    return &(data())[head & ~(Wrapped32() | Mask32())];
  }

public:
  template <bool MW_ = MW, bool MR_ = MR, bool V_ = V>
  ZuIfT<!MW_ && !MR_ && !V_> push2() {
    writeAssert();
    uint32_t head = this->head().load_();
    ;
    head += MsgSize;
    if (__builtin_expect(
	  !!((head & ~(Wrapped32() | Mask32())) >= this->size()), 0
	))
      head = (head ^ Wrapped32()) - this->size();
    ;
    wakeReaders(head);
    inCount().store_(inCount().load_() + 1);
    inBytes().store_(inBytes().load_() + MsgSize);
  }

private:
  template <bool Wait, bool MW_ = MW, bool MR_ = MR, bool V_ = V>
  ZuIfT<!MW_ && !MR_ && V_, void *> push_(unsigned size) {
    writeAssert();
    size = alignAssert(size);
retry:
    uint32_t head = this->head().load_();
    if (__builtin_expect(!!(head & EndOfFile32()), 0)) return nullptr;
    uint32_t tail = this->tail();
    if (pushFull(head, tail, size)) do {
	++m_full;
	if (gc() > 0) goto retry;
	if constexpr (!Wait) return nullptr;
	if (__builtin_expect(!!(!params().ll), 0)) {
	  if (this->tail().cmpXch(tail | Waiting32(), tail) != tail) goto retry;
	  tail |= Waiting32();
	  if (m_tailBlocker.wait(this->tail(), tail, params()) != Zu::OK)
	    return nullptr;
	}
	goto retry;
      } while (0);
    return &(data())[head & ~(Wrapped32() | Mask32())];
  }

public:
  template <bool MW_ = MW, bool MR_ = MR, bool V_ = V>
  ZuIfT<!MW_ && !MR_ && V_> push2(unsigned size) {
    writeAssert();
    size = alignAssert(size);
    uint32_t head = this->head().load_();
    ;
    head += size;
    if (__builtin_expect(
	  !!((head & ~(Wrapped32() | Mask32())) >= this->size()), 0
	))
      head = (head ^ Wrapped32()) - this->size();
    ;
    wakeReaders(head);
    inCount().store_(inCount().load_() + 1);
    inBytes().store_(inBytes().load_() + size);
  }

private:
  template <bool Wait, bool MW_ = MW, bool MR_ = MR, bool V_ = V>
  ZuIfT<!MW_ && MR_ && !V_, void *> push_() {
    writeAssert();
retry:
    if (!this->rdrMask().load_()) return nullptr;
    uint32_t head = this->head().load_();
    if (__builtin_expect(!!(head & EndOfFile32()), 0)) return nullptr;
    uint32_t tail = this->tail();
    if (pushFull(head, tail)) do {
	++m_full;
	if (gc() > 0) goto retry;
	if constexpr (!Wait) return nullptr;
	if (__builtin_expect(!!(!params().ll), 0)) {
	  if (this->tail().cmpXch(tail | Waiting32(), tail) != tail) goto retry;
	  tail |= Waiting32();
	  if (m_tailBlocker.wait(this->tail(), tail, params()) != Zu::OK)
	    return nullptr;
	}
	goto retry;
      } while (0);
    auto ptr =
      reinterpret_cast<uint64_t *>(&(data())[head & ~(Wrapped32() | Mask32())]);
    return &ptr[1];
  }

public:
  template <bool MW_ = MW, bool MR_ = MR, bool V_ = V>
  ZuIfT<!MW_ && MR_ && !V_> push2() {
    writeAssert();
    uint32_t head = this->head().load_();
    ;
    auto head_ = head;
    head += MsgSize;
    if (__builtin_expect(
	  !!((head & ~(Wrapped32() | Mask32())) >= this->size()), 0
	))
      head = (head ^ Wrapped32()) - this->size();
    *reinterpret_cast<uint64_t *>(&(data())[head & ~(Wrapped32() | Mask32())]) =
      0;
    this->head() = head;
    wakeReaders(head_);
    inCount().store_(inCount().load_() + 1);
    inBytes().store_(inBytes().load_() + MsgSize);
  }

private:
  template <bool Wait, bool MW_ = MW, bool MR_ = MR, bool V_ = V>
  ZuIfT<!MW_ && MR_ && V_, void *> push_(unsigned size) {
    writeAssert();
    size = alignAssert(size);
retry:
    if (!this->rdrMask().load_()) return nullptr;
    uint32_t head = this->head().load_();
    if (__builtin_expect(!!(head & EndOfFile32()), 0)) return nullptr;
    uint32_t tail = this->tail();
    if (pushFull(head, tail, size)) do {
	++m_full;
	if (gc() > 0) goto retry;
	if constexpr (!Wait) return nullptr;
	if (__builtin_expect(!!(!params().ll), 0)) {
	  if (this->tail().cmpXch(tail | Waiting32(), tail) != tail) goto retry;
	  tail |= Waiting32();
	  if (m_tailBlocker.wait(this->tail(), tail, params()) != Zu::OK)
	    return nullptr;
	}
	goto retry;
      } while (0);
    auto ptr =
      reinterpret_cast<uint64_t *>(&(data())[head & ~(Wrapped32() | Mask32())]);
    return &ptr[1];
  }

public:
  template <bool MW_ = MW, bool MR_ = MR, bool V_ = V>
  ZuIfT<!MW_ && MR_ && V_> push2(unsigned size) {
    writeAssert();
    size = alignAssert(size);
    uint32_t head = this->head().load_();
    ;
    auto head_ = head;
    head += size;
    if (__builtin_expect(
	  !!((head & ~(Wrapped32() | Mask32())) >= this->size()), 0
	))
      head = (head ^ Wrapped32()) - this->size();
    *reinterpret_cast<uint64_t *>(&(data())[head & ~(Wrapped32() | Mask32())]) =
      0;
    this->head() = head;
    wakeReaders(head_);
    inCount().store_(inCount().load_() + 1);
    inBytes().store_(inBytes().load_() + size);
  }

private:
  template <bool Wait, bool MW_ = MW, bool MR_ = MR, bool V_ = V>
  ZuIfT<MW_ && !MR_ && !V_, void *> push_() {
    writeAssert();
retry:
    uint32_t head = this->head().load_();
    if (__builtin_expect(!!(head & Locked32()), 0)) goto retry;
    if (__builtin_expect(!!(head & EndOfFile32()), 0)) return nullptr;
    uint32_t tail = this->tail();
    if (pushFull(head, tail)) do {
	++m_full;
	if (gc() > 0) goto retry;
	if constexpr (!Wait) return nullptr;
	if (__builtin_expect(!!(!params().ll), 0)) {
	  if (this->tail().cmpXch(tail | Waiting32(), tail) != tail) goto retry;
	  tail |= Waiting32();
	  if (m_tailBlocker.wait(this->tail(), tail, params()) != Zu::OK)
	    return nullptr;
	}
	goto retry;
      } while (0);
    auto head_ = head;
    head += MsgSize;
    if (__builtin_expect(
	  !!((head & ~(Wrapped32() | Mask32())) >= this->size()), 0
	))
      head = (head ^ Wrapped32()) - this->size();
    if (__builtin_expect(
	  !!(this->head().cmpXch(head | Locked32(), head_) != head_), 0
	))
      goto retry;
    *reinterpret_cast<uint64_t *>(&(data())[head & ~(Wrapped32() | Mask32())]) =
      0;
    this->head() = head;
    auto ptr = reinterpret_cast<uint64_t *>(&(data()
    )[head_ & ~(Wrapped32() | Mask32())]);
    return &ptr[1];
  }

public:
  template <bool MW_ = MW, bool MR_ = MR, bool V_ = V>
  ZuIfT<MW_ && !MR_ && !V_> push2(void *ptr) {
    writeAssert();
    uint32_t head =
      static_cast<uint32_t>((reinterpret_cast<uint8_t *>(ptr) - 8) - data());
    wakeReaders(head);
    inCount().store_(inCount().load_() + 1);
    inBytes().store_(inBytes().load_() + MsgSize);
  }

private:
  template <bool Wait, bool MW_ = MW, bool MR_ = MR, bool V_ = V>
  ZuIfT<MW_ && !MR_ && V_, void *> push_(unsigned size) {
    writeAssert();
    size = alignAssert(size);
retry:
    uint32_t head = this->head().load_();
    if (__builtin_expect(!!(head & Locked32()), 0)) goto retry;
    if (__builtin_expect(!!(head & EndOfFile32()), 0)) return nullptr;
    uint32_t tail = this->tail();
    if (pushFull(head, tail, size)) do {
	++m_full;
	if (gc() > 0) goto retry;
	if constexpr (!Wait) return nullptr;
	if (__builtin_expect(!!(!params().ll), 0)) {
	  if (this->tail().cmpXch(tail | Waiting32(), tail) != tail) goto retry;
	  tail |= Waiting32();
	  if (m_tailBlocker.wait(this->tail(), tail, params()) != Zu::OK)
	    return nullptr;
	}
	goto retry;
      } while (0);
    auto head_ = head;
    head += size;
    if (__builtin_expect(
	  !!((head & ~(Wrapped32() | Mask32())) >= this->size()), 0
	))
      head = (head ^ Wrapped32()) - this->size();
    if (__builtin_expect(
	  !!(this->head().cmpXch(head | Locked32(), head_) != head_), 0
	))
      goto retry;
    *reinterpret_cast<uint64_t *>(&(data())[head & ~(Wrapped32() | Mask32())]) =
      0;
    this->head() = head;
    auto ptr = reinterpret_cast<uint64_t *>(&(data()
    )[head_ & ~(Wrapped32() | Mask32())]);
    return &ptr[1];
  }

public:
  template <bool MW_ = MW, bool MR_ = MR, bool V_ = V>
  ZuIfT<MW_ && !MR_ && V_> push2(void *ptr, unsigned size) {
    writeAssert();
    size = alignAssert(size);
    uint32_t head =
      static_cast<uint32_t>((reinterpret_cast<uint8_t *>(ptr) - 8) - data());
    wakeReaders(head);
    inCount().store_(inCount().load_() + 1);
    inBytes().store_(inBytes().load_() + size);
  }

private:
  template <bool Wait, bool MW_ = MW, bool MR_ = MR, bool V_ = V>
  ZuIfT<MW_ && MR_ && !V_, void *> push_() {
    writeAssert();
retry:
    if (!this->rdrMask().load_()) return nullptr;
    uint32_t head = this->head().load_();
    if (__builtin_expect(!!(head & Locked32()), 0)) goto retry;
    if (__builtin_expect(!!(head & EndOfFile32()), 0)) return nullptr;
    uint32_t tail = this->tail();
    if (pushFull(head, tail)) do {
	++m_full;
	if (gc() > 0) goto retry;
	if constexpr (!Wait) return nullptr;
	if (__builtin_expect(!!(!params().ll), 0)) {
	  if (this->tail().cmpXch(tail | Waiting32(), tail) != tail) goto retry;
	  tail |= Waiting32();
	  if (m_tailBlocker.wait(this->tail(), tail, params()) != Zu::OK)
	    return nullptr;
	}
	goto retry;
      } while (0);
    auto head_ = head;
    head += MsgSize;
    if (__builtin_expect(
	  !!((head & ~(Wrapped32() | Mask32())) >= this->size()), 0
	))
      head = (head ^ Wrapped32()) - this->size();
    if (__builtin_expect(
	  !!(this->head().cmpXch(head | Locked32(), head_) != head_), 0
	))
      goto retry;
    *reinterpret_cast<uint64_t *>(&(data())[head & ~(Wrapped32() | Mask32())]) =
      0;
    this->head() = head;
    auto ptr = reinterpret_cast<uint64_t *>(&(data()
    )[head_ & ~(Wrapped32() | Mask32())]);
    return &ptr[1];
  }

public:
  template <bool MW_ = MW, bool MR_ = MR, bool V_ = V>
  ZuIfT<MW_ && MR_ && !V_> push2(void *ptr) {
    writeAssert();
    uint32_t head =
      static_cast<uint32_t>((reinterpret_cast<uint8_t *>(ptr) - 8) - data());
    wakeReaders(head);
    inCount().store_(inCount().load_() + 1);
    inBytes().store_(inBytes().load_() + MsgSize);
  }

private:
  template <bool Wait, bool MW_ = MW, bool MR_ = MR, bool V_ = V>
  ZuIfT<MW_ && MR_ && V_, void *> push_(unsigned size) {
    writeAssert();
    size = alignAssert(size);
retry:
    if (!this->rdrMask().load_()) return nullptr;
    uint32_t head = this->head().load_();
    if (__builtin_expect(!!(head & Locked32()), 0)) goto retry;
    if (__builtin_expect(!!(head & EndOfFile32()), 0)) return nullptr;
    uint32_t tail = this->tail();
    if (pushFull(head, tail, size)) do {
	++m_full;
	if (gc() > 0) goto retry;
	if constexpr (!Wait) return nullptr;
	if (__builtin_expect(!!(!params().ll), 0)) {
	  if (this->tail().cmpXch(tail | Waiting32(), tail) != tail) goto retry;
	  tail |= Waiting32();
	  if (m_tailBlocker.wait(this->tail(), tail, params()) != Zu::OK)
	    return nullptr;
	}
	goto retry;
      } while (0);
    auto head_ = head;
    head += size;
    if (__builtin_expect(
	  !!((head & ~(Wrapped32() | Mask32())) >= this->size()), 0
	))
      head = (head ^ Wrapped32()) - this->size();
    if (__builtin_expect(
	  !!(this->head().cmpXch(head | Locked32(), head_) != head_), 0
	))
      goto retry;
    *reinterpret_cast<uint64_t *>(&(data())[head & ~(Wrapped32() | Mask32())]) =
      0;
    this->head() = head;
    auto ptr = reinterpret_cast<uint64_t *>(&(data()
    )[head_ & ~(Wrapped32() | Mask32())]);
    return &ptr[1];
  }

public:
  template <bool MW_ = MW, bool MR_ = MR, bool V_ = V>
  ZuIfT<MW_ && MR_ && V_> push2(void *ptr, unsigned size) {
    writeAssert();
    size = alignAssert(size);
    uint32_t head =
      static_cast<uint32_t>((reinterpret_cast<uint8_t *>(ptr) - 8) - data());
    wakeReaders(head);
    inCount().store_(inCount().load_() + 1);
    inBytes().store_(inBytes().load_() + size);
  }

  template <bool MW_ = MW, bool MR_ = MR>
  ZuIfT<!MW_ && !MR_> eof(bool eof = true) {
    writeAssert();
    uint32_t head = this->head().load_();
    if (eof)
      wakeReaders<EndOfFile()>(head);
    else
      this->head() = head & ~EndOfFile32();
  }
  template <bool MW_ = MW, bool MR_ = MR> ZuIfT<MW_> eof(bool eof = true) {
    writeAssert();
retry:
    uint32_t head = this->head().load_();
    if (head & Locked32()) goto retry;
    if (eof) {
      if (this->head().cmpXch(head | Locked32() | EndOfFile32(), head) != head)
	goto retry;
      wakeReaders<EndOfFile()>(head);
      this->head() = head | EndOfFile32();
    } else {
      if (this->head().cmpXch((head | Locked32()) & ~EndOfFile32(), head) !=
	  head)
	goto retry;
      *reinterpret_cast<uint64_t *>(&(data())[head & ~(Wrapped32() | Mask32())]
      ) &= ~EndOfFile();
      this->head() = head & ~EndOfFile32();
    }
  }
  template <bool MW_ = MW, bool MR_ = MR>
  ZuIfT<!MW_ && MR_> eof(bool eof = true) {
    writeAssert();
    uint32_t head = this->head().load_();
    if (eof) {
      this->head() = (head |= EndOfFile32());
      wakeReaders<EndOfFile()>(head);
    } else {
      this->head() = head & ~EndOfFile32();
      *reinterpret_cast<uint64_t *>(&(data())[head & ~(Wrapped32() | Mask32())]
      ) &= ~EndOfFile();
    }
  }

private:
  int writeStatus_() const {
    uint32_t head = this->head().load_();
    if (__builtin_expect(!!(head & EndOfFile32()), 0)) return Zu::EndOfFile;
    head &= ~(Wrapped32() | Mask32());
    uint32_t tail = this->tail() & ~(Wrapped32() | Mask32());
    if (head < tail) return tail - head;
    return size() - (head - tail);
  }

public:
  template <bool MR_ = MR> ZuIfT<!MR_, int> writeStatus() const {
    ((m_flags & Write) ? void() :
			 ZmAssert_fail(
			   "m_flags & Write", "../../zm/src/zlib/ZmRing.hh",
			   1199, __PRETTY_FUNCTION__
			 ));
    if (__builtin_expect(!!(!ctrl()), 0)) return Zu::IOError;
    return writeStatus_();
  }

  template <bool MR_ = MR> ZuIfT<MR_, int> writeStatus() const {
    ((m_flags & Write) ? void() :
			 ZmAssert_fail(
			   "m_flags & Write", "../../zm/src/zlib/ZmRing.hh",
			   1206, __PRETTY_FUNCTION__
			 ));
    if (__builtin_expect(!!(!ctrl()), 0)) return Zu::IOError;
    if (__builtin_expect(!!(!rdrMask()), 0)) return Zu::NotReady;
    return writeStatus_();
  }

public:
  inline T *shift() { return shift_<1>(); }
  inline T *tryShift() { return shift_<0>(); }

private:
  template <bool MR_ = MR> ZuIfT<!MR_> readAssert() {
    ((ctrl()) ?
       void() :
       ZmAssert_fail(
	 "ctrl()", "../../zm/src/zlib/ZmRing.hh", 1221, __PRETTY_FUNCTION__
       ));
    ((m_flags & Read) ? void() :
			ZmAssert_fail(
			  "m_flags & Read", "../../zm/src/zlib/ZmRing.hh", 1222,
			  __PRETTY_FUNCTION__
			));
  }
  template <bool MR_ = MR> ZuIfT<MR_> readAssert() {
    readAssert<false>();
    ((rdrID() >= 0) ? void() :
		      ZmAssert_fail(
			"rdrID() >= 0", "../../zm/src/zlib/ZmRing.hh", 1227,
			__PRETTY_FUNCTION__
		      ));
  }

  void wakeWriters(uint32_t tail) {
    tail &= ~Waiting32();
    if (__builtin_expect(!!(this->tail().xch(tail) & Waiting32()), 0))
      m_tailBlocker.wake(this->tail());
  }

  template <bool Wait, bool MW_ = MW, bool MR_ = MR>
  ZuIfT<!MW_ && !MR_, T *> shift_() {
    readAssert();
    uint32_t tail = this->tail().load_() & ~Mask32();
retry:
    uint32_t head = this->head();
    if constexpr (MW)
      if (head & Locked32()) goto retry;
    (void());
    if ((tail == (head & ~Mask32()))) do {
	if (__builtin_expect(!!(head & EndOfFile32()), 0)) return nullptr;
	if constexpr (!Wait) return nullptr;
	if (__builtin_expect(!!(!params().ll), 0)) {
	  if (this->head().cmpXch(head | Waiting32(), head) != head) goto retry;
	  head |= Waiting32();
	  if (m_headBlocker.wait(this->head(), head, params()) != Zu::OK)
	    return nullptr;
	}
	goto retry;
      } while (0);
    return reinterpret_cast<T *>(&(data())[tail & ~Wrapped32()]);
  }

public:
  template <bool MW_ = MW, bool MR_ = MR, bool V_ = V>
  ZuIfT<!MW_ && !MR_ && !V_> shift2() {
    readAssert();
    uint32_t tail = this->tail().load_() & ~Mask32();
    tail += MsgSize;
    if (__builtin_expect(!!((tail & ~Wrapped32()) >= this->size()), 0))
      tail = (tail ^ Wrapped32()) - this->size();
    wakeWriters(tail);
    this->outCount().store_(this->outCount().load_() + 1);
    this->outBytes().store_(this->outBytes().load_() + MsgSize);
  }

  template <bool MW_ = MW, bool MR_ = MR, bool V_ = V>
  ZuIfT<!MW_ && !MR_ && V_> shift2(unsigned size) {
    readAssert();
    size = alignAssert(size);
    uint32_t tail = this->tail().load_() & ~Mask32();
    tail += size;
    if (__builtin_expect(!!((tail & ~Wrapped32()) >= this->size()), 0))
      tail = (tail ^ Wrapped32()) - this->size();
    wakeWriters(tail);
    this->outCount().store_(this->outCount().load_() + 1);
    this->outBytes().store_(this->outBytes().load_() + size);
  }

private:
  template <bool Wait, bool MW_ = MW, bool MR_ = MR>
  ZuIfT<!MW_ && MR_, T *> shift_() {
    readAssert();
    uint32_t tail = rdrTail();
retry:
    auto hdrPtr =
      reinterpret_cast<ZmAtomic<uint64_t> *>(&(data())[tail & ~Wrapped32()]);
    uint64_t hdr = *hdrPtr;
    (void());
    if ((!(hdr & ~Mask()))) do {
	if (__builtin_expect(!!(hdr & EndOfFile()), 0)) return nullptr;
	if constexpr (!Wait) return nullptr;
	if (__builtin_expect(!!(!params().ll), 0)) {
	  if (hdrPtr->cmpXch(hdr | Waiting(), hdr) != hdr) goto retry;
	  hdr |= Waiting();
	  auto &hdr32 =
	    reinterpret_cast<ZmAtomic<uint32_t> *>(hdrPtr)[Flags32Offset];
	  if (m_headBlocker.wait(hdr32, hdr >> 32, params()) != Zu::OK)
	    return nullptr;
	}
	goto retry;
      } while (0);
    return reinterpret_cast<T *>(&hdrPtr[1]);
    ;
  }

public:
  template <bool MW_ = MW, bool MR_ = MR, bool V_ = V>
  ZuIfT<!MW_ && MR_ && !V_> shift2() {
    readAssert();
    uint32_t tail = rdrTail();
    auto tail_ = tail;
    tail += MsgSize;
    if (__builtin_expect(!!((tail & ~Wrapped32()) >= this->size()), 0))
      tail = (tail ^ Wrapped32()) - this->size();
    rdrTail(tail);
    if ((*reinterpret_cast<ZmAtomic<uint64_t> *>(&(data())[tail_ & ~Wrapped32()]
	 ) &= ~(1ULL << rdrID())) &
	RdrMask())
      return;
    wakeWriters(tail);
    this->outCount().store_(this->outCount().load_() + 1);
    this->outBytes().store_(this->outBytes().load_() + MsgSize);
  }

  template <bool MW_ = MW, bool MR_ = MR, bool V_ = V>
  ZuIfT<!MW_ && MR_ && V_> shift2(unsigned size) {
    readAssert();
    size = alignAssert(size);
    uint32_t tail = rdrTail();
    auto tail_ = tail;
    tail += size;
    if (__builtin_expect(!!((tail & ~Wrapped32()) >= this->size()), 0))
      tail = (tail ^ Wrapped32()) - this->size();
    rdrTail(tail);
    if ((*reinterpret_cast<ZmAtomic<uint64_t> *>(&(data())[tail_ & ~Wrapped32()]
	 ) &= ~(1ULL << rdrID())) &
	RdrMask())
      return;
    wakeWriters(tail);
    this->outCount().store_(this->outCount().load_() + 1);
    this->outBytes().store_(this->outBytes().load_() + size);
  }

private:
  template <bool Wait, bool MW_ = MW, bool MR_ = MR>
  ZuIfT<MW_ && !MR_, T *> shift_() {
    readAssert();
    uint32_t tail = this->tail().load_() & ~Mask32();
retry:
    auto hdrPtr =
      reinterpret_cast<ZmAtomic<uint64_t> *>(&(data())[tail & ~Wrapped32()]);
    uint64_t hdr = *hdrPtr;
    (void());
    if ((!(hdr & ~Mask()))) do {
	if (__builtin_expect(!!(hdr & EndOfFile()), 0)) return nullptr;
	if constexpr (!Wait) return nullptr;
	if (__builtin_expect(!!(!params().ll), 0)) {
	  if (hdrPtr->cmpXch(hdr | Waiting(), hdr) != hdr) goto retry;
	  hdr |= Waiting();
	  auto &hdr32 =
	    reinterpret_cast<ZmAtomic<uint32_t> *>(hdrPtr)[Flags32Offset];
	  if (m_headBlocker.wait(hdr32, hdr >> 32, params()) != Zu::OK)
	    return nullptr;
	}
	goto retry;
      } while (0);
    return reinterpret_cast<T *>(&hdrPtr[1]);
  }

public:
  template <bool MW_ = MW, bool MR_ = MR, bool V_ = V>
  ZuIfT<MW_ && !MR_ && !V_> shift2() {
    readAssert();
    uint32_t tail = this->tail().load_() & ~Mask32();
    *reinterpret_cast<ZmAtomic<uint64_t> *>(&(data())[tail & ~Wrapped32()]) = 0;
    tail += MsgSize;
    if (__builtin_expect(!!((tail & ~Wrapped32()) >= this->size()), 0))
      tail = (tail ^ Wrapped32()) - this->size();
    wakeWriters(tail);
    this->outCount().store_(this->outCount().load_() + 1);
    this->outBytes().store_(this->outBytes().load_() + MsgSize);
  }

  template <bool MW_ = MW, bool MR_ = MR, bool V_ = V>
  ZuIfT<MW_ && !MR_ && V_> shift2(unsigned size) {
    readAssert();
    size = alignAssert(size);
    uint32_t tail = this->tail().load_() & ~Mask32();
    *reinterpret_cast<ZmAtomic<uint64_t> *>(&(data())[tail & ~Wrapped32()]) = 0;
    tail += size;
    if (__builtin_expect(!!((tail & ~Wrapped32()) >= this->size()), 0))
      tail = (tail ^ Wrapped32()) - this->size();
    wakeWriters(tail);
    this->outCount().store_(this->outCount().load_() + 1);
    this->outBytes().store_(this->outBytes().load_() + size);
  }

private:
  template <bool Wait, bool MW_ = MW, bool MR_ = MR>
  ZuIfT<MW_ && MR_, T *> shift_() {
    readAssert();
    uint32_t tail = rdrTail();
retry:
    auto hdrPtr =
      reinterpret_cast<ZmAtomic<uint64_t> *>(&(data())[tail & ~Wrapped32()]);
    uint64_t hdr = *hdrPtr;
    (void());
    if ((!(hdr & ~Mask()))) do {
	if (__builtin_expect(!!(hdr & EndOfFile()), 0)) return nullptr;
	if constexpr (!Wait) return nullptr;
	if (__builtin_expect(!!(!params().ll), 0)) {
	  if (hdrPtr->cmpXch(hdr | Waiting(), hdr) != hdr) goto retry;
	  hdr |= Waiting();
	  auto &hdr32 =
	    reinterpret_cast<ZmAtomic<uint32_t> *>(hdrPtr)[Flags32Offset];
	  if (m_headBlocker.wait(hdr32, hdr >> 32, params()) != Zu::OK)
	    return nullptr;
	}
	goto retry;
      } while (0);
    return reinterpret_cast<T *>(&hdrPtr[1]);
    ;
  }

public:
  template <bool MW_ = MW, bool MR_ = MR, bool V_ = V>
  ZuIfT<MW_ && MR_ && !V_> shift2() {
    readAssert();
    uint32_t tail = rdrTail();
    auto tail_ = tail;
    tail += MsgSize;
    if (__builtin_expect(!!((tail & ~Wrapped32()) >= this->size()), 0))
      tail = (tail ^ Wrapped32()) - this->size();
    rdrTail(tail);
    if ((*reinterpret_cast<ZmAtomic<uint64_t> *>(&(data())[tail_ & ~Wrapped32()]
	 ) &= ~(1ULL << rdrID())) &
	RdrMask())
      return;
    wakeWriters(tail);
    this->outCount().store_(this->outCount().load_() + 1);
    this->outBytes().store_(this->outBytes().load_() + MsgSize);
  }

  template <bool MW_ = MW, bool MR_ = MR, bool V_ = V>
  ZuIfT<MW_ && MR_ && V_> shift2(unsigned size) {
    readAssert();
    size = alignAssert(size);
    uint32_t tail = rdrTail();
    auto tail_ = tail;
    tail += size;
    if (__builtin_expect(!!((tail & ~Wrapped32()) >= this->size()), 0))
      tail = (tail ^ Wrapped32()) - this->size();
    rdrTail(tail);
    if ((*reinterpret_cast<ZmAtomic<uint64_t> *>(&(data())[tail_ & ~Wrapped32()]
	 ) &= ~(1ULL << rdrID())) &
	RdrMask())
      return;
    wakeWriters(tail);
    this->outCount().store_(this->outCount().load_() + 1);
    this->outBytes().store_(this->outBytes().load_() + size);
  }

private:
  int readStatus_(uint32_t tail) const {
    uint32_t head = this->head();
    bool eof = head & EndOfFile32();
    head &= ~Mask32();
    if ((head ^ tail) == Wrapped32()) return size();
    head &= ~Wrapped32();
    tail &= ~Wrapped32();
    if (head >= tail) {
      if (head > tail) return head - tail;
      if (__builtin_expect(!!(eof), 0)) return Zu::EndOfFile;
      return 0;
    }
    return size() - (tail - head);
  }

public:
  template <bool MR_ = MR> ZuIfT<!MR_, int> readStatus() const {
    ((m_flags & Read) ? void() :
			ZmAssert_fail(
			  "m_flags & Read", "../../zm/src/zlib/ZmRing.hh", 1467,
			  __PRETTY_FUNCTION__
			));
    if (__builtin_expect(!!(!ctrl()), 0)) return Zu::IOError;
    return readStatus_(this->tail().load_() & ~Mask32());
  }

  template <bool MR_ = MR> ZuIfT<MR_, int> readStatus() const {
    ((m_flags & Read) ? void() :
			ZmAssert_fail(
			  "m_flags & Read", "../../zm/src/zlib/ZmRing.hh", 1474,
			  __PRETTY_FUNCTION__
			));
    if (__builtin_expect(!!(!ctrl()), 0)) return Zu::IOError;
    return readStatus_(rdrTail());
  }

  unsigned count_() const {
    int i = readStatus();
    if (i < 0) return 0;
    if constexpr (!MsgSize)
      return i;
    else
      return i / MsgSize;
  }

  void stats(
    uint64_t &inCount, uint64_t &inBytes, uint64_t &outCount, uint64_t &outBytes
  ) const {
    ((ctrl()) ?
       void() :
       ZmAssert_fail(
	 "ctrl()", "../../zm/src/zlib/ZmRing.hh", 1491, __PRETTY_FUNCTION__
       ));

    inCount = this->inCount().load_();
    inBytes = this->inBytes().load_();
    outCount = this->outCount().load_();
    outBytes = this->outBytes().load_();
  }

private:
  ParamData m_params;
  Blocker m_headBlocker, m_tailBlocker;
  uint32_t m_flags = 0;
  uint32_t m_size = 0;
  uint32_t m_full = 0;
};

template <typename Ring, bool MW> inline bool RingExt<Ring, MW, true>::open_() {
  if (ring()->flags() & Ring::Read) {
    uint32_t rdrCount;
    do {
      rdrCount = ring()->rdrCount();
      if (rdrCount >= MaxRdrs) return false;
    } while (ring()->rdrCount().cmpXch(rdrCount + 1, rdrCount) != rdrCount);
  }
  return true;
}

template <typename Ring, bool MW>
inline void RingExt<Ring, MW, true>::close_() {
  if (ring()->flags() & Ring::Read) {
    if (rdrID() >= 0) detach();
    --ring()->rdrCount();
  }
}

template <typename Ring, bool MW, bool MR>
inline int RingExt<Ring, MW, MR>::attach() {
  (void());
  (void());
  (void());
  (void());
  return Zu::OK;
}

template <typename Ring, bool MW> inline int RingExt<Ring, MW, true>::attach() {
  enum { Read = Ring::Read };

  ((ring()->ctrl()) ? void() :
		      ZmAssert_fail(
			"ring()->ctrl()", "../../zm/src/zlib/ZmRing.hh", 1556,
			__PRETTY_FUNCTION__
		      ));
  ((ring()->flags() & Read) ?
     void() :
     ZmAssert_fail(
       "ring()->flags() & Read", "../../zm/src/zlib/ZmRing.hh", 1557,
       __PRETTY_FUNCTION__
     ));

  if (rdrID() >= 0) return Zu::OK;

  {
    uint64_t attMask;
    unsigned id;
    do {
      attMask = ring()->attMask().load_();
      for (id = 0; id < MaxRdrs; id++)
	if (!(attMask & (1ULL << id))) break;
      if (id == MaxRdrs) return Zu::IOError;
    } while (ring()->attMask().cmpXch(attMask | (1ULL << id), attMask) !=
	     attMask);
    rdrID(id);
  }

  ++(ring()->attSeqNo());

  ring()->attached(rdrID());

  (void());

  auto data = ring()->data();
  auto size = ring()->size();

  uint32_t tail = ring()->tail().load_() & ~Mask32();
  uint32_t head = ring()->head() & ~Mask32();
  uint32_t head_;
  (void());
  ring()->rdrMask() |= (1ULL << rdrID());
  (void());

  do {
    while (tail != head) {
      auto hdrPtr =
	reinterpret_cast<ZmAtomic<uint64_t> *>(&data[tail & ~Wrapped32()]);
      if (*hdrPtr & (1ULL << rdrID())) goto done;
      tail += ring()->align(Ring::SizeAxor(&hdrPtr[1]));
      if ((tail & ~Wrapped32()) >= size) tail = (tail ^ Wrapped32()) - size;
    }
    head_ = head;
    head = ring()->head() & ~Mask32();
  } while (head != head_);
done:
  (void());

  rdrTail(tail);

  ++(ring()->attSeqNo());

  return Zu::OK;
}

template <typename Ring, bool MW, bool MR>
inline void RingExt<Ring, MW, MR>::detach() {
  (void());
  (void());
  (void());
}

template <typename Ring, bool MW>
inline void RingExt<Ring, MW, true>::detach() {
  enum { Read = Ring::Read };

  ((ring()->ctrl()) ? void() :
		      ZmAssert_fail(
			"ring()->ctrl()", "../../zm/src/zlib/ZmRing.hh", 1629,
			__PRETTY_FUNCTION__
		      ));
  ((ring()->flags() & Read) ?
     void() :
     ZmAssert_fail(
       "ring()->flags() & Read", "../../zm/src/zlib/ZmRing.hh", 1630,
       __PRETTY_FUNCTION__
     ));

  if (rdrID() < 0) return;

  ++(ring()->attSeqNo());

  ring()->rdrMask() &= ~(1ULL << rdrID());
  (void());

  auto data = ring()->data();
  auto size = ring()->size();

  uint32_t tail = rdrTail();
  (void());
  uint32_t head = ring()->head() & ~Mask32();
  uint32_t head_;

  do {
    while (tail != head) {
      auto hdrPtr =
	reinterpret_cast<ZmAtomic<uint64_t> *>(&data[tail & ~Wrapped32()]);
      if (!(*hdrPtr & (1ULL << rdrID()))) goto done;
      tail += ring()->align(Ring::SizeAxor(&hdrPtr[1]));
      if ((tail & ~Wrapped32()) >= size) tail = (tail ^ Wrapped32()) - size;
      if (*hdrPtr &= ~(1ULL << rdrID())) continue;
      ring()->wakeWriters(tail);
    }
    head_ = head;
    head = ring()->head() & ~Mask32();
  } while (head != head_);
done:
  (void());

  rdrTail(tail);

  ring()->detached(rdrID());

  ++(ring()->attSeqNo());

  ring()->attMask() &= ~(1ULL << rdrID());
  rdrID(-1);
}

} // namespace ZmRing_

using ZmRingParams = ZmRing_::Params;

template <typename NTP = ZmRing_::Defaults> using ZmRing = ZmRing_::Ring<NTP>;

class ZmXRingParams {
public:
  ZmXRingParams &&initial(unsigned v) {
    m_initial = v;
    return ZuMv(*this);
  }
  ZmXRingParams &&increment(unsigned v) {
    m_increment = v;
    return ZuMv(*this);
  }
  ZmXRingParams &&maxFrag(double v) {
    m_maxFrag = v;
    return ZuMv(*this);
  }

  unsigned initial() const { return m_initial; }
  unsigned increment() const { return m_increment; }
  double maxFrag() const { return m_maxFrag; }

private:
  unsigned m_initial = 8;
  unsigned m_increment = 8;
  double m_maxFrag = 50.0;
};

struct ZmXRing_Defaults {
  static constexpr auto KeyAxor = ZuDefaultAxor();
  template <typename T> using CmpT = ZuCmp<T>;
  template <typename T> using KeyCmpT = ZuCmp<T>;
  template <typename T> using OpsT = ZuArrayFn<T>;
  using Lock = ZmNoLock;
  static const char *HeapID() { return "ZmXRing"; }
  enum { Sharded = 0 };
};

template <auto KeyAxor_, typename NTP = ZmXRing_Defaults>
struct ZmXRingKey : public NTP {
  static constexpr auto KeyAxor = KeyAxor_;
};

template <template <typename> typename Cmp_, typename NTP = ZmXRing_Defaults>
struct ZmXRingCmp : public NTP {
  template <typename T> using CmpT = Cmp_<T>;
  template <typename T> using OpsT = ZuArrayFn<T, Cmp_<T>>;
};

template <template <typename> typename KeyCmp_, typename NTP = ZmXRing_Defaults>
struct ZmXRingKeyCmp : public NTP {
  template <typename T> using KeyCmpT = KeyCmp_<T>;
};

template <typename Lock_, class NTP = ZmXRing_Defaults>
struct ZmXRingLock : public NTP {
  using Lock = Lock_;
};

template <auto HeapID_, typename NTP = ZmXRing_Defaults>
struct ZmXRingHeapID : public NTP {
  static constexpr auto HeapID = HeapID_;
};

template <bool Sharded_, typename NTP = ZmXRing_Defaults>
struct ZmXRingSharded : public NTP {
  enum { Sharded = Sharded_ };
};

template <typename T, class NTP> class ZmXRing;

template <typename Ring> struct ZmXRing_Unlocked;
template <typename T, class NTP> struct ZmXRing_Unlocked<ZmXRing<T, NTP>> {
  using Ring = ZmXRing<T, NTP>;

  template <typename P> T *findPtr(P &&v) {
    return static_cast<Ring *>(this)->findPtr_(ZuFwd<P>(v));
  }
  void delPtr(T *ptr) { return static_cast<Ring *>(this)->delPtr_(ptr); }
};

template <typename Ring, class Lock> struct ZmXRing_Base { };
template <typename Ring>
struct ZmXRing_Base<Ring, ZmNoLock> : public ZmXRing_Unlocked<Ring> { };

template <typename T_, class NTP = ZmXRing_Defaults>
class ZmXRing :
  private ZmVHeap<NTP::HeapID, NTP::Sharded, alignof(T_)>,
  public ZmXRing_Base<ZmXRing<T_, NTP>, typename NTP::Lock>,
  public NTP::template OpsT<T_> {
  ZmXRing(const ZmXRing &);
  ZmXRing &operator=(const ZmXRing &);

  friend ZmXRing_Unlocked<ZmXRing>;

public:
  using T = T_;
  static constexpr auto KeyAxor = NTP::KeyAxor;
  using Key = ZuRDecay<decltype(KeyAxor(ZuDeclVal<const T &>()))>;
  using Ops = typename NTP::template OpsT<T>;
  using Cmp = typename NTP::template CmpT<T>;
  using KeyCmp = typename NTP::template KeyCmpT<T>;
  using Lock = typename NTP::Lock;
  static constexpr auto HeapID = NTP::HeapID;
  enum { Sharded = NTP::Sharded };

  using Guard = ZmGuard<Lock>;
  using ReadGuard = ZmReadGuard<Lock>;

  ZmXRing(ZmXRingParams params = {}) :
    m_initial{params.initial()}, m_increment{params.increment()},
    m_defrag{1.0 - (double)params.maxFrag() / 100.0} { }

  ~ZmXRing() {
    clean_();
    vfree(m_data);
  }

  ZmXRing(ZmXRing &&ring) noexcept :
    m_initial{ring.m_initial}, m_increment{ring.m_increment},
    m_defrag{ring.m_defrag} {
    Guard guard(ring.m_lock);
    m_data = ring.m_data;
    m_offset = ring.m_offset;
    m_size = ring.m_size;
    m_length = ring.m_length;
    m_count = ring.m_count;
    ring.m_data = nullptr;
    ring.m_offset = 0;
    ring.m_size = 0;
    ring.m_length = 0;
    ring.m_count = 0;
  }
  ZmXRing &operator=(ZmXRing &&ring) noexcept {
    this->~ZmXRing();
    new (this) ZmXRing{ZuMv(ring)};
  }

  unsigned initial() const { return m_initial; }
  unsigned increment() const { return m_increment; }
  unsigned maxFrag() const { return (unsigned)((1.0 - m_defrag) * 100.0); }

  unsigned size() const {
    ReadGuard guard(m_lock);
    return m_size;
  }
  unsigned length() const {
    ReadGuard guard(m_lock);
    return m_length;
  }

  unsigned size_() const { return m_size; }
  unsigned length_() const { return m_length; }
  unsigned count_() const { return m_count; }
  unsigned offset_() const { return m_offset; }

private:
  using VHeap = ZmVHeap<HeapID, Sharded, alignof(T)>;
  using VHeap::valloc;
  using VHeap::vfree;

  void lazy() {
    if (__builtin_expect(!!(!m_data), 0)) extend(m_initial);
  }

  void clean_() {
    if (!m_data) return;
    unsigned o = m_offset + m_length;
    if (o > m_size) {
      int n = m_size - m_offset;
      Ops::destroyItems(m_data + m_offset, n);
      Ops::destroyItems(m_data, o - m_size);
    } else {
      Ops::destroyItems(m_data + m_offset, m_length);
    }
  }

  void extend(unsigned size) {
    T *data = static_cast<T *>(valloc(size * sizeof(T)));
    ((data) ? void() :
	      ZmAssert_fail(
		"data", "../../zm/src/zlib/ZmXRing.hh", 216, __PRETTY_FUNCTION__
	      ));
    if (m_data) {
      unsigned o = m_offset + m_length;
      if (o > m_size) {
	int n = m_size - m_offset;
	Ops::moveItems(data, m_data + m_offset, n);
	Ops::moveItems(data + n, m_data, o - m_size);
      } else {
	Ops::moveItems(data, m_data + m_offset, m_length);
      }
      vfree(m_data);
    }
    m_data = data, m_size = size, m_offset = 0;
  }

public:
  void init(ZmXRingParams params = ZmXRingParams()) {
    Guard guard(m_lock);
    if ((m_initial = params.initial()) > m_size) extend(params.initial());
    m_increment = params.increment();
    m_defrag = 1.0 - (double)params.maxFrag() / 100.0;
  }

  void clean() {
    Guard guard(m_lock);
    clean_();
    m_offset = m_length = m_count = 0;
  }

private:
  void push() {
    if (m_count >= m_size) extend(m_size + m_increment);
  }
  unsigned offset(unsigned i) {
    if ((i += m_offset) >= m_size) i -= m_size;
    return i;
  }

public:
  template <typename P> void push(P &&v) {
    Guard guard(m_lock);

    lazy();
    push();
    Ops::initItem(m_data + offset(m_length++), ZuFwd<P>(v));
    m_count++;
  }

  template <typename P> void findPush(P &&v) {
    Guard guard(m_lock);

    for (int i = m_length; --i >= 0;) {
      unsigned o = offset(i);
      if (Cmp::equals(m_data[o], v)) return;
    }
    lazy();
    push();
    Ops::initItem(m_data + offset(m_length++), ZuFwd<P>(v));
    m_count++;
  }

  T pop() {
    Guard guard(m_lock);

    if (m_count <= 0) return Cmp::null();
    --m_count;
    unsigned o = offset(--m_length);
    T v = ZuMv(m_data[o]);
    Ops::destroyItem(m_data + o);
    {
      int i = m_length;
      while (--i >= 0) {
	o = offset(i);
	if (!Cmp::null(m_data[o])) break;
	Ops::destroyItem(m_data + o);
      }
      m_length = ++i;
    }
    return v;
  }

  template <typename P> void unshift(P &&v) {
    Guard guard(m_lock);

    lazy();
    push();
    unsigned o = offset(m_size - 1);
    m_offset = o, m_length++;
    Ops::initItem(m_data + o, ZuFwd<P>(v));
    m_count++;
  }

  template <typename P> void findUnshift(P &&v) {
    Guard guard(m_lock);

    for (unsigned i = 0; i < m_length; i++) {
      unsigned o = offset(i);
      if (Cmp::equals(m_data[o], v)) return;
    }
    lazy();
    push();
    unsigned o = offset(m_size - 1);
    m_offset = o, m_length++;
    Ops::initItem(m_data + o, ZuFwd<P>(v));
    m_count++;
  }

  T shift() {
    Guard guard(m_lock);

    if (m_count <= 0) return Cmp::null();
    --m_count;
    int i = m_length, j = 0, o = m_offset;
    T v = ZuMv(m_data[o]);
    do {
      Ops::destroyItem(m_data + o);
    } while (--i > 0 && Cmp::null(m_data[o = offset(++j)]));
    m_offset = o, m_length = i;
    return v;
  }

  T head() {
    Guard guard(m_lock);

    if (m_length <= 0) return Cmp::null();
    return m_data[m_offset];
  }
  T tail() {
    Guard guard(m_lock);

    if (m_length <= 0) return Cmp::null();
    return m_data[offset(m_length - 1)];
  }

  template <typename P> T find(const P &v) {
    Guard guard(m_lock);
    for (int i = m_length; --i >= 0;) {
      unsigned o = offset(i);
      if (KeyCmp::equals(KeyAxor(m_data[o]), v)) return m_data[o];
    }
    return Cmp::null();
  }

private:
  template <typename P> T *findPtr_(const P &v) {
    for (int i = m_length; --i >= 0;) {
      unsigned o = offset(i);
      if (Cmp::equals(m_data[o], v)) return &m_data[o];
    }
    return nullptr;
  }

public:
  template <typename P> T del(const P &v) {
    Guard guard(m_lock);
    T *ptr = findPtr_(v);
    if (!ptr) return Cmp::null();
    T data = ZuMv(*ptr);
    delPtr_(ptr);
    return data;
  }

private:
  void delPtr_(T *ptr) {
    int i = ptr - m_data;

    m_count--;

    int o = offset(m_length - 1);
    if (i == o) {
      Ops::destroyItem(ptr);
      i = --m_length;
      while (--i >= 0) {
	if (!Cmp::null(m_data[o = offset(i)])) break;
	Ops::destroyItem(m_data + o);
      }
      m_length = ++i;
    } else if (i == (int)m_offset) {
      Ops::destroyItem(ptr);
      ++m_offset, --m_length, i = -1;
      while (++i < (int)m_length) {
	if (!Cmp::null(m_data[o = offset(i)])) break;
	Ops::destroyItem(m_data + o);
      }
      if (--i > 0) m_offset = offset(i), m_length -= i;
    } else {
      *ptr = Cmp::null();
      if ((double)m_count < (double)m_length * m_defrag) {
	i = m_length - 1;
	while (--i >= 0) {
	  if (Cmp::null(m_data[offset(i)])) {
	    int j = i;
	    while (--j >= 0 && Cmp::null(m_data[offset(j)]));
	    ++i, ++j;
	    for (int n = j; n < i; n++) Ops::destroyItem(m_data + offset(n));
	    for (int n = m_length - i; --n >= 0; i++, j++) {
	      Ops::initItem(m_data + offset(j), ZuMv(m_data[offset(i)]));
	      Ops::destroyItem(m_data + offset(i));
	    }
	    m_length -= (i - j);
	    i = j;
	  }
	}
      }
    }
  }

  class Iterator_;
  friend Iterator_;
  class Iterator_ : private Guard {
    Iterator_(const Iterator_ &);
    Iterator_ &operator=(const Iterator_ &);

  protected:
    using Ring = ZmXRing<T, NTP>;

    Iterator_(Ring &ring, unsigned i) :
      Guard(ring.m_lock), m_ring(ring), m_i(i) { }

    Ring &m_ring;
    int m_i;
  };

public:
  class Iterator;
  friend Iterator;
  class Iterator : private Iterator_ {
    using Iterator_::m_ring;
    using Iterator_::m_i;

  public:
    Iterator(typename Iterator_::Ring &ring) : Iterator_(ring, 0) { }
    T *iteratePtr() {
      unsigned o;
      do {
	if (m_i >= m_ring.m_length) return nullptr;
	o = m_ring.offset(m_i++);
      } while (Cmp::null(m_ring.m_data[o]));
      return m_ring.m_data + o;
    }
    const T &iterate() {
      unsigned o;
      do {
	if (m_i >= (int)m_ring.m_length) return ZuNullRef<T, Cmp>();
	o = m_ring.offset(m_i++);
      } while (Cmp::null(m_ring.m_data[o]));
      return m_ring.m_data[o];
    }
  };
  auto iterator() { return Iterator{*this}; }
  class RevIterator;
  friend RevIterator;
  class RevIterator : private Iterator_ {
    using Iterator_::m_ring;
    using Iterator_::m_i;

  public:
    RevIterator(typename Iterator_::Ring &ring) :
      Iterator_(ring, ring.m_length) { }
    T *iteratePtr() {
      unsigned o;
      do {
	if (m_i <= 0) return nullptr;
	o = m_ring.offset(--m_i);
      } while (Cmp::null(m_ring.m_data[o]));
      return m_ring.m_data + o;
    }
    const T &iterate() {
      unsigned o;
      do {
	if (m_i <= 0) return ZuNullRef<T, Cmp>();
	o = m_ring.offset(--m_i);
      } while (Cmp::null(m_ring.m_data[o]));
      return m_ring.m_data[o];
    }
  };
  auto revIterator() { return RevIterator{*this}; }

private:
  Lock m_lock;
  T *m_data = nullptr;
  unsigned m_offset = 0;
  unsigned m_size = 0;
  unsigned m_length = 0;
  unsigned m_count = 0;
  unsigned m_initial;
  unsigned m_increment;
  double m_defrag;
};

__attribute__((unused)) static int ck_cc_ffs(unsigned int x) {
  return __builtin_ffsl(x);
}

__attribute__((unused)) static int ck_cc_ffsl(unsigned long x) {
  return __builtin_ffsll(x);
}

__attribute__((unused)) static int ck_cc_ctz(unsigned int x) {
  return __builtin_ctz(x);
}

__attribute__((unused)) static int ck_cc_popcount(unsigned int x) {
  return __builtin_popcount(x);
}

__attribute__((unused)) static int ck_cc_ffsll(unsigned long long v) {
  unsigned int i;
  if (v == 0) return 0;
  for (i = 1; (v & 1) == 0; i++, v >>= 1);
  return i;
}

__attribute__((unused)) static void ck_pr_barrier(void) {
  __asm__ __volatile__("" ::: "memory");
  return;
}

__attribute__((unused)) static void *ck_pr_md_load_ptr(const void *target) {
  void *r;

  ck_pr_barrier();
  r = ((void *)(uintptr_t)(*(volatile void *const *)(target)));
  ck_pr_barrier();

  return r;
}

__attribute__((unused)) static void
ck_pr_md_store_ptr(void *target, const void *v) {
  ck_pr_barrier();
  *(volatile void **)target = ((void *)(uintptr_t)(v));
  ck_pr_barrier();
  return;
}

__attribute__((unused)) static char ck_pr_md_load_char(const char *target) {
  char r;
  ck_pr_barrier();
  r = (*(volatile __typeof__(*(const char *)target) *)&(*(const char *)target));
  ck_pr_barrier();
  return (r);
}
__attribute__((unused)) static void ck_pr_md_store_char(char *target, char v) {
  ck_pr_barrier();
  (*(volatile __typeof__(*(char *)target) *)&(*(char *)target)) = v;
  ck_pr_barrier();
  return;
}
__attribute__((unused)) static unsigned int
ck_pr_md_load_uint(const unsigned int *target) {
  unsigned int r;
  ck_pr_barrier();
  r = (*(volatile __typeof__(*(const unsigned int *)target
  ) *)&(*(const unsigned int *)target));
  ck_pr_barrier();
  return (r);
}
__attribute__((unused)) static void
ck_pr_md_store_uint(unsigned int *target, unsigned int v) {
  ck_pr_barrier();
  (*(volatile __typeof__(*(unsigned int *)target) *)&(*(unsigned int *)target)
  ) = v;
  ck_pr_barrier();
  return;
}
__attribute__((unused)) static int ck_pr_md_load_int(const int *target) {
  int r;
  ck_pr_barrier();
  r = (*(volatile __typeof__(*(const int *)target) *)&(*(const int *)target));
  ck_pr_barrier();
  return (r);
}
__attribute__((unused)) static void ck_pr_md_store_int(int *target, int v) {
  ck_pr_barrier();
  (*(volatile __typeof__(*(int *)target) *)&(*(int *)target)) = v;
  ck_pr_barrier();
  return;
}

__attribute__((unused)) static double
ck_pr_md_load_double(const double *target) {
  double r;
  ck_pr_barrier();
  r =
    (*(volatile __typeof__(*(const double *)target) *)&(*(const double *)target)
    );
  ck_pr_barrier();
  return (r);
}
__attribute__((unused)) static void
ck_pr_md_store_double(double *target, double v) {
  ck_pr_barrier();
  (*(volatile __typeof__(*(double *)target) *)&(*(double *)target)) = v;
  ck_pr_barrier();
  return;
}

__attribute__((unused)) static uint64_t
ck_pr_md_load_64(const uint64_t *target) {
  uint64_t r;
  ck_pr_barrier();
  r = (*(volatile __typeof__(*(const uint64_t *)target
  ) *)&(*(const uint64_t *)target));
  ck_pr_barrier();
  return (r);
}
__attribute__((unused)) static void
ck_pr_md_store_64(uint64_t *target, uint64_t v) {
  ck_pr_barrier();
  (*(volatile __typeof__(*(uint64_t *)target) *)&(*(uint64_t *)target)) = v;
  ck_pr_barrier();
  return;
}
__attribute__((unused)) static uint32_t
ck_pr_md_load_32(const uint32_t *target) {
  uint32_t r;
  ck_pr_barrier();
  r = (*(volatile __typeof__(*(const uint32_t *)target
  ) *)&(*(const uint32_t *)target));
  ck_pr_barrier();
  return (r);
}
__attribute__((unused)) static void
ck_pr_md_store_32(uint32_t *target, uint32_t v) {
  ck_pr_barrier();
  (*(volatile __typeof__(*(uint32_t *)target) *)&(*(uint32_t *)target)) = v;
  ck_pr_barrier();
  return;
}
__attribute__((unused)) static uint16_t
ck_pr_md_load_16(const uint16_t *target) {
  uint16_t r;
  ck_pr_barrier();
  r = (*(volatile __typeof__(*(const uint16_t *)target
  ) *)&(*(const uint16_t *)target));
  ck_pr_barrier();
  return (r);
}
__attribute__((unused)) static void
ck_pr_md_store_16(uint16_t *target, uint16_t v) {
  ck_pr_barrier();
  (*(volatile __typeof__(*(uint16_t *)target) *)&(*(uint16_t *)target)) = v;
  ck_pr_barrier();
  return;
}
__attribute__((unused)) static uint8_t ck_pr_md_load_8(const uint8_t *target) {
  uint8_t r;
  ck_pr_barrier();
  r = (*(volatile __typeof__(*(const uint8_t *)target
  ) *)&(*(const uint8_t *)target));
  ck_pr_barrier();
  return (r);
}
__attribute__((unused)) static void
ck_pr_md_store_8(uint8_t *target, uint8_t v) {
  ck_pr_barrier();
  (*(volatile __typeof__(*(uint8_t *)target) *)&(*(uint8_t *)target)) = v;
  ck_pr_barrier();
  return;
}

__attribute__((unused)) static void ck_pr_stall(void) { ck_pr_barrier(); }

__attribute__((unused)) static void ck_pr_fence_strict_atomic(void) {
  __sync_synchronize();
}
__attribute__((unused)) static void ck_pr_fence_strict_atomic_atomic(void) {
  __sync_synchronize();
}
__attribute__((unused)) static void ck_pr_fence_strict_atomic_load(void) {
  __sync_synchronize();
}
__attribute__((unused)) static void ck_pr_fence_strict_atomic_store(void) {
  __sync_synchronize();
}
__attribute__((unused)) static void ck_pr_fence_strict_store_atomic(void) {
  __sync_synchronize();
}
__attribute__((unused)) static void ck_pr_fence_strict_load_atomic(void) {
  __sync_synchronize();
}
__attribute__((unused)) static void ck_pr_fence_strict_load(void) {
  __sync_synchronize();
}
__attribute__((unused)) static void ck_pr_fence_strict_load_load(void) {
  __sync_synchronize();
}
__attribute__((unused)) static void ck_pr_fence_strict_load_store(void) {
  __sync_synchronize();
}
__attribute__((unused)) static void ck_pr_fence_strict_store(void) {
  __sync_synchronize();
}
__attribute__((unused)) static void ck_pr_fence_strict_store_store(void) {
  __sync_synchronize();
}
__attribute__((unused)) static void ck_pr_fence_strict_store_load(void) {
  __sync_synchronize();
}
__attribute__((unused)) static void ck_pr_fence_strict_memory(void) {
  __sync_synchronize();
}
__attribute__((unused)) static void ck_pr_fence_strict_acquire(void) {
  __sync_synchronize();
}
__attribute__((unused)) static void ck_pr_fence_strict_release(void) {
  __sync_synchronize();
}
__attribute__((unused)) static void ck_pr_fence_strict_acqrel(void) {
  __sync_synchronize();
}
__attribute__((unused)) static void ck_pr_fence_strict_lock(void) {
  __sync_synchronize();
}
__attribute__((unused)) static void ck_pr_fence_strict_unlock(void) {
  __sync_synchronize();
}

__attribute__((unused)) static bool
ck_pr_cas_ptr(void *target, void *compare, void *set) {
  bool z;
  z = __sync_bool_compare_and_swap((void **)target, compare, set);
  return z;
}

__attribute__((unused)) static bool
ck_pr_cas_char(char *target, char compare, char set) {
  bool z;
  z = __sync_bool_compare_and_swap((char *)target, compare, set);
  return z;
}
__attribute__((unused)) static bool
ck_pr_cas_int(int *target, int compare, int set) {
  bool z;
  z = __sync_bool_compare_and_swap((int *)target, compare, set);
  return z;
}
__attribute__((unused)) static bool
ck_pr_cas_uint(unsigned int *target, unsigned int compare, unsigned int set) {
  bool z;
  z = __sync_bool_compare_and_swap((unsigned int *)target, compare, set);
  return z;
}
__attribute__((unused)) static bool
ck_pr_cas_64(uint64_t *target, uint64_t compare, uint64_t set) {
  bool z;
  z = __sync_bool_compare_and_swap((uint64_t *)target, compare, set);
  return z;
}
__attribute__((unused)) static bool
ck_pr_cas_32(uint32_t *target, uint32_t compare, uint32_t set) {
  bool z;
  z = __sync_bool_compare_and_swap((uint32_t *)target, compare, set);
  return z;
}
__attribute__((unused)) static bool
ck_pr_cas_16(uint16_t *target, uint16_t compare, uint16_t set) {
  bool z;
  z = __sync_bool_compare_and_swap((uint16_t *)target, compare, set);
  return z;
}
__attribute__((unused)) static bool
ck_pr_cas_8(uint8_t *target, uint8_t compare, uint8_t set) {
  bool z;
  z = __sync_bool_compare_and_swap((uint8_t *)target, compare, set);
  return z;
}

__attribute__((unused)) static bool
ck_pr_cas_ptr_value(void *target, void *compare, void *set, void *v) {
  set = __sync_val_compare_and_swap((void **)target, compare, set);
  *(void **)v = set;
  return (set == compare);
}

__attribute__((unused)) static bool
ck_pr_cas_char_value(char *target, char compare, char set, char *v) {
  set = __sync_val_compare_and_swap(target, compare, set);
  *v = set;
  return (set == compare);
}
__attribute__((unused)) static bool
ck_pr_cas_int_value(int *target, int compare, int set, int *v) {
  set = __sync_val_compare_and_swap(target, compare, set);
  *v = set;
  return (set == compare);
}
__attribute__((unused)) static bool ck_pr_cas_uint_value(
  unsigned int *target, unsigned int compare, unsigned int set, unsigned int *v
) {
  set = __sync_val_compare_and_swap(target, compare, set);
  *v = set;
  return (set == compare);
}
__attribute__((unused)) static bool ck_pr_cas_64_value(
  uint64_t *target, uint64_t compare, uint64_t set, uint64_t *v
) {
  set = __sync_val_compare_and_swap(target, compare, set);
  *v = set;
  return (set == compare);
}
__attribute__((unused)) static bool ck_pr_cas_32_value(
  uint32_t *target, uint32_t compare, uint32_t set, uint32_t *v
) {
  set = __sync_val_compare_and_swap(target, compare, set);
  *v = set;
  return (set == compare);
}
__attribute__((unused)) static bool ck_pr_cas_16_value(
  uint16_t *target, uint16_t compare, uint16_t set, uint16_t *v
) {
  set = __sync_val_compare_and_swap(target, compare, set);
  *v = set;
  return (set == compare);
}
__attribute__((unused)) static bool
ck_pr_cas_8_value(uint8_t *target, uint8_t compare, uint8_t set, uint8_t *v) {
  set = __sync_val_compare_and_swap(target, compare, set);
  *v = set;
  return (set == compare);
}

__attribute__((unused)) static void *ck_pr_faa_ptr(void *target, void *d) {
  d = __sync_fetch_and_add((void **)target, d);
  return (d);
}

__attribute__((unused)) static char ck_pr_faa_char(char *target, char d) {
  d = __sync_fetch_and_add((char *)target, d);
  return (d);
}
__attribute__((unused)) static unsigned int
ck_pr_faa_uint(unsigned int *target, unsigned int d) {
  d = __sync_fetch_and_add((unsigned int *)target, d);
  return (d);
}
__attribute__((unused)) static int ck_pr_faa_int(int *target, int d) {
  d = __sync_fetch_and_add((int *)target, d);
  return (d);
}
__attribute__((unused)) static uint64_t
ck_pr_faa_64(uint64_t *target, uint64_t d) {
  d = __sync_fetch_and_add((uint64_t *)target, d);
  return (d);
}
__attribute__((unused)) static uint32_t
ck_pr_faa_32(uint32_t *target, uint32_t d) {
  d = __sync_fetch_and_add((uint32_t *)target, d);
  return (d);
}
__attribute__((unused)) static uint16_t
ck_pr_faa_16(uint16_t *target, uint16_t d) {
  d = __sync_fetch_and_add((uint16_t *)target, d);
  return (d);
}
__attribute__((unused)) static uint8_t ck_pr_faa_8(uint8_t *target, uint8_t d) {
  d = __sync_fetch_and_add((uint8_t *)target, d);
  return (d);
}

__attribute__((unused)) static void ck_pr_add_ptr(void *target, void *d) {
  d = __sync_fetch_and_add((void **)target, d);
  return;
}
__attribute__((unused)) static void ck_pr_add_char(char *target, char d) {
  d = __sync_fetch_and_add((char *)target, d);
  return;
}
__attribute__((unused)) static void ck_pr_add_int(int *target, int d) {
  d = __sync_fetch_and_add((int *)target, d);
  return;
}
__attribute__((unused)) static void
ck_pr_add_uint(unsigned int *target, unsigned int d) {
  d = __sync_fetch_and_add((unsigned int *)target, d);
  return;
}
__attribute__((unused)) static void ck_pr_add_64(uint64_t *target, uint64_t d) {
  d = __sync_fetch_and_add((uint64_t *)target, d);
  return;
}
__attribute__((unused)) static void ck_pr_add_32(uint32_t *target, uint32_t d) {
  d = __sync_fetch_and_add((uint32_t *)target, d);
  return;
}
__attribute__((unused)) static void ck_pr_add_16(uint16_t *target, uint16_t d) {
  d = __sync_fetch_and_add((uint16_t *)target, d);
  return;
}
__attribute__((unused)) static void ck_pr_add_8(uint8_t *target, uint8_t d) {
  d = __sync_fetch_and_add((uint8_t *)target, d);
  return;
}
__attribute__((unused)) static void ck_pr_sub_ptr(void *target, void *d) {
  d = __sync_fetch_and_sub((void **)target, d);
  return;
}
__attribute__((unused)) static void ck_pr_sub_char(char *target, char d) {
  d = __sync_fetch_and_sub((char *)target, d);
  return;
}
__attribute__((unused)) static void ck_pr_sub_int(int *target, int d) {
  d = __sync_fetch_and_sub((int *)target, d);
  return;
}
__attribute__((unused)) static void
ck_pr_sub_uint(unsigned int *target, unsigned int d) {
  d = __sync_fetch_and_sub((unsigned int *)target, d);
  return;
}
__attribute__((unused)) static void ck_pr_sub_64(uint64_t *target, uint64_t d) {
  d = __sync_fetch_and_sub((uint64_t *)target, d);
  return;
}
__attribute__((unused)) static void ck_pr_sub_32(uint32_t *target, uint32_t d) {
  d = __sync_fetch_and_sub((uint32_t *)target, d);
  return;
}
__attribute__((unused)) static void ck_pr_sub_16(uint16_t *target, uint16_t d) {
  d = __sync_fetch_and_sub((uint16_t *)target, d);
  return;
}
__attribute__((unused)) static void ck_pr_sub_8(uint8_t *target, uint8_t d) {
  d = __sync_fetch_and_sub((uint8_t *)target, d);
  return;
}
__attribute__((unused)) static void ck_pr_and_ptr(void *target, void *d) {
  d = __sync_fetch_and_and((void **)target, d);
  return;
}
__attribute__((unused)) static void ck_pr_and_char(char *target, char d) {
  d = __sync_fetch_and_and((char *)target, d);
  return;
}
__attribute__((unused)) static void ck_pr_and_int(int *target, int d) {
  d = __sync_fetch_and_and((int *)target, d);
  return;
}
__attribute__((unused)) static void
ck_pr_and_uint(unsigned int *target, unsigned int d) {
  d = __sync_fetch_and_and((unsigned int *)target, d);
  return;
}
__attribute__((unused)) static void ck_pr_and_64(uint64_t *target, uint64_t d) {
  d = __sync_fetch_and_and((uint64_t *)target, d);
  return;
}
__attribute__((unused)) static void ck_pr_and_32(uint32_t *target, uint32_t d) {
  d = __sync_fetch_and_and((uint32_t *)target, d);
  return;
}
__attribute__((unused)) static void ck_pr_and_16(uint16_t *target, uint16_t d) {
  d = __sync_fetch_and_and((uint16_t *)target, d);
  return;
}
__attribute__((unused)) static void ck_pr_and_8(uint8_t *target, uint8_t d) {
  d = __sync_fetch_and_and((uint8_t *)target, d);
  return;
}
__attribute__((unused)) static void ck_pr_or_ptr(void *target, void *d) {
  d = __sync_fetch_and_or((void **)target, d);
  return;
}
__attribute__((unused)) static void ck_pr_or_char(char *target, char d) {
  d = __sync_fetch_and_or((char *)target, d);
  return;
}
__attribute__((unused)) static void ck_pr_or_int(int *target, int d) {
  d = __sync_fetch_and_or((int *)target, d);
  return;
}
__attribute__((unused)) static void
ck_pr_or_uint(unsigned int *target, unsigned int d) {
  d = __sync_fetch_and_or((unsigned int *)target, d);
  return;
}
__attribute__((unused)) static void ck_pr_or_64(uint64_t *target, uint64_t d) {
  d = __sync_fetch_and_or((uint64_t *)target, d);
  return;
}
__attribute__((unused)) static void ck_pr_or_32(uint32_t *target, uint32_t d) {
  d = __sync_fetch_and_or((uint32_t *)target, d);
  return;
}
__attribute__((unused)) static void ck_pr_or_16(uint16_t *target, uint16_t d) {
  d = __sync_fetch_and_or((uint16_t *)target, d);
  return;
}
__attribute__((unused)) static void ck_pr_or_8(uint8_t *target, uint8_t d) {
  d = __sync_fetch_and_or((uint8_t *)target, d);
  return;
}
__attribute__((unused)) static void ck_pr_xor_ptr(void *target, void *d) {
  d = __sync_fetch_and_xor((void **)target, d);
  return;
}
__attribute__((unused)) static void ck_pr_xor_char(char *target, char d) {
  d = __sync_fetch_and_xor((char *)target, d);
  return;
}
__attribute__((unused)) static void ck_pr_xor_int(int *target, int d) {
  d = __sync_fetch_and_xor((int *)target, d);
  return;
}
__attribute__((unused)) static void
ck_pr_xor_uint(unsigned int *target, unsigned int d) {
  d = __sync_fetch_and_xor((unsigned int *)target, d);
  return;
}
__attribute__((unused)) static void ck_pr_xor_64(uint64_t *target, uint64_t d) {
  d = __sync_fetch_and_xor((uint64_t *)target, d);
  return;
}
__attribute__((unused)) static void ck_pr_xor_32(uint32_t *target, uint32_t d) {
  d = __sync_fetch_and_xor((uint32_t *)target, d);
  return;
}
__attribute__((unused)) static void ck_pr_xor_16(uint16_t *target, uint16_t d) {
  d = __sync_fetch_and_xor((uint16_t *)target, d);
  return;
}
__attribute__((unused)) static void ck_pr_xor_8(uint8_t *target, uint8_t d) {
  d = __sync_fetch_and_xor((uint8_t *)target, d);
  return;
}

__attribute__((unused)) static void ck_pr_inc_ptr(void *target) {
  ck_pr_add_ptr(target, (void *)1);
  return;
}
__attribute__((unused)) static void ck_pr_dec_ptr(void *target) {
  ck_pr_sub_ptr(target, (void *)1);
  return;
}
__attribute__((unused)) static void ck_pr_inc_char(char *target) {
  ck_pr_add_char(target, (char)1);
  return;
}
__attribute__((unused)) static void ck_pr_dec_char(char *target) {
  ck_pr_sub_char(target, (char)1);
  return;
}
__attribute__((unused)) static void ck_pr_inc_int(int *target) {
  ck_pr_add_int(target, (int)1);
  return;
}
__attribute__((unused)) static void ck_pr_dec_int(int *target) {
  ck_pr_sub_int(target, (int)1);
  return;
}
__attribute__((unused)) static void ck_pr_inc_uint(unsigned int *target) {
  ck_pr_add_uint(target, (unsigned int)1);
  return;
}
__attribute__((unused)) static void ck_pr_dec_uint(unsigned int *target) {
  ck_pr_sub_uint(target, (unsigned int)1);
  return;
}
__attribute__((unused)) static void ck_pr_inc_64(uint64_t *target) {
  ck_pr_add_64(target, (uint64_t)1);
  return;
}
__attribute__((unused)) static void ck_pr_dec_64(uint64_t *target) {
  ck_pr_sub_64(target, (uint64_t)1);
  return;
}
__attribute__((unused)) static void ck_pr_inc_32(uint32_t *target) {
  ck_pr_add_32(target, (uint32_t)1);
  return;
}
__attribute__((unused)) static void ck_pr_dec_32(uint32_t *target) {
  ck_pr_sub_32(target, (uint32_t)1);
  return;
}
__attribute__((unused)) static void ck_pr_inc_16(uint16_t *target) {
  ck_pr_add_16(target, (uint16_t)1);
  return;
}
__attribute__((unused)) static void ck_pr_dec_16(uint16_t *target) {
  ck_pr_sub_16(target, (uint16_t)1);
  return;
}
__attribute__((unused)) static void ck_pr_inc_8(uint8_t *target) {
  ck_pr_add_8(target, (uint8_t)1);
  return;
}
__attribute__((unused)) static void ck_pr_dec_8(uint8_t *target) {
  ck_pr_sub_8(target, (uint8_t)1);
  return;
}

__attribute__((unused)) static void ck_pr_fence_load_depends(void) {
  ck_pr_barrier();
  return;
}

__attribute__((unused)) static void ck_pr_fence_atomic(void) {
  ck_pr_barrier();
  return;
}
__attribute__((unused)) static void ck_pr_fence_atomic_load(void) {
  ck_pr_barrier();
  return;
}
__attribute__((unused)) static void ck_pr_fence_atomic_store(void) {
  ck_pr_barrier();
  return;
}
__attribute__((unused)) static void ck_pr_fence_store_atomic(void) {
  ck_pr_barrier();
  return;
}
__attribute__((unused)) static void ck_pr_fence_load_atomic(void) {
  ck_pr_barrier();
  return;
}
__attribute__((unused)) static void ck_pr_fence_load_store(void) {
  ck_pr_barrier();
  return;
}
__attribute__((unused)) static void ck_pr_fence_store_load(void) {
  ck_pr_fence_strict_store_load();
  return;
}
__attribute__((unused)) static void ck_pr_fence_load(void) {
  ck_pr_barrier();
  return;
}
__attribute__((unused)) static void ck_pr_fence_store(void) {
  ck_pr_barrier();
  return;
}
__attribute__((unused)) static void ck_pr_fence_memory(void) {
  ck_pr_fence_strict_memory();
  return;
}
__attribute__((unused)) static void ck_pr_fence_acquire(void) {
  ck_pr_barrier();
  return;
}
__attribute__((unused)) static void ck_pr_fence_release(void) {
  ck_pr_barrier();
  return;
}
__attribute__((unused)) static void ck_pr_fence_acqrel(void) {
  ck_pr_barrier();
  return;
}
__attribute__((unused)) static void ck_pr_fence_lock(void) {
  ck_pr_barrier();
  return;
}
__attribute__((unused)) static void ck_pr_fence_unlock(void) {
  ck_pr_barrier();
  return;
}

__attribute__((unused)) static void ck_pr_rfo(const void *m) {
  (void)m;
  return;
}

__attribute__((unused)) static bool
ck_pr_btc_int(int *target, unsigned int offset) {
  int previous;
  int punt;
  punt = ck_pr_md_load_int(target);
  previous = (int)punt;
  while (ck_pr_cas_int_value(
	   target, (int)previous, (int)(previous ^ (((int)1 << offset))),
	   &previous
	 ) == false)
    ck_pr_stall();
  return ((previous >> offset) & 1);
}

__attribute__((unused)) static bool
ck_pr_btr_int(int *target, unsigned int offset) {
  int previous;
  int punt;
  punt = ck_pr_md_load_int(target);
  previous = (int)punt;
  while (ck_pr_cas_int_value(
	   target, (int)previous, (int)(previous & (~((int)1 << offset))),
	   &previous
	 ) == false)
    ck_pr_stall();
  return ((previous >> offset) & 1);
}

__attribute__((unused)) static bool
ck_pr_bts_int(int *target, unsigned int offset) {
  int previous;
  int punt;
  punt = ck_pr_md_load_int(target);
  previous = (int)punt;
  while (ck_pr_cas_int_value(
	   target, (int)previous, (int)(previous | (((int)1 << offset))),
	   &previous
	 ) == false)
    ck_pr_stall();
  return ((previous >> offset) & 1);
}

__attribute__((unused)) static bool
ck_pr_btc_uint(unsigned int *target, unsigned int offset) {
  unsigned int previous;
  unsigned int punt;
  punt = ck_pr_md_load_uint(target);
  previous = (unsigned int)punt;
  while (ck_pr_cas_uint_value(
	   target, (unsigned int)previous,
	   (unsigned int)(previous ^ (((unsigned int)1 << offset))), &previous
	 ) == false)
    ck_pr_stall();
  return ((previous >> offset) & 1);
}

__attribute__((unused)) static bool
ck_pr_btr_uint(unsigned int *target, unsigned int offset) {
  unsigned int previous;
  unsigned int punt;
  punt = ck_pr_md_load_uint(target);
  previous = (unsigned int)punt;
  while (ck_pr_cas_uint_value(
	   target, (unsigned int)previous,
	   (unsigned int)(previous & (~((unsigned int)1 << offset))), &previous
	 ) == false)
    ck_pr_stall();
  return ((previous >> offset) & 1);
}

__attribute__((unused)) static bool
ck_pr_bts_uint(unsigned int *target, unsigned int offset) {
  unsigned int previous;
  unsigned int punt;
  punt = ck_pr_md_load_uint(target);
  previous = (unsigned int)punt;
  while (ck_pr_cas_uint_value(
	   target, (unsigned int)previous,
	   (unsigned int)(previous | (((unsigned int)1 << offset))), &previous
	 ) == false)
    ck_pr_stall();
  return ((previous >> offset) & 1);
}

__attribute__((unused)) static bool
ck_pr_btc_ptr(void *target, unsigned int offset) {
  uintptr_t previous;
  void *punt;
  punt = ck_pr_md_load_ptr(target);
  previous = (uintptr_t)punt;
  while (ck_pr_cas_ptr_value(
	   target, (void *)previous,
	   (void *)(previous ^ (((uintptr_t)1 << offset))), &previous
	 ) == false)
    ck_pr_stall();
  return ((previous >> offset) & 1);
}

__attribute__((unused)) static bool
ck_pr_btr_ptr(void *target, unsigned int offset) {
  uintptr_t previous;
  void *punt;
  punt = ck_pr_md_load_ptr(target);
  previous = (uintptr_t)punt;
  while (ck_pr_cas_ptr_value(
	   target, (void *)previous,
	   (void *)(previous & (~((uintptr_t)1 << offset))), &previous
	 ) == false)
    ck_pr_stall();
  return ((previous >> offset) & 1);
}

__attribute__((unused)) static bool
ck_pr_bts_ptr(void *target, unsigned int offset) {
  uintptr_t previous;
  void *punt;
  punt = ck_pr_md_load_ptr(target);
  previous = (uintptr_t)punt;
  while (ck_pr_cas_ptr_value(
	   target, (void *)previous,
	   (void *)(previous | (((uintptr_t)1 << offset))), &previous
	 ) == false)
    ck_pr_stall();
  return ((previous >> offset) & 1);
}

__attribute__((unused)) static bool
ck_pr_btc_64(uint64_t *target, unsigned int offset) {
  uint64_t previous;
  uint64_t punt;
  punt = ck_pr_md_load_64(target);
  previous = (uint64_t)punt;
  while (ck_pr_cas_64_value(
	   target, (uint64_t)previous,
	   (uint64_t)(previous ^ (((uint64_t)1 << offset))), &previous
	 ) == false)
    ck_pr_stall();
  return ((previous >> offset) & 1);
}

__attribute__((unused)) static bool
ck_pr_btr_64(uint64_t *target, unsigned int offset) {
  uint64_t previous;
  uint64_t punt;
  punt = ck_pr_md_load_64(target);
  previous = (uint64_t)punt;
  while (ck_pr_cas_64_value(
	   target, (uint64_t)previous,
	   (uint64_t)(previous & (~((uint64_t)1 << offset))), &previous
	 ) == false)
    ck_pr_stall();
  return ((previous >> offset) & 1);
}

__attribute__((unused)) static bool
ck_pr_bts_64(uint64_t *target, unsigned int offset) {
  uint64_t previous;
  uint64_t punt;
  punt = ck_pr_md_load_64(target);
  previous = (uint64_t)punt;
  while (ck_pr_cas_64_value(
	   target, (uint64_t)previous,
	   (uint64_t)(previous | (((uint64_t)1 << offset))), &previous
	 ) == false)
    ck_pr_stall();
  return ((previous >> offset) & 1);
}

__attribute__((unused)) static bool
ck_pr_btc_32(uint32_t *target, unsigned int offset) {
  uint32_t previous;
  uint32_t punt;
  punt = ck_pr_md_load_32(target);
  previous = (uint32_t)punt;
  while (ck_pr_cas_32_value(
	   target, (uint32_t)previous,
	   (uint32_t)(previous ^ (((uint32_t)1 << offset))), &previous
	 ) == false)
    ck_pr_stall();
  return ((previous >> offset) & 1);
}

__attribute__((unused)) static bool
ck_pr_btr_32(uint32_t *target, unsigned int offset) {
  uint32_t previous;
  uint32_t punt;
  punt = ck_pr_md_load_32(target);
  previous = (uint32_t)punt;
  while (ck_pr_cas_32_value(
	   target, (uint32_t)previous,
	   (uint32_t)(previous & (~((uint32_t)1 << offset))), &previous
	 ) == false)
    ck_pr_stall();
  return ((previous >> offset) & 1);
}

__attribute__((unused)) static bool
ck_pr_bts_32(uint32_t *target, unsigned int offset) {
  uint32_t previous;
  uint32_t punt;
  punt = ck_pr_md_load_32(target);
  previous = (uint32_t)punt;
  while (ck_pr_cas_32_value(
	   target, (uint32_t)previous,
	   (uint32_t)(previous | (((uint32_t)1 << offset))), &previous
	 ) == false)
    ck_pr_stall();
  return ((previous >> offset) & 1);
}

__attribute__((unused)) static bool
ck_pr_btc_16(uint16_t *target, unsigned int offset) {
  uint16_t previous;
  uint16_t punt;
  punt = ck_pr_md_load_16(target);
  previous = (uint16_t)punt;
  while (ck_pr_cas_16_value(
	   target, (uint16_t)previous,
	   (uint16_t)(previous ^ (((uint16_t)1 << offset))), &previous
	 ) == false)
    ck_pr_stall();
  return ((previous >> offset) & 1);
}

__attribute__((unused)) static bool
ck_pr_btr_16(uint16_t *target, unsigned int offset) {
  uint16_t previous;
  uint16_t punt;
  punt = ck_pr_md_load_16(target);
  previous = (uint16_t)punt;
  while (ck_pr_cas_16_value(
	   target, (uint16_t)previous,
	   (uint16_t)(previous & (~((uint16_t)1 << offset))), &previous
	 ) == false)
    ck_pr_stall();
  return ((previous >> offset) & 1);
}

__attribute__((unused)) static bool
ck_pr_bts_16(uint16_t *target, unsigned int offset) {
  uint16_t previous;
  uint16_t punt;
  punt = ck_pr_md_load_16(target);
  previous = (uint16_t)punt;
  while (ck_pr_cas_16_value(
	   target, (uint16_t)previous,
	   (uint16_t)(previous | (((uint16_t)1 << offset))), &previous
	 ) == false)
    ck_pr_stall();
  return ((previous >> offset) & 1);
}

__attribute__((unused)) static bool ck_pr_inc_char_is_zero(char *target) {
  char previous;
  char punt;
  punt = (char)ck_pr_md_load_char(target);
  previous = (char)punt;
  while (ck_pr_cas_char_value(
	   target, (char)previous, (char)(previous + 1), &previous
	 ) == false)
    ck_pr_stall();
  return previous == (char)-1;
}
__attribute__((unused)) static void
ck_pr_inc_char_zero(char *target, bool *zero) {
  *zero = ck_pr_inc_char_is_zero(target);
  return;
}

__attribute__((unused)) static bool ck_pr_dec_char_is_zero(char *target) {
  char previous;
  char punt;
  punt = (char)ck_pr_md_load_char(target);
  previous = (char)punt;
  while (ck_pr_cas_char_value(
	   target, (char)previous, (char)(previous - 1), &previous
	 ) == false)
    ck_pr_stall();
  return previous == (char)1;
}
__attribute__((unused)) static void
ck_pr_dec_char_zero(char *target, bool *zero) {
  *zero = ck_pr_dec_char_is_zero(target);
  return;
}

__attribute__((unused)) static bool ck_pr_inc_int_is_zero(int *target) {
  int previous;
  int punt;
  punt = (int)ck_pr_md_load_int(target);
  previous = (int)punt;
  while (ck_pr_cas_int_value(
	   target, (int)previous, (int)(previous + 1), &previous
	 ) == false)
    ck_pr_stall();
  return previous == (int)-1;
}
__attribute__((unused)) static void
ck_pr_inc_int_zero(int *target, bool *zero) {
  *zero = ck_pr_inc_int_is_zero(target);
  return;
}

__attribute__((unused)) static bool ck_pr_dec_int_is_zero(int *target) {
  int previous;
  int punt;
  punt = (int)ck_pr_md_load_int(target);
  previous = (int)punt;
  while (ck_pr_cas_int_value(
	   target, (int)previous, (int)(previous - 1), &previous
	 ) == false)
    ck_pr_stall();
  return previous == (int)1;
}
__attribute__((unused)) static void
ck_pr_dec_int_zero(int *target, bool *zero) {
  *zero = ck_pr_dec_int_is_zero(target);
  return;
}

__attribute__((unused)) static bool
ck_pr_inc_uint_is_zero(unsigned int *target) {
  unsigned int previous;
  unsigned int punt;
  punt = (unsigned int)ck_pr_md_load_uint(target);
  previous = (unsigned int)punt;
  while (ck_pr_cas_uint_value(
	   target, (unsigned int)previous, (unsigned int)(previous + 1),
	   &previous
	 ) == false)
    ck_pr_stall();
  return previous == (unsigned int)(0x7fffffff * 2U + 1U);
}
__attribute__((unused)) static void
ck_pr_inc_uint_zero(unsigned int *target, bool *zero) {
  *zero = ck_pr_inc_uint_is_zero(target);
  return;
}

__attribute__((unused)) static bool
ck_pr_dec_uint_is_zero(unsigned int *target) {
  unsigned int previous;
  unsigned int punt;
  punt = (unsigned int)ck_pr_md_load_uint(target);
  previous = (unsigned int)punt;
  while (ck_pr_cas_uint_value(
	   target, (unsigned int)previous, (unsigned int)(previous - 1),
	   &previous
	 ) == false)
    ck_pr_stall();
  return previous == (unsigned int)1;
}
__attribute__((unused)) static void
ck_pr_dec_uint_zero(unsigned int *target, bool *zero) {
  *zero = ck_pr_dec_uint_is_zero(target);
  return;
}

__attribute__((unused)) static bool ck_pr_inc_ptr_is_zero(void *target) {
  uintptr_t previous;
  void *punt;
  punt = (void *)ck_pr_md_load_ptr(target);
  previous = (uintptr_t)punt;
  while (ck_pr_cas_ptr_value(
	   target, (void *)previous, (void *)(previous + 1), &previous
	 ) == false)
    ck_pr_stall();
  return previous == (uintptr_t)(0x7fffffff * 2U + 1U);
}

__attribute__((unused)) static bool ck_pr_dec_ptr_is_zero(void *target) {
  uintptr_t previous;
  void *punt;
  punt = (void *)ck_pr_md_load_ptr(target);
  previous = (uintptr_t)punt;
  while (ck_pr_cas_ptr_value(
	   target, (void *)previous, (void *)(previous - 1), &previous
	 ) == false)
    ck_pr_stall();
  return previous == (uintptr_t)1;
}

__attribute__((unused)) static bool ck_pr_inc_64_is_zero(uint64_t *target) {
  uint64_t previous;
  uint64_t punt;
  punt = (uint64_t)ck_pr_md_load_64(target);
  previous = (uint64_t)punt;
  while (ck_pr_cas_64_value(
	   target, (uint64_t)previous, (uint64_t)(previous + 1), &previous
	 ) == false)
    ck_pr_stall();
  return previous == (uint64_t)(18446744073709551615UL);
}
__attribute__((unused)) static void
ck_pr_inc_64_zero(uint64_t *target, bool *zero) {
  *zero = ck_pr_inc_64_is_zero(target);
  return;
}

__attribute__((unused)) static bool ck_pr_dec_64_is_zero(uint64_t *target) {
  uint64_t previous;
  uint64_t punt;
  punt = (uint64_t)ck_pr_md_load_64(target);
  previous = (uint64_t)punt;
  while (ck_pr_cas_64_value(
	   target, (uint64_t)previous, (uint64_t)(previous - 1), &previous
	 ) == false)
    ck_pr_stall();
  return previous == (uint64_t)1;
}
__attribute__((unused)) static void
ck_pr_dec_64_zero(uint64_t *target, bool *zero) {
  *zero = ck_pr_dec_64_is_zero(target);
  return;
}

__attribute__((unused)) static bool ck_pr_inc_32_is_zero(uint32_t *target) {
  uint32_t previous;
  uint32_t punt;
  punt = (uint32_t)ck_pr_md_load_32(target);
  previous = (uint32_t)punt;
  while (ck_pr_cas_32_value(
	   target, (uint32_t)previous, (uint32_t)(previous + 1), &previous
	 ) == false)
    ck_pr_stall();
  return previous == (uint32_t)(4294967295U);
}
__attribute__((unused)) static void
ck_pr_inc_32_zero(uint32_t *target, bool *zero) {
  *zero = ck_pr_inc_32_is_zero(target);
  return;
}

__attribute__((unused)) static bool ck_pr_dec_32_is_zero(uint32_t *target) {
  uint32_t previous;
  uint32_t punt;
  punt = (uint32_t)ck_pr_md_load_32(target);
  previous = (uint32_t)punt;
  while (ck_pr_cas_32_value(
	   target, (uint32_t)previous, (uint32_t)(previous - 1), &previous
	 ) == false)
    ck_pr_stall();
  return previous == (uint32_t)1;
}
__attribute__((unused)) static void
ck_pr_dec_32_zero(uint32_t *target, bool *zero) {
  *zero = ck_pr_dec_32_is_zero(target);
  return;
}

__attribute__((unused)) static bool ck_pr_inc_16_is_zero(uint16_t *target) {
  uint16_t previous;
  uint16_t punt;
  punt = (uint16_t)ck_pr_md_load_16(target);
  previous = (uint16_t)punt;
  while (ck_pr_cas_16_value(
	   target, (uint16_t)previous, (uint16_t)(previous + 1), &previous
	 ) == false)
    ck_pr_stall();
  return previous == (uint16_t)(65535);
}
__attribute__((unused)) static void
ck_pr_inc_16_zero(uint16_t *target, bool *zero) {
  *zero = ck_pr_inc_16_is_zero(target);
  return;
}

__attribute__((unused)) static bool ck_pr_dec_16_is_zero(uint16_t *target) {
  uint16_t previous;
  uint16_t punt;
  punt = (uint16_t)ck_pr_md_load_16(target);
  previous = (uint16_t)punt;
  while (ck_pr_cas_16_value(
	   target, (uint16_t)previous, (uint16_t)(previous - 1), &previous
	 ) == false)
    ck_pr_stall();
  return previous == (uint16_t)1;
}
__attribute__((unused)) static void
ck_pr_dec_16_zero(uint16_t *target, bool *zero) {
  *zero = ck_pr_dec_16_is_zero(target);
  return;
}

__attribute__((unused)) static bool ck_pr_inc_8_is_zero(uint8_t *target) {
  uint8_t previous;
  uint8_t punt;
  punt = (uint8_t)ck_pr_md_load_8(target);
  previous = (uint8_t)punt;
  while (ck_pr_cas_8_value(
	   target, (uint8_t)previous, (uint8_t)(previous + 1), &previous
	 ) == false)
    ck_pr_stall();
  return previous == (uint8_t)(255);
}
__attribute__((unused)) static void
ck_pr_inc_8_zero(uint8_t *target, bool *zero) {
  *zero = ck_pr_inc_8_is_zero(target);
  return;
}

__attribute__((unused)) static bool ck_pr_dec_8_is_zero(uint8_t *target) {
  uint8_t previous;
  uint8_t punt;
  punt = (uint8_t)ck_pr_md_load_8(target);
  previous = (uint8_t)punt;
  while (ck_pr_cas_8_value(
	   target, (uint8_t)previous, (uint8_t)(previous - 1), &previous
	 ) == false)
    ck_pr_stall();
  return previous == (uint8_t)1;
}
__attribute__((unused)) static void
ck_pr_dec_8_zero(uint8_t *target, bool *zero) {
  *zero = ck_pr_dec_8_is_zero(target);
  return;
}

__attribute__((unused)) static void ck_pr_not_char(char *target) {
  char previous;
  char punt;
  punt = (char)ck_pr_md_load_char(target);
  previous = (char)punt;
  while (ck_pr_cas_char_value(
	   target, (char)previous, (char)(~previous), &previous
	 ) == false)
    ck_pr_stall();
  return;
}

__attribute__((unused)) static void ck_pr_neg_char(char *target) {
  char previous;
  char punt;
  punt = (char)ck_pr_md_load_char(target);
  previous = (char)punt;
  while (ck_pr_cas_char_value(
	   target, (char)previous, (char)(-previous), &previous
	 ) == false)
    ck_pr_stall();
  return;
}

__attribute__((unused)) static void
ck_pr_neg_char_zero(char *target, bool *zero) {
  char previous;
  char punt;
  punt = (char)ck_pr_md_load_char(target);
  previous = (char)punt;
  while (ck_pr_cas_char_value(
	   target, (char)previous, (char)(-previous), &previous
	 ) == false)
    ck_pr_stall();
  *zero = previous == 0;
  return;
}

__attribute__((unused)) static void ck_pr_not_int(int *target) {
  int previous;
  int punt;
  punt = (int)ck_pr_md_load_int(target);
  previous = (int)punt;
  while (ck_pr_cas_int_value(
	   target, (int)previous, (int)(~previous), &previous
	 ) == false)
    ck_pr_stall();
  return;
}

__attribute__((unused)) static void ck_pr_neg_int(int *target) {
  int previous;
  int punt;
  punt = (int)ck_pr_md_load_int(target);
  previous = (int)punt;
  while (ck_pr_cas_int_value(
	   target, (int)previous, (int)(-previous), &previous
	 ) == false)
    ck_pr_stall();
  return;
}

__attribute__((unused)) static void
ck_pr_neg_int_zero(int *target, bool *zero) {
  int previous;
  int punt;
  punt = (int)ck_pr_md_load_int(target);
  previous = (int)punt;
  while (ck_pr_cas_int_value(
	   target, (int)previous, (int)(-previous), &previous
	 ) == false)
    ck_pr_stall();
  *zero = previous == 0;
  return;
}

__attribute__((unused)) static void ck_pr_not_uint(unsigned int *target) {
  unsigned int previous;
  unsigned int punt;
  punt = (unsigned int)ck_pr_md_load_uint(target);
  previous = (unsigned int)punt;
  while (ck_pr_cas_uint_value(
	   target, (unsigned int)previous, (unsigned int)(~previous), &previous
	 ) == false)
    ck_pr_stall();
  return;
}

__attribute__((unused)) static void ck_pr_neg_uint(unsigned int *target) {
  unsigned int previous;
  unsigned int punt;
  punt = (unsigned int)ck_pr_md_load_uint(target);
  previous = (unsigned int)punt;
  while (ck_pr_cas_uint_value(
	   target, (unsigned int)previous, (unsigned int)(-previous), &previous
	 ) == false)
    ck_pr_stall();
  return;
}

__attribute__((unused)) static void
ck_pr_neg_uint_zero(unsigned int *target, bool *zero) {
  unsigned int previous;
  unsigned int punt;
  punt = (unsigned int)ck_pr_md_load_uint(target);
  previous = (unsigned int)punt;
  while (ck_pr_cas_uint_value(
	   target, (unsigned int)previous, (unsigned int)(-previous), &previous
	 ) == false)
    ck_pr_stall();
  *zero = previous == 0;
  return;
}

__attribute__((unused)) static void ck_pr_not_ptr(void *target) {
  uintptr_t previous;
  void *punt;
  punt = (void *)ck_pr_md_load_ptr(target);
  previous = (uintptr_t)punt;
  while (ck_pr_cas_ptr_value(
	   target, (void *)previous, (void *)(~previous), &previous
	 ) == false)
    ck_pr_stall();
  return;
}

__attribute__((unused)) static void ck_pr_neg_ptr(void *target) {
  uintptr_t previous;
  void *punt;
  punt = (void *)ck_pr_md_load_ptr(target);
  previous = (uintptr_t)punt;
  while (ck_pr_cas_ptr_value(
	   target, (void *)previous, (void *)(-previous), &previous
	 ) == false)
    ck_pr_stall();
  return;
}

__attribute__((unused)) static void
ck_pr_neg_ptr_zero(void *target, bool *zero) {
  uintptr_t previous;
  void *punt;
  punt = (void *)ck_pr_md_load_ptr(target);
  previous = (uintptr_t)punt;
  while (ck_pr_cas_ptr_value(
	   target, (void *)previous, (void *)(-previous), &previous
	 ) == false)
    ck_pr_stall();
  *zero = previous == 0;
  return;
}

__attribute__((unused)) static void ck_pr_not_64(uint64_t *target) {
  uint64_t previous;
  uint64_t punt;
  punt = (uint64_t)ck_pr_md_load_64(target);
  previous = (uint64_t)punt;
  while (ck_pr_cas_64_value(
	   target, (uint64_t)previous, (uint64_t)(~previous), &previous
	 ) == false)
    ck_pr_stall();
  return;
}

__attribute__((unused)) static void ck_pr_neg_64(uint64_t *target) {
  uint64_t previous;
  uint64_t punt;
  punt = (uint64_t)ck_pr_md_load_64(target);
  previous = (uint64_t)punt;
  while (ck_pr_cas_64_value(
	   target, (uint64_t)previous, (uint64_t)(-previous), &previous
	 ) == false)
    ck_pr_stall();
  return;
}

__attribute__((unused)) static void
ck_pr_neg_64_zero(uint64_t *target, bool *zero) {
  uint64_t previous;
  uint64_t punt;
  punt = (uint64_t)ck_pr_md_load_64(target);
  previous = (uint64_t)punt;
  while (ck_pr_cas_64_value(
	   target, (uint64_t)previous, (uint64_t)(-previous), &previous
	 ) == false)
    ck_pr_stall();
  *zero = previous == 0;
  return;
}

__attribute__((unused)) static void ck_pr_not_32(uint32_t *target) {
  uint32_t previous;
  uint32_t punt;
  punt = (uint32_t)ck_pr_md_load_32(target);
  previous = (uint32_t)punt;
  while (ck_pr_cas_32_value(
	   target, (uint32_t)previous, (uint32_t)(~previous), &previous
	 ) == false)
    ck_pr_stall();
  return;
}

__attribute__((unused)) static void ck_pr_neg_32(uint32_t *target) {
  uint32_t previous;
  uint32_t punt;
  punt = (uint32_t)ck_pr_md_load_32(target);
  previous = (uint32_t)punt;
  while (ck_pr_cas_32_value(
	   target, (uint32_t)previous, (uint32_t)(-previous), &previous
	 ) == false)
    ck_pr_stall();
  return;
}

__attribute__((unused)) static void
ck_pr_neg_32_zero(uint32_t *target, bool *zero) {
  uint32_t previous;
  uint32_t punt;
  punt = (uint32_t)ck_pr_md_load_32(target);
  previous = (uint32_t)punt;
  while (ck_pr_cas_32_value(
	   target, (uint32_t)previous, (uint32_t)(-previous), &previous
	 ) == false)
    ck_pr_stall();
  *zero = previous == 0;
  return;
}

__attribute__((unused)) static void ck_pr_not_16(uint16_t *target) {
  uint16_t previous;
  uint16_t punt;
  punt = (uint16_t)ck_pr_md_load_16(target);
  previous = (uint16_t)punt;
  while (ck_pr_cas_16_value(
	   target, (uint16_t)previous, (uint16_t)(~previous), &previous
	 ) == false)
    ck_pr_stall();
  return;
}

__attribute__((unused)) static void ck_pr_neg_16(uint16_t *target) {
  uint16_t previous;
  uint16_t punt;
  punt = (uint16_t)ck_pr_md_load_16(target);
  previous = (uint16_t)punt;
  while (ck_pr_cas_16_value(
	   target, (uint16_t)previous, (uint16_t)(-previous), &previous
	 ) == false)
    ck_pr_stall();
  return;
}

__attribute__((unused)) static void
ck_pr_neg_16_zero(uint16_t *target, bool *zero) {
  uint16_t previous;
  uint16_t punt;
  punt = (uint16_t)ck_pr_md_load_16(target);
  previous = (uint16_t)punt;
  while (ck_pr_cas_16_value(
	   target, (uint16_t)previous, (uint16_t)(-previous), &previous
	 ) == false)
    ck_pr_stall();
  *zero = previous == 0;
  return;
}

__attribute__((unused)) static void ck_pr_not_8(uint8_t *target) {
  uint8_t previous;
  uint8_t punt;
  punt = (uint8_t)ck_pr_md_load_8(target);
  previous = (uint8_t)punt;
  while (ck_pr_cas_8_value(
	   target, (uint8_t)previous, (uint8_t)(~previous), &previous
	 ) == false)
    ck_pr_stall();
  return;
}

__attribute__((unused)) static void ck_pr_neg_8(uint8_t *target) {
  uint8_t previous;
  uint8_t punt;
  punt = (uint8_t)ck_pr_md_load_8(target);
  previous = (uint8_t)punt;
  while (ck_pr_cas_8_value(
	   target, (uint8_t)previous, (uint8_t)(-previous), &previous
	 ) == false)
    ck_pr_stall();
  return;
}

__attribute__((unused)) static void
ck_pr_neg_8_zero(uint8_t *target, bool *zero) {
  uint8_t previous;
  uint8_t punt;
  punt = (uint8_t)ck_pr_md_load_8(target);
  previous = (uint8_t)punt;
  while (ck_pr_cas_8_value(
	   target, (uint8_t)previous, (uint8_t)(-previous), &previous
	 ) == false)
    ck_pr_stall();
  *zero = previous == 0;
  return;
}

__attribute__((unused)) static char ck_pr_fas_char(char *target, char update) {
  char previous;
  previous = ck_pr_md_load_char(target);
  while (ck_pr_cas_char_value(target, previous, update, &previous) == false)
    ck_pr_stall();
  return (previous);
}

__attribute__((unused)) static int ck_pr_fas_int(int *target, int update) {
  int previous;
  previous = ck_pr_md_load_int(target);
  while (ck_pr_cas_int_value(target, previous, update, &previous) == false)
    ck_pr_stall();
  return (previous);
}

__attribute__((unused)) static unsigned int
ck_pr_fas_uint(unsigned int *target, unsigned int update) {
  unsigned int previous;
  previous = ck_pr_md_load_uint(target);
  while (ck_pr_cas_uint_value(target, previous, update, &previous) == false)
    ck_pr_stall();
  return (previous);
}

__attribute__((unused)) static void *ck_pr_fas_ptr(void *target, void *update) {
  void *previous;
  previous = ck_pr_md_load_ptr(target);
  while (ck_pr_cas_ptr_value(target, previous, update, &previous) == false)
    ck_pr_stall();
  return (previous);
}

__attribute__((unused)) static uint64_t
ck_pr_fas_64(uint64_t *target, uint64_t update) {
  uint64_t previous;
  previous = ck_pr_md_load_64(target);
  while (ck_pr_cas_64_value(target, previous, update, &previous) == false)
    ck_pr_stall();
  return (previous);
}

__attribute__((unused)) static uint32_t
ck_pr_fas_32(uint32_t *target, uint32_t update) {
  uint32_t previous;
  previous = ck_pr_md_load_32(target);
  while (ck_pr_cas_32_value(target, previous, update, &previous) == false)
    ck_pr_stall();
  return (previous);
}

__attribute__((unused)) static uint16_t
ck_pr_fas_16(uint16_t *target, uint16_t update) {
  uint16_t previous;
  previous = ck_pr_md_load_16(target);
  while (ck_pr_cas_16_value(target, previous, update, &previous) == false)
    ck_pr_stall();
  return (previous);
}

__attribute__((unused)) static uint8_t
ck_pr_fas_8(uint8_t *target, uint8_t update) {
  uint8_t previous;
  previous = ck_pr_md_load_8(target);
  while (ck_pr_cas_8_value(target, previous, update, &previous) == false)
    ck_pr_stall();
  return (previous);
}

struct ck_elide_config {
  unsigned short skip_busy;
  short retry_busy;
  unsigned short skip_other;
  short retry_other;
  unsigned short skip_conflict;
  short retry_conflict;
};

struct ck_elide_stat {
  unsigned int n_fallback;
  unsigned int n_elide;
  unsigned short skip;
};
typedef struct ck_elide_stat ck_elide_stat_t;

__attribute__((unused)) static void ck_elide_stat_init(ck_elide_stat_t *st) {
  memset(st, 0, sizeof(*st));
  return;
}

struct ck_rwlock {
  unsigned int writer;
  unsigned int n_readers;
};
typedef struct ck_rwlock ck_rwlock_t;

__attribute__((unused)) static void ck_rwlock_init(struct ck_rwlock *rw) {
  rw->writer = 0;
  rw->n_readers = 0;
  ck_pr_barrier();
  return;
}

__attribute__((unused)) static void ck_rwlock_write_unlock(ck_rwlock_t *rw) {
  ck_pr_fence_unlock();
  ck_pr_md_store_uint(
    ((void)sizeof(*((&rw->writer)) = ((0))), ((&rw->writer))), ((0))
  );
  return;
}

__attribute__((unused)) static bool ck_rwlock_locked_writer(ck_rwlock_t *rw) {
  bool r;

  r = ck_pr_md_load_uint(((&rw->writer)));
  ck_pr_fence_acquire();
  return r;
}

__attribute__((unused)) static void ck_rwlock_write_downgrade(ck_rwlock_t *rw) {
  ck_pr_inc_uint(&rw->n_readers);
  ck_rwlock_write_unlock(rw);
  return;
}

__attribute__((unused)) static bool ck_rwlock_locked(ck_rwlock_t *rw) {
  bool l;

  l = ck_pr_md_load_uint(((&rw->n_readers))) |
    ck_pr_md_load_uint(((&rw->writer)));
  ck_pr_fence_acquire();
  return l;
}

__attribute__((unused)) static bool ck_rwlock_write_trylock(ck_rwlock_t *rw) {
  if (ck_pr_fas_uint(&rw->writer, 1) != 0) return false;

  ck_pr_fence_atomic_load();

  if (ck_pr_md_load_uint(((&rw->n_readers))) != 0) {
    ck_rwlock_write_unlock(rw);
    return false;
  }

  ck_pr_fence_lock();
  return true;
}

__attribute__((unused)) static bool
ck_elide_ck_rwlock_write_trylock(ck_rwlock_t *lock) {
  return ck_rwlock_locked(lock);
}

__attribute__((unused)) static void ck_rwlock_write_lock(ck_rwlock_t *rw) {
  while (ck_pr_fas_uint(&rw->writer, 1) != 0) ck_pr_stall();

  ck_pr_fence_atomic_load();

  while (ck_pr_md_load_uint(((&rw->n_readers))) != 0) ck_pr_stall();

  ck_pr_fence_lock();
  return;
}

__attribute__((unused)) static void ck_elide_ck_rwlock_write_lock_adaptive(
  ck_rwlock_t *lock, struct ck_elide_stat *st, struct ck_elide_config *c
) {
  (void)st;
  (void)c;
  ck_rwlock_write_lock(lock);
  return;
}
__attribute__((unused)) static void ck_elide_ck_rwlock_write_unlock_adaptive(
  struct ck_elide_stat *st, ck_rwlock_t *lock
) {
  (void)st;
  ck_rwlock_write_unlock(lock);
  return;
}
__attribute__((unused)) static void
ck_elide_ck_rwlock_write_lock(ck_rwlock_t *lock) {
  ck_rwlock_write_lock(lock);
  return;
}
__attribute__((unused)) static void
ck_elide_ck_rwlock_write_unlock(ck_rwlock_t *lock) {
  ck_rwlock_write_unlock(lock);
  return;
}

__attribute__((unused)) static bool ck_rwlock_read_trylock(ck_rwlock_t *rw) {
  if (ck_pr_md_load_uint(((&rw->writer))) != 0) return false;

  ck_pr_inc_uint(&rw->n_readers);

  ck_pr_fence_atomic_load();

  if (ck_pr_md_load_uint(((&rw->writer))) == 0) {
    ck_pr_fence_lock();
    return true;
  }

  ck_pr_dec_uint(&rw->n_readers);
  return false;
}

__attribute__((unused)) static bool
ck_elide_ck_rwlock_read_trylock(ck_rwlock_t *lock) {
  return ck_rwlock_locked_writer(lock);
}

__attribute__((unused)) static void ck_rwlock_read_lock(ck_rwlock_t *rw) {
  for (;;) {
    while (ck_pr_md_load_uint(((&rw->writer))) != 0) ck_pr_stall();

    ck_pr_inc_uint(&rw->n_readers);

    ck_pr_fence_atomic_load();

    if (ck_pr_md_load_uint(((&rw->writer))) == 0) break;

    ck_pr_dec_uint(&rw->n_readers);
  }

  ck_pr_fence_load();
  return;
}

__attribute__((unused)) static bool ck_rwlock_locked_reader(ck_rwlock_t *rw) {
  ck_pr_fence_load();
  return ck_pr_md_load_uint(((&rw->n_readers)));
}

__attribute__((unused)) static void ck_rwlock_read_unlock(ck_rwlock_t *rw) {
  ck_pr_fence_load_atomic();
  ck_pr_dec_uint(&rw->n_readers);
  return;
}

__attribute__((unused)) static void ck_elide_ck_rwlock_read_lock_adaptive(
  ck_rwlock_t *lock, struct ck_elide_stat *st, struct ck_elide_config *c
) {
  (void)st;
  (void)c;
  ck_rwlock_read_lock(lock);
  return;
}
__attribute__((unused)) static void ck_elide_ck_rwlock_read_unlock_adaptive(
  struct ck_elide_stat *st, ck_rwlock_t *lock
) {
  (void)st;
  ck_rwlock_read_unlock(lock);
  return;
}
__attribute__((unused)) static void
ck_elide_ck_rwlock_read_lock(ck_rwlock_t *lock) {
  ck_rwlock_read_lock(lock);
  return;
}
__attribute__((unused)) static void
ck_elide_ck_rwlock_read_unlock(ck_rwlock_t *lock) {
  ck_rwlock_read_unlock(lock);
  return;
}

struct ck_rwlock_recursive {
  struct ck_rwlock rw;
  unsigned int wc;
};
typedef struct ck_rwlock_recursive ck_rwlock_recursive_t;

__attribute__((unused)) static void
ck_rwlock_recursive_write_lock(ck_rwlock_recursive_t *rw, unsigned int tid) {
  unsigned int o;

  o = ck_pr_md_load_uint(((&rw->rw.writer)));
  if (o == tid) goto leave;

  while (ck_pr_cas_uint(&rw->rw.writer, 0, tid) == false) ck_pr_stall();

  ck_pr_fence_atomic_load();

  while (ck_pr_md_load_uint(((&rw->rw.n_readers))) != 0) ck_pr_stall();

  ck_pr_fence_lock();
leave:
  rw->wc++;
  return;
}

__attribute__((unused)) static bool
ck_rwlock_recursive_write_trylock(ck_rwlock_recursive_t *rw, unsigned int tid) {
  unsigned int o;

  o = ck_pr_md_load_uint(((&rw->rw.writer)));
  if (o == tid) goto leave;

  if (ck_pr_cas_uint(&rw->rw.writer, 0, tid) == false) return false;

  ck_pr_fence_atomic_load();

  if (ck_pr_md_load_uint(((&rw->rw.n_readers))) != 0) {
    ck_pr_md_store_uint(
      ((void)sizeof(*((&rw->rw.writer)) = ((0))), ((&rw->rw.writer))), ((0))
    );
    return false;
  }

  ck_pr_fence_lock();
leave:
  rw->wc++;
  return true;
}

__attribute__((unused)) static void
ck_rwlock_recursive_write_unlock(ck_rwlock_recursive_t *rw) {
  if (--rw->wc == 0) {
    ck_pr_fence_unlock();
    ck_pr_md_store_uint(
      ((void)sizeof(*((&rw->rw.writer)) = ((0))), ((&rw->rw.writer))), ((0))
    );
  }

  return;
}

__attribute__((unused)) static void
ck_rwlock_recursive_read_lock(ck_rwlock_recursive_t *rw) {
  ck_rwlock_read_lock(&rw->rw);
  return;
}

__attribute__((unused)) static bool
ck_rwlock_recursive_read_trylock(ck_rwlock_recursive_t *rw) {
  return ck_rwlock_read_trylock(&rw->rw);
}

__attribute__((unused)) static void
ck_rwlock_recursive_read_unlock(ck_rwlock_recursive_t *rw) {
  ck_rwlock_read_unlock(&rw->rw);
  return;
}

struct ck_pflock {
  uint32_t rin;
  uint32_t rout;
  uint32_t win;
  uint32_t wout;
};
typedef struct ck_pflock ck_pflock_t;

__attribute__((unused)) static void ck_pflock_init(struct ck_pflock *pf) {
  pf->rin = 0;
  pf->rout = 0;
  pf->win = 0;
  pf->wout = 0;
  ck_pr_barrier();

  return;
}

__attribute__((unused)) static void ck_pflock_write_unlock(ck_pflock_t *pf) {
  ck_pr_fence_unlock();

  ck_pr_and_32(&pf->rin, 0xFFFFFFF0);

  ck_pr_faa_32(&pf->wout, 1);
  return;
}

__attribute__((unused)) static void ck_pflock_write_lock(ck_pflock_t *pf) {
  uint32_t ticket;

  ticket = ck_pr_faa_32(&pf->win, 1);
  while (ck_pr_md_load_32(((&pf->wout))) != ticket) ck_pr_stall();

  ticket = ck_pr_faa_32(&pf->rin, (ticket & 0x1) | 0x2);

  while (ck_pr_md_load_32(((&pf->rout))) != ticket) ck_pr_stall();

  ck_pr_fence_lock();
  return;
}

__attribute__((unused)) static void ck_pflock_read_unlock(ck_pflock_t *pf) {
  ck_pr_fence_unlock();
  ck_pr_faa_32(&pf->rout, 0x100);
  return;
}

__attribute__((unused)) static void ck_pflock_read_lock(ck_pflock_t *pf) {
  uint32_t w;

  w = ck_pr_faa_32(&pf->rin, 0x100) & 0x3;
  if (w == 0) goto leave;

  while ((ck_pr_md_load_32(((&pf->rin))) & 0x3) == w) ck_pr_stall();

leave:

  ck_pr_fence_lock();
  return;
}

class ZmRWLock {
  ZmRWLock(const ZmRWLock &);
  ZmRWLock &operator=(const ZmRWLock &);

public:
  inline ZmRWLock() { memset(&m_lock, 0, sizeof(ck_rwlock_recursive_t)); }

  inline void lock() { ck_rwlock_recursive_write_lock(&m_lock, Zm::getTID()); }
  inline int trylock() {
    return ck_rwlock_recursive_write_trylock(&m_lock, Zm::getTID()) ? 0 : -1;
  }
  inline void unlock() { ck_rwlock_recursive_write_unlock(&m_lock); }

  inline void readlock() { ck_rwlock_recursive_read_lock(&m_lock); }
  inline int readtrylock() {
    return ck_rwlock_recursive_read_trylock(&m_lock) ? 0 : -1;
  }
  inline void readunlock() { ck_rwlock_recursive_read_unlock(&m_lock); }

  template <typename S> void print(S &s) const {
    s << "writer=" << ZuBoxed(m_lock.rw.writer)
      << " n_readers=" << ZuBoxed(m_lock.rw.n_readers)
      << " wc=" << ZuBoxed(m_lock.wc);
  }
  friend ZuPrintFn ZuPrintType(ZmRWLock *);

private:
  ck_rwlock_recursive_t m_lock;
};

template <>
struct ZmLockTraits<ZmRWLock> : public ZmGenericLockTraits<ZmRWLock> {
  enum { RWLock = 1 };
  inline static void readlock(ZmRWLock &l) { l.readlock(); }
  inline static int readtrylock(ZmRWLock &l) { return l.readtrylock(); }
  inline static void readunlock(ZmRWLock &l) { l.readunlock(); }
};

class ZmPRWLock {
  ZmPRWLock(const ZmPRWLock &);
  ZmPRWLock &operator=(const ZmPRWLock &);

public:
  inline ZmPRWLock() { ck_pflock_init(&m_lock); }

  inline void lock() { ck_pflock_write_lock(&m_lock); }
  inline void unlock() { ck_pflock_write_unlock(&m_lock); }

  inline void readlock() { ck_pflock_read_lock(&m_lock); }
  inline void readunlock() { ck_pflock_read_unlock(&m_lock); }

  template <typename S> void print(S &s) const {
    s << "rin=" << ZuBoxed(m_lock.rin) << " rout=" << ZuBoxed(m_lock.rout)
      << " win=" << ZuBoxed(m_lock.win) << " lock=" << ZuBoxed(m_lock.wout);
  }
  friend ZuPrintFn ZuPrintType(ZmPRWLock *);

private:
  ck_pflock_t m_lock;
};

template <>
struct ZmLockTraits<ZmPRWLock> : public ZmGenericLockTraits<ZmPRWLock> {
  enum { CanTry = 0, Recursive = 0, RWLock = 1 };
  inline static void readlock(ZmPRWLock &l) { l.readlock(); }
  inline static void readunlock(ZmPRWLock &l) { l.readunlock(); }

private:
  static int trylock(ZmPRWLock &);
  static int readtrylock(ZmPRWLock &);
};

namespace ZmBlock_ {
inline ZmSemaphore &sem() { return ZmTLS<ZmSemaphore, sem>(); }
}

template <typename... Args> struct ZmBlock {
  using R = ZuTuple<Args...>;
  template <typename L> R operator()(L l) const {
    R r;
    auto &sem = ZmBlock_::sem();
    l([&sem, &r](Args... args) mutable {
      r = ZuMvTuple(ZuMv(args)...);
      sem.post();
    });
    sem.wait();
    return r;
  }
  template <typename L, typename Reduce>
  R operator()(unsigned n, L l, Reduce reduce) const {
    auto r = ZmAlloc_<R>{static_cast<R *>(
      !(n) ? nullptr :
	     (((ZmStackAvail() >> 1) < ((n) * sizeof(R))) ?
		Zm::alignedAlloc<alignof(R)>((n) * sizeof(R)) :
		__builtin_alloca_with_align((n) * sizeof(R), (alignof(R)) << 3))
    )};
    if (!r) throw std::bad_alloc{};
    auto &sem = ZmBlock_::sem();
    for (unsigned i = 0; i < n; i++)
      l(i, [&sem, &r = r[i]](Args... args) mutable {
	r = ZuMvTuple(ZuMv(args)...);
	sem.post();
      });
    for (unsigned i = 0; i < n; i++) sem.wait();
    for (unsigned i = 1; i < n; i++) reduce(r[0], r[i]);
    return r[0];
  }
};
template <typename Arg> struct ZmBlock<Arg> {
  using R = Arg;
  template <typename L> R operator()(L l) const {
    R r;
    auto &sem = ZmBlock_::sem();
    l([&sem, &r](Arg arg) mutable {
      r = ZuMv(arg);
      sem.post();
    });
    sem.wait();
    return r;
  }
  template <typename L, typename Reduce>
  R operator()(unsigned n, L l, Reduce reduce) const {
    auto r = ZmAlloc_<R>{static_cast<R *>(
      !(n) ? nullptr :
	     (((ZmStackAvail() >> 1) < ((n) * sizeof(R))) ?
		Zm::alignedAlloc<alignof(R)>((n) * sizeof(R)) :
		__builtin_alloca_with_align((n) * sizeof(R), (alignof(R)) << 3))
    )};
    if (!r) throw std::bad_alloc{};
    auto &sem = ZmBlock_::sem();
    for (unsigned i = 0; i < n; i++)
      l(i, [&sem, &r = r[i]](Arg arg) mutable {
	r = ZuMv(arg);
	sem.post();
      });
    for (unsigned i = 0; i < n; i++) sem.wait();
    for (unsigned i = 1; i < n; i++) reduce(r[0], r[i]);
    return r[0];
  }
};
template <> struct ZmBlock<> {
  template <typename L> void operator()(L l) const {
    auto &sem = ZmBlock_::sem();
    l([&sem]() mutable { sem.post(); });
    sem.wait();
    return;
  }
  template <typename L> void operator()(unsigned n, L l) const {
    auto &sem = ZmBlock_::sem();
    for (unsigned i = 0; i < n; i++) l(i, [&sem]() mutable { sem.post(); });
    for (unsigned i = 0; i < n; i++) sem.wait();
    return;
  }
};

namespace ZmEngineState {
enum _ { Stopped = 0, Starting, Running, Stopping, StartPending, StopPending };
}

template <typename Impl> class ZmEngine {
  auto impl() const { return static_cast<const Impl *>(this); }
  auto impl() { return static_cast<Impl *>(this); }

private:
  using Lock = ZmPRWLock;
  using Guard = ZmGuard<Lock>;
  using ReadGuard = ZmReadGuard<Lock>;

  static const char *HeapID() { return "ZmEngine"; };
  using CtrlFnRing = ZmXRing<ZmFn<void(bool)>, ZmXRingHeapID<HeapID>>;

public:
  template <typename L> bool lock(int state, L l) {
    Guard guard(m_lock);
    if (m_state != state) {
      std::cerr
	<< (ZuCArray<120>{} << "ZmEngine::lock() m_state=" << int(m_state)
			    << " state=" << state << '\n')
	<< std::flush;
      return false;
    }
    return l();
  }

  void start(ZmFn<void(bool)>);
  void stop(ZmFn<void(bool)>);

  bool start();
  bool stop();

  int state() const { return m_state; }
  bool running() const {
    using namespace ZmEngineState;
    switch (m_state) {
    case Starting:
    case Running:
      return true;
    }
    return false;
  }

  bool stopped();

protected:
  void started(bool ok);
  void stopped(bool ok);

  void stateChanged() { }

  template <typename L> bool spawn(L l) {
    l();
    return true;
  }
  void wake() { stopped(); }

private:
  Lock m_lock;
  CtrlFnRing m_startFn, m_stopFn;
  ZmAtomic<int> m_state = ZmEngineState::Stopped;
};

template <typename Impl>
inline void ZmEngine<Impl>::start(ZmFn<void(bool)> startFn) {
  using namespace ZmEngineState;
  bool ok;

  {
    Guard guard(m_lock);

    if (m_state == Running) {
      startFn(true);
      return;
    }

    if (startFn) m_startFn.push(ZuMv(startFn));

    switch (m_state.load_()) {
    case Stopped:
      m_state = Starting;
      break;
    case Stopping:
      m_state = StartPending;
      guard.unlock();
      impl()->stateChanged();
      return;
    case StopPending:
      m_state = Starting;
      guard.unlock();
      impl()->stateChanged();
      return;
    default:
      return;
    }
  }

  ok = impl()->spawn([this]() { impl()->start_(); });

  if (ok)
    impl()->stateChanged();
  else
    started(false);
}
template <typename Impl> inline bool ZmEngine<Impl>::start() {
  return ZmBlock<bool>{}([this](auto wake) { this->start(ZuMv(wake)); });
}
template <typename Impl> inline void ZmEngine<Impl>::started(bool ok) {
  using namespace ZmEngineState;
  Guard guard(m_lock);
  bool stop = false, stopped = false;
  auto startFn = ZuMv(m_startFn);
  m_startFn.clean();
  if (!ok) {
    switch (m_state) {
    case Starting:
      m_state = Stopped;
      break;
    case StopPending:
      stopped = true;
      m_state = Stopping;
      break;
    }
  } else {
    switch (m_state) {
    case Starting:
      m_state = Running;
      break;
    case StopPending:
      stop = true;
      m_state = Running;
      break;
    }
  }
  guard.unlock();
  impl()->stateChanged();
  while (auto fn = startFn.shift()) fn(ok);
  if (stop)
    this->stop({});
  else if (stopped)
    this->stopped(true);
}

template <typename Impl>
inline void ZmEngine<Impl>::stop(ZmFn<void(bool)> stopFn) {
  using namespace ZmEngineState;

  {
    Guard guard(m_lock);

    if (m_state == Stopped) {
      stopFn(true);
      return;
    }

    if (stopFn) m_stopFn.push(ZuMv(stopFn));

    switch (m_state.load_()) {
    case Running:
      m_state = Stopping;
      break;
    case Starting:
      m_state = StopPending;
      guard.unlock();
      impl()->stateChanged();
      return;
    case StartPending:
      m_state = Stopping;
      guard.unlock();
      impl()->stateChanged();
      return;
    default:
      return;
    }
  }

  impl()->stateChanged();

  impl()->wake();
}
template <typename Impl> inline bool ZmEngine<Impl>::stop() {
  return ZmBlock<bool>{}([this](auto wake) { this->stop(ZuMv(wake)); });
}
template <typename Impl> inline bool ZmEngine<Impl>::stopped() {
  using namespace ZmEngineState;
  switch (m_state) {
  case Stopping:
  case StartPending:
    impl()->stop_();
    return true;
  }
  return false;
}
template <typename Impl> inline void ZmEngine<Impl>::stopped(bool ok) {
  using namespace ZmEngineState;
  Guard guard(m_lock);
  bool start = false, started = false;
  auto stopFn = ZuMv(m_stopFn);
  m_stopFn.clean();
  if (!ok) {
    switch (m_state) {
    case Stopping:
      m_state = Running;
      break;
    case StartPending:
      started = true;
      m_state = Starting;
      break;
    }
  } else {
    switch (m_state) {
    case Stopping:
      m_state = Stopped;
      break;
    case StartPending:
      start = true;
      m_state = Stopped;
      break;
    }
  }
  guard.unlock();
  impl()->stateChanged();
  while (auto fn = stopFn.shift()) fn(ok);
  if (start)
    this->start({});
  else if (started)
    this->started(true);
}

class ZmSchedTParams : public ZmThreadParams {
public:
  ZmSchedTParams &&isolated(bool b) {
    m_isolated = b;
    return ZuMv(*this);
  }

  bool isolated() const { return m_isolated; }

private:
  bool m_isolated = false;
};

struct ZmSchedParams {
  ZmSchedParams() = default;
  ZmSchedParams(const ZmSchedParams &) = default;
  ZmSchedParams &operator=(const ZmSchedParams &) = default;
  ZmSchedParams(ZmSchedParams &&) = default;
  ZmSchedParams &operator=(ZmSchedParams &&) = default;

  using Thread = ZmSchedTParams;
  using Threads = ZuMvArray<Thread>;

  using ID = ZuID;

  ZmSchedParams &&id(ID id) {
    m_id = id;
    return ZuMv(*this);
  }
  ZmSchedParams &&nThreads(unsigned v) {
    m_threads.length((m_nThreads = v) + 1);
    return ZuMv(*this);
  }
  ZmSchedParams &&stackSize(unsigned v) {
    m_stackSize = v;
    return ZuMv(*this);
  }
  ZmSchedParams &&priority(unsigned v) {
    m_priority = v;
    return ZuMv(*this);
  }
  ZmSchedParams &&partition(unsigned v) {
    m_partition = v;
    return ZuMv(*this);
  }
  ZmSchedParams &&quantum(ZuTime v) {
    m_quantum = v;
    return ZuMv(*this);
  }

  ZmSchedParams &&queueSize(unsigned v) {
    m_queueSize = v;
    return ZuMv(*this);
  }
  ZmSchedParams &&ll(bool v) {
    m_ll = v;
    return ZuMv(*this);
  }
  ZmSchedParams &&spin(unsigned v) {
    m_spin = v;
    return ZuMv(*this);
  }
  ZmSchedParams &&timeout(unsigned v) {
    m_timeout = v;
    return ZuMv(*this);
  }

  ZmSchedParams &&startTimer(bool b) {
    m_startTimer = b;
    return ZuMv(*this);
  }

  template <typename L> ZmSchedParams &&thread(unsigned sid, L l) {
    l(m_threads[sid]);
    return ZuMv(*this);
  }
  Thread &thread(unsigned sid) { return m_threads[sid]; }

  ID id() const { return m_id; }
  unsigned nThreads() const { return m_nThreads; }
  unsigned stackSize() const { return m_stackSize; }
  int priority() const { return m_priority; }
  int partition() const { return m_partition; }
  const ZuTime &quantum() const { return m_quantum; }

  unsigned queueSize() const { return m_queueSize; }
  bool ll() const { return m_ll; }
  unsigned spin() const { return m_spin; }
  unsigned timeout() const { return m_timeout; }

  bool startTimer() const { return m_startTimer; }

  const Thread &thread(unsigned sid) const { return m_threads[sid]; }

public:
  unsigned sid(ZuCSpan s) const {
    unsigned sid;
    if (sid = ZuBox<unsigned, ZuBoxCmp<ZuCmp0>>{s}) return sid;
    for (sid = 0; sid <= m_nThreads; sid++)
      if (s == m_threads[sid].name()) return sid;
    return 0;
  }

private:
  ID m_id;
  unsigned m_nThreads = 1;
  unsigned m_stackSize = 0;
  int m_priority = -1;
  int m_partition = -1;
  ZuTime m_quantum{ZuTime::Nano{1000}};

  unsigned m_queueSize = 131072;
  unsigned m_spin = 1000;
  unsigned m_timeout = 1;

  Threads m_threads = Threads{m_nThreads + 1};

  bool m_startTimer = false;

  bool m_ll = false;
};

class ZmScheduler : public ZmEngine<ZmScheduler> {
  ZmScheduler(const ZmScheduler &) = delete;
  ZmScheduler &operator=(const ZmScheduler &) = delete;

  friend ZmEngine<ZmScheduler>;

public:
  using ID = ZmSchedParams::ID;

private:
  using Ring = ZmRing<ZmRingMW<true>>;

  static const char *Fn_HeapID() { return "ZmScheduler.Fn"; }
  using Fn = ZmRingFn<ZmRingFnHeapID<Fn_HeapID>>;

  static const char *OverRing_HeapID() { return "ZmScheduler.OverRing"; }
  using OverRing_ = ZmXRing<Fn, ZmXRingHeapID<OverRing_HeapID>>;
  struct OverRing : public OverRing_ {
    using Lock = ZmPLock;
    using Guard = ZmGuard<Lock>;
    using ReadGuard = ZmReadGuard<Lock>;

    inline void push(Fn fn) {
      Guard guard(m_lock);
      OverRing_::push(ZuMv(fn));
      ++m_inCount;
    }
    inline void unshift(Fn fn) {
      Guard guard(m_lock);
      OverRing_::unshift(ZuMv(fn));
      --m_outCount;
    }
    inline Fn shift() {
      Guard guard(m_lock);
      Fn fn = OverRing_::shift();
      if (fn) ++m_outCount;
      return fn;
    }
    void stats(uint64_t &inCount, uint64_t &outCount) const {
      ReadGuard guard(m_lock);
      inCount = m_inCount;
      outCount = m_outCount;
    }

    Lock m_lock;
    unsigned m_inCount = 0;
    unsigned m_outCount = 0;
  };
  enum { OverRing_Increment = 128 };

private:
  struct Timer_ {
    Fn fn;
    unsigned sid = 0;
    ZuTime timeout;
    bool transient = false;

    Timer_() { }
    Timer_(const Timer_ &) = delete;
    Timer_ &operator=(const Timer_ &) = delete;
    Timer_(Timer_ &&) = delete;
    Timer_ &operator=(Timer_ &&) = delete;
    ~Timer_() = default;

    Timer_(bool transient_) : transient{transient_} { }

    bool operator!() const { return !*timeout; }
    operator const void *() const {
      return !*this ? reinterpret_cast<const void *>(0) :
		      static_cast<const void *>(this);
    }
  };
  static const ZuTime &Timer_TimeoutAxor(const Timer_ &t) { return t.timeout; }
  static const char *ScheduleTree_HeapID() {
    return "ZmScheduler.ScheduleTree";
  }
  using ScheduleTree = ZmRBTree<
    Timer_,
    ZmRBTreeKey<
      Timer_TimeoutAxor,
      ZmRBTreeNode<
	Timer_, ZmRBTreeHeapID<ScheduleTree_HeapID, ZmRBTreeShadow<true>>>>>;

public:
  using Timer = ScheduleTree::Node;

public:
  ZmScheduler(ZmSchedParams params = {});
  virtual ~ZmScheduler();

  const ZmSchedParams &params() const { return m_params; }

protected:
  ZmSchedParams &params_() { return m_params; }

public:
  ZuID id() const { return m_params.id(); }

  bool stop();

  bool reset();

  void wakeFn(unsigned tid, ZmFn<> fn);

  enum { Update = 0, Advance, Defer };

  template <typename L> void add(L l) {
    Fn fn{l};
    add_(fn);
  }

  template <typename L> void add(L l, ZuTime timeout) {
    Fn fn{l};
    schedule_(0, fn, timeout, Update, nullptr);
  }
  template <typename L> void add(L l, ZuTime timeout, Timer *timer) {
    Fn fn{l};
    schedule_(0, fn, timeout, Update, timer);
  }
  template <typename L> void add(L l, ZuTime timeout, int mode, Timer *timer) {
    Fn fn{l};
    schedule_(0, fn, timeout, mode, timer);
  }

  template <typename L> void run(unsigned sid, L l, ZuTime timeout) {
    Fn fn{l};
    schedule_(sid, fn, timeout, Update, nullptr);
  }
  template <typename L>
  void run(unsigned sid, L l, ZuTime timeout, Timer *timer) {
    Fn fn{l};
    schedule_(sid, fn, timeout, Update, timer);
  }

  template <typename L>
  void run(unsigned sid, L l, ZuTime timeout, int mode, Timer *timer) {
    Fn fn{l};
    schedule_(sid, fn, timeout, mode, timer);
  }

private:
  void schedule_(unsigned sid, Fn &, ZuTime timeout, int mode, Timer *);

public:
  bool del(Timer *);

  bool invoked(unsigned sid) const {
    ((sid && sid <= m_params.nThreads()) ?
       void() :
       ZmAssert_fail(
	 "sid && sid <= m_params.nThreads()",
	 "../../zm/src/zlib/ZmScheduler.hh", 320, __PRETTY_FUNCTION__
       ));
    Thread *thread = &m_threads[sid - 1];
    return Zm::getTID() == thread->tid;
  }

  template <typename L> void run(unsigned sid, L l) {
    ((sid && sid <= m_params.nThreads()) ?
       void() :
       ZmAssert_fail(
	 "sid && sid <= m_params.nThreads()",
	 "../../zm/src/zlib/ZmScheduler.hh", 328, __PRETTY_FUNCTION__
       ));
    Fn fn{l};
    run_(&m_threads[sid - 1], fn);
  }

  template <typename L> void push(unsigned sid, L l) {
    ((sid && sid <= m_params.nThreads()) ?
       void() :
       ZmAssert_fail(
	 "sid && sid <= m_params.nThreads()",
	 "../../zm/src/zlib/ZmScheduler.hh", 336, __PRETTY_FUNCTION__
       ));
    Fn fn{l};
    push_(&m_threads[sid - 1], fn);
  }

  template <typename L> void invoke(unsigned sid, L l) {
    ((sid && sid <= m_params.nThreads()) ?
       void() :
       ZmAssert_fail(
	 "sid && sid <= m_params.nThreads()",
	 "../../zm/src/zlib/ZmScheduler.hh", 344, __PRETTY_FUNCTION__
       ));
    Thread *thread = &m_threads[sid - 1];
    if (__builtin_expect(!!(Zm::getTID() == thread->tid), 1)) {
      l();
      return;
    }
    Fn fn{l};
    run_(thread, fn);
  }

private:
  template <typename O1, typename O2>
  struct IsObjectLambda__ :
    public ZuBool<
      ZuObjectTraits<O1>::IsObject && ZuObjectTraits<O2>::IsObject &&
      (ZuInspect<O1, O2>::Is || ZuInspect<O2, O1>::Is)> { };
  template <typename O, typename L, typename = void>
  struct IsObjectLambda_ : public ZuFalse { };

  template <typename O, typename L>
  struct IsObjectLambda_<O, L, decltype(*ZuDeclVal<L &>()(), void())> :
    public IsObjectLambda__<O, decltype(*ZuDeclVal<L &>()())> { };

  template <typename O, typename L, typename R = void>
  using IsObjectLambda = ZuIfT<IsObjectLambda_<O, L>{}, R>;

public:
  template <typename O, typename L>
  IsObjectLambda<O, L> invoke(unsigned sid, O *o, L l) {
    ((sid && sid <= m_params.nThreads()) ?
       void() :
       ZmAssert_fail(
	 "sid && sid <= m_params.nThreads()",
	 "../../zm/src/zlib/ZmScheduler.hh", 388, __PRETTY_FUNCTION__
       ));
    Thread *thread = &m_threads[sid - 1];
    if (__builtin_expect(!!(Zm::getTID() == thread->tid), 1)) {
      l();
      return;
    }
    o->ref();
    auto m = [l = ZuMv(l)]() mutable { l()->deref(); };
    Fn fn{m};
    run_(thread, fn);
  }

  inline void threadInit(ZmFn<> fn) { m_threadInitFn = ZuMv(fn); }
  inline void threadFinal(ZmFn<> fn) { m_threadFinalFn = ZuMv(fn); }

  inline unsigned nWorkers() const { return m_nWorkers; }
  inline unsigned workerID(unsigned i) const {
    if (__builtin_expect(!!(i < m_nWorkers), 1))
      return (m_workers[i] - &m_threads[0]) + 1;
    return 0;
  }

  unsigned size() const {
    return m_threads[0].ring.size() * m_params.nThreads();
  }
  unsigned count_() const {
    unsigned count = 0;
    for (unsigned i = 0, n = m_params.nThreads(); i < n; i++)
      count += m_threads[i].ring.count_();
    return count;
  }
  ZmThreadID tid(unsigned sid) const { return m_threads[sid - 1].tid; }
  const Ring &ring(unsigned sid) const { return m_threads[sid - 1].ring; }
  const OverRing &overRing(unsigned sid) const {
    return m_threads[sid - 1].overRing;
  }

  unsigned sid(ZuCSpan s) const {
    unsigned sid;
    if (sid = ZuBox<unsigned, ZuBoxCmp<ZuCmp0>>{s}) return sid;
    unsigned n;
    for (sid = 0, n = m_params.nThreads(); sid <= n; sid++)
      if (s == m_params.thread(sid).name()) return sid;
    return 0;
  }

private:
  void start_();
  void stop_();
  template <typename L> bool spawn(L l) {
    m_thread = ZmThread{ZuMv(l), m_params.thread(0).detached(true), 0};
    return !!m_thread;
  }
  void wake();

protected:
  virtual bool start__();
  virtual bool stop__();

  void busy();
  void idle();

private:
  using SchedLock = ZmPLock;
  using SchedGuard = ZmGuard<SchedLock>;

  using SpawnLock = ZmPLock;
  using SpawnGuard = ZmGuard<SpawnLock>;
  using SpawnReadGuard = ZmReadGuard<SpawnLock>;

  struct Thread {
    Ring ring;
    ZmFn<> wakeFn;
    ZmThreadID tid = 0;
    ZmThread thread;
    ZmAtomic<unsigned> overCount;
    OverRing overRing;
  };

  void wake(Thread *thread) { (thread->wakeFn)(); }

  void timer();
  bool timerAdd(Fn &fn);

  void add_(Fn &fn);
  void run_(Thread *thread, Fn &fn);
  bool tryRun_(Thread *thread, Fn &fn);
  bool push_(Thread *thread, Fn &fn);
  bool tryPush_(Thread *thread, Fn &fn);

  void work();

  ZmSchedParams m_params;

  ZmThread m_thread;

  ZmSemaphore m_pending;

  SchedLock m_schedLock;
  ScheduleTree m_schedule;

  ZmAtomic<unsigned> m_next;
  Thread *m_threads;
  unsigned m_nWorkers = 0;
  Thread **m_workers;

  SpawnLock m_spawnLock;
  unsigned m_runThreads = 0;

  ZmFn<> m_threadInitFn;
  ZmFn<> m_threadFinalFn;
};

inline constexpr const uint32_t ZmHashBits(uint32_t code, unsigned bits) {
  bits = 32U - bits;
  return ((code << bits) ^ code) >> bits;
}

template <typename Lock> class ZmHash_LockMgr {
  using LockTraits = ZmLockTraits<Lock>;

  enum { CacheLineSize = Zm::CacheLineSize };

  static_assert(
    (sizeof(Lock) <= CacheLineSize), "sizeof(Lock) <= CacheLineSize"
  );

  Lock &lock_(unsigned i) const {
    return *reinterpret_cast<Lock *>(
      reinterpret_cast<uint8_t *>(m_locks) + (i * CacheLineSize)
    );
  }

public:
  unsigned bits() const { return m_bits; }
  unsigned cBits() const { return m_cBits; }

protected:
  ZmHash_LockMgr() { }

  void init(const ZmHashParams &params) {
    bits(params.bits());
    cBits(params.cBits());

    if (m_cBits > m_bits) m_cBits = m_bits;
    unsigned n = 1U << m_cBits;
    unsigned size = n * CacheLineSize;
    m_locks = Zm::alignedAlloc<CacheLineSize>(size);
    if (!m_locks) throw std::bad_alloc{};
    for (unsigned i = 0; i < n; ++i) new (&lock_(i)) Lock();
  }

  ~ZmHash_LockMgr() {
    if (__builtin_expect(!!(!m_locks), 0)) return;
    unsigned n = 1U << m_cBits;
    for (unsigned i = 0; i < n; ++i) lock_(i).~Lock();
    Zm::alignedFree(m_locks);
  }

  void bits(unsigned n) { m_bits = n < 2 ? 2 : n > 28 ? 28 : n; }
  void cBits(unsigned n) { m_cBits = n < 0 ? 0 : n > 12 ? 12 : n; }

  Lock &lockCode(uint32_t code) const {
    return lockSlot(ZmHashBits(code, m_bits));
  }
  Lock &lockSlot(unsigned slot) const {
    return lock_(slot >> (m_bits - m_cBits));
  }

  bool lockAllResize(unsigned bits) {
    for (unsigned i = 0; i < (1U << m_cBits); i++) {
      LockTraits::lock(lock_(i));

      if (m_bits >= bits) {
	for (int j = i; j >= 0; --j) LockTraits::unlock(lock_(j));
	return false;
      }
    }
    return true;
  }
  void lockAll() {
    unsigned n = (1U << m_cBits);
    for (unsigned i = 0; i < n; i++) LockTraits::lock(lock_(i));
  }
  void unlockAll() {
    unsigned n = (1U << m_cBits);
    for (int i = n; --i >= 0;) LockTraits::unlock(lock_(i));
  }

protected:
  unsigned m_bits = 2;

private:
  unsigned m_cBits = 2;
  mutable void *m_locks = nullptr;
};

template <> class ZmHash_LockMgr<ZmNoLock> {
protected:
  ZmHash_LockMgr() { }
  ~ZmHash_LockMgr() { }

  void init(const ZmHashParams &params) { bits(params.bits()); }

public:
  unsigned bits() const { return m_bits; }
  static constexpr unsigned cBits() { return 0; }

protected:
  void bits(unsigned n) { m_bits = n < 2 ? 2 : n > 28 ? 28 : n; }
  void cBits(unsigned) { }

  ZmNoLock &lockCode(uint32_t code) const {
    return const_cast<ZmNoLock &>(ZuNullRef<ZmNoLock>());
  }
  ZmNoLock &lockSlot(unsigned slot) const {
    return const_cast<ZmNoLock &>(ZuNullRef<ZmNoLock>());
  }

  bool lockAllResize(unsigned) { return true; }
  void lockAll() { }
  void unlockAll() { }

protected:
  unsigned m_bits = 2;
};

struct ZmHash_Defaults {
  static constexpr auto KeyAxor = ZuDefaultAxor();
  static constexpr auto ValAxor = ZuDefaultAxor();
  template <typename T> using CmpT = ZuCmp<T>;
  template <typename T> using ValCmpT = ZuCmp<T>;
  template <typename T> using HashFnT = ZuHash<T>;
  using Lock = ZmNoLock;
  using Node = ZuEmpty;
  enum { Shadow = 0 };
  static const char *ID() { return "ZmHash"; }
  static const char *HeapID() { return "ZmHash"; }
  enum { Sharded = 0 };
};

template <auto KeyAxor_, typename NTP = ZmHash_Defaults>
struct ZmHashKey : public NTP {
  static constexpr auto KeyAxor = KeyAxor_;
};

template <auto KeyAxor_, auto ValAxor_, typename NTP = ZmHash_Defaults>
struct ZmHashKeyVal : public NTP {
  static constexpr auto KeyAxor = KeyAxor_;
  static constexpr auto ValAxor = ValAxor_;
};

template <template <typename> typename Cmp_, typename NTP = ZmHash_Defaults>
struct ZmHashCmp : public NTP {
  template <typename T> using CmpT = Cmp_<T>;
};

template <template <typename> typename ValCmp_, typename NTP = ZmHash_Defaults>
struct ZmHashValCmp : public NTP {
  template <typename T> using ValCmpT = ValCmp_<T>;
};

template <template <typename> typename HashFn_, typename NTP = ZmHash_Defaults>
struct ZmHashFn : public NTP {
  template <typename T> using HashFnT = HashFn_<T>;
};

template <typename Lock_, typename NTP = ZmHash_Defaults>
struct ZmHashLock : public NTP {
  using Lock = Lock_;
};

template <typename Node_, typename NTP = ZmHash_Defaults>
struct ZmHashNode : public NTP {
  using Node = Node_;
};

template <auto ID_, typename NTP = ZmHash_Defaults, auto HeapID_ = NTP::HeapID>
struct ZmHashID : public NTP {
  static constexpr auto ID = ID_;
};
template <auto ID_, typename NTP>
struct ZmHashID<ID_, NTP, ZmHash_Defaults::HeapID> : public NTP {
  static constexpr auto ID = ID_;
  static constexpr auto HeapID = ID_;
};

template <bool Shadow_, typename NTP = ZmHash_Defaults>
struct ZmHashShadow : public NTP {
  enum { Shadow = Shadow_ };
  static constexpr auto HeapID = ZmHeapDisable();
};

template <auto HeapID_, typename NTP = ZmHash_Defaults, auto ID_ = NTP::ID>
struct ZmHashHeapID : public NTP {
  static constexpr auto HeapID = HeapID_;
};
template <auto HeapID_, typename NTP>
struct ZmHashHeapID<HeapID_, NTP, ZmHash_Defaults::ID> : public NTP {
  static constexpr auto ID = HeapID_;
  static constexpr auto HeapID = HeapID_;
};
template <typename NTP, auto ID_>
struct ZmHashHeapID<ZmHeapDisable(), NTP, ID_> : public NTP {
  static constexpr auto HeapID = ZmHeapDisable();
};
template <typename NTP>
struct ZmHashHeapID<ZmHeapDisable(), NTP, ZmHash_Defaults::ID> : public NTP {
  static constexpr auto HeapID = ZmHeapDisable();
};

template <bool Sharded_, typename NTP = ZmHash_Defaults>
struct ZmHashSharded : public NTP {
  enum { Sharded = Sharded_ };
};

template <typename Node> struct ZmHash_NodeExt {
  Node *next = nullptr;
};

template <typename T, typename Cmp, typename = void>
struct ZmHash_IsStaticCmp : public ZuFalse { };
template <typename T, typename Cmp>
struct ZmHash_IsStaticCmp<
  T, Cmp,
  decltype(Cmp::cmp(ZuDeclVal<const T &>(), ZuDeclVal<const T &>()), void())> :
  public ZuTrue { };

template <typename T, typename Cmp, typename = void>
struct ZmHash_IsStaticEquals : public ZuFalse { };
template <typename T, typename Cmp>
struct ZmHash_IsStaticEquals<
  T, Cmp,
  decltype(Cmp::equals(ZuDeclVal<const T &>(), ZuDeclVal<const T &>()), void())> :
  public ZuTrue { };

template <typename T_, typename NTP = ZmHash_Defaults>
class ZmHash :
  public ZmAnyHash,
  public ZmHash_LockMgr<typename NTP::Lock>,
  public ZmNodeFn<NTP::Shadow, typename NTP::Node> {
public:
  using T = T_;
  static constexpr auto KeyAxor = NTP::KeyAxor;
  static constexpr auto ValAxor = NTP::ValAxor;
  using KeyRet = decltype(KeyAxor(ZuDeclVal<const T &>()));
  using ValRet = decltype(ValAxor(ZuDeclVal<const T &>()));
  using Key = ZuRDecay<KeyRet>;
  using Val = ZuRDecay<ValRet>;
  using Cmp = typename NTP::template CmpT<Key>;
  using ValCmp = typename NTP::template ValCmpT<Val>;
  using HashFn = typename NTP::template HashFnT<Key>;
  using Lock = typename NTP::Lock;
  using NodeBase = typename NTP::Node;
  static constexpr auto ID = NTP::ID;
  enum { Shadow = NTP::Shadow };
  static constexpr auto HeapID = NTP::HeapID;
  enum { Sharded = NTP::Sharded };

private:
  using LockMgr = ZmHash_LockMgr<Lock>;
  using NodeFn = ZmNodeFn<Shadow, NodeBase>;

  using LockTraits = ZmLockTraits<Lock>;
  using Guard = ZmGuard<Lock>;
  using ReadGuard = ZmReadGuard<Lock>;

  using LockMgr::lockCode;
  using LockMgr::lockSlot;
  using LockMgr::lockAllResize;
  using LockMgr::lockAll;
  using LockMgr::unlockAll;

  using LockMgr::m_bits;

public:
  unsigned bits() const { return m_bits; }
  using LockMgr::cBits;

  struct Node;
  using Node_ = ZmNode<
    T, KeyAxor, ValAxor, NodeBase, ZmHash_NodeExt<Node>, HeapID, Sharded>;
  struct Node : public Node_ {
    using Node_::Node_;
    using Node_::operator=;
  };
  using NodeExt = ZmHash_NodeExt<Node>;
  using NodeRef = typename NodeFn::template Ref<Node>;
  using NodeMvRef = typename NodeFn::template MvRef<Node>;
  using NodePtr = Node *;

  using NodeFn::nodeRef;
  using NodeFn::nodeDeref;
  using NodeFn::nodeAcquire;
  using NodeFn::nodeDelete;

  static KeyRet key(const Node *node) {
    if (__builtin_expect(!!(node), 1)) return node->Node::key();
    return ZuNullRef<Key, Cmp>();
  }
  Key keyMv(NodeMvRef node) {
    if (__builtin_expect(!!(node), 1)) return ZuMv(*node).Node::key();
    return ZuNullRef<Key, Cmp>();
  }
  static ValRet val(const Node *node) {
    if (__builtin_expect(!!(node), 1)) return node->Node::val();
    return ZuNullRef<Val, ValCmp>();
  }
  Val valMv(NodeMvRef node) {
    if (__builtin_expect(!!(node), 1)) return ZuMv(*node).Node::val();
    return ZuNullRef<Val, ValCmp>();
  }

private:
  template <typename I> struct Iterator__ {
    decltype(auto) iterateKey() {
      return key(static_cast<I *>(this)->iterate());
    }
    decltype(auto) iterateVal() {
      return val(static_cast<I *>(this)->iterate());
    }
  };

  template <typename I> class Iterator_;
  template <typename> friend class Iterator_;
  template <typename I> class Iterator_ : public Iterator__<I> {
    using Hash = ZmHash<T, NTP>;
    friend Hash;

    Iterator_(const Iterator_ &) = delete;
    Iterator_ &operator=(const Iterator_ &) = delete;

  protected:
    Hash &hash;
    int slot = -1;
    typename Hash::Node *node = nullptr;
    typename Hash::Node *prev = nullptr;

    Iterator_(Iterator_ &&) = default;
    Iterator_ &operator=(Iterator_ &&) = default;

    Iterator_(Hash &hash_) : hash{hash_} { }

  public:
    void reset() { hash.startIterate(static_cast<I &>(*this)); }
    Node *iterate() { return hash.iterate(static_cast<I &>(*this)); }

    unsigned count() const { return hash.count_(); }
  };

  template <typename, typename> class KeyIterator_;
  template <typename, typename> friend class KeyIterator_;
  template <typename I, typename IKey_>
  class KeyIterator_ : public Iterator_<I> {
    using Hash = ZmHash<T, NTP>;
    friend class ZmHash<T, NTP>;

    KeyIterator_(const KeyIterator_ &) = delete;
    KeyIterator_ &operator=(const KeyIterator_ &) = delete;

  public:
    using IKey = IKey_;

  protected:
    IKey key;

    using Iterator_<I>::hash;

    KeyIterator_(KeyIterator_ &&) = default;
    KeyIterator_ &operator=(KeyIterator_ &&) = default;

    template <typename IKey__>
    KeyIterator_(Hash &hash_, IKey__ &&key_) :
      Iterator_<I>{hash_}, key{ZuFwd<IKey__>(key_)} { }

  public:
    void reset() { hash.startKeyIterate(static_cast<I &>(*this)); }
    Node *iterate() { return hash.keyIterate(static_cast<I &>(*this)); }
  };

public:
  class Iterator : public Iterator_<Iterator> {
    Iterator(const Iterator &) = delete;
    Iterator &operator=(const Iterator &) = delete;

    using Hash = ZmHash<T, NTP>;
    friend Hash;

    using Base = Iterator_<Iterator>;
    using Base::hash;

  public:
    Iterator(Iterator &&) = default;
    Iterator &operator=(Iterator &&) = default;

    Iterator(Hash &hash_) : Base{hash_} { hash.startIterate(*this); }
    ~Iterator() { hash.endIterate(*this); }

    NodeMvRef del() { return hash.delIterate(*this); }
  };

  class ReadIterator : public Iterator_<ReadIterator> {
    ReadIterator(const ReadIterator &) = delete;
    ReadIterator &operator=(const ReadIterator &) = delete;

    using Hash = ZmHash<T, NTP>;
    friend Hash;

    using Base = Iterator_<ReadIterator>;
    using Base::hash;

  public:
    ReadIterator(ReadIterator &&) = default;
    ReadIterator &operator=(ReadIterator &&) = default;

    ReadIterator(const Hash &hash_) : Base{const_cast<Hash &>(hash_)} {
      const_cast<Hash &>(hash).startIterate(*this);
    }
    ~ReadIterator() { hash.endIterate(*this); }
  };

  template <typename IKey_>
  class KeyIterator : public KeyIterator_<KeyIterator<IKey_>, IKey_> {
    KeyIterator(const KeyIterator &) = delete;
    KeyIterator &operator=(const KeyIterator &) = delete;

    using Hash = ZmHash<T, NTP>;
    friend Hash;

    using Base = KeyIterator_<KeyIterator<IKey_>, IKey_>;
    using typename Base::IKey;
    using Base::key;
    using Base::hash;

  public:
    KeyIterator(KeyIterator &&) = default;
    KeyIterator &operator=(KeyIterator &&) = default;

    template <typename IKey__>
    KeyIterator(Hash &hash_, IKey__ &&key_) : Base{hash_, ZuFwd<IKey__>(key_)} {
      hash.startKeyIterate(*this);
    }
    ~KeyIterator() { hash.endIterate(*this); }
    NodeMvRef del() { return hash.delIterate(*this); }
  };

  template <typename IKey_>
  class ReadKeyIterator : public KeyIterator_<ReadKeyIterator<IKey_>, IKey_> {
    ReadKeyIterator(const ReadKeyIterator &) = delete;
    ReadKeyIterator &operator=(const ReadKeyIterator &) = delete;

    using Hash = ZmHash<T, NTP>;
    friend Hash;
    using Base = KeyIterator_<ReadKeyIterator<IKey_>, IKey_>;

    using typename Base::IKey;
    using Base::key;
    using Base::hash;

  public:
    ReadKeyIterator(ReadKeyIterator &&) = default;
    ReadKeyIterator &operator=(ReadKeyIterator &&) = default;

    template <typename IKey__>
    ReadKeyIterator(const Hash &hash_, IKey__ &&key_) :
      Base{const_cast<Hash &>(hash_), ZuFwd<IKey__>(key_)} {
      const_cast<Hash &>(hash).startKeyIterate(*this);
    }
    ~ReadKeyIterator() { hash.endIterate(*this); }
  };

private:
  void init(const ZmHashParams &params) {
    double loadFactor = params.loadFactor();
    if (loadFactor < 1.0) loadFactor = 1.0;
    m_loadFactor = (unsigned)(loadFactor * (1 << 4));
    m_table = static_cast<NodePtr *>(
      Zm::alignedAlloc<Zm::CacheLineSize>(sizeof(NodePtr) << m_bits)
    );
    memset(m_table, 0, sizeof(NodePtr) << m_bits);
    ZmHashMgr::add(this);
  }

public:
  ZmHash() : m_id{ID()} {
    auto params = ZmHashParams{m_id};
    LockMgr::init(params);
    ZmHash::init(params);
  }

  template <typename ID, decltype(ZuIfT<ZuTraits<ID>::IsString>(), int()) = 0>
  ZmHash(const ID &id) : m_id{id} {
    auto params = ZmHashParams{m_id};
    LockMgr::init(params);
    ZmHash::init(params);
  }

  template <typename Cmp_, decltype(ZuIfT<ZuIsExact<Cmp_, Cmp>{}>(), int()) = 0>
  ZmHash(Cmp_ cmp) : m_id{ID()}, m_cmp{ZuMv(cmp)} {
    auto params = ZmHashParams{m_id};
    LockMgr::init(params);
    ZmHash::init(params);
  }

  template <
    typename Params,
    decltype(ZuIfT<ZuIsExact<Params, ZmHashParams>{}>(), int()) = 0>
  ZmHash(const Params &params) : m_id{ID()} {
    LockMgr::init(params);
    ZmHash::init(params);
  }

  template <
    typename ID, typename Cmp_,
    decltype(ZuIfT<ZuTraits<ID>::IsString &&bool(ZuIsExact<Cmp_, Cmp>{})>(), int()) =
      0>
  ZmHash(const ID &id, Cmp_ cmp) : m_id{id}, m_cmp{ZuMv(cmp)} {
    auto params = ZmHashParams{m_id};
    LockMgr::init(params);
    ZmHash::init(params);
  }

  template <
    typename Cmp_, typename Params,
    decltype(ZuIfT<bool(ZuIsExact<Cmp_, Cmp>{}) && bool(ZuIsExact<Params, ZmHashParams>{})>(), int()) =
      0>
  ZmHash(Cmp_ cmp, const Params &params) : m_id{ID()}, m_cmp{ZuMv(cmp)} {
    LockMgr::init(params);
    ZmHash::init(params);
  }

  template <
    typename ID, typename Params,
    decltype(ZuIfT<ZuTraits<ID>::IsString &&bool(ZuIsExact<Params, ZmHashParams>{})>(), int()) =
      0>
  ZmHash(const ID &id, const Params &params) : m_id{id} {
    LockMgr::init(params);
    ZmHash::init(params);
  }

  template <
    typename ID, typename Cmp_, typename Params,
    decltype(ZuIfT<ZuTraits<ID>::IsString &&bool(ZuIsExact<Cmp_, Cmp>{}) && bool(ZuIsExact<Params, ZmHashParams>{})>(), int()) =
      0>
  ZmHash(const ID &id, Cmp_ cmp, const Params &params) :
    m_id{id}, m_cmp(ZuMv(cmp)) {
    LockMgr::init(params);
    ZmHash::init(params);
  }

  ZmHash(const ZmHash &) = delete;
  ZmHash &operator=(const ZmHash &) = delete;
  ZmHash(ZmHash &&) = delete;
  ZmHash &operator=(ZmHash &&) = delete;

  ~ZmHash() {
    ZmHashMgr::del(this);
    clean();
    Zm::alignedFree(m_table);
  }

  unsigned loadFactor_() const { return m_loadFactor; }
  double loadFactor() const { return static_cast<double>(m_loadFactor) / 16.0; }
  unsigned size() const {
    return static_cast<double>(static_cast<uint64_t>(1) << m_bits) *
      loadFactor();
  }

  unsigned count_() const { return m_count.load_(); }

  template <typename P> NodeRef add(P &&data) {
    Node *node = new Node{ZuFwd<P>(data)};
    addNode(node);
    return node;
  }
  template <typename P0, typename P1> NodeRef add(P0 &&p0, P1 &&p1) {
    return add(ZuFwdTuple(ZuFwd<P0>(p0), ZuFwd<P1>(p1)));
  }
  template <bool _ = !ZuInspect<NodeRef, Node *>::Same>
  ZuIfT<_> addNode(const NodeRef &node_) {
    addNode(node_.ptr());
  }
  template <bool _ = !ZuInspect<NodeRef, Node *>::Same>
  ZuIfT<_> addNode(NodeRef &&node_) {
    Node *node = this->nodeRelease(ZuMv(node_));
    uint32_t code = HashFn::hash(node->Node::key());
    Guard guard(lockCode(code));
    addNode_(node, code);
  }
  void addNode(Node *node) {
    uint32_t code = HashFn::hash(node->Node::key());
    nodeRef(node);
    Guard guard(lockCode(code));
    addNode_(node, code);
  }

private:
  void addNode_(Node *node, uint32_t code) {
    unsigned count = m_count.load_();

    {
      unsigned bits = m_bits;

      if (count < (1U << 28) && ((count << 4) >> bits) >= m_loadFactor) {
	Lock &lock = lockCode(code);

	LockTraits::unlock(lock);
	resize(bits + 1);
	LockTraits::lock(lock);
      }
    }

    unsigned slot = ZmHashBits(code, m_bits);

    node->NodeExt::next = m_table[slot];
    m_table[slot] = ZuMv(node);
    m_count.store_(count + 1);
  }

private:
  template <typename U, typename V = Key>
  struct IsKey : public ZuBool<ZuInspect<U, V>::Converts> { };
  template <typename U, typename R = void>
  using MatchKey = ZuIfT<IsKey<U>{}, R>;
  template <typename U, typename V = T, bool = ZuInspect<NodeBase, V>::Is>
  struct IsData : public ZuBool<!IsKey<U>{} && ZuInspect<U, V>::Converts> { };
  template <typename U, typename V>
  struct IsData<U, V, true> : public ZuFalse { };
  template <typename U, typename R = void>
  using MatchData = ZuIfT<IsData<U>{}, R>;

public:
  template <
    typename Key_ = Key, typename Cmp_ = Cmp,
    decltype(ZuIfT<ZmHash_IsStaticCmp<Key_, Cmp_>{}>(), int()) = 0>
  inline static auto cmp(const Key &l, const Key &r) {
    return Cmp::cmp(l, r);
  }
  template <
    typename Key_ = Key, typename Cmp_ = Cmp,
    decltype(ZuIfT<!ZmHash_IsStaticCmp<Key_, Cmp_>{}>(), int()) = 0>
  inline auto cmp(const Key &l, const Key &r) const {
    return m_cmp.cmp(l, r);
  }
  template <
    typename Key_ = Key, typename Cmp_ = Cmp,
    decltype(ZuIfT<ZmHash_IsStaticEquals<Key_, Cmp_>{}>(), int()) = 0>
  inline static auto equals(const Key &l, const Key &r) {
    return Cmp::equals(l, r);
  }
  template <
    typename Key_ = Key, typename Cmp_ = Cmp,
    decltype(ZuIfT<!ZmHash_IsStaticEquals<Key_, Cmp_>{}>(), int()) = 0>
  inline auto equals(const Key &l, const Key &r) const {
    return m_cmp.equals(l, r);
  }

private:
  template <
    typename P, typename Key_ = Key, typename Cmp_ = Cmp,
    decltype(ZuIfT<ZmHash_IsStaticCmp<Key_, Cmp_>{}>(), int()) = 0>
  inline static auto matchKey(const P &key) {
    return
      [&key](const Node *node) { return Cmp::equals(node->Node::key(), key); };
  }
  template <
    typename P, typename Key_ = Key, typename Cmp_ = Cmp,
    decltype(ZuIfT<!ZmHash_IsStaticCmp<Key_, Cmp_>{}>(), int()) = 0>
  inline auto matchKey(const P &key) const {
    return [this, &key](const Node *node) {
      return m_cmp.equals(node->Node::key(), key);
    };
  }

  template <typename P> inline static auto matchData(const P &data) {
    return [&data](const Node *node) { return node->Node::data() == data; };
  }
  inline static auto matchNode(Node *node_) {
    return [node_](const Node *node) { return node == node_; };
  }

public:
  template <typename P> MatchKey<P, NodeRef> find(const P &key) const {
    uint32_t code = HashFn::hash(key);
    ReadGuard guard(lockCode(code));
    return find_(matchKey(key), code);
  }
  template <typename P> MatchData<P, NodeRef> find(const P &data) const {
    uint32_t code = HashFn::hash(KeyAxor(data));
    ReadGuard guard(lockCode(code));
    return find_(matchData(data), code);
  }
  template <typename P0, typename P1> NodeRef find(P0 &&p0, P1 &&p1) {
    return find(ZuFwdTuple(ZuFwd<P0>(p0), ZuFwd<P1>(p1)));
  }

  template <typename P> MatchKey<P, Node *> findPtr(const P &key) const {
    uint32_t code = HashFn::hash(key);
    ReadGuard guard(lockCode(code));
    return find_(matchKey(key), code);
  }
  template <typename P> MatchData<P, Node *> findPtr(const P &data) const {
    uint32_t code = HashFn::hash(KeyAxor(data));
    ReadGuard guard(lockCode(code));
    return find_(matchData(data), code);
  }

  template <typename P> MatchKey<P, Key> findKey(const P &key) const {
    uint32_t code = HashFn::hash(key);
    ReadGuard guard(lockCode(code));
    return key(find_(matchKey(key), code));
  }
  template <typename P> MatchData<P, Key> findKey(const P &data) const {
    uint32_t code = HashFn::hash(KeyAxor(data));
    ReadGuard guard(lockCode(code));
    return key(find_(matchData(data), code));
  }
  template <typename P0, typename P1> decltype(auto) findKey(P0 &&p0, P1 &&p1) {
    return findKey(ZuFwdTuple(ZuFwd<P0>(p0), ZuFwd<P1>(p1)));
  }

  template <typename P> MatchKey<P, Val> findVal(const P &key) const {
    uint32_t code = HashFn::hash(key);
    ReadGuard guard(lockCode(code));
    return val(find_(matchKey(key), code));
  }
  template <typename P> MatchData<P, Val> findVal(const P &data) const {
    uint32_t code = HashFn::hash(KeyAxor(data));
    ReadGuard guard(lockCode(code));
    return val(find_(matchData(data), code));
  }
  template <typename P0, typename P1> Val findVal(P0 &&p0, P1 &&p1) {
    return findVal(ZuFwdTuple(ZuFwd<P0>(p0), ZuFwd<P1>(p1)));
  }

private:
  template <typename Match> Node *find_(Match match, uint32_t code) const {
    Node *node;
    unsigned slot = ZmHashBits(code, m_bits);

    for (node = m_table[slot]; node && !match(node);
	 node = node->NodeExt::next);

    return node;
  }

public:
  template <typename P> NodeRef findAdd(P &&data) {
    uint32_t code = HashFn::hash(KeyAxor(data));
    Guard guard(lockCode(code));
    return findAdd_(ZuFwd<P>(data), code);
  }
  template <typename P0, typename P1> NodeRef findAdd(P0 &&p0, P1 &&p1) {
    return findAdd(ZuFwdTuple(ZuFwd<P0>(p0), ZuFwd<P1>(p1)));
  }
  template <typename P> Node *findAddPtr(P &&data) {
    uint32_t code = HashFn::hash(KeyAxor(data));
    Guard guard(lockCode(code));
    return findAdd_(ZuFwd<P>(data), code);
  }
  template <typename P0, typename P1> Node *findAddPtr(P0 &&p0, P1 &&p1) {
    return findAddPtr(ZuFwdTuple(ZuFwd<P0>(p0), ZuFwd<P1>(p1)));
  }

private:
  template <typename P> Node *findAdd_(P &&data, uint32_t code) {
    Node *node;
    unsigned slot = ZmHashBits(code, m_bits);

    for (node = m_table[slot];
	 node && !equals(node->Node::key(), KeyAxor(data));
	 node = node->NodeExt::next);

    if (!node) addNode_(node = new Node{ZuFwd<P>(data)}, code);
    return node;
  }

public:
  template <typename P> MatchKey<P, NodeMvRef> del(const P &key) {
    uint32_t code = HashFn::hash(key);
    Guard guard(lockCode(code));
    return delNode_(matchKey(key), code);
  }
  template <typename P> MatchData<P, NodeMvRef> del(const P &data) {
    uint32_t code = HashFn::hash(KeyAxor(data));
    Guard guard(lockCode(code));
    return delNode_(matchData(data), code);
  }
  template <typename P0, typename P1> NodeMvRef del(P0 &&p0, P1 &&p1) {
    return del(ZuFwdTuple(ZuFwd<P0>(p0), ZuFwd<P1>(p1)));
  }
  NodeMvRef delNode(Node *node) {
    uint32_t code = HashFn::hash(node->Node::key());
    Guard guard(lockCode(code));
    return delNode_(matchNode(node), code);
  }

  template <typename P> MatchKey<P, Key> delKey(const P &key) {
    uint32_t code = HashFn::hash(key);
    Guard guard(lockCode(code));
    return keyMv(delNode_(matchKey(key), code));
  }
  template <typename P> MatchData<P, Key> delKey(const P &data) {
    uint32_t code = HashFn::hash(KeyAxor(data));
    Guard guard(lockCode(code));
    return keyMv(delNode_(matchData(data), code));
  }
  template <typename P0, typename P1> decltype(auto) delKey(P0 &&p0, P1 &&p1) {
    return delKey(ZuFwdTuple(ZuFwd<P0>(p0), ZuFwd<P1>(p1)));
  }
  decltype(auto) delNodeKey(Node *node) {
    uint32_t code = HashFn::hash(node->Node::key());
    return keyMv(delNode_(matchNode(node), code));
  }

  template <typename P> MatchKey<P, Val> delVal(const P &key) {
    uint32_t code = HashFn::hash(key);
    Guard guard(lockCode(code));
    return valMv(delNode_(matchKey(key), code));
  }
  template <typename P> MatchData<P, Val> delVal(const P &data) {
    uint32_t code = HashFn::hash(KeyAxor(data));
    Guard guard(lockCode(code));
    return valMv(delNode_(matchData(data), code));
  }
  template <typename P0, typename P1> decltype(auto) delVal(P0 &&p0, P1 &&p1) {
    return delVal(ZuFwdTuple(ZuFwd<P0>(p0), ZuFwd<P1>(p1)));
  }
  decltype(auto) delNodeVal(Node *node) {
    uint32_t code = HashFn::hash(node->Node::key());
    return valMv(delNode_(matchNode(node), code));
  }

private:
  template <typename Match> NodeMvRef delNode_(Match match, uint32_t code) {
    unsigned count = m_count.load_();
    if (!count) return 0;

    Node *node, *prevNode = nullptr;
    unsigned slot = ZmHashBits(code, m_bits);

    for (node = m_table[slot]; node && !match(node);
	 prevNode = node, node = node->NodeExt::next);

    if (!node) return 0;

    if (!prevNode)
      m_table[slot] = node->NodeExt::next;
    else
      prevNode->NodeExt::next = node->NodeExt::next;

    m_count.store_(count - 1);

    node->NodeExt::next = nullptr;

    return nodeAcquire(node);
  }

public:
  auto iterator() { return Iterator{*this}; }
  template <typename P> auto iterator(P key) {
    return KeyIterator<P>{*this, ZuMv(key)};
  }

  auto readIterator() const { return ReadIterator{*this}; }
  template <typename P> auto readIterator(P key) const {
    return ReadKeyIterator<P>{*this, ZuMv(key)};
  }

private:
  template <typename I> void startIterate(I &iterator) {
    LockTraits::lock(lockSlot(0));
    iterator.slot = 0;
    iterator.node = nullptr;
    iterator.prev = nullptr;
  }
  template <typename I> void startKeyIterate(I &iterator) {
    uint32_t code = HashFn::hash(iterator.key);

    LockTraits::lock(lockCode(code));
    iterator.slot = ZmHashBits(code, m_bits);
    iterator.node = nullptr;
    iterator.prev = nullptr;
  }
  template <typename I> Node *iterate(I &iterator) {
    int slot = iterator.slot;

    if (slot < 0) return nullptr;

    Node *node = iterator.node, *prevNode;

    if (!node) {
      prevNode = nullptr;
      node = m_table[slot];
    } else {
      prevNode = node;
      node = node->NodeExt::next;
    }

    if (!node) {
      prevNode = nullptr;
      do {
	LockTraits::unlock(lockSlot(slot));
	if (++slot >= (1U << m_bits)) {
	  iterator.slot = -1;
	  return nullptr;
	}
	LockTraits::lock(lockSlot(slot));
	iterator.slot = slot;
      } while (!(node = m_table[slot]));
    }

    iterator.prev = prevNode;
    return iterator.node = node;
  }
  template <typename I> Node *keyIterate(I &iterator) {
    int slot = iterator.slot;

    if (slot < 0) return nullptr;

    Node *node = iterator.node, *prevNode;

    if (!node) {
      prevNode = nullptr;
      node = m_table[slot];
    } else {
      prevNode = node;
      node = node->NodeExt::next;
    }

    for (; node && !equals(node->Node::key(), iterator.key);
	 prevNode = node, node = node->NodeExt::next);

    if (!node) {
      LockTraits::unlock(lockSlot(slot));
      iterator.slot = -1;
      return nullptr;
    }

    iterator.prev = prevNode;
    return iterator.node = node;
  }
  template <typename I> void endIterate(I &iterator) {
    if (iterator.slot < 0) return;

    LockTraits::unlock(lockSlot(iterator.slot));
  }
  template <typename I> NodeMvRef delIterate(I &iterator) {
    Node *node = iterator.node, *prevNode = iterator.prev;

    unsigned count = m_count.load_();
    if (!count || !node) return nullptr;

    if (!prevNode)
      m_table[iterator.slot] = node->NodeExt::next;
    else
      prevNode->NodeExt::next = node->NodeExt::next;

    iterator.node = prevNode;

    m_count.store_(count - 1);

    node->NodeExt::next = nullptr;

    return nodeAcquire(node);
  }

public:
  void clean() {
    lockAll();

    for (unsigned i = 0, n = (1U << m_bits); i < n; i++) {
      Node *node, *prevNode;

      node = m_table[i];

      while (prevNode = node) {
	node = prevNode->NodeExt::next;
	nodeDeref(prevNode);
	nodeDelete(prevNode);
      }

      m_table[i] = nullptr;
    }
    m_count = 0;

    unlockAll();
  }

  template <typename P> Lock &lock(P &&key) {
    return lockCode(HashFn::hash(ZuFwd<P>(key)));
  }

  void telemetry(ZmHashTelemetry &data) const {
    data.id = m_id;
    data.addr = reinterpret_cast<uintptr_t>(this);
    data.loadFactor = loadFactor();
    unsigned count = m_count.load_();
    unsigned bits = m_bits;
    data.effLoadFactor = static_cast<double>(count) / (1 << bits);
    data.nodeSize = sizeof(Node);
    data.count = count;
    data.resized = m_resized.load_();
    data.bits = bits;
    data.cBits = cBits();
    data.linear = false;
    data.shadow = Shadow;
  }

private:
  void resize(unsigned bits) {
    if (!lockAllResize(bits)) return;

    m_resized.store_(m_resized.load_() + 1);

    unsigned n = (1U << m_bits);

    m_bits = bits;

    NodePtr *table = static_cast<NodePtr *>(
      Zm::alignedAlloc<Zm::CacheLineSize>(sizeof(NodePtr) << bits)
    );
    memset(table, 0, sizeof(NodePtr) << bits);
    Node *node, *nextNode;

    for (unsigned i = 0; i < n; i++)
      for (node = m_table[i]; node; node = nextNode) {
	nextNode = node->NodeExt::next;
	unsigned j = ZmHashBits(HashFn::hash(node->Node::key()), bits);
	node->NodeExt::next = table[j];
	table[j] = node;
      }
    Zm::alignedFree(m_table);
    m_table = table;

    unlockAll();
  }

  ZmIDString m_id;
  Cmp m_cmp;
  unsigned m_loadFactor = 0;
  ZmAtomic<unsigned> m_count = 0;
  ZmAtomic<unsigned> m_resized = 0;
  NodePtr *m_table;
};

template <typename P0, typename P1, typename NTP = ZmHash_Defaults>
using ZmHashKV = ZmHash<
  ZuTuple<P0, P1>, ZmHashKeyVal<ZuTupleAxor<0>(), ZuTupleAxor<1>(), NTP>>;

class ZeLog;

namespace ZeSinkType {
using T = int8_t;
enum { Invalid = -1, File, Debug, System, Lambda, N };
static_assert((N <= 1024), "N <= 1024");
enum {
  Bits = N <= 2 ? 1 :
    N <= 4      ? 2 :
    N <= 8      ? 3 :
    N <= 16     ? 4 :
    N <= 32     ? 5 :
    N <= 64     ? 6 :
    N <= 128    ? 7 :
    N <= 256    ? 8 :
    N <= 512    ? 9 :
		  10
};
template <typename Impl> struct Map_ : public ZuObject {
private:
  using V2S = ZmLHashKV<T, ZuCSpan, ZmLHashStatic<Bits, ZmLHashLocal<>>>;
  using S2V = ZmLHashKV<ZuCSpan, T, ZmLHashStatic<Bits, ZmLHashLocal<>>>;

protected:
  void init(const char *s, int v, ...) {
    if (__builtin_expect(!!(!s), 0)) return;
    add(s, v);
    va_list args;

    __builtin_va_start(

      args

      ,

      v

    );
    while (s =

	     __builtin_va_arg(

	       args

	       ,

	       const char *

	     )

    )
      add(
	s,
	v =

	  __builtin_va_arg(

	    args

	    ,

	    int

	  )

      );

    __builtin_va_end(

      args

    );
  }
  void add(ZuCSpan s, T v) {
    m_s2v.add(s, v);
    m_v2s.add(v, s);
  }
  static Impl *instance() { return ZmSingleton<Impl>::instance(); }

private:
  T s2v_(ZuCSpan s) const { return m_s2v.findVal(s); }
  ZuCSpan v2s_(T v) const { return m_v2s.findVal(v); }
  template <typename L> void all_(L l) const {
    auto i = m_s2v.readIterator();
    while (auto kv = i.iterate()) {
      l(kv->template p<0>(), kv->template p<1>());
    }
  }

public:
  Map_() = default;
  static T s2v(ZuCSpan s) { return instance()->s2v_(s); }
  static ZuCSpan v2s(T v) { return instance()->v2s_(v); }
  template <typename L> static void all(L l) { instance()->all_(ZuMv(l)); }

private:
  S2V m_s2v;
  V2S m_v2s;
};
inline ZuTuple<const char *const *const, unsigned> names() {
  static const char *names[] = {"File", "Debug", "System", "Lambda"};
  return ZuTuple<const char *const *const, unsigned>{
    names, static_cast<unsigned>(sizeof(names) / sizeof(names[0]))
  };
}
inline const char *name(int i) {
  ZuTuple<const char *const *const, unsigned> names_ = names();
  if (i >= (int)names_.p<1>()) return "Unknown";
  if (i < 0) return "";
  return names_.p<0>()[i];
}
struct Map : public Map_<Map> {
  static constexpr const char *id() { return "ZeSinkType"; }
  Map() {
    for (unsigned i = 0; i < N; i++) this->add(name(i), i);
  }
};
template <typename S> inline T lookup(const S &s) { return Map::s2v(s); };
} // namespace ZeSinkType
struct ZeSink : public ZmPolymorph {
  int type;

  ZeSink(int type_) : type(type_) { }

  virtual void pre(ZeLogBuf &, const ZeEventInfo &) = 0;
  virtual void post(ZeLogBuf &, const ZeEventInfo &) = 0;
  virtual void age() = 0;
};

struct ZeSinkOptions {
  ZeSinkOptions &path(ZuCSpan path) {
    m_path = path;
    return *this;
  }
  ZeSinkOptions &age(unsigned age) {
    m_age = age;
    return *this;
  }
  ZeSinkOptions &tzOffset(unsigned tzOffset) {
    m_tzOffset = tzOffset;
    return *this;
  }

  const auto &path() const { return m_path; }
  auto age() const { return m_age; }
  auto tzOffset() const { return m_tzOffset; }

private:
  ZuCSpan m_path;
  unsigned m_age = 8;
  int m_tzOffset = 0;
};

class ZeFileSink : public ZeSink {
  using Lock = ZmPLock;
  using Guard = ZmGuard<Lock>;

public:
  ZeFileSink() : ZeSink{ZeSinkType::File} { init(); }
  ZeFileSink(const ZeSinkOptions &options) :
    ZeSink{ZeSinkType::File}, m_path{options.path()}, m_age{options.age()},
    m_dateFmt{options.tzOffset()} {
    init();
  }

  ~ZeFileSink();

  void pre(ZeLogBuf &, const ZeEventInfo &);
  void post(ZeLogBuf &, const ZeEventInfo &);
  void age();

private:
  void init();
  void age_();

  ZtString m_path;
  unsigned m_age = 8;
  ZuDateTimeFmt::CSV m_dateFmt;

  Lock m_lock;
  FILE *m_file = nullptr;
};

class ZeDebugSink : public ZeSink {
  using Lock = ZmPLock;
  using Guard = ZmGuard<Lock>;

public:
  ZeDebugSink() : ZeSink{ZeSinkType::Debug}, m_started{Zm::now()} { init(); }
  ZeDebugSink(const ZeSinkOptions &options) :
    ZeSink{ZeSinkType::Debug}, m_path{options.path()}, m_started{Zm::now()} {
    init();
  }

  ~ZeDebugSink();

  void pre(ZeLogBuf &, const ZeEventInfo &);
  void post(ZeLogBuf &, const ZeEventInfo &);
  void age() { }

private:
  void init();

  ZtString m_path;
  FILE *m_file = nullptr;
  ZuTime m_started;
};

struct ZeSysSink : public ZeSink {
  ZeSysSink() : ZeSink{ZeSinkType::System} { }

  void pre(ZeLogBuf &, const ZeEventInfo &);
  void post(ZeLogBuf &, const ZeEventInfo &);
  void age() { }
};

struct ZeLambdaSink_ : public ZeSink {
  ZeLambdaSink_(int tzOffset = 0) :
    ZeSink{ZeSinkType::Lambda}, m_dateFmt{tzOffset} { }

  void pre(ZeLogBuf &, const ZeEventInfo &);

private:
  ZuDateTimeFmt::CSV m_dateFmt;
};
template <typename L> struct ZeLambdaSink : public ZeLambdaSink_ {
  L l;

  ZeLambdaSink(L l_, int tzOffset = 0) :
    ZeLambdaSink_{tzOffset}, l{ZuMv(l_)} { }

  void post(ZeLogBuf &buf, const ZeEventInfo &info) { l(buf, info); }
  void age() { }
};

class ZeLog {
  ZeLog(const ZeLog &);
  ZeLog &operator=(const ZeLog &);

  using Lock = ZmPLock;
  using Guard = ZmGuard<Lock>;

  using Ring = ZmRing<ZmRingMW<true>>;
  using Fn = ZmRingFn<ZeLog *>;

  ZeLog();

public:
  static ZeLog *instance();

  template <typename... Args> static ZmRef<ZeSink> fileSink(Args &&...args) {
    return new ZeFileSink(ZuFwd<Args>(args)...);
  }
  template <typename... Args> static ZmRef<ZeSink> debugSink(Args &&...args) {
    return new ZeDebugSink(ZuFwd<Args>(args)...);
  }
  template <typename... Args> static ZmRef<ZeSink> sysSink(Args &&...args) {
    return new ZeSysSink(ZuFwd<Args>(args)...);
  }
  template <typename L> static ZmRef<ZeSink> lambdaSink(L l) {
    return new ZeLambdaSink<L>(ZuMv(l));
  }

  static void init() { instance()->init_(); }
  static void init(const char *program) { instance()->init_(program); }
  static void init(const char *program, const char *facility) {
    instance()->init_(program, facility);
  }

  static void bufSize(unsigned n) { instance()->bufSize_(n); }

  static ZuCSpan program() { return instance()->program_(); }

  static int level() { return instance()->level_(); }
  static void level(int l) { instance()->level_(l); }

  template <typename... Args> static void sink(Args &&...args) {
    instance()->sink_(ZuFwd<Args>(args)...);
  }

  static void start() { instance()->start_(); }
  static void stop() { instance()->stop_(); }
  static void forked() { instance()->forked_(); }

  template <typename L> static void log(ZeEvent<L> e) {
    instance()->log_(ZuMv(e));
  }
  template <typename L> void log_(ZeEvent<L> e) {
    if (static_cast<int>(e.severity) < m_level) return;
    auto fn_ = [e = ZuMv(e)](ZeLog *this_) mutable {
      auto sink = this_->sink_();
      auto &buf = this_->m_buf;
      buf.null();
      sink->pre(buf, e);
      buf << e;
      sink->post(buf, e);
    };
    Fn fn{fn_};
    log__(fn);
  }
  static void age() { instance()->age_(); }

private:
  void init_();
  void init__();
  void init_(const char *program);
  void init_(const char *program, const char *facility);
  void init__(const char *program, const char *facility);

  void bufSize_(unsigned n) { m_bufSize = n; }

  ZuCSpan program_() const { return m_program; }
  ZuCSpan facility_() const { return m_facility; }

  int level_() const { return m_level; }
  void level_(int l) { m_level = l; }

  ZmRef<ZeSink> sink_();
  void sink_(ZmRef<ZeSink> sink);

  void start_();
  void start__();
  void stop_();
  void forked_();

  void work_();

  void log__(Fn &fn);

  void age_();

private:
  ZtString m_program;
  ZtString m_facility;
  int m_level;
  unsigned m_bufSize = (1 << 20);

  ZmThread m_thread;
  Ring m_ring;

  Lock m_lock;
  ZmRef<ZeSink> m_sink;

  ZeLogBuf m_buf;
};

template <typename L> inline void ZeLogEvent(ZeEvent<L> e) {
  ZeLog::instance()->log_(ZuMv(e));
}

template <typename L>
inline decltype(ZuDeclVal<L &>()(ZuDeclVal<ZeLogBuf &>()), void())
ZeBackTrace(ZeEvent<L> event_) {
  ZmBackTrace bt{1};
  ZeLogEvent(ZeEvent(
    event_.severity, event_.file, event_.line, event_.function,
    [bt = ZuMv(bt), l = ZuMv(event_).l](auto &s) mutable {
    l(s);
    s << '\n' << ZuMv(bt);
  }
  ));
}
template <typename L>
inline decltype(ZuDeclVal<L &>()(ZuDeclVal<ZeLogBuf &>(), ZuDeclVal<const ZeEventInfo &>()), void())
ZeBackTrace(ZeEvent<L> event_) {
  ZmBackTrace bt{1};
  ZeLogEvent(ZeEvent(
    event_.severity, event_.file, event_.line, event_.function,
    [bt = ZuMv(bt), l = ZuMv(event_).l](auto &s, const auto &info) mutable {
    l(s, info);
    s << '\n' << ZuMv(bt);
  }
  ));
}

class ZiIP : public in_addr {
public:
  using Hostname = Zi::Hostname;

  enum Result { OK = Zi::OK, IOError = Zi::IOError };

  ZiIP() { s_addr = 0; }

  ZiIP(const ZiIP &a) { s_addr = a.s_addr; }
  ZiIP &operator=(const ZiIP &a) {
    s_addr = a.s_addr;
    return *this;
  }

  explicit ZiIP(struct in_addr ia) { s_addr = ia.s_addr; }
  ZiIP &operator=(struct in_addr ia) {
    s_addr = ia.s_addr;
    return *this;
  }

  ZiIP(uint32_t n) { s_addr = htonl(n); }
  ZiIP &operator=(uint32_t n) {
    s_addr = htonl(n);
    return *this;
  }

  template <typename S, decltype(ZuMatchString<S>(), int()) = 0> ZiIP(S &&s) {
    if (!s) {
      s_addr = 0;
      return;
    }

    ZeError e;
    if (resolve(ZuFwd<S>(s), &e) != OK) throw e;
  }
  template <typename S> ZuMatchString<S, ZiIP &> &operator=(S &&s) {
    if (!s) {
      s_addr = 0;
      return *this;
    }

    ZeError e;
    if (resolve(ZuFwd<S>(s), &e) != OK) throw e;
    return *this;
  }

  bool operator!() const { return !s_addr; }
  operator const void *() const {
    return !*this ? reinterpret_cast<const void *>(0) :
		    static_cast<const void *>(this);
  }

  bool equals(const ZiIP &a) const { return s_addr == a.s_addr; }
  int cmp(const ZiIP &a) const {
    return ZuCmp<uint32_t>::cmp(s_addr, a.s_addr);
  }
  friend inline bool operator==(const ZiIP &l, const ZiIP &r) {
    return l.equals(r);
  }
  friend inline int operator<=>(const ZiIP &l, const ZiIP &r) {
    return l.cmp(r);
  }

  operator uint32_t() const { return ntohl(s_addr); }

  uint32_t hash() const { return s_addr; }

  template <typename S> void print(S &s) const {
    const uint8_t *__attribute__((__may_alias__)) addr =
      reinterpret_cast<const uint8_t *>(&s_addr);
    s << ZuBoxed(addr[0]) << '.' << ZuBoxed(addr[1]) << '.' << ZuBoxed(addr[2])
      << '.' << ZuBoxed(addr[3]);
  }

  bool multicast() const {
    unsigned i = ((static_cast<uint32_t>(ntohl(s_addr))) >> 24) & 0xff;
    return i >= 224 && i < 240;
  }

  struct Traits : public ZuBaseTraits<ZiIP> {
    enum { IsPOD = 1 };
  };
  friend Traits ZuTraitsType(ZiIP *);

  friend ZuPrintFn ZuPrintType(ZiIP *);

private:
  int resolve_(ZuCSpan, ZeError *e = 0);

public:
  template <typename S> ZuMatchString<S, int> resolve(S &&s, ZeError *e = 0) {
    return resolve_(ZuCSpan{ZuFwd<S>(s)}, e);
  }
  Hostname name(ZeError *e = 0);
};

class ZiSockAddr {
public:
  ZiSockAddr() { null(); }
  ZiSockAddr(ZiIP ip, uint16_t port) { init(ip, port); }

  void null() {
    m_sin.sin_family =

      0;
  }
  void init(ZiIP ip, uint16_t port) {
    m_sin.sin_family =

      2;
    m_sin.sin_port = htons(port);
    m_sin.sin_addr = ip;
    memset(&m_sin.sin_zero, 0, sizeof(m_sin.sin_zero));
  }

  ZiIP ip() const { return ZiIP(m_sin.sin_addr); }
  uint16_t port() const { return ntohs(m_sin.sin_port); }

  struct sockaddr *sa() { return (struct sockaddr *)&m_sin; }
  int len() const { return sizeof(struct sockaddr_in); }

  bool operator!() const {
    return m_sin.sin_family ==

      0;
  }
  operator const void *() const {
    return !*this ? reinterpret_cast<const void *>(0) :
		    static_cast<const void *>(this);
  }

  struct sockaddr_in m_sin;
};

class ZiConnection;

struct ZiIOContext {
  ZiConnection *cxn = nullptr;
  ZmAnyFn fn;
  uint8_t *ptr = nullptr;
  unsigned size = 0;
  unsigned offset = 0;
  unsigned length = 0;
  ZiSockAddr addr;

  static constexpr uintptr_t invalid_ptr() { return uintptr_t(-1); }

private:
  friend ZiConnection;

  template <typename Fn> void init_(Fn &&fn_) {
    fn = ZuFwd<Fn>(fn_);
    ptr = nullptr;
    size = offset = length = 0;
    (*this)();
  }

public:
  template <typename Fn>
  void init(Fn &&fn_, const void *ptr_, unsigned size_, unsigned offset_) {
    ((size_) ?
       void() :
       ZmAssert_fail(
	 "size_", "../../zi/src/zlib/ZiIOContext.hh", 47, __PRETTY_FUNCTION__
       ));
    fn = ZuFwd<Fn>(fn_);
    ptr = static_cast<uint8_t *>(const_cast<void *>(ptr_));
    size = size_;
    offset = offset_;
    length = 0;
  }

  template <typename Fn, typename Addr>
  void init(
    Fn &&fn_, const void *ptr_, unsigned size_, unsigned offset_, Addr &&addr_
  ) {
    ((size_) ?
       void() :
       ZmAssert_fail(
	 "size_", "../../zi/src/zlib/ZiIOContext.hh", 56, __PRETTY_FUNCTION__
       ));
    fn = ZuFwd<Fn>(fn_);
    ptr = static_cast<uint8_t *>(const_cast<void *>(ptr_));
    size = size_;
    offset = offset_;
    length = 0;
    addr = ZuFwd<Addr>(addr_);
  }

  bool initialized() { return ptr; }

  void complete() {
    fn = {};
    ptr = nullptr;
  }
  bool completed() const { return !fn; }

  void disconnect() {
    fn = {};
    ptr = reinterpret_cast<uint8_t *>(invalid_ptr());
  }
  bool disconnected() const {
    return reinterpret_cast<uintptr_t>(ptr) == invalid_ptr();
  }

  bool operator()();
};
using ZiIOFn = ZmFn<bool(ZiIOContext &)>;
inline bool ZiIOContext::operator()() { return fn.as<ZiIOFn>()(*this); }

class ZiConnection;
class ZiMultiplex;

class ZiCxnOptions;
struct ZiCxnInfo;

using ZiFailFn = ZmFn<void(bool)>;

class ZiMReq : public ip_mreq {
public:
  ZiMReq() {
    new (&imr_multiaddr) ZiIP();
    new (&imr_interface) ZiIP();
  }
  ZiMReq(const ZiIP &addr, const ZiIP &mif) {
    new (&imr_multiaddr) ZiIP(addr);
    new (&imr_interface) ZiIP(mif);
  }

  ZiMReq(const ZiMReq &m) { addr() = m.addr(), mif() = m.mif(); }
  ZiMReq &operator=(const ZiMReq &m) {
    if (__builtin_expect(!!(this != &m), 1)) addr() = m.addr(), mif() = m.mif();
    return *this;
  }

  explicit ZiMReq(const struct ip_mreq &m) {
    addr() = m.imr_multiaddr, mif() = m.imr_interface;
  }
  ZiMReq &operator=(const struct ip_mreq &m) {
    if ((const struct ip_mreq *)this != &m)
      addr() = m.imr_multiaddr, mif() = m.imr_interface;
    return *this;
  }

  bool equals(const ZiMReq &m) const {
    return addr() == m.addr() && mif() == m.mif();
  }
  int cmp(const ZiMReq &m) const {
    int r;
    if (r = addr().cmp(m.addr())) return r;
    return mif().cmp(m.mif());
  }
  friend inline bool operator==(const ZiMReq &l, const ZiMReq &r) {
    return l.equals(r);
  }
  friend inline int operator<=>(const ZiMReq &l, const ZiMReq &r) {
    return l.cmp(r);
  }

  bool operator!() const { return !addr() && !mif(); }
  operator const void *() const {
    return !*this ? reinterpret_cast<const void *>(0) :
		    static_cast<const void *>(this);
  }

  uint32_t hash() const { return addr().hash() ^ mif().hash(); }

  template <typename S> void print(S &s) const { s << addr() << "->" << mif(); }

  const ZiIP &addr() const { return *(const ZiIP *)&imr_multiaddr; }
  ZiIP &addr() { return *(ZiIP *)&imr_multiaddr; }
  const ZiIP &mif() const { return *(const ZiIP *)&imr_interface; }
  ZiIP &mif() { return *(ZiIP *)&imr_interface; }

  struct Traits : public ZuBaseTraits<ZiMReq> {
    enum { IsPOD = 1 };
  };
  friend Traits ZuTraitsType(ZiMReq *);

  friend ZuPrintFn ZuPrintType(ZiMReq *);
};

namespace ZiCxnFlags {
using T = uint8_t;
enum {
  Invalid = -1,
  UDP_,
  Multicast_,
  LoopBack_,
  KeepAlive_,
  Nagle_,
  NetLink_,
  N
};
static_assert((N <= 1024), "N <= 1024");
enum {
  Bits = N <= 2 ? 1 :
    N <= 4      ? 2 :
    N <= 8      ? 3 :
    N <= 16     ? 4 :
    N <= 32     ? 5 :
    N <= 64     ? 6 :
    N <= 128    ? 7 :
    N <= 256    ? 8 :
    N <= 512    ? 9 :
		  10
};
template <typename Impl> struct Map_ : public ZuObject {
private:
  using V2S = ZmLHashKV<T, ZuCSpan, ZmLHashStatic<Bits, ZmLHashLocal<>>>;
  using S2V = ZmLHashKV<ZuCSpan, T, ZmLHashStatic<Bits, ZmLHashLocal<>>>;

protected:
  void init(const char *s, int v, ...) {
    if (__builtin_expect(!!(!s), 0)) return;
    add(s, v);
    va_list args;

    __builtin_va_start(

      args

      ,

      v

    );
    while (s =

	     __builtin_va_arg(

	       args

	       ,

	       const char *

	     )

    )
      add(
	s,
	v =

	  __builtin_va_arg(

	    args

	    ,

	    int

	  )

      );

    __builtin_va_end(

      args

    );
  }
  void add(ZuCSpan s, T v) {
    m_s2v.add(s, v);
    m_v2s.add(v, s);
  }
  static Impl *instance() { return ZmSingleton<Impl>::instance(); }

private:
  T s2v_(ZuCSpan s) const { return m_s2v.findVal(s); }
  ZuCSpan v2s_(T v) const { return m_v2s.findVal(v); }
  template <typename L> void all_(L l) const {
    auto i = m_s2v.readIterator();
    while (auto kv = i.iterate()) {
      l(kv->template p<0>(), kv->template p<1>());
    }
  }

public:
  Map_() = default;
  static T s2v(ZuCSpan s) { return instance()->s2v_(s); }
  static ZuCSpan v2s(T v) { return instance()->v2s_(v); }
  template <typename L> static void all(L l) { instance()->all_(ZuMv(l)); }

private:
  S2V m_s2v;
  V2S m_v2s;
};
inline static constexpr uint8_t UDP() { return (uint8_t(1) << UDP_); }
inline static constexpr uint8_t Multicast() {
  return (uint8_t(1) << Multicast_);
}
inline static constexpr uint8_t LoopBack() { return (uint8_t(1) << LoopBack_); }
inline static constexpr uint8_t KeepAlive() {
  return (uint8_t(1) << KeepAlive_);
}
inline static constexpr uint8_t Nagle() { return (uint8_t(1) << Nagle_); }
inline static constexpr uint8_t NetLink() { return (uint8_t(1) << NetLink_); };
class Map : public Map_<Map> {
public:
  static constexpr const char *id() { return "ZiCxnFlags"; }
  Map() {
    this->init(
      "U", UDP_, "M", Multicast_, "L", LoopBack_, "L", KeepAlive_, "D", Nagle_,
      "N", NetLink_, (const char *)0
    );
  }

private:
  template <typename S, typename Flags_>
  unsigned print_(S &s, Flags_ v, ZuCSpan delim = "|") const {
    if (!v) return 0;
    bool first = true;
    unsigned n = 0;
    Flags_ mask = 1;
    for (unsigned i = 0; i < N; i++, (mask <<= 1)) {
      if (v & mask) {
	if (ZuCSpan s_ = this->v2s(i)) {
	  if (!first) s << delim;
	  s << s_;
	  first = false;
	  n++;
	}
      }
    }
    return n;
  }
  template <typename Flags_> Flags_ scan_(ZuCSpan s, ZuCSpan delim) const {
    if (!s) return 0;
    Flags_ v = 0;
    bool end = false;
    unsigned len = 0, clen = 0;
    const char *cstr = s.data(), *next;
    char c = 0;
    Flags_ mask = 1;
    do {
      for (next = cstr; len < s.length() && (c = *next) != 0;
	   clen++, len++, next++) {
	unsigned n = delim.length();
	if (!n || (len + n < s.length() && c == delim[0])) {
	  bool delimited = true;
	  for (unsigned i = 1; i < n; i++)
	    if (next[i] != delim[i]) {
	      delimited = false;
	      break;
	    }
	  if (delimited) {
	    len += n;
	    next += n;
	    break;
	  }
	}
      }
      if (len > s.length() || c == 0) end = true;
      T i = this->s2v(ZuCSpan(cstr, clen));
      if (__builtin_expect(!!(i == T(-1)), 0)) return 0;
      v |= (mask << unsigned(i));
      cstr = next;
      clen = 0;
    } while (!end);
    return v;
  }

public:
  template <typename Flags_>
  static Flags_ scan(ZuCSpan s, ZuCSpan delim = "|") {
    return instance()->template scan_<Flags_>(s, delim);
  }
  template <typename Flags_> struct Print : public ZuPrintable {
    Print(Flags_ v_, ZuCSpan delim_ = "|") : v(v_), delim{delim_} { }
    template <typename S> void print(S &s) const {
      ZmSingleton<Map>::instance()->print_(s, v, delim);
    }
    const Flags_ v;
    ZuCSpan delim;
  };
  template <typename Flags_>
  static Print<Flags_> print(Flags_ v, ZuCSpan delim = "|") {
    return Print<Flags_>{v, delim};
  }
};
;
} // namespace ZiCxnFlags
class ZiCxnOptions {
  using MReqs = ZuArray<ZiMReq, 1>;

public:
  ZiCxnOptions() = default;
  ZiCxnOptions(const ZiCxnOptions &) = default;
  ZiCxnOptions &operator=(const ZiCxnOptions &) = default;
  ZiCxnOptions(ZiCxnOptions &&) = default;
  ZiCxnOptions &operator=(ZiCxnOptions &&) = default;

  uint32_t flags() const { return m_flags; }
  ZiCxnOptions &flags(uint32_t flags) {
    m_flags = flags;
    return *this;
  }
  bool udp() const {
    using namespace ZiCxnFlags;
    return m_flags & UDP();
  }
  ZiCxnOptions &udp(bool b) {
    using namespace ZiCxnFlags;
    b ? (m_flags |= UDP()) : (m_flags &= ~UDP());
    return *this;
  }
  bool multicast() const {
    using namespace ZiCxnFlags;
    return m_flags & Multicast();
  }
  ZiCxnOptions &multicast(bool b) {
    using namespace ZiCxnFlags;
    b ? (m_flags |= Multicast()) : (m_flags &= ~Multicast());
    return *this;
  }
  bool loopBack() const {
    using namespace ZiCxnFlags;
    return m_flags & LoopBack();
  }
  ZiCxnOptions &loopBack(bool b) {
    using namespace ZiCxnFlags;
    b ? (m_flags |= LoopBack()) : (m_flags &= ~LoopBack());
    return *this;
  }
  bool keepAlive() const {
    using namespace ZiCxnFlags;
    return m_flags & KeepAlive();
  }
  ZiCxnOptions &keepAlive(bool b) {
    using namespace ZiCxnFlags;
    b ? (m_flags |= KeepAlive()) : (m_flags &= ~KeepAlive());
    return *this;
  }
  const MReqs &mreqs() const { return m_mreqs; }
  void mreq(const ZiMReq &mreq) { m_mreqs.push(mreq); }
  const ZiIP &mif() const { return m_mif; }
  ZiCxnOptions &mif(ZiIP ip) {
    m_mif = ip;
    return *this;
  }
  const unsigned &ttl() const { return m_ttl; }
  ZiCxnOptions &ttl(unsigned i) {
    m_ttl = i;
    return *this;
  }

  bool netlink() const { return false; }
  ZiCxnOptions &netlink(bool) { return *this; }
  ZuCSpan familyName() const { return ZuCSpan{}; }
  ZiCxnOptions &familyName(ZuCSpan) { return *this; }

  bool nagle() const {
    using namespace ZiCxnFlags;
    return m_flags & Nagle();
  }
  ZiCxnOptions &nagle(bool b) {
    using namespace ZiCxnFlags;
    b ? (m_flags |= Nagle()) : (m_flags &= ~Nagle());
    return *this;
  }

  bool equals(const ZiCxnOptions &o) const {
    using namespace ZiCxnFlags;
    if (m_flags != o.m_flags) return false;

    if (!(m_flags & Multicast())) return true;
    return m_mreqs == o.m_mreqs && m_mif == o.m_mif && m_ttl == o.m_ttl;
  }
  int cmp(const ZiCxnOptions &o) const {
    using namespace ZiCxnFlags;
    int i;
    if (i = ZuCmp<uint32_t>::cmp(m_flags, o.m_flags)) return i;

    if (!(m_flags & Multicast())) return i;
    if (i = m_mreqs.cmp(o.m_mreqs)) return i;
    if (i = m_mif.cmp(o.m_mif)) return i;
    return ZuBoxed(m_ttl).cmp(o.m_ttl);
  }
  friend inline bool operator==(const ZiCxnOptions &l, const ZiCxnOptions &r) {
    return l.equals(r);
  }
  friend inline int operator<=>(const ZiCxnOptions &l, const ZiCxnOptions &r) {
    return l.cmp(r);
  }

  uint32_t hash() const {
    using namespace ZiCxnFlags;
    uint32_t code = ZuHash<uint32_t>::hash(m_flags);

    if (!(m_flags & Multicast())) return code;
    return code ^ m_mreqs.hash() ^ m_mif.hash() ^ ZuBoxed(m_ttl).hash();
  }

  template <typename S> void print(S &s) const {
    using namespace ZiCxnFlags;
    s << "flags=" << Map::print(m_flags);
    if (m_flags & Multicast()) {
      s << " mreqs={";
      for (unsigned i = 0; i < m_mreqs.length(); i++) {
	if (i) s << ',';
	s << m_mreqs[i];
      }
      s << "} mif=" << m_mif << " TTL=" << ZuBoxed(m_ttl);
    }
  }

  friend ZuPrintFn ZuPrintType(ZiCxnOptions *);

private:
  MReqs m_mreqs;
  ZiIP m_mif;
  unsigned m_ttl = 0;

  ZiCxnFlags::T m_flags = 0;
};

struct ZiListenInfo {
  Zi::Socket socket;
  unsigned nAccepts = 0;
  ZiIP ip;
  uint16_t port = 0;
  ZiCxnOptions options;

  template <typename S> void print(S &s) const {
    s << "socket=" << ZuBoxed(socket) << " nAccepts=" << nAccepts
      << " options={" << options << "} localAddr=" << ip << ':' << port;
  }
  friend ZuPrintFn ZuPrintType(ZiListenInfo *);
};

namespace ZiCxnType {
using T = int8_t;
enum { Invalid = -1, TCPIn, TCPOut, UDP, N };
static_assert((N <= 1024), "N <= 1024");
enum {
  Bits = N <= 2 ? 1 :
    N <= 4      ? 2 :
    N <= 8      ? 3 :
    N <= 16     ? 4 :
    N <= 32     ? 5 :
    N <= 64     ? 6 :
    N <= 128    ? 7 :
    N <= 256    ? 8 :
    N <= 512    ? 9 :
		  10
};
template <typename Impl> struct Map_ : public ZuObject {
private:
  using V2S = ZmLHashKV<T, ZuCSpan, ZmLHashStatic<Bits, ZmLHashLocal<>>>;
  using S2V = ZmLHashKV<ZuCSpan, T, ZmLHashStatic<Bits, ZmLHashLocal<>>>;

protected:
  void init(const char *s, int v, ...) {
    if (__builtin_expect(!!(!s), 0)) return;
    add(s, v);
    va_list args;

    __builtin_va_start(

      args

      ,

      v

    );
    while (s =

	     __builtin_va_arg(

	       args

	       ,

	       const char *

	     )

    )
      add(
	s,
	v =

	  __builtin_va_arg(

	    args

	    ,

	    int

	  )

      );

    __builtin_va_end(

      args

    );
  }
  void add(ZuCSpan s, T v) {
    m_s2v.add(s, v);
    m_v2s.add(v, s);
  }
  static Impl *instance() { return ZmSingleton<Impl>::instance(); }

private:
  T s2v_(ZuCSpan s) const { return m_s2v.findVal(s); }
  ZuCSpan v2s_(T v) const { return m_v2s.findVal(v); }
  template <typename L> void all_(L l) const {
    auto i = m_s2v.readIterator();
    while (auto kv = i.iterate()) {
      l(kv->template p<0>(), kv->template p<1>());
    }
  }

public:
  Map_() = default;
  static T s2v(ZuCSpan s) { return instance()->s2v_(s); }
  static ZuCSpan v2s(T v) { return instance()->v2s_(v); }
  template <typename L> static void all(L l) { instance()->all_(ZuMv(l)); }

private:
  S2V m_s2v;
  V2S m_v2s;
};
inline ZuTuple<const char *const *const, unsigned> names() {
  static const char *names[] = {"TCPIn", "TCPOut", "UDP"};
  return ZuTuple<const char *const *const, unsigned>{
    names, static_cast<unsigned>(sizeof(names) / sizeof(names[0]))
  };
}
inline const char *name(int i) {
  ZuTuple<const char *const *const, unsigned> names_ = names();
  if (i >= (int)names_.p<1>()) return "Unknown";
  if (i < 0) return "";
  return names_.p<0>()[i];
}
struct Map : public Map_<Map> {
  static constexpr const char *id() { return "ZiCxnType"; }
  Map() {
    for (unsigned i = 0; i < N; i++) this->add(name(i), i);
  }
};
template <typename S> inline T lookup(const S &s) { return Map::s2v(s); };
} // namespace ZiCxnType

struct ZiCxnInfo {
  int type = -1;
  Zi::Socket socket;
  ZiCxnOptions options;
  ZiIP localIP;
  uint16_t localPort = 0;
  ZiIP remoteIP;
  uint16_t remotePort = 0;

  bool operator!() const { return type != ZiCxnType::T(-1); }
  operator const void *() const {
    return !*this ? reinterpret_cast<const void *>(0) :
		    static_cast<const void *>(this);
  }

  template <typename S> void print(S &s) const {
    s << "type=" << ZiCxnType::name(type) << " socket=" << ZuBoxed(socket)
      << " options={" << options << "} ";
    if (!options.netlink()) {
      s << "localAddr=" << localIP << ':' << localPort
	<< " remoteAddr=" << remoteIP << ':' << remotePort;
    } else {
    }
  }
  friend ZuPrintFn ZuPrintType(ZiCxnInfo *);
};

struct ZiCxnTelemetry {
  ZuID mxID;
  uint64_t socket = 0;
  uint32_t rxBufSize = 0;
  uint32_t rxBufLen = 0;
  uint32_t txBufSize = 0;
  uint32_t txBufLen = 0;
  ZiIP mreqAddr;
  ZiIP mreqIf;
  ZiIP mif;
  uint32_t ttl = 0;
  ZiIP localIP;
  ZiIP remoteIP;
  uint16_t localPort = 0;
  uint16_t remotePort = 0;
  uint8_t flags = 0;
  int8_t type = -1;
};

using ZiListenFn = ZmFn<void(const ZiListenInfo &)>;
using ZiConnectFn = ZmFn<ZiConnection *(const ZiCxnInfo &)>;

class ZiConnection : public ZmPolymorph {
  ZiConnection(const ZiConnection &) = delete;
  ZiConnection &operator=(const ZiConnection &) = delete;

  friend ZiMultiplex;

public:
  using Socket = Zi::Socket;

  static Zi::Socket SocketAxor(const ZiConnection *c) {
    return c->info().socket;
  }
  static const char *HeapID() { return "ZiMultiplex.Connection"; }

protected:
  ZiConnection(ZiMultiplex *mx, const ZiCxnInfo &ci);

public:
  virtual ~ZiConnection();

  void recv(ZiIOFn fn);
  void recv_(ZiIOFn fn);

  void send(ZiIOFn fn);
  void send_(ZiIOFn fn);

  void disconnect();

  void close();

  virtual void connected(ZiIOContext &rxContext) = 0;
  virtual void disconnected() = 0;

  bool up() const { return m_rxUp.load_() && m_txUp.load_(); }

  ZiMultiplex *mx() const { return m_mx; }
  const ZiCxnInfo &info() const { return m_info; }

  void telemetry(ZiCxnTelemetry &data) const;

private:
  void connected();

  bool recv();

  void errorRecv(int status, ZeError e);
  void executedRecv(unsigned n);

  void send();
  void errorSend(int status, ZeError e);
  void executedSend(unsigned n);

  void disconnect_1();
  void disconnect_2();
  void close_1();
  void close_2();

  void errorDisconnect(int status, ZeError e);
  void executedDisconnect();

  ZiMultiplex *m_mx;
  ZiCxnInfo m_info;

  ZmAtomic<unsigned> m_rxUp;
  uint64_t m_rxRequests;
  uint64_t m_rxBytes;
  ZiIOContext m_rxContext;

  ZmAtomic<unsigned> m_txUp;
  uint64_t m_txRequests;
  uint64_t m_txBytes;
  ZiIOContext m_txContext;
};

struct ZiMxParams {
  enum { RxThread = 1, TxThread = 2 };

  ZiMxParams() :
    m_scheduler{
      ZmSchedParams{}
	.nThreads(3)
	.thread(ZiMxParams::RxThread, [](auto &t) { t.isolated(true); })
	.thread(ZiMxParams::TxThread, [](auto &t) { t.isolated(true); })
    } { }

  ZiMxParams(const ZiMxParams &) = default;
  ZiMxParams &operator=(const ZiMxParams &) = default;
  ZiMxParams(ZiMxParams &&) = default;
  ZiMxParams &operator=(ZiMxParams &&) = default;

  ZiMxParams &&rxThread(unsigned tid) {
    m_rxThread = tid;
    return ZuMv(*this);
  }
  ZiMxParams &&txThread(unsigned tid) {
    m_txThread = tid;
    return ZuMv(*this);
  }

  ZiMxParams &&epollMaxFDs(unsigned n) {
    m_epollMaxFDs = n;
    return ZuMv(*this);
  }
  ZiMxParams &&epollQuantum(unsigned n) {
    m_epollQuantum = n;
    return ZuMv(*this);
  }

  ZiMxParams &&rxBufSize(unsigned v) {
    m_rxBufSize = v;
    return ZuMv(*this);
  }
  ZiMxParams &&txBufSize(unsigned v) {
    m_txBufSize = v;
    return ZuMv(*this);
  }
  ZiMxParams &&listenerHash(const char *id) {
    m_listenerHash = id;
    return ZuMv(*this);
  }
  ZiMxParams &&requestHash(const char *id) {
    m_requestHash = id;
    return ZuMv(*this);
  }
  ZiMxParams &&cxnHash(const char *id) {
    m_cxnHash = id;
    return ZuMv(*this);
  }

  ZiMxParams &&trace(bool b) {
    m_trace = b;
    return ZuMv(*this);
  }
  ZiMxParams &&debug(bool b) {
    m_debug = b;
    return ZuMv(*this);
  }
  ZiMxParams &&frag(bool b) {
    m_frag = b;
    return ZuMv(*this);
  }
  ZiMxParams &&yield(bool b) {
    m_yield = b;
    return ZuMv(*this);
  }

  ZmSchedParams &scheduler() { return m_scheduler; }

  template <typename L> ZiMxParams &&scheduler(L l) {
    l(m_scheduler);
    return ZuMv(*this);
  }

  unsigned rxThread() const { return m_rxThread; }
  unsigned txThread() const { return m_txThread; }

  unsigned epollMaxFDs() const { return m_epollMaxFDs; }
  unsigned epollQuantum() const { return m_epollQuantum; }

  unsigned rxBufSize() const { return m_rxBufSize; }
  unsigned txBufSize() const { return m_txBufSize; }
  ZuCSpan listenerHash() const { return m_listenerHash; }
  ZuCSpan requestHash() const { return m_requestHash; }
  ZuCSpan cxnHash() const { return m_cxnHash; }

  bool trace() const { return m_trace; }
  bool debug() const { return m_debug; }
  bool frag() const { return m_frag; }
  bool yield() const { return m_yield; }

private:
  ZmSchedParams m_scheduler;
  unsigned m_rxThread = RxThread;
  unsigned m_txThread = TxThread;

  unsigned m_epollMaxFDs = 256;
  unsigned m_epollQuantum = 8;

  unsigned m_rxBufSize = 0;
  unsigned m_txBufSize = 0;
  const char *m_listenerHash = "ZiMultiplex.ListenerHash";
  const char *m_requestHash = "ZiMultiplex.RequestHash";
  const char *m_cxnHash = "ZiMultiplex.CxnHash";

  bool m_trace = false;
  bool m_debug = false;
  bool m_frag = false;
  bool m_yield = false;
};

struct ZiMxTelemetry {
  ZuID id;
  uint32_t stackSize = 0;
  uint32_t queueSize = 0;
  uint32_t spin = 0;
  uint32_t timeout = 0;
  uint32_t rxBufSize = 0;
  uint32_t txBufSize = 0;
  uint16_t rxThread = 0;
  uint16_t txThread = 0;
  uint16_t partition = 0;
  int8_t state = ZmEngineState::Stopped;
  uint8_t ll = 0;
  uint8_t priority = 0;
  uint8_t nThreads = 0;
};

class ZiMultiplex : public ZmScheduler {
  ZiMultiplex(const ZiMultiplex &);
  ZiMultiplex &operator=(const ZiMultiplex &);

  friend ZiConnection;

  class Listener_;

  class Accept_;

  class Connect_;

  class Listener_ : public ZuObject {
    friend ZiMultiplex;

    friend Accept_;

    using Socket = Zi::Socket;

  public:
    static Zi::Socket SocketAxor(const Listener_ &l) { return l.info().socket; }
    static const char *HeapID() { return "ZiMultiplex.Listener"; }

  protected:
    template <typename... Args>
    Listener_(ZiMultiplex *mx, ZiConnectFn acceptFn, Args &&...args) :
      m_mx(mx), m_acceptFn(acceptFn), m_up(1), m_info{ZuFwd<Args>(args)...} { }

  private:
    const ZiConnectFn &acceptFn() const { return m_acceptFn; }
    bool up() const { return m_up; }
    void down() { m_up = 0; }
    const ZiListenInfo &info() const { return m_info; }

    ZiMultiplex *m_mx;
    ZiConnectFn m_acceptFn;
    bool m_up;
    ZiListenInfo m_info;
  };
  using ListenerHash = ZmHash<
    Listener_,
    ZmHashNode<
      Listener_,
      ZmHashKey<
	Listener_::SocketAxor,
	ZmHashHeapID<Listener_::HeapID, ZmHashSharded<true>>>>>;
  using Listener = ListenerHash::Node;

  static constexpr const char *Connect_HeapID() {
    return "ZiMultiplex.Connect";
  }

  class Connect_ :
    public ZuObject

  {
    friend ZiMultiplex;

    using Socket = Zi::Socket;

  public:
    static Zi::Socket SocketAxor(const Connect_ &c) { return c.info().socket; }

  protected:
    template <typename... Args>
    Connect_(ZiMultiplex *mx, ZiConnectFn fn, ZiFailFn failFn, Args &&...args) :
      m_mx(mx), m_fn(fn), m_failFn(failFn), m_info{ZuFwd<Args>(args)...} { }

  private:
    void fail(bool transient) { m_failFn(transient); }

    const ZiConnectFn &fn() const { return m_fn; }
    const ZiCxnInfo &info() const { return m_info; }
    ZiCxnInfo &info() { return m_info; }

    ZiMultiplex *m_mx;
    ZiConnectFn m_fn;
    ZiFailFn m_failFn;
    ZiCxnInfo m_info;
  };

  using ConnectHash = ZmHash<
    Connect_,
    ZmHashNode<
      Connect_, ZmHashKey<Connect_::SocketAxor, ZmHashHeapID<Connect_HeapID>>>>;
  using Connect = ConnectHash::Node;

  using CxnHash = ZmHash<
    ZmRef<ZiConnection>,
    ZmHashKey<ZiConnection::SocketAxor, ZmHashHeapID<ZiConnection::HeapID>>>;

public:
  using Socket = Zi::Socket;

  ZiMultiplex(ZiMxParams mxParams = ZiMxParams{});
  ~ZiMultiplex();

  void allCxns(ZmFn<void(ZiConnection *)> fn);
  void allCxns_(ZmFn<void(ZiConnection *)> fn);

  void listen(
    ZiListenFn listenFn, ZiFailFn failFn, ZiConnectFn acceptFn, ZiIP localIP,
    uint16_t localPort, unsigned nAccepts, ZiCxnOptions options = ZiCxnOptions()
  );
  void listen_(
    ZiListenFn listenFn, ZiFailFn failFn, ZiConnectFn acceptFn, ZiIP localIP,
    uint16_t localPort, unsigned nAccepts, ZiCxnOptions options = ZiCxnOptions()
  );
  void stopListening(ZiIP localIP, uint16_t localPort);
  void stopListening_(ZiIP localIP, uint16_t localPort);

  void connect(
    ZiConnectFn fn, ZiFailFn failFn, ZiIP localIP, uint16_t localPort,
    ZiIP remoteIP, uint16_t remotePort, ZiCxnOptions options = ZiCxnOptions()
  );
  void connect_(
    ZiConnectFn fn, ZiFailFn failFn, ZiIP localIP, uint16_t localPort,
    ZiIP remoteIP, uint16_t remotePort, ZiCxnOptions options = ZiCxnOptions()
  );

  void udp(
    ZiConnectFn fn, ZiFailFn failFn, ZiIP localIP, uint16_t localPort,
    ZiIP remoteIP, uint16_t remotePort, ZiCxnOptions options = ZiCxnOptions()
  );
  void udp_(
    ZiConnectFn fn, ZiFailFn failFn, ZiIP localIP, uint16_t localPort,
    ZiIP remoteIP, uint16_t remotePort, ZiCxnOptions options = ZiCxnOptions()
  );

  unsigned rxThread() const { return m_rxThread; }
  unsigned txThread() const { return m_txThread; }

  template <typename... Args> void rxRun(Args &&...args) {
    run(m_rxThread, ZuFwd<Args>(args)...);
  }
  template <typename... Args> void rxInvoke(Args &&...args) {
    invoke(m_rxThread, ZuFwd<Args>(args)...);
  }
  template <typename... Args> void txRun(Args &&...args) {
    run(m_txThread, ZuFwd<Args>(args)...);
  }
  template <typename... Args> void txInvoke(Args &&...args) {
    invoke(m_txThread, ZuFwd<Args>(args)...);
  }

  bool trace() const { return m_trace; }
  void trace(bool b) { m_trace = b; }
  bool debug() const { return m_debug; }
  void debug(bool b) { m_debug = b; }
  bool frag() const { return m_frag; }
  void frag(bool b) { m_frag = b; }
  bool yield() const { return m_yield; }
  void yield(bool b) { m_yield = b; }

  unsigned epollMaxFDs() const { return m_epollMaxFDs; }
  unsigned epollQuantum() const { return m_epollQuantum; }

  unsigned rxBufSize() const { return m_rxBufSize; }
  unsigned txBufSize() const { return m_txBufSize; }

  void telemetry(ZiMxTelemetry &data) const;

private:
  bool start__();
  bool stop__();

  void stop_1();
  void stop_2();
  void stop_3();

  void busy() { ZmScheduler::busy(); }
  void idle() { ZmScheduler::idle(); }

  void rx();

  void wake();
  void wakeRx();

  void connect(Connect *);

  void executedConnect(ZiConnectFn, const ZiCxnInfo &);

  void accept(Listener *);

  void disconnected(ZiConnection *cxn);

  bool epollRecv(ZiConnection *, int s, uint32_t events);

  bool initSocket(Socket, const ZiCxnOptions &);

  bool cxnAdd(ZiConnection *, Socket);
  void cxnDel(Socket);

  bool listenerAdd(Listener *, Socket);
  void listenerDel(Socket);

  bool connectAdd(Connect *, Socket);
  void connectDel(Socket);

  bool readWake();
  void writeWake();

  ZmSemaphore *m_stopping = nullptr;

  unsigned m_rxThread = 0;

  ZmRef<ListenerHash> m_listeners;
  unsigned m_nAccepts = 0;

  ZmRef<ConnectHash> m_connects;

  ZmRef<CxnHash> m_cxns;

  unsigned m_txThread = 0;

  unsigned m_rxBufSize = 0;
  unsigned m_txBufSize = 0;

  unsigned m_epollMaxFDs = 0;
  unsigned m_epollQuantum = 0;
  int m_epollFD = -1;
  int m_wakeFD = -1, m_wakeFD2 = -1;

  bool m_trace = false;
  bool m_debug = false;
  bool m_frag = false;
  bool m_yield = false;

  void traceCapture() { m_tracer.capture(1); }

public:
  template <typename S> void traceDump(S &s) { m_tracer.dump(s); }

private:
  ZmBackTracer<64> m_tracer;
};

inline constexpr const char *ZiMxMgr_HeapID() { return "ZiMxMgr"; }

class ZiMxMgr {
  using Map = ZmRBTreeKV<
    ZuID, ZiMultiplex *, ZmRBTreeLock<ZmPLock, ZmRBTreeHeapID<ZiMxMgr_HeapID>>>;

  friend ZiMultiplex;

public:
  static ZiMxMgr *instance();

  template <typename L> static void all(L l) { instance()->all_(ZuMv(l)); }

  static ZiMultiplex *find(ZuID id);

private:
  static void add(ZiMultiplex *);
  static void del(ZiMultiplex *);

  template <typename L> void all_(L l) const {
    auto i = m_map.readIterator();
    while (auto mx = i.iterateVal()) l(mx);
  }

private:
  Map m_map;
};

namespace flatbuffers {

const char *FLATBUFFERS_VERSION();
}

namespace flatbuffers {
typedef std::string_view string_view;
}

namespace flatbuffers {

template <typename T> inline constexpr bool IsConstTrue(T t) { return !!t; }
}

namespace flatbuffers {

typedef uint32_t uoffset_t;
typedef uint64_t uoffset64_t;

typedef int32_t soffset_t;
typedef int64_t soffset64_t;

typedef uint16_t voffset_t;

typedef uintmax_t largest_scalar_t;

static const size_t kFileIdentifierLength = 4;

inline bool VerifyAlignmentRequirements(size_t align, size_t min_align = 1) {
  return (min_align <= align) && (align <= (32)) && (align & (align - 1)) == 0;
}

template <typename T> T EndianSwap(T t) {
  if (sizeof(T) == 1) {
    return t;
  } else if (sizeof(T) == 2) {
    union {
      T t;
      uint16_t i;
    } u = {t};
    u.i = __builtin_bswap16(u.i);
    return u.t;
  } else if (sizeof(T) == 4) {
    union {
      T t;
      uint32_t i;
    } u = {t};
    u.i = __builtin_bswap32(u.i);
    return u.t;
  } else if (sizeof(T) == 8) {
    union {
      T t;
      uint64_t i;
    } u = {t};
    u.i = __builtin_bswap64(u.i);
    return u.t;
  } else {
    (static_cast<bool>(0) ? void(0) :
			    __assert_fail(
			      "0", __builtin_FILE(), __builtin_LINE(),
			      __extension__ __PRETTY_FUNCTION__
			    ));
    return t;
  }
}

template <typename T> T EndianScalar(T t) { return t; }

template <typename T>

__attribute__((no_sanitize_undefined)) T ReadScalar(const void *p) {
  return EndianScalar(*reinterpret_cast<const T *>(p));
}

template <typename T>

__attribute__((no_sanitize_undefined)) void WriteScalar(void *p, T t) {
  *reinterpret_cast<T *>(p) = EndianScalar(t);
}

template <typename T> struct Offset;
template <typename T>
__attribute__((no_sanitize_undefined)) void WriteScalar(void *p, Offset<T> t) {
  *reinterpret_cast<uoffset_t *>(p) = EndianScalar(t.o);
}

__attribute__((no_sanitize_undefined)) inline size_t
PaddingBytes(size_t buf_size, size_t scalar_size) {
  return ((~buf_size) + 1) & (scalar_size - 1);
}

template <typename T> inline bool IsTheSameAs(T e, T def) { return e == def; }

template <typename T>
inline bool IsOutRange(const T &v, const T &low, const T &high) {
  return (v < low) || (high < v);
}

template <typename T>
inline bool IsInRange(const T &v, const T &low, const T &high) {
  return !IsOutRange(v, low, high);
}

} // namespace flatbuffers

namespace flatbuffers {

template <typename T> using numeric_limits = std::numeric_limits<T>;

template <typename T> using is_scalar = std::is_scalar<T>;
template <typename T, typename U> using is_same = std::is_same<T, U>;
template <typename T> using is_floating_point = std::is_floating_point<T>;
template <typename T> using is_unsigned = std::is_unsigned<T>;
template <typename T> using is_enum = std::is_enum<T>;
template <typename T> using make_unsigned = std::make_unsigned<T>;
template <bool B, class T, class F>
using conditional = std::conditional<B, T, F>;
template <class T, T v> using integral_constant = std::integral_constant<T, v>;
template <bool B> using bool_constant = integral_constant<bool, B>;
using true_type = std::true_type;
using false_type = std::false_type;

template <class T> using unique_ptr = std::unique_ptr<T>;

template <class T> using Optional = std::optional<T>;
using nullopt_t = std::nullopt_t;
inline constexpr nullopt_t nullopt = std::nullopt;

inline constexpr std::size_t dynamic_extent = std::dynamic_extent;
template <class T, std::size_t Extent = std::dynamic_extent>
using span = std::span<T, Extent>;

template <class ElementType, std::size_t Extent>
constexpr flatbuffers::span<ElementType, Extent>
make_span(ElementType (&arr)[Extent]) noexcept {
  return span<ElementType, Extent>(arr);
}

template <class ElementType, std::size_t Extent>
constexpr flatbuffers::span<const ElementType, Extent>
make_span(const ElementType (&arr)[Extent]) noexcept {
  return span<const ElementType, Extent>(arr);
}

template <class ElementType, std::size_t Extent>
constexpr flatbuffers::span<ElementType, Extent>
make_span(std::array<ElementType, Extent> &arr) noexcept {
  return span<ElementType, Extent>(arr);
}

template <class ElementType, std::size_t Extent>
constexpr flatbuffers::span<const ElementType, Extent>
make_span(const std::array<ElementType, Extent> &arr) noexcept {
  return span<const ElementType, Extent>(arr);
}

template <class ElementType, std::size_t Extent>
constexpr flatbuffers::span<ElementType, dynamic_extent>
make_span(ElementType *first, std::size_t count) noexcept {
  return span<ElementType, dynamic_extent>(first, count);
}

template <class ElementType, std::size_t Extent>
constexpr flatbuffers::span<const ElementType, dynamic_extent>
make_span(const ElementType *first, std::size_t count) noexcept {
  return span<const ElementType, dynamic_extent>(first, count);
}

} // namespace flatbuffers

namespace flatbuffers {

template <typename T = void> struct Offset {
  typedef uoffset_t offset_type;

  offset_type o;
  Offset() : o(0) { }
  Offset(const offset_type _o) : o(_o) { }
  Offset<> Union() const { return o; }
  bool IsNull() const { return !o; }
};

template <typename T = void> struct Offset64 {
  typedef uoffset64_t offset_type;

  offset_type o;
  Offset64() : o(0) { }
  Offset64(const offset_type offset) : o(offset) { }
  Offset64<> Union() const { return o; }
  bool IsNull() const { return !o; }
};

static_assert(sizeof(Offset<>) == 4, "Offset has wrong size");
static_assert(sizeof(Offset64<>) == 8, "Offset64 has wrong size");

inline void EndianCheck() {
  int endiantest = 1;

  (static_cast<bool>(*reinterpret_cast<char *>(&endiantest) == 1) ?
     void(0) :
     __assert_fail(
       "*reinterpret_cast<char *>(&endiantest) == FLATBUFFERS_LITTLEENDIAN",
       __builtin_FILE(), __builtin_LINE(), __extension__ __PRETTY_FUNCTION__
     ));
  (void)endiantest;
}

template <typename T> constexpr size_t AlignOf() { return __alignof__(T); }

inline static bool StringLessThan(
  const char *a_data, uoffset_t a_size, const char *b_data, uoffset_t b_size
) {
  const auto cmp = memcmp(a_data, b_data, (std::min)(a_size, b_size));
  return cmp == 0 ? a_size < b_size : cmp < 0;
}

template <typename T> struct IndirectHelper {
  typedef T return_type;
  typedef T mutable_return_type;
  static const size_t element_stride = sizeof(T);

  static return_type Read(const uint8_t *p, const size_t i) {
    return EndianScalar((reinterpret_cast<const T *>(p))[i]);
  }
  static mutable_return_type Read(uint8_t *p, const size_t i) {
    return reinterpret_cast<mutable_return_type>(
      Read(const_cast<const uint8_t *>(p), i)
    );
  }
};

template <typename T, template <typename> class OffsetT>
struct IndirectHelper<OffsetT<T>> {
  typedef const T *return_type;
  typedef T *mutable_return_type;
  typedef typename OffsetT<T>::offset_type offset_type;
  static const offset_type element_stride = sizeof(offset_type);

  static return_type Read(const uint8_t *const p, const offset_type i) {
    const uint8_t *const offset_location = p + i * element_stride;

    return reinterpret_cast<return_type>(
      offset_location + ReadScalar<offset_type>(offset_location)
    );
  }
  static mutable_return_type Read(uint8_t *const p, const offset_type i) {
    uint8_t *const offset_location = p + i * element_stride;

    return reinterpret_cast<mutable_return_type>(
      offset_location + ReadScalar<offset_type>(offset_location)
    );
  }
};

template <typename T> struct IndirectHelper<const T *> {
  typedef const T *return_type;
  typedef T *mutable_return_type;
  static const size_t element_stride = sizeof(T);

  static return_type Read(const uint8_t *const p, const size_t i) {
    return reinterpret_cast<return_type>(p + i * element_stride);
  }
  static mutable_return_type Read(uint8_t *const p, const size_t i) {
    return reinterpret_cast<mutable_return_type>(p + i * element_stride);
  }
};

inline const char *
GetBufferIdentifier(const void *buf, bool size_prefixed = false) {
  return reinterpret_cast<const char *>(buf) +
    ((size_prefixed) ? 2 * sizeof(uoffset_t) : sizeof(uoffset_t));
}

inline bool BufferHasIdentifier(
  const void *buf, const char *identifier, bool size_prefixed = false
) {
  return strncmp(
	   GetBufferIdentifier(buf, size_prefixed), identifier,
	   flatbuffers::kFileIdentifierLength
	 ) == 0;
}

template <typename T> T *GetMutableRoot(void *buf) {
  if (!buf) return nullptr;
  EndianCheck();
  return reinterpret_cast<T *>(
    reinterpret_cast<uint8_t *>(buf) +
    EndianScalar(*reinterpret_cast<uoffset_t *>(buf))
  );
}

template <typename T, typename SizeT = uoffset_t>
T *GetMutableSizePrefixedRoot(void *buf) {
  return GetMutableRoot<T>(reinterpret_cast<uint8_t *>(buf) + sizeof(SizeT));
}

template <typename T> const T *GetRoot(const void *buf) {
  return GetMutableRoot<T>(const_cast<void *>(buf));
}

template <typename T, typename SizeT = uoffset_t>
const T *GetSizePrefixedRoot(const void *buf) {
  return GetRoot<T>(reinterpret_cast<const uint8_t *>(buf) + sizeof(SizeT));
}

} // namespace flatbuffers

namespace flatbuffers {

struct String;

template <
  typename T, typename IT, typename Data = uint8_t *,
  typename SizeT = uoffset_t>
struct VectorIterator {
  typedef std::random_access_iterator_tag iterator_category;
  typedef IT value_type;
  typedef ptrdiff_t difference_type;
  typedef IT *pointer;
  typedef IT &reference;

  static const SizeT element_stride = IndirectHelper<T>::element_stride;

  VectorIterator(Data data, SizeT i) : data_(data + element_stride * i) { }
  VectorIterator(const VectorIterator &other) : data_(other.data_) { }
  VectorIterator() : data_(nullptr) { }

  VectorIterator &operator=(const VectorIterator &other) {
    data_ = other.data_;
    return *this;
  }

  VectorIterator &operator=(VectorIterator &&other) {
    data_ = other.data_;
    return *this;
  }

  bool operator==(const VectorIterator &other) const {
    return data_ == other.data_;
  }

  bool operator<(const VectorIterator &other) const {
    return data_ < other.data_;
  }

  bool operator!=(const VectorIterator &other) const {
    return data_ != other.data_;
  }

  difference_type operator-(const VectorIterator &other) const {
    return (data_ - other.data_) / element_stride;
  }

  IT operator*() const { return IndirectHelper<T>::Read(data_, 0); }

  IT operator->() const { return IndirectHelper<T>::Read(data_, 0); }

  VectorIterator &operator++() {
    data_ += element_stride;
    return *this;
  }

  VectorIterator operator++(int) {
    VectorIterator temp(data_, 0);
    data_ += element_stride;
    return temp;
  }

  VectorIterator operator+(const SizeT &offset) const {
    return VectorIterator(data_ + offset * element_stride, 0);
  }

  VectorIterator &operator+=(const SizeT &offset) {
    data_ += offset * element_stride;
    return *this;
  }

  VectorIterator &operator--() {
    data_ -= element_stride;
    return *this;
  }

  VectorIterator operator--(int) {
    VectorIterator temp(data_, 0);
    data_ -= element_stride;
    return temp;
  }

  VectorIterator operator-(const SizeT &offset) const {
    return VectorIterator(data_ - offset * element_stride, 0);
  }

  VectorIterator &operator-=(const SizeT &offset) {
    data_ -= offset * element_stride;
    return *this;
  }

private:
  Data data_;
};

template <typename T, typename IT, typename SizeT = uoffset_t>
using VectorConstIterator = VectorIterator<T, IT, const uint8_t *, SizeT>;

template <typename Iterator>
struct VectorReverseIterator : public std::reverse_iterator<Iterator> {
  explicit VectorReverseIterator(Iterator iter) :
    std::reverse_iterator<Iterator>(iter) { }

  typename Iterator::value_type operator*() const {
    auto tmp = std::reverse_iterator<Iterator>::current;
    return *--tmp;
  }

  typename Iterator::value_type operator->() const {
    auto tmp = std::reverse_iterator<Iterator>::current;
    return *--tmp;
  }
};

template <typename T, typename SizeT = uoffset_t> class Vector {
public:
  typedef VectorIterator<
    T, typename IndirectHelper<T>::mutable_return_type, uint8_t *, SizeT>
    iterator;
  typedef VectorConstIterator<T, typename IndirectHelper<T>::return_type, SizeT>
    const_iterator;
  typedef VectorReverseIterator<iterator> reverse_iterator;
  typedef VectorReverseIterator<const_iterator> const_reverse_iterator;

  typedef typename flatbuffers::bool_constant<flatbuffers::is_scalar<T>::value>
    scalar_tag;

  static constexpr bool is_span_observable =
    scalar_tag::value && (1 || sizeof(T) == 1);

  SizeT size() const { return EndianScalar(length_); }

  [[deprecated("use size() instead")]]
  SizeT Length() const {
    return size();
  }

  typedef SizeT size_type;
  typedef typename IndirectHelper<T>::return_type return_type;
  typedef typename IndirectHelper<T>::mutable_return_type mutable_return_type;
  typedef return_type value_type;

  return_type Get(SizeT i) const {
    (static_cast<bool>(i < size()) ?
       void(0) :
       __assert_fail(
	 "i < size()", __builtin_FILE(), __builtin_LINE(),
	 __extension__ __PRETTY_FUNCTION__
       ));
    return IndirectHelper<T>::Read(Data(), i);
  }

  return_type operator[](SizeT i) const { return Get(i); }

  template <typename E> E GetEnum(SizeT i) const {
    return static_cast<E>(Get(i));
  }

  template <typename U> const U *GetAs(SizeT i) const {
    return reinterpret_cast<const U *>(Get(i));
  }

  const String *GetAsString(SizeT i) const {
    return reinterpret_cast<const String *>(Get(i));
  }

  const void *GetStructFromOffset(size_t o) const {
    return reinterpret_cast<const void *>(Data() + o);
  }

  iterator begin() { return iterator(Data(), 0); }
  const_iterator begin() const { return const_iterator(Data(), 0); }

  iterator end() { return iterator(Data(), size()); }
  const_iterator end() const { return const_iterator(Data(), size()); }

  reverse_iterator rbegin() { return reverse_iterator(end()); }
  const_reverse_iterator rbegin() const {
    return const_reverse_iterator(end());
  }

  reverse_iterator rend() { return reverse_iterator(begin()); }
  const_reverse_iterator rend() const {
    return const_reverse_iterator(begin());
  }

  const_iterator cbegin() const { return begin(); }

  const_iterator cend() const { return end(); }

  const_reverse_iterator crbegin() const { return rbegin(); }

  const_reverse_iterator crend() const { return rend(); }

  void Mutate(SizeT i, const T &val) {
    (static_cast<bool>(i < size()) ?
       void(0) :
       __assert_fail(
	 "i < size()", __builtin_FILE(), __builtin_LINE(),
	 __extension__ __PRETTY_FUNCTION__
       ));
    WriteScalar(data() + i, val);
  }

  void MutateOffset(SizeT i, const uint8_t *val) {
    (static_cast<bool>(i < size()) ?
       void(0) :
       __assert_fail(
	 "i < size()", __builtin_FILE(), __builtin_LINE(),
	 __extension__ __PRETTY_FUNCTION__
       ));
    static_assert(sizeof(T) == sizeof(SizeT), "Unrelated types");
    WriteScalar(
      data() + i, static_cast<SizeT>(val - (Data() + i * sizeof(SizeT)))
    );
  }

  mutable_return_type GetMutableObject(SizeT i) const {
    (static_cast<bool>(i < size()) ?
       void(0) :
       __assert_fail(
	 "i < size()", __builtin_FILE(), __builtin_LINE(),
	 __extension__ __PRETTY_FUNCTION__
       ));
    return const_cast<mutable_return_type>(IndirectHelper<T>::Read(Data(), i));
  }

  const uint8_t *Data() const {
    return reinterpret_cast<const uint8_t *>(&length_ + 1);
  }

  uint8_t *Data() { return reinterpret_cast<uint8_t *>(&length_ + 1); }

  const T *data() const { return reinterpret_cast<const T *>(Data()); }
  T *data() { return reinterpret_cast<T *>(Data()); }

  template <typename K> return_type LookupByKey(K key) const {
    void *search_result = std::
      bsearch(&key, Data(), size(), IndirectHelper<T>::element_stride, KeyCompare<K>);

    if (!search_result) { return nullptr; }

    const uint8_t *element = reinterpret_cast<const uint8_t *>(search_result);

    return IndirectHelper<T>::Read(element, 0);
  }

  template <typename K> mutable_return_type MutableLookupByKey(K key) {
    return const_cast<mutable_return_type>(LookupByKey(key));
  }

protected:
  Vector();

  SizeT length_;

private:
  Vector(const Vector &);
  Vector &operator=(const Vector &);

  template <typename K> static int KeyCompare(const void *ap, const void *bp) {
    const K *key = reinterpret_cast<const K *>(ap);
    const uint8_t *data = reinterpret_cast<const uint8_t *>(bp);
    auto table = IndirectHelper<T>::Read(data, 0);

    return -table->KeyCompareWithValue(*key);
  }
};

template <typename T> using Vector64 = Vector<T, uoffset64_t>;

template <class U>
constexpr flatbuffers::span<U> make_span(Vector<U> &vec) noexcept {
  static_assert(
    Vector<U>::is_span_observable,
    "wrong type U, only LE-scalar, or byte types are allowed"
  );
  return span<U>(vec.data(), vec.size());
}

template <class U>
constexpr flatbuffers::span<const U> make_span(const Vector<U> &vec) noexcept {
  static_assert(
    Vector<U>::is_span_observable,
    "wrong type U, only LE-scalar, or byte types are allowed"
  );
  return span<const U>(vec.data(), vec.size());
}

template <class U>
constexpr flatbuffers::span<uint8_t> make_bytes_span(Vector<U> &vec) noexcept {
  static_assert(
    Vector<U>::scalar_tag::value,
    "wrong type U, only LE-scalar, or byte types are allowed"
  );
  return span<uint8_t>(vec.Data(), vec.size() * sizeof(U));
}

template <class U>
constexpr flatbuffers::span<const uint8_t>
make_bytes_span(const Vector<U> &vec) noexcept {
  static_assert(
    Vector<U>::scalar_tag::value,
    "wrong type U, only LE-scalar, or byte types are allowed"
  );
  return span<const uint8_t>(vec.Data(), vec.size() * sizeof(U));
}

template <class U>
constexpr flatbuffers::span<U> make_span(Vector<U> *ptr) noexcept {
  static_assert(
    Vector<U>::is_span_observable,
    "wrong type U, only LE-scalar, or byte types are allowed"
  );
  return ptr ? make_span(*ptr) : span<U>();
}

template <class U>
constexpr flatbuffers::span<const U> make_span(const Vector<U> *ptr) noexcept {
  static_assert(
    Vector<U>::is_span_observable,
    "wrong type U, only LE-scalar, or byte types are allowed"
  );
  return ptr ? make_span(*ptr) : span<const U>();
}

class VectorOfAny {
public:
  uoffset_t size() const { return EndianScalar(length_); }

  const uint8_t *Data() const {
    return reinterpret_cast<const uint8_t *>(&length_ + 1);
  }
  uint8_t *Data() { return reinterpret_cast<uint8_t *>(&length_ + 1); }

protected:
  VectorOfAny();

  uoffset_t length_;

private:
  VectorOfAny(const VectorOfAny &);
  VectorOfAny &operator=(const VectorOfAny &);
};

template <typename T, typename U>
Vector<Offset<T>> *VectorCast(Vector<Offset<U>> *ptr) {
  static_assert(std::is_base_of<T, U>::value, "Unrelated types");
  return reinterpret_cast<Vector<Offset<T>> *>(ptr);
}

template <typename T, typename U>
const Vector<Offset<T>> *VectorCast(const Vector<Offset<U>> *ptr) {
  static_assert(std::is_base_of<T, U>::value, "Unrelated types");
  return reinterpret_cast<const Vector<Offset<T>> *>(ptr);
}

template <typename T> inline static size_t VectorLength(const Vector<T> *v) {
  return v ? v->size() : 0;
}

} // namespace flatbuffers

namespace flatbuffers {

template <typename T, uint16_t length> class Array {
  typedef typename flatbuffers::bool_constant<flatbuffers::is_scalar<T>::value>
    scalar_tag;
  typedef
    typename flatbuffers::conditional<scalar_tag::value, T, const T *>::type
      IndirectHelperType;

public:
  typedef uint16_t size_type;
  typedef typename IndirectHelper<IndirectHelperType>::return_type return_type;
  typedef VectorConstIterator<T, return_type, uoffset_t> const_iterator;
  typedef VectorReverseIterator<const_iterator> const_reverse_iterator;

  static constexpr bool is_span_observable =
    (scalar_tag::value && (1 || sizeof(T) == 1)) || !scalar_tag::value;

  constexpr uint16_t size() const { return length; }

  return_type Get(uoffset_t i) const {
    (static_cast<bool>(i < size()) ?
       void(0) :
       __assert_fail(
	 "i < size()", __builtin_FILE(), __builtin_LINE(),
	 __extension__ __PRETTY_FUNCTION__
       ));
    return IndirectHelper<IndirectHelperType>::Read(Data(), i);
  }

  return_type operator[](uoffset_t i) const { return Get(i); }

  template <typename E> E GetEnum(uoffset_t i) const {
    return static_cast<E>(Get(i));
  }

  const_iterator begin() const { return const_iterator(Data(), 0); }
  const_iterator end() const { return const_iterator(Data(), size()); }

  const_reverse_iterator rbegin() const {
    return const_reverse_iterator(end());
  }
  const_reverse_iterator rend() const {
    return const_reverse_iterator(begin());
  }

  const_iterator cbegin() const { return begin(); }
  const_iterator cend() const { return end(); }

  const_reverse_iterator crbegin() const { return rbegin(); }
  const_reverse_iterator crend() const { return rend(); }

  typename flatbuffers::conditional<scalar_tag::value, void, T *>::type
  GetMutablePointer(uoffset_t i) const {
    (static_cast<bool>(i < size()) ?
       void(0) :
       __assert_fail(
	 "i < size()", __builtin_FILE(), __builtin_LINE(),
	 __extension__ __PRETTY_FUNCTION__
       ));
    return const_cast<T *>(&data()[i]);
  }

  void Mutate(uoffset_t i, const T &val) { MutateImpl(scalar_tag(), i, val); }

  const uint8_t *Data() const { return data_; }

  uint8_t *Data() { return data_; }

  const T *data() const { return reinterpret_cast<const T *>(Data()); }
  T *data() { return reinterpret_cast<T *>(Data()); }

  void CopyFromSpan(flatbuffers::span<const T, length> src) {
    const auto p1 = reinterpret_cast<const uint8_t *>(src.data());
    const auto p2 = Data();
    (static_cast<bool>(
       !(p1 >= p2 && p1 < (p2 + length)) && !(p2 >= p1 && p2 < (p1 + length))
     ) ?
       void(0) :
       __assert_fail(
	 "!(p1 >= p2 && p1 < (p2 + length)) && !(p2 >= p1 && p2 < (p1 + "
	 "length))",
	 __builtin_FILE(), __builtin_LINE(), __extension__ __PRETTY_FUNCTION__
       ));
    (void)p1;
    (void)p2;
    CopyFromSpanImpl(flatbuffers::bool_constant<is_span_observable>(), src);
  }

protected:
  void MutateImpl(flatbuffers::true_type, uoffset_t i, const T &val) {
    (static_cast<bool>(i < size()) ?
       void(0) :
       __assert_fail(
	 "i < size()", __builtin_FILE(), __builtin_LINE(),
	 __extension__ __PRETTY_FUNCTION__
       ));
    WriteScalar(data() + i, val);
  }

  void MutateImpl(flatbuffers::false_type, uoffset_t i, const T &val) {
    *(GetMutablePointer(i)) = val;
  }

  void CopyFromSpanImpl(
    flatbuffers::true_type, flatbuffers::span<const T, length> src
  ) {
    std::memcpy(data(), src.data(), length * sizeof(T));
  }

  void CopyFromSpanImpl(
    flatbuffers::false_type, flatbuffers::span<const T, length> src
  ) {
    for (size_type k = 0; k < length; k++) { Mutate(k, src[k]); }
  }

  constexpr Array();

  uint8_t data_[length * sizeof(T)];

private:
  Array(const Array &);
  Array &operator=(const Array &);
};

template <typename T, uint16_t length, template <typename> class OffsetT>
class Array<OffsetT<T>, length> {
  static_assert(flatbuffers::is_same<T, void>::value, "unexpected type T");

public:
  typedef const void *return_type;
  typedef uint16_t size_type;

  const uint8_t *Data() const { return data_; }

  return_type operator[](uoffset_t) const {
    (static_cast<bool>(false) ? void(0) :
				__assert_fail(
				  "false", __builtin_FILE(), __builtin_LINE(),
				  __extension__ __PRETTY_FUNCTION__
				));
    return nullptr;
  }

private:
  Array();
  Array(const Array &);
  Array &operator=(const Array &);

  uint8_t data_[1];
};

template <class U, uint16_t N>
constexpr flatbuffers::span<U, N> make_span(Array<U, N> &arr) noexcept {
  static_assert(
    Array<U, N>::is_span_observable,
    "wrong type U, only plain struct, LE-scalar, or byte types are allowed"
  );
  return span<U, N>(arr.data(), N);
}

template <class U, uint16_t N>
constexpr flatbuffers::span<const U, N>
make_span(const Array<U, N> &arr) noexcept {
  static_assert(
    Array<U, N>::is_span_observable,
    "wrong type U, only plain struct, LE-scalar, or byte types are allowed"
  );
  return span<const U, N>(arr.data(), N);
}

template <class U, uint16_t N>
constexpr flatbuffers::span<uint8_t, sizeof(U) * N>
make_bytes_span(Array<U, N> &arr) noexcept {
  static_assert(
    Array<U, N>::is_span_observable,
    "internal error, Array<T> might hold only scalars or structs"
  );
  return span<uint8_t, sizeof(U) * N>(arr.Data(), sizeof(U) * N);
}

template <class U, uint16_t N>
constexpr flatbuffers::span<const uint8_t, sizeof(U) * N>
make_bytes_span(const Array<U, N> &arr) noexcept {
  static_assert(
    Array<U, N>::is_span_observable,
    "internal error, Array<T> might hold only scalars or structs"
  );
  return span<const uint8_t, sizeof(U) * N>(arr.Data(), sizeof(U) * N);
}

template <typename T, uint16_t length>
Array<T, length> &CastToArray(T (&arr)[length]) {
  return *reinterpret_cast<Array<T, length> *>(arr);
}

template <typename T, uint16_t length>
const Array<T, length> &CastToArray(const T (&arr)[length]) {
  return *reinterpret_cast<const Array<T, length> *>(arr);
}

template <typename E, typename T, uint16_t length>
Array<E, length> &CastToArrayOfEnum(T (&arr)[length]) {
  static_assert(sizeof(E) == sizeof(T), "invalid enum type E");
  return *reinterpret_cast<Array<E, length> *>(arr);
}

template <typename E, typename T, uint16_t length>
const Array<E, length> &CastToArrayOfEnum(const T (&arr)[length]) {
  static_assert(sizeof(E) == sizeof(T), "invalid enum type E");
  return *reinterpret_cast<const Array<E, length> *>(arr);
}

template <typename T, uint16_t length>
bool operator==(
  const Array<T, length> &lhs, const Array<T, length> &rhs
) noexcept {
  return std::addressof(lhs) == std::addressof(rhs) ||
    (lhs.size() == rhs.size() &&
     std::memcmp(lhs.Data(), rhs.Data(), rhs.size() * sizeof(T)) == 0);
}

} // namespace flatbuffers

namespace flatbuffers {

class Verifier final {
public:
  struct Options {
    uoffset_t max_depth = 64;

    uoffset_t max_tables = 1000000;

    bool check_alignment = true;

    bool check_nested_flatbuffers = true;

    size_t max_size = std::numeric_limits<::flatbuffers::soffset_t>::max();

    bool assert = false;
  };

  explicit Verifier(
    const uint8_t *const buf, const size_t buf_len, const Options &opts
  ) : buf_(buf), size_(buf_len), opts_(opts) {
    (static_cast<bool>(size_ < opts.max_size) ?
       void(0) :
       __assert_fail(
	 "size_ < opts.max_size", __builtin_FILE(), __builtin_LINE(),
	 __extension__ __PRETTY_FUNCTION__
       ));
  }

  Verifier(
    const uint8_t *const buf, const size_t buf_len,
    const uoffset_t max_depth = 64, const uoffset_t max_tables = 1000000,
    const bool check_alignment = true
  ) :
    Verifier(buf, buf_len, [&] {
      Options opts;
      opts.max_depth = max_depth;
      opts.max_tables = max_tables;
      opts.check_alignment = check_alignment;
      return opts;
    }()) { }

  bool Check(const bool ok) const { return ok; }

  bool Verify(const size_t elem, const size_t elem_len) const {
    return Check(elem_len < size_ && elem <= size_ - elem_len);
  }

  bool VerifyAlignment(const size_t elem, const size_t align) const {
    return Check((elem & (align - 1)) == 0 || !opts_.check_alignment);
  }

  template <typename T> bool Verify(const size_t elem) const {
    return VerifyAlignment(elem, sizeof(T)) && Verify(elem, sizeof(T));
  }

  bool VerifyFromPointer(const uint8_t *const p, const size_t len) {
    return Verify(static_cast<size_t>(p - buf_), len);
  }

  bool VerifyFieldStruct(
    const uint8_t *const base, const voffset_t elem_off, const size_t elem_len,
    const size_t align
  ) const {
    const auto f = static_cast<size_t>(base - buf_) + elem_off;
    return VerifyAlignment(f, align) && Verify(f, elem_len);
  }

  template <typename T>
  bool VerifyField(
    const uint8_t *const base, const voffset_t elem_off, const size_t align
  ) const {
    const auto f = static_cast<size_t>(base - buf_) + elem_off;
    return VerifyAlignment(f, align) && Verify(f, sizeof(T));
  }

  template <typename T> bool VerifyTable(const T *const table) {
    return !table || table->Verify(*this);
  }

  template <int &..., typename T, typename LenT>
  bool VerifyVector(const Vector<T, LenT> *const vec) const {
    return !vec ||
      VerifyVectorOrString<LenT>(
	reinterpret_cast<const uint8_t *>(vec), sizeof(T)
      );
  }

  template <int &..., typename T, typename LenT>
  bool VerifyVector(const Vector<const T *, LenT> *const vec) const {
    return VerifyVector(reinterpret_cast<const Vector<T, LenT> *>(vec));
  }

  bool VerifyString(const String *const str) const {
    size_t end;
    return !str ||
      (VerifyVectorOrString<uoffset_t>(
	 reinterpret_cast<const uint8_t *>(str), 1, &end
       ) &&
       Verify(end, 1) && Check(buf_[end] == '\0'));
  }

  template <typename LenT = uoffset_t>
  bool VerifyVectorOrString(
    const uint8_t *const vec, const size_t elem_size,
    size_t *const end = nullptr
  ) const {
    const auto vec_offset = static_cast<size_t>(vec - buf_);

    if (!Verify<LenT>(vec_offset)) return false;

    const LenT size = ReadScalar<LenT>(vec);
    const auto max_elems = opts_.max_size / elem_size;
    if (!Check(size < max_elems)) return false;
    const auto byte_size = sizeof(LenT) + elem_size * size;
    if (end) *end = vec_offset + byte_size;
    return Verify(vec_offset, byte_size);
  }

  bool VerifyVectorOfStrings(const Vector<Offset<String>> *const vec) const {
    if (vec) {
      for (uoffset_t i = 0; i < vec->size(); i++) {
	if (!VerifyString(vec->Get(i))) return false;
      }
    }
    return true;
  }

  template <typename T>
  bool VerifyVectorOfTables(const Vector<Offset<T>> *const vec) {
    if (vec) {
      for (uoffset_t i = 0; i < vec->size(); i++) {
	if (!vec->Get(i)->Verify(*this)) return false;
      }
    }
    return true;
  }

  __attribute__((no_sanitize_undefined)) bool
  VerifyTableStart(const uint8_t *const table) {
    const auto tableo = static_cast<size_t>(table - buf_);
    if (!Verify<soffset_t>(tableo)) return false;

    const auto vtableo =
      tableo - static_cast<size_t>(ReadScalar<soffset_t>(table));

    if (!(VerifyComplexity() && Verify<voffset_t>(vtableo) &&
	  VerifyAlignment(
	    ReadScalar<voffset_t>(buf_ + vtableo), sizeof(voffset_t)
	  )))
      return false;
    const auto vsize = ReadScalar<voffset_t>(buf_ + vtableo);
    return Check((vsize & 1) == 0) && Verify(vtableo, vsize);
  }

  template <typename T>
  bool VerifyBufferFromStart(const char *const identifier, const size_t start) {
    if (!Check(
	  size_ >= sizeof(uoffset_t) + sizeof(soffset_t) + sizeof(uint16_t) +
	    sizeof(uint16_t)
	))
      return false;

    if (identifier &&
	!Check(
	  (size_ >= 2 * sizeof(flatbuffers::uoffset_t) &&
	   BufferHasIdentifier(buf_ + start, identifier))
	)) {
      return false;
    }

    const auto o = VerifyOffset<uoffset_t>(start);
    return Check(o != 0) &&
      reinterpret_cast<const T *>(buf_ + start + o)->Verify(*this);
  }

  template <typename T, int &..., typename SizeT>
  bool VerifyNestedFlatBuffer(
    const Vector<uint8_t, SizeT> *const buf, const char *const identifier
  ) {
    if (!opts_.check_nested_flatbuffers) return true;

    if (!buf) return true;

    if (!Check(
	  buf->size() >= sizeof(uoffset_t) + sizeof(soffset_t) +
	    sizeof(uint16_t) + sizeof(uint16_t)
	))
      return false;

    Verifier nested_verifier(buf->data(), buf->size(), opts_);
    return nested_verifier.VerifyBuffer<T>(identifier);
  }

  template <typename T> bool VerifyBuffer() { return VerifyBuffer<T>(nullptr); }

  template <typename T> bool VerifyBuffer(const char *const identifier) {
    return VerifyBufferFromStart<T>(identifier, 0);
  }

  template <typename T, typename SizeT = uoffset_t>
  bool VerifySizePrefixedBuffer(const char *const identifier) {
    return Verify<SizeT>(0U) &&

      Check(ReadScalar<SizeT>(buf_) + sizeof(SizeT) <= size_) &&
      VerifyBufferFromStart<T>(identifier, sizeof(SizeT));
  }

  template <typename OffsetT = uoffset_t, typename SOffsetT = soffset_t>
  size_t VerifyOffset(const size_t start) const {
    if (!Verify<OffsetT>(start)) return 0;
    const auto o = ReadScalar<OffsetT>(buf_ + start);

    if (!Check(o != 0)) return 0;

    if (!Check(static_cast<SOffsetT>(o) >= 0)) return 0;

    if (!Verify(start + o, 1)) return 0;
    return o;
  }

  template <typename OffsetT = uoffset_t>
  size_t VerifyOffset(const uint8_t *const base, const voffset_t start) const {
    return VerifyOffset<OffsetT>(static_cast<size_t>(base - buf_) + start);
  }

  bool VerifyComplexity() {
    depth_++;
    num_tables_++;
    return Check(depth_ <= opts_.max_depth && num_tables_ <= opts_.max_tables);
  }

  bool EndTable() {
    depth_--;
    return true;
  }

  size_t GetComputedSize() const {
    (void)upper_bound_;
    (static_cast<bool>(false) ? void(0) :
				__assert_fail(
				  "false", __builtin_FILE(), __builtin_LINE(),
				  __extension__ __PRETTY_FUNCTION__
				));
    return 0;
  }

  std::vector<uint8_t> *GetFlexReuseTracker() { return flex_reuse_tracker_; }

  void SetFlexReuseTracker(std::vector<uint8_t> *const rt) {
    flex_reuse_tracker_ = rt;
  }

private:
  const uint8_t *buf_;
  const size_t size_;
  const Options opts_;

  mutable size_t upper_bound_ = 0;

  uoffset_t depth_ = 0;
  uoffset_t num_tables_ = 0;
  std::vector<uint8_t> *flex_reuse_tracker_ = nullptr;
};

template <>
inline size_t Verifier::VerifyOffset<uoffset64_t>(const size_t start) const {
  return VerifyOffset<uoffset64_t, soffset64_t>(start);
}

} // namespace flatbuffers

namespace flatbuffers {

struct BufferRefBase { };

template <typename T> struct BufferRef : BufferRefBase {
  BufferRef() : buf(nullptr), len(0), must_free(false) { }
  BufferRef(uint8_t *_buf, uoffset_t _len) :
    buf(_buf), len(_len), must_free(false) { }

  ~BufferRef() {
    if (must_free) free(buf);
  }

  const T *GetRoot() const { return flatbuffers::GetRoot<T>(buf); }

  bool Verify() {
    Verifier verifier(buf, len);
    return verifier.VerifyBuffer<T>(nullptr);
  }

  uint8_t *buf;
  uoffset_t len;
  bool must_free;
};

} // namespace flatbuffers

namespace flatbuffers {

class Allocator {
public:
  virtual ~Allocator() { }

  virtual uint8_t *allocate(size_t size) = 0;

  virtual void deallocate(uint8_t *p, size_t size) = 0;

  virtual uint8_t *reallocate_downward(
    uint8_t *old_p, size_t old_size, size_t new_size, size_t in_use_back,
    size_t in_use_front
  ) {
    (static_cast<bool>(new_size > old_size) ?
       void(0) :
       __assert_fail(
	 "new_size > old_size", __builtin_FILE(), __builtin_LINE(),
	 __extension__ __PRETTY_FUNCTION__
       ));
    uint8_t *new_p = allocate(new_size);
    memcpy_downward(
      old_p, old_size, new_p, new_size, in_use_back, in_use_front
    );
    deallocate(old_p, old_size);
    return new_p;
  }

protected:
  void memcpy_downward(
    uint8_t *old_p, size_t old_size, uint8_t *new_p, size_t new_size,
    size_t in_use_back, size_t in_use_front
  ) {
    memcpy(
      new_p + new_size - in_use_back, old_p + old_size - in_use_back,
      in_use_back
    );
    memcpy(new_p, old_p, in_use_front);
  }
};

} // namespace flatbuffers

namespace flatbuffers {

class DefaultAllocator : public Allocator {
public:
  uint8_t *allocate(size_t size) override { return new uint8_t[size]; }

  void deallocate(uint8_t *p, size_t) override { delete[] p; }

  static void dealloc(void *p, size_t) { delete[] static_cast<uint8_t *>(p); }
};

inline uint8_t *Allocate(Allocator *allocator, size_t size) {
  return allocator ? allocator->allocate(size) :
		     DefaultAllocator().allocate(size);
}

inline void Deallocate(Allocator *allocator, uint8_t *p, size_t size) {
  if (allocator)
    allocator->deallocate(p, size);
  else
    DefaultAllocator().deallocate(p, size);
}

inline uint8_t *ReallocateDownward(
  Allocator *allocator, uint8_t *old_p, size_t old_size, size_t new_size,
  size_t in_use_back, size_t in_use_front
) {
  return allocator ? allocator->reallocate_downward(
		       old_p, old_size, new_size, in_use_back, in_use_front
		     ) :
		     DefaultAllocator().reallocate_downward(
		       old_p, old_size, new_size, in_use_back, in_use_front
		     );
}

} // namespace flatbuffers

namespace flatbuffers {

class DetachedBuffer {
public:
  DetachedBuffer() :
    allocator_(nullptr), own_allocator_(false), buf_(nullptr), reserved_(0),
    cur_(nullptr), size_(0) { }

  DetachedBuffer(
    Allocator *allocator, bool own_allocator, uint8_t *buf, size_t reserved,
    uint8_t *cur, size_t sz
  ) :
    allocator_(allocator), own_allocator_(own_allocator), buf_(buf),
    reserved_(reserved), cur_(cur), size_(sz) { }

  DetachedBuffer(DetachedBuffer &&other) noexcept :
    allocator_(other.allocator_), own_allocator_(other.own_allocator_),
    buf_(other.buf_), reserved_(other.reserved_), cur_(other.cur_),
    size_(other.size_) {
    other.reset();
  }

  DetachedBuffer &operator=(DetachedBuffer &&other) noexcept {
    if (this == &other) return *this;

    destroy();

    allocator_ = other.allocator_;
    own_allocator_ = other.own_allocator_;
    buf_ = other.buf_;
    reserved_ = other.reserved_;
    cur_ = other.cur_;
    size_ = other.size_;

    other.reset();

    return *this;
  }

  ~DetachedBuffer() { destroy(); }

  const uint8_t *data() const { return cur_; }

  uint8_t *data() { return cur_; }

  size_t size() const { return size_; }

  DetachedBuffer(const DetachedBuffer &other) = delete;
  DetachedBuffer &operator=(const DetachedBuffer &other) = delete;

protected:
  Allocator *allocator_;
  bool own_allocator_;
  uint8_t *buf_;
  size_t reserved_;
  uint8_t *cur_;
  size_t size_;

  inline void destroy() {
    if (buf_) Deallocate(allocator_, buf_, reserved_);
    if (own_allocator_ && allocator_) { delete allocator_; }
    reset();
  }

  inline void reset() {
    allocator_ = nullptr;
    own_allocator_ = false;
    buf_ = nullptr;
    reserved_ = 0;
    cur_ = nullptr;
    size_ = 0;
  }
};

} // namespace flatbuffers

namespace flatbuffers {

struct String : public Vector<char> {
  const char *c_str() const { return reinterpret_cast<const char *>(Data()); }
  std::string str() const { return std::string(c_str(), size()); }

  flatbuffers::string_view string_view() const {
    return flatbuffers::string_view(c_str(), size());
  }

  operator flatbuffers::string_view() const {
    return flatbuffers::string_view(c_str(), size());
  }

  bool operator<(const String &o) const {
    return StringLessThan(this->data(), this->size(), o.data(), o.size());
  }
};

inline static std::string GetString(const String *str) {
  return str ? str->str() : "";
}

inline static const char *GetCstring(const String *str) {
  return str ? str->c_str() : "";
}

inline static flatbuffers::string_view GetStringView(const String *str) {
  return str ? str->string_view() : flatbuffers::string_view();
}

} // namespace flatbuffers

namespace flatbuffers {

class Struct final {
public:
  template <typename T> T GetField(uoffset_t o) const {
    return ReadScalar<T>(&data_[o]);
  }

  template <typename T> T GetStruct(uoffset_t o) const {
    return reinterpret_cast<T>(&data_[o]);
  }

  const uint8_t *GetAddressOf(uoffset_t o) const { return &data_[o]; }
  uint8_t *GetAddressOf(uoffset_t o) { return &data_[o]; }

private:
  Struct();
  Struct(const Struct &);
  Struct &operator=(const Struct &);

  uint8_t data_[1];
};

} // namespace flatbuffers

namespace flatbuffers {

class Table {
public:
  const uint8_t *GetVTable() const {
    return data_ - ReadScalar<soffset_t>(data_);
  }

  voffset_t GetOptionalFieldOffset(voffset_t field) const {
    auto vtable = GetVTable();

    auto vtsize = ReadScalar<voffset_t>(vtable);

    return field < vtsize ? ReadScalar<voffset_t>(vtable + field) : 0;
  }

  template <typename T> T GetField(voffset_t field, T defaultval) const {
    auto field_offset = GetOptionalFieldOffset(field);
    return field_offset ? ReadScalar<T>(data_ + field_offset) : defaultval;
  }

  template <typename P, typename OffsetSize = uoffset_t>
  P GetPointer(voffset_t field) {
    auto field_offset = GetOptionalFieldOffset(field);
    auto p = data_ + field_offset;
    return field_offset ? reinterpret_cast<P>(p + ReadScalar<OffsetSize>(p)) :
			  nullptr;
  }
  template <typename P, typename OffsetSize = uoffset_t>
  P GetPointer(voffset_t field) const {
    return const_cast<Table *>(this)->GetPointer<P, OffsetSize>(field);
  }

  template <typename P> P GetPointer64(voffset_t field) {
    return GetPointer<P, uoffset64_t>(field);
  }

  template <typename P> P GetPointer64(voffset_t field) const {
    return GetPointer<P, uoffset64_t>(field);
  }

  template <typename P> P GetStruct(voffset_t field) const {
    auto field_offset = GetOptionalFieldOffset(field);
    auto p = const_cast<uint8_t *>(data_ + field_offset);
    return field_offset ? reinterpret_cast<P>(p) : nullptr;
  }

  template <typename Raw, typename Face>
  flatbuffers::Optional<Face> GetOptional(voffset_t field) const {
    auto field_offset = GetOptionalFieldOffset(field);
    auto p = data_ + field_offset;
    return field_offset ?
      Optional<Face>(static_cast<Face>(ReadScalar<Raw>(p))) :
      Optional<Face>();
  }

  template <typename T> bool SetField(voffset_t field, T val, T def) {
    auto field_offset = GetOptionalFieldOffset(field);
    if (!field_offset) return IsTheSameAs(val, def);
    WriteScalar(data_ + field_offset, val);
    return true;
  }
  template <typename T> bool SetField(voffset_t field, T val) {
    auto field_offset = GetOptionalFieldOffset(field);
    if (!field_offset) return false;
    WriteScalar(data_ + field_offset, val);
    return true;
  }

  bool SetPointer(voffset_t field, const uint8_t *val) {
    auto field_offset = GetOptionalFieldOffset(field);
    if (!field_offset) return false;
    WriteScalar(
      data_ + field_offset, static_cast<uoffset_t>(val - (data_ + field_offset))
    );
    return true;
  }

  uint8_t *GetAddressOf(voffset_t field) {
    auto field_offset = GetOptionalFieldOffset(field);
    return field_offset ? data_ + field_offset : nullptr;
  }
  const uint8_t *GetAddressOf(voffset_t field) const {
    return const_cast<Table *>(this)->GetAddressOf(field);
  }

  bool CheckField(voffset_t field) const {
    return GetOptionalFieldOffset(field) != 0;
  }

  bool VerifyTableStart(Verifier &verifier) const {
    return verifier.VerifyTableStart(data_);
  }

  template <typename T>
  bool
  VerifyField(const Verifier &verifier, voffset_t field, size_t align) const {
    auto field_offset = GetOptionalFieldOffset(field);

    return !field_offset || verifier.VerifyField<T>(data_, field_offset, align);
  }

  template <typename T>
  bool VerifyFieldRequired(
    const Verifier &verifier, voffset_t field, size_t align
  ) const {
    auto field_offset = GetOptionalFieldOffset(field);
    return verifier.Check(field_offset != 0) &&
      verifier.VerifyField<T>(data_, field_offset, align);
  }

  template <typename OffsetT = uoffset_t>
  bool VerifyOffset(const Verifier &verifier, voffset_t field) const {
    auto field_offset = GetOptionalFieldOffset(field);
    return !field_offset || verifier.VerifyOffset<OffsetT>(data_, field_offset);
  }

  template <typename OffsetT = uoffset_t>
  bool VerifyOffsetRequired(const Verifier &verifier, voffset_t field) const {
    auto field_offset = GetOptionalFieldOffset(field);
    return verifier.Check(field_offset != 0) &&
      verifier.VerifyOffset<OffsetT>(data_, field_offset);
  }

  bool VerifyOffset64(const Verifier &verifier, voffset_t field) const {
    return VerifyOffset<uoffset64_t>(verifier, field);
  }

  bool VerifyOffset64Required(const Verifier &verifier, voffset_t field) const {
    return VerifyOffsetRequired<uoffset64_t>(verifier, field);
  }

private:
  Table();
  Table(const Table &other);
  Table &operator=(const Table &);

  uint8_t data_[1];
};

template <>
inline flatbuffers::Optional<bool>
Table::GetOptional<uint8_t, bool>(voffset_t field) const {
  auto field_offset = GetOptionalFieldOffset(field);
  auto p = data_ + field_offset;
  return field_offset ? Optional<bool>(ReadScalar<uint8_t>(p) != 0) :
			Optional<bool>();
}

} // namespace flatbuffers

namespace flatbuffers {

template <typename SizeT = uoffset_t> class vector_downward {
public:
  explicit vector_downward(
    size_t initial_size, Allocator *allocator, bool own_allocator,
    size_t buffer_minalign,
    const SizeT max_size = std::numeric_limits<::flatbuffers::soffset_t>::max()
  ) :
    allocator_(allocator), own_allocator_(own_allocator),
    initial_size_(initial_size), max_size_(max_size),
    buffer_minalign_(buffer_minalign), reserved_(0), size_(0), buf_(nullptr),
    cur_(nullptr), scratch_(nullptr) { }

  vector_downward(vector_downward &&other) noexcept

    :
    allocator_(other.allocator_), own_allocator_(other.own_allocator_),
    initial_size_(other.initial_size_), max_size_(other.max_size_),
    buffer_minalign_(other.buffer_minalign_), reserved_(other.reserved_),
    size_(other.size_), buf_(other.buf_), cur_(other.cur_),
    scratch_(other.scratch_) {
    other.own_allocator_ = false;
    other.reserved_ = 0;
    other.buf_ = nullptr;
    other.cur_ = nullptr;
    other.scratch_ = nullptr;
  }

  vector_downward &operator=(vector_downward &&other) noexcept {
    vector_downward temp(std::move(other));
    swap(temp);
    return *this;
  }

  ~vector_downward() {
    clear_buffer();
    clear_allocator();
  }

  void reset() {
    clear_buffer();
    clear();
  }

  void clear() {
    if (buf_) {
      cur_ = buf_ + reserved_;
    } else {
      reserved_ = 0;
      cur_ = nullptr;
    }
    size_ = 0;
    clear_scratch();
  }

  void clear_scratch() { scratch_ = buf_; }

  void clear_allocator() {
    if (own_allocator_ && allocator_) { delete allocator_; }
    allocator_ = nullptr;
    own_allocator_ = false;
  }

  void clear_buffer() {
    if (buf_) Deallocate(allocator_, buf_, reserved_);
    buf_ = nullptr;
  }

  uint8_t *release_raw(size_t &allocated_bytes, size_t &offset) {
    auto *buf = buf_;
    allocated_bytes = reserved_;
    offset = vector_downward::offset();

    buf_ = nullptr;
    clear();
    return buf;
  }

  DetachedBuffer release() {
    DetachedBuffer fb(
      allocator_, own_allocator_, buf_, reserved_, cur_, size()
    );
    if (own_allocator_) {
      allocator_ = nullptr;
      own_allocator_ = false;
    }
    buf_ = nullptr;
    clear();
    return fb;
  }

  size_t ensure_space(size_t len) {
    (static_cast<bool>(cur_ >= scratch_ && scratch_ >= buf_) ?
       void(0) :
       __assert_fail(
	 "cur_ >= scratch_ && scratch_ >= buf_", __builtin_FILE(),
	 __builtin_LINE(), __extension__ __PRETTY_FUNCTION__
       ));

    if (len > unused_buffer_size()) { reallocate(len); }
    (static_cast<bool>(size() < max_size_) ?
       void(0) :
       __assert_fail(
	 "size() < max_size_", __builtin_FILE(), __builtin_LINE(),
	 __extension__ __PRETTY_FUNCTION__
       ));
    return len;
  }

  inline uint8_t *make_space(size_t len) {
    if (len) {
      ensure_space(len);
      cur_ -= len;
      size_ += static_cast<SizeT>(len);
    }
    return cur_;
  }

  Allocator *get_custom_allocator() { return allocator_; }

  size_t offset() const { return cur_ - buf_; }

  inline SizeT size() const { return size_; }

  SizeT unused_buffer_size() const {
    return static_cast<SizeT>(cur_ - scratch_);
  }

  SizeT scratch_size() const { return static_cast<SizeT>(scratch_ - buf_); }

  size_t capacity() const { return reserved_; }

  uint8_t *data() const {
    (static_cast<bool>(cur_) ? void(0) :
			       __assert_fail(
				 "cur_", __builtin_FILE(), __builtin_LINE(),
				 __extension__ __PRETTY_FUNCTION__
			       ));
    return cur_;
  }

  uint8_t *scratch_data() const {
    (static_cast<bool>(buf_) ? void(0) :
			       __assert_fail(
				 "buf_", __builtin_FILE(), __builtin_LINE(),
				 __extension__ __PRETTY_FUNCTION__
			       ));
    return buf_;
  }

  uint8_t *scratch_end() const {
    (static_cast<bool>(scratch_) ?
       void(0) :
       __assert_fail(
	 "scratch_", __builtin_FILE(), __builtin_LINE(),
	 __extension__ __PRETTY_FUNCTION__
       ));
    return scratch_;
  }

  uint8_t *data_at(size_t offset) const { return buf_ + reserved_ - offset; }

  void push(const uint8_t *bytes, size_t num) {
    if (num > 0) { memcpy(make_space(num), bytes, num); }
  }

  template <typename T> void push_small(const T &little_endian_t) {
    make_space(sizeof(T));
    *reinterpret_cast<T *>(cur_) = little_endian_t;
  }

  template <typename T> void scratch_push_small(const T &t) {
    ensure_space(sizeof(T));
    *reinterpret_cast<T *>(scratch_) = t;
    scratch_ += sizeof(T);
  }

  void fill(size_t zero_pad_bytes) {
    make_space(zero_pad_bytes);
    for (size_t i = 0; i < zero_pad_bytes; i++) cur_[i] = 0;
  }

  void fill_big(size_t zero_pad_bytes) {
    memset(make_space(zero_pad_bytes), 0, zero_pad_bytes);
  }

  void pop(size_t bytes_to_remove) {
    cur_ += bytes_to_remove;
    size_ -= static_cast<SizeT>(bytes_to_remove);
  }

  void scratch_pop(size_t bytes_to_remove) { scratch_ -= bytes_to_remove; }

  void swap(vector_downward &other) {
    using std::swap;
    swap(allocator_, other.allocator_);
    swap(own_allocator_, other.own_allocator_);
    swap(initial_size_, other.initial_size_);
    swap(buffer_minalign_, other.buffer_minalign_);
    swap(reserved_, other.reserved_);
    swap(size_, other.size_);
    swap(max_size_, other.max_size_);
    swap(buf_, other.buf_);
    swap(cur_, other.cur_);
    swap(scratch_, other.scratch_);
  }

  void swap_allocator(vector_downward &other) {
    using std::swap;
    swap(allocator_, other.allocator_);
    swap(own_allocator_, other.own_allocator_);
  }

private:
  vector_downward(const vector_downward &) = delete;
  vector_downward &operator=(const vector_downward &) = delete;

  Allocator *allocator_;
  bool own_allocator_;
  size_t initial_size_;

  SizeT max_size_;
  size_t buffer_minalign_;
  size_t reserved_;
  SizeT size_;
  uint8_t *buf_;
  uint8_t *cur_;
  uint8_t *scratch_;

  void reallocate(size_t len) {
    auto old_reserved = reserved_;
    auto old_size = size();
    auto old_scratch_size = scratch_size();
    reserved_ +=
      (std::max)(len, old_reserved ? old_reserved / 2 : initial_size_);
    reserved_ = (reserved_ + buffer_minalign_ - 1) & ~(buffer_minalign_ - 1);
    if (buf_) {
      buf_ = ReallocateDownward(
	allocator_, buf_, old_reserved, reserved_, old_size, old_scratch_size
      );
    } else {
      buf_ = Allocate(allocator_, reserved_);
    }
    cur_ = buf_ + reserved_ - old_size;
    scratch_ = buf_ + old_scratch_size;
  }
};

} // namespace flatbuffers

namespace flatbuffers {

inline voffset_t FieldIndexToOffset(voffset_t field_id) {
  const voffset_t fixed_fields = 2 * sizeof(voffset_t);
  size_t offset = fixed_fields + field_id * sizeof(voffset_t);
  (static_cast<bool>(offset < std::numeric_limits<voffset_t>::max()) ?
     void(0) :
     __assert_fail(
       "offset < std::numeric_limits<voffset_t>::max()", __builtin_FILE(),
       __builtin_LINE(), __extension__ __PRETTY_FUNCTION__
     ));
  return static_cast<voffset_t>(offset);
}

template <typename T, typename Alloc = std::allocator<T>>
const T *data(const std::vector<T, Alloc> &v) {
  static uint8_t t;
  return v.empty() ? reinterpret_cast<const T *>(&t) : &v.front();
}
template <typename T, typename Alloc = std::allocator<T>>
T *data(std::vector<T, Alloc> &v) {
  static uint8_t t;
  return v.empty() ? reinterpret_cast<T *>(&t) : &v.front();
}

template <bool Is64Aware = false> class FlatBufferBuilderImpl {
public:
  typedef
    typename std::conditional<Is64Aware, uoffset64_t, uoffset_t>::type SizeT;

  explicit FlatBufferBuilderImpl(
    size_t initial_size = 1024, Allocator *allocator = nullptr,
    bool own_allocator = false,
    size_t buffer_minalign = AlignOf<largest_scalar_t>()
  ) :
    buf_(
      initial_size, allocator, own_allocator, buffer_minalign,
      static_cast<SizeT>(
	Is64Aware ? std::numeric_limits<::flatbuffers::soffset64_t>::max() :
		    std::numeric_limits<::flatbuffers::soffset_t>::max()
      )
    ),
    num_field_loc(0), max_voffset_(0), length_of_64_bit_region_(0),
    nested(false), finished(false), minalign_(1), force_defaults_(false),
    dedup_vtables_(true), string_pool(nullptr) {
    EndianCheck();
  }

  FlatBufferBuilderImpl(FlatBufferBuilderImpl &&other) noexcept :
    buf_(
      1024, nullptr, false, AlignOf<largest_scalar_t>(),
      static_cast<SizeT>(
	Is64Aware ? std::numeric_limits<::flatbuffers::soffset64_t>::max() :
		    std::numeric_limits<::flatbuffers::soffset_t>::max()
      )
    ),
    num_field_loc(0), max_voffset_(0), length_of_64_bit_region_(0),
    nested(false), finished(false), minalign_(1), force_defaults_(false),
    dedup_vtables_(true), string_pool(nullptr) {
    EndianCheck();

    Swap(other);
  }

  FlatBufferBuilderImpl &operator=(FlatBufferBuilderImpl &&other) noexcept {
    FlatBufferBuilderImpl temp(std::move(other));
    Swap(temp);
    return *this;
  }

  void Swap(FlatBufferBuilderImpl &other) {
    using std::swap;
    buf_.swap(other.buf_);
    swap(num_field_loc, other.num_field_loc);
    swap(max_voffset_, other.max_voffset_);
    swap(length_of_64_bit_region_, other.length_of_64_bit_region_);
    swap(nested, other.nested);
    swap(finished, other.finished);
    swap(minalign_, other.minalign_);
    swap(force_defaults_, other.force_defaults_);
    swap(dedup_vtables_, other.dedup_vtables_);
    swap(string_pool, other.string_pool);
  }

  ~FlatBufferBuilderImpl() {
    if (string_pool) delete string_pool;
  }

  void Reset() {
    Clear();
    buf_.reset();
  }

  void Clear() {
    ClearOffsets();
    buf_.clear();
    nested = false;
    finished = false;
    minalign_ = 1;
    length_of_64_bit_region_ = 0;
    if (string_pool) string_pool->clear();
  }

  SizeT GetSize() const { return buf_.size(); }

  template <bool is_64 = Is64Aware>

  typename std::enable_if<is_64, uoffset_t>::type
  GetSizeRelative32BitRegion() const {
    return static_cast<uoffset_t>(GetSize() - length_of_64_bit_region_);
  }

  template <bool is_64 = Is64Aware>

  typename std::enable_if<!is_64, uoffset_t>::type
  GetSizeRelative32BitRegion() const {
    return static_cast<uoffset_t>(GetSize());
  }

  uint8_t *GetBufferPointer() const {
    Finished();
    return buf_.data();
  }

  flatbuffers::span<uint8_t> GetBufferSpan() const {
    Finished();
    return flatbuffers::span<uint8_t>(buf_.data(), buf_.size());
  }

  uint8_t *GetCurrentBufferPointer() const { return buf_.data(); }

  DetachedBuffer Release() {
    Finished();
    DetachedBuffer buffer = buf_.release();
    Clear();
    return buffer;
  }

  uint8_t *ReleaseRaw(size_t &size, size_t &offset) {
    Finished();
    uint8_t *raw = buf_.release_raw(size, offset);
    Clear();
    return raw;
  }

  size_t GetBufferMinAlignment() const {
    Finished();
    return minalign_;
  }

  void Finished() const {
    (static_cast<bool>(finished) ?
       void(0) :
       __assert_fail(
	 "finished", __builtin_FILE(), __builtin_LINE(),
	 __extension__ __PRETTY_FUNCTION__
       ));
  }

  void ForceDefaults(bool fd) { force_defaults_ = fd; }

  void DedupVtables(bool dedup) { dedup_vtables_ = dedup; }

  void Pad(size_t num_bytes) { buf_.fill(num_bytes); }

  void TrackMinAlign(size_t elem_size) {
    if (elem_size > minalign_) minalign_ = elem_size;
  }

  void Align(size_t elem_size) {
    TrackMinAlign(elem_size);
    buf_.fill(PaddingBytes(buf_.size(), elem_size));
  }

  void PushFlatBuffer(const uint8_t *bytes, size_t size) {
    PushBytes(bytes, size);
    finished = true;
  }

  void PushBytes(const uint8_t *bytes, size_t size) { buf_.push(bytes, size); }

  void PopBytes(size_t amount) { buf_.pop(amount); }

  template <typename T> void AssertScalarT() {
    static_assert(flatbuffers::is_scalar<T>::value, "T must be a scalar type");
  }

  template <typename T, typename ReturnT = uoffset_t>
  ReturnT PushElement(T element) {
    AssertScalarT<T>();
    Align(sizeof(T));
    buf_.push_small(EndianScalar(element));
    return CalculateOffset<ReturnT>();
  }

  template <typename T, template <typename> class OffsetT = Offset>
  uoffset_t PushElement(OffsetT<T> off) {
    return PushElement(ReferTo(off.o));
  }

  void TrackField(voffset_t field, uoffset_t off) {
    FieldLoc fl = {off, field};
    buf_.scratch_push_small(fl);
    num_field_loc++;
    if (field > max_voffset_) { max_voffset_ = field; }
  }

  template <typename T> void AddElement(voffset_t field, T e, T def) {
    if (IsTheSameAs(e, def) && !force_defaults_) return;
    TrackField(field, PushElement(e));
  }

  template <typename T> void AddElement(voffset_t field, T e) {
    TrackField(field, PushElement(e));
  }

  template <typename T> void AddOffset(voffset_t field, Offset<T> off) {
    if (off.IsNull()) return;
    AddElement(field, ReferTo(off.o), static_cast<uoffset_t>(0));
  }

  template <typename T> void AddOffset(voffset_t field, Offset64<T> off) {
    if (off.IsNull()) return;
    AddElement(field, ReferTo(off.o), static_cast<uoffset64_t>(0));
  }

  template <typename T> void AddStruct(voffset_t field, const T *structptr) {
    if (!structptr) return;
    Align(AlignOf<T>());
    buf_.push_small(*structptr);
    TrackField(field, CalculateOffset<uoffset_t>());
  }

  void AddStructOffset(voffset_t field, uoffset_t off) {
    TrackField(field, off);
  }

  uoffset_t ReferTo(uoffset_t off) {
    Align(sizeof(uoffset_t));

    return ReferTo(off, GetSizeRelative32BitRegion());
  }

  uoffset64_t ReferTo(uoffset64_t off) {
    Align(sizeof(uoffset64_t));

    return ReferTo(off, GetSize());
  }

  template <typename T, typename T2> T ReferTo(const T off, const T2 size) {
    (static_cast<bool>(off && off <= size) ?
       void(0) :
       __assert_fail(
	 "off && off <= size", __builtin_FILE(), __builtin_LINE(),
	 __extension__ __PRETTY_FUNCTION__
       ));
    return size - off + static_cast<T>(sizeof(T));
  }

  template <typename T> T ReferTo(const T off, const T size) {
    (static_cast<bool>(off && off <= size) ?
       void(0) :
       __assert_fail(
	 "off && off <= size", __builtin_FILE(), __builtin_LINE(),
	 __extension__ __PRETTY_FUNCTION__
       ));
    return size - off + static_cast<T>(sizeof(T));
  }

  void NotNested() {
    (static_cast<bool>(!nested) ?
       void(0) :
       __assert_fail(
	 "!nested", __builtin_FILE(), __builtin_LINE(),
	 __extension__ __PRETTY_FUNCTION__
       ));

    (static_cast<bool>(!num_field_loc) ?
       void(0) :
       __assert_fail(
	 "!num_field_loc", __builtin_FILE(), __builtin_LINE(),
	 __extension__ __PRETTY_FUNCTION__
       ));
  }

  uoffset_t StartTable() {
    NotNested();
    nested = true;
    return GetSizeRelative32BitRegion();
  }

  uoffset_t EndTable(uoffset_t start) {
    (static_cast<bool>(nested) ? void(0) :
				 __assert_fail(
				   "nested", __builtin_FILE(), __builtin_LINE(),
				   __extension__ __PRETTY_FUNCTION__
				 ));

    const uoffset_t vtable_offset_loc =
      static_cast<uoffset_t>(PushElement<soffset_t>(0));

    max_voffset_ = (std::max)(
      static_cast<voffset_t>(max_voffset_ + sizeof(voffset_t)),
      FieldIndexToOffset(0)
    );
    buf_.fill_big(max_voffset_);
    const uoffset_t table_object_size = vtable_offset_loc - start;

    (static_cast<bool>(table_object_size < 0x10000) ?
       void(0) :
       __assert_fail(
	 "table_object_size < 0x10000", __builtin_FILE(), __builtin_LINE(),
	 __extension__ __PRETTY_FUNCTION__
       ));
    WriteScalar<voffset_t>(
      buf_.data() + sizeof(voffset_t), static_cast<voffset_t>(table_object_size)
    );
    WriteScalar<voffset_t>(buf_.data(), max_voffset_);

    for (auto it = buf_.scratch_end() - num_field_loc * sizeof(FieldLoc);
	 it < buf_.scratch_end(); it += sizeof(FieldLoc)) {
      auto field_location = reinterpret_cast<FieldLoc *>(it);
      const voffset_t pos =
	static_cast<voffset_t>(vtable_offset_loc - field_location->off);

      (static_cast<bool>(
	 !ReadScalar<voffset_t>(buf_.data() + field_location->id)
       ) ?
	 void(0) :
	 __assert_fail(
	   "!ReadScalar<voffset_t>(buf_.data() + field_location->id)",
	   __builtin_FILE(), __builtin_LINE(), __extension__ __PRETTY_FUNCTION__
	 ));
      WriteScalar<voffset_t>(buf_.data() + field_location->id, pos);
    }
    ClearOffsets();
    auto vt1 = reinterpret_cast<voffset_t *>(buf_.data());
    auto vt1_size = ReadScalar<voffset_t>(vt1);
    auto vt_use = GetSizeRelative32BitRegion();

    if (dedup_vtables_) {
      for (auto it = buf_.scratch_data(); it < buf_.scratch_end();
	   it += sizeof(uoffset_t)) {
	auto vt_offset_ptr = reinterpret_cast<uoffset_t *>(it);
	auto vt2 = reinterpret_cast<voffset_t *>(buf_.data_at(*vt_offset_ptr));
	auto vt2_size = ReadScalar<voffset_t>(vt2);
	if (vt1_size != vt2_size || 0 != memcmp(vt2, vt1, vt1_size)) continue;
	vt_use = *vt_offset_ptr;
	buf_.pop(GetSizeRelative32BitRegion() - vtable_offset_loc);
	break;
      }
    }

    if (vt_use == GetSizeRelative32BitRegion()) {
      buf_.scratch_push_small(vt_use);
    }

    WriteScalar(
      buf_.data_at(vtable_offset_loc + length_of_64_bit_region_),
      static_cast<soffset_t>(vt_use) - static_cast<soffset_t>(vtable_offset_loc)
    );
    nested = false;
    return vtable_offset_loc;
  }

  [[deprecated("call the version above instead")]]
  uoffset_t EndTable(uoffset_t start, voffset_t) {
    return EndTable(start);
  }

  template <typename T> void Required(Offset<T> table, voffset_t field) {
    auto table_ptr = reinterpret_cast<const Table *>(buf_.data_at(table.o));
    bool ok = table_ptr->GetOptionalFieldOffset(field) != 0;

    (static_cast<bool>(ok) ? void(0) :
			     __assert_fail(
			       "ok", __builtin_FILE(), __builtin_LINE(),
			       __extension__ __PRETTY_FUNCTION__
			     ));
    (void)ok;
  }

  uoffset_t StartStruct(size_t alignment) {
    Align(alignment);
    return GetSizeRelative32BitRegion();
  }

  uoffset_t EndStruct() { return GetSizeRelative32BitRegion(); }

  void ClearOffsets() {
    buf_.scratch_pop(num_field_loc * sizeof(FieldLoc));
    num_field_loc = 0;
    max_voffset_ = 0;
  }

  void PreAlign(size_t len, size_t alignment) {
    if (len == 0) return;
    TrackMinAlign(alignment);
    buf_.fill(PaddingBytes(GetSize() + len, alignment));
  }

  template <typename AlignT> void PreAlign(size_t len) {
    AssertScalarT<AlignT>();
    PreAlign(len, AlignOf<AlignT>());
  }

  template <template <typename> class OffsetT = Offset>
  OffsetT<String> CreateString(const char *str, size_t len) {
    CreateStringImpl(str, len);
    return OffsetT<String>(
      CalculateOffset<typename OffsetT<String>::offset_type>()
    );
  }

  template <template <typename> class OffsetT = Offset>
  OffsetT<String> CreateString(const char *str) {
    return CreateString<OffsetT>(str, strlen(str));
  }

  template <template <typename> class OffsetT = Offset>
  OffsetT<String> CreateString(char *str) {
    return CreateString<OffsetT>(str, strlen(str));
  }

  template <template <typename> class OffsetT = Offset>
  OffsetT<String> CreateString(const std::string &str) {
    return CreateString<OffsetT>(str.c_str(), str.length());
  }

  template <template <typename> class OffsetT = Offset>
  OffsetT<String> CreateString(flatbuffers::string_view str) {
    return CreateString<OffsetT>(str.data(), str.size());
  }

  template <template <typename> class OffsetT = Offset>
  OffsetT<String> CreateString(const String *str) {
    return str ? CreateString<OffsetT>(str->c_str(), str->size()) : 0;
  }

  template <
    template <typename> class OffsetT = Offset,

    int &...ExplicitArgumentBarrier, typename T>
  OffsetT<String> CreateString(const T &str) {
    return CreateString<OffsetT>(str.data(), str.length());
  }

  Offset<String> CreateSharedString(const char *str, size_t len) {
    (static_cast<bool>(1) ?
       void(0) :
       __assert_fail(
	 "FLATBUFFERS_GENERAL_HEAP_ALLOC_OK", __builtin_FILE(),
	 __builtin_LINE(), __extension__ __PRETTY_FUNCTION__
       ));
    if (!string_pool) {
      string_pool = new StringOffsetMap(StringOffsetCompare(buf_));
    }

    const size_t size_before_string = buf_.size();

    const Offset<String> off = CreateString<Offset>(str, len);
    auto it = string_pool->find(off);

    if (it != string_pool->end()) {
      buf_.pop(buf_.size() - size_before_string);
      return *it;
    }

    string_pool->insert(off);
    return off;
  }

  Offset<String> CreateSharedString(const flatbuffers::string_view str) {
    return CreateSharedString(str.data(), str.size());
  }

  Offset<String> CreateSharedString(const String *str) {
    return str ? CreateSharedString(str->c_str(), str->size()) : 0;
  }

  template <typename LenT = uoffset_t, typename ReturnT = uoffset_t>
  ReturnT EndVector(size_t len) {
    (static_cast<bool>(nested) ? void(0) :
				 __assert_fail(
				   "nested", __builtin_FILE(), __builtin_LINE(),
				   __extension__ __PRETTY_FUNCTION__
				 ));
    nested = false;
    return PushElement<LenT, ReturnT>(static_cast<LenT>(len));
  }

  template <
    template <typename> class OffsetT = Offset, typename LenT = uint32_t>
  void StartVector(size_t len, size_t elemsize, size_t alignment) {
    NotNested();
    nested = true;

    PreAlign<LenT>(len * elemsize);
    PreAlign(len * elemsize, alignment);
  }

  template <
    typename T, template <typename> class OffsetT = Offset,
    typename LenT = uint32_t>
  void StartVector(size_t len) {
    return StartVector<OffsetT, LenT>(len, sizeof(T), AlignOf<T>());
  }

  void ForceVectorAlignment(
    const size_t len, const size_t elemsize, const size_t alignment
  ) {
    if (len == 0) return;
    (static_cast<bool>(VerifyAlignmentRequirements(alignment)) ?
       void(0) :
       __assert_fail(
	 "VerifyAlignmentRequirements(alignment)", __builtin_FILE(),
	 __builtin_LINE(), __extension__ __PRETTY_FUNCTION__
       ));
    PreAlign(len * elemsize, alignment);
  }

  template <bool is_64 = Is64Aware>
  typename std::enable_if<is_64, void>::type ForceVectorAlignment64(
    const size_t len, const size_t elemsize, const size_t alignment
  ) {
    (static_cast<bool>(GetSize() == length_of_64_bit_region_) ?
       void(0) :
       __assert_fail(
	 "GetSize() == length_of_64_bit_region_", __builtin_FILE(),
	 __builtin_LINE(), __extension__ __PRETTY_FUNCTION__
       ));

    ForceVectorAlignment(len, elemsize, alignment);

    length_of_64_bit_region_ = GetSize();
  }

  void ForceStringAlignment(size_t len, size_t alignment) {
    if (len == 0) return;
    (static_cast<bool>(VerifyAlignmentRequirements(alignment)) ?
       void(0) :
       __assert_fail(
	 "VerifyAlignmentRequirements(alignment)", __builtin_FILE(),
	 __builtin_LINE(), __extension__ __PRETTY_FUNCTION__
       ));
    PreAlign((len + 1) * sizeof(char), alignment);
  }

  template <
    typename T, template <typename...> class OffsetT = Offset,
    template <typename...> class VectorT = Vector>
  OffsetT<VectorT<T>> CreateVector(const T *v, size_t len) {
    typedef typename VectorT<T>::size_type LenT;
    typedef typename OffsetT<VectorT<T>>::offset_type offset_type;

    AssertScalarT<T>();
    StartVector<T, OffsetT, LenT>(len);
    if (len > 0) {
      PushBytes(reinterpret_cast<const uint8_t *>(v), len * sizeof(T));
    }
    return OffsetT<VectorT<T>>(EndVector<LenT, offset_type>(len));
  }

  template <typename T, class C>
  Offset<Vector<T>> CreateVector(const C &array) {
    return CreateVector(array.data(), array.size());
  }

  template <typename T>
  Offset<Vector<T>> CreateVector(std::initializer_list<T> v) {
    return CreateVector(v.begin(), v.size());
  }

  template <typename T>
  Offset<Vector<Offset<T>>> CreateVector(const Offset<T> *v, size_t len) {
    StartVector<Offset<T>>(len);
    for (auto i = len; i > 0;) { PushElement(v[--i]); }
    return Offset<Vector<Offset<T>>>(EndVector(len));
  }

  template <typename T, typename Alloc = std::allocator<T>>
  Offset<Vector<T>> CreateVector(const std::vector<T, Alloc> &v) {
    return CreateVector(data(v), v.size());
  }

  template <
    template <typename...> class VectorT = Vector64,
    int &...ExplicitArgumentBarrier, typename T>
  Offset64<VectorT<T>> CreateVector64(const std::vector<T> &v) {
    return CreateVector<T, Offset64, VectorT>(data(v), v.size());
  }

  Offset<Vector<uint8_t>> CreateVector(const std::vector<bool> &v) {
    StartVector<uint8_t>(v.size());
    for (auto i = v.size(); i > 0;) {
      PushElement(static_cast<uint8_t>(v[--i]));
    }
    return Offset<Vector<uint8_t>>(EndVector(v.size()));
  }

  template <typename T>
  Offset<Vector<T>>
  CreateVector(size_t vector_size, const std::function<T(size_t i)> &f) {
    (static_cast<bool>(1) ?
       void(0) :
       __assert_fail(
	 "FLATBUFFERS_GENERAL_HEAP_ALLOC_OK", __builtin_FILE(),
	 __builtin_LINE(), __extension__ __PRETTY_FUNCTION__
       ));
    std::vector<T> elems(vector_size);
    for (size_t i = 0; i < vector_size; i++) elems[i] = f(i);
    return CreateVector(elems);
  }

  template <typename T, typename F, typename S>
  Offset<Vector<T>> CreateVector(size_t vector_size, F f, S *state) {
    (static_cast<bool>(1) ?
       void(0) :
       __assert_fail(
	 "FLATBUFFERS_GENERAL_HEAP_ALLOC_OK", __builtin_FILE(),
	 __builtin_LINE(), __extension__ __PRETTY_FUNCTION__
       ));
    std::vector<T> elems(vector_size);
    for (size_t i = 0; i < vector_size; i++) elems[i] = f(i, state);
    return CreateVector(elems);
  }

  template <
    typename StringType = std::string,
    typename Alloc = std::allocator<StringType>>
  Offset<Vector<Offset<String>>>
  CreateVectorOfStrings(const std::vector<StringType, Alloc> &v) {
    return CreateVectorOfStrings(v.cbegin(), v.cend());
  }

  template <class It>
  Offset<Vector<Offset<String>>> CreateVectorOfStrings(It begin, It end) {
    auto distance = std::distance(begin, end);
    (static_cast<bool>(distance >= 0) ?
       void(0) :
       __assert_fail(
	 "distance >= 0", __builtin_FILE(), __builtin_LINE(),
	 __extension__ __PRETTY_FUNCTION__
       ));
    auto size = static_cast<size_t>(distance);
    auto scratch_buffer_usage = size * sizeof(Offset<String>);

    buf_.ensure_space(scratch_buffer_usage);
    for (auto it = begin; it != end; ++it) {
      buf_.scratch_push_small(CreateString(*it));
    }
    StartVector<Offset<String>>(size);
    for (size_t i = 1; i <= size; i++) {
      PushElement(*reinterpret_cast<Offset<String> *>(
	buf_.scratch_end() - i * sizeof(Offset<String>)
      ));
    }
    buf_.scratch_pop(scratch_buffer_usage);
    return Offset<Vector<Offset<String>>>(EndVector(size));
  }

  template <
    typename T, template <typename...> class OffsetT = Offset,
    template <typename...> class VectorT = Vector>
  OffsetT<VectorT<const T *>> CreateVectorOfStructs(const T *v, size_t len) {
    typedef typename VectorT<T>::size_type LenT;
    typedef typename OffsetT<VectorT<const T *>>::offset_type offset_type;

    StartVector<OffsetT, LenT>(len, sizeof(T), AlignOf<T>());
    if (len > 0) {
      PushBytes(reinterpret_cast<const uint8_t *>(v), sizeof(T) * len);
    }
    return OffsetT<VectorT<const T *>>(EndVector<LenT, offset_type>(len));
  }

  template <typename T>
  Offset<Vector<const T *>> CreateVectorOfStructs(
    size_t vector_size, const std::function<void(size_t i, T *)> &filler
  ) {
    T *structs = StartVectorOfStructs<T>(vector_size);
    for (size_t i = 0; i < vector_size; i++) {
      filler(i, structs);
      structs++;
    }
    return EndVectorOfStructs<T>(vector_size);
  }

  template <typename T, typename F, typename S>
  Offset<Vector<const T *>>
  CreateVectorOfStructs(size_t vector_size, F f, S *state) {
    T *structs = StartVectorOfStructs<T>(vector_size);
    for (size_t i = 0; i < vector_size; i++) {
      f(i, structs, state);
      structs++;
    }
    return EndVectorOfStructs<T>(vector_size);
  }

  template <
    typename T, template <typename...> class OffsetT = Offset,
    template <typename...> class VectorT = Vector,
    typename Alloc = std::allocator<T>>
  OffsetT<VectorT<const T *>>
  CreateVectorOfStructs(const std::vector<T, Alloc> &v) {
    return CreateVectorOfStructs<T, OffsetT, VectorT>(data(v), v.size());
  }

  template <
    template <typename...> class VectorT = Vector64, int &..., typename T>
  Offset64<VectorT<const T *>>
  CreateVectorOfStructs64(const std::vector<T> &v) {
    return CreateVectorOfStructs<T, Offset64, VectorT>(data(v), v.size());
  }

  template <typename T, typename S>
  Offset<Vector<const T *>> CreateVectorOfNativeStructs(
    const S *v, size_t len, T (*const pack_func)(const S &)
  ) {
    (static_cast<bool>(pack_func) ?
       void(0) :
       __assert_fail(
	 "pack_func", __builtin_FILE(), __builtin_LINE(),
	 __extension__ __PRETTY_FUNCTION__
       ));
    auto structs = StartVectorOfStructs<T>(len);
    for (size_t i = 0; i < len; i++) { structs[i] = pack_func(v[i]); }
    return EndVectorOfStructs<T>(len);
  }

  template <typename T, typename S>
  Offset<Vector<const T *>>
  CreateVectorOfNativeStructs(const S *v, size_t len) {
    extern T Pack(const S &);
    return CreateVectorOfNativeStructs(v, len, Pack);
  }

  template <typename T, typename S, typename Alloc = std::allocator<T>>
  Offset<Vector<const T *>> CreateVectorOfNativeStructs(
    const std::vector<S, Alloc> &v, T (*const pack_func)(const S &)
  ) {
    return CreateVectorOfNativeStructs<T, S>(data(v), v.size(), pack_func);
  }

  template <typename T, typename S, typename Alloc = std::allocator<S>>
  Offset<Vector<const T *>>
  CreateVectorOfNativeStructs(const std::vector<S, Alloc> &v) {
    return CreateVectorOfNativeStructs<T, S>(data(v), v.size());
  }

  template <typename T> struct StructKeyComparator {
    bool operator()(const T &a, const T &b) const {
      return a.KeyCompareLessThan(&b);
    }
  };

  template <typename T, typename Alloc = std::allocator<T>>
  Offset<Vector<const T *>>
  CreateVectorOfSortedStructs(std::vector<T, Alloc> *v) {
    return CreateVectorOfSortedStructs(data(*v), v->size());
  }

  template <typename T, typename S, typename Alloc = std::allocator<T>>
  Offset<Vector<const T *>>
  CreateVectorOfSortedNativeStructs(std::vector<S, Alloc> *v) {
    return CreateVectorOfSortedNativeStructs<T, S>(data(*v), v->size());
  }

  template <typename T>
  Offset<Vector<const T *>> CreateVectorOfSortedStructs(T *v, size_t len) {
    std::stable_sort(v, v + len, StructKeyComparator<T>());
    return CreateVectorOfStructs(v, len);
  }

  template <typename T, typename S>
  Offset<Vector<const T *>>
  CreateVectorOfSortedNativeStructs(S *v, size_t len) {
    extern T Pack(const S &);
    auto structs = StartVectorOfStructs<T>(len);
    for (size_t i = 0; i < len; i++) { structs[i] = Pack(v[i]); }
    std::stable_sort(structs, structs + len, StructKeyComparator<T>());
    return EndVectorOfStructs<T>(len);
  }

  template <typename T> struct TableKeyComparator {
    explicit TableKeyComparator(vector_downward<SizeT> &buf) : buf_(buf) { }
    TableKeyComparator(const TableKeyComparator &other) : buf_(other.buf_) { }
    bool operator()(const Offset<T> &a, const Offset<T> &b) const {
      auto table_a = reinterpret_cast<T *>(buf_.data_at(a.o));
      auto table_b = reinterpret_cast<T *>(buf_.data_at(b.o));
      return table_a->KeyCompareLessThan(table_b);
    }
    vector_downward<SizeT> &buf_;

  private:
    TableKeyComparator &operator=(const TableKeyComparator &other) = delete;
  };

  template <typename T>
  Offset<Vector<Offset<T>>>
  CreateVectorOfSortedTables(Offset<T> *v, size_t len) {
    std::stable_sort(v, v + len, TableKeyComparator<T>(buf_));
    return CreateVector(v, len);
  }

  template <typename T, typename Alloc = std::allocator<T>>
  Offset<Vector<Offset<T>>>
  CreateVectorOfSortedTables(std::vector<Offset<T>, Alloc> *v) {
    return CreateVectorOfSortedTables(data(*v), v->size());
  }

  uoffset_t CreateUninitializedVector(
    size_t len, size_t elemsize, size_t alignment, uint8_t **buf
  ) {
    NotNested();
    StartVector(len, elemsize, alignment);
    buf_.make_space(len * elemsize);
    const uoffset_t vec_start = GetSizeRelative32BitRegion();
    auto vec_end = EndVector(len);
    *buf = buf_.data_at(vec_start);
    return vec_end;
  }

  [[deprecated("call the version above instead")]]
  uoffset_t
  CreateUninitializedVector(size_t len, size_t elemsize, uint8_t **buf) {
    return CreateUninitializedVector(len, elemsize, elemsize, buf);
  }

  template <typename T>
  Offset<Vector<T>> CreateUninitializedVector(size_t len, T **buf) {
    AssertScalarT<T>();
    return CreateUninitializedVector(
      len, sizeof(T), AlignOf<T>(), reinterpret_cast<uint8_t **>(buf)
    );
  }

  template <typename T>
  Offset<Vector<const T *>>
  CreateUninitializedVectorOfStructs(size_t len, T **buf) {
    return CreateUninitializedVector(
      len, sizeof(T), AlignOf<T>(), reinterpret_cast<uint8_t **>(buf)
    );
  }

  template <typename T, typename U>
  Offset<Vector<T>> CreateVectorScalarCast(const U *v, size_t len) {
    AssertScalarT<T>();
    AssertScalarT<U>();
    StartVector<T>(len);
    for (auto i = len; i > 0;) { PushElement(static_cast<T>(v[--i])); }
    return Offset<Vector<T>>(EndVector(len));
  }

  template <typename T> Offset<const T *> CreateStruct(const T &structobj) {
    NotNested();
    Align(AlignOf<T>());
    buf_.push_small(structobj);
    return Offset<const T *>(
      CalculateOffset<typename Offset<const T *>::offset_type>()
    );
  }

  template <typename T>
  void Finish(Offset<T> root, const char *file_identifier = nullptr) {
    Finish(root.o, file_identifier, false);
  }

  template <typename T>
  void
  FinishSizePrefixed(Offset<T> root, const char *file_identifier = nullptr) {
    Finish(root.o, file_identifier, true);
  }

  void SwapBufAllocator(FlatBufferBuilderImpl &other) {
    buf_.swap_allocator(other.buf_);
  }

  static const size_t kFileIdentifierLength =
    ::flatbuffers::kFileIdentifierLength;

protected:
  FlatBufferBuilderImpl(const FlatBufferBuilderImpl &);
  FlatBufferBuilderImpl &operator=(const FlatBufferBuilderImpl &);

  void Finish(uoffset_t root, const char *file_identifier, bool size_prefix) {
    (static_cast<bool>(!finished) ?
       void(0) :
       __assert_fail(
	 "!finished", __builtin_FILE(), __builtin_LINE(),
	 __extension__ __PRETTY_FUNCTION__
       ));

    NotNested();
    buf_.clear_scratch();

    const size_t prefix_size = size_prefix ? sizeof(SizeT) : 0;

    TrackMinAlign(prefix_size);

    const size_t root_offset_size = sizeof(uoffset_t);
    const size_t file_id_size = file_identifier ? kFileIdentifierLength : 0;

    PreAlign(prefix_size + root_offset_size + file_id_size, minalign_);

    if (file_identifier) {
      (static_cast<bool>(strlen(file_identifier) == kFileIdentifierLength) ?
	 void(0) :
	 __assert_fail(
	   "strlen(file_identifier) == kFileIdentifierLength", __builtin_FILE(),
	   __builtin_LINE(), __extension__ __PRETTY_FUNCTION__
	 ));
      PushBytes(
	reinterpret_cast<const uint8_t *>(file_identifier),
	kFileIdentifierLength
      );
    }
    PushElement(ReferTo(root));
    if (size_prefix) { PushElement(GetSize()); }
    finished = true;
  }

  struct FieldLoc {
    uoffset_t off;
    voffset_t id;
  };

  vector_downward<SizeT> buf_;

  uoffset_t num_field_loc;

  voffset_t max_voffset_;

  size_t length_of_64_bit_region_;

  bool nested;

  bool finished;

  size_t minalign_;

  bool force_defaults_;

  bool dedup_vtables_;

  struct StringOffsetCompare {
    explicit StringOffsetCompare(const vector_downward<SizeT> &buf) :
      buf_(&buf) { }
    bool operator()(const Offset<String> &a, const Offset<String> &b) const {
      auto stra = reinterpret_cast<const String *>(buf_->data_at(a.o));
      auto strb = reinterpret_cast<const String *>(buf_->data_at(b.o));
      return StringLessThan(
	stra->data(), stra->size(), strb->data(), strb->size()
      );
    }
    const vector_downward<SizeT> *buf_;
  };

  typedef std::set<Offset<String>, StringOffsetCompare> StringOffsetMap;
  StringOffsetMap *string_pool;

private:
  void CanAddOffset64() {
    static_assert(Is64Aware, "cannot add 64-bit offset to a 32-bit builder");

    (static_cast<bool>(GetSize() == length_of_64_bit_region_) ?
       void(0) :
       __assert_fail(
	 "GetSize() == length_of_64_bit_region_", __builtin_FILE(),
	 __builtin_LINE(), __extension__ __PRETTY_FUNCTION__
       ));
  }

  void CreateStringImpl(const char *str, size_t len) {
    NotNested();
    PreAlign<uoffset_t>(len + 1);
    buf_.fill(1);
    PushBytes(reinterpret_cast<const uint8_t *>(str), len);
    PushElement(static_cast<uoffset_t>(len));
  }

  template <typename T, template <typename> class OffsetT = Offset>
  T *StartVectorOfStructs(size_t vector_size) {
    StartVector<OffsetT>(vector_size, sizeof(T), AlignOf<T>());
    return reinterpret_cast<T *>(buf_.make_space(vector_size * sizeof(T)));
  }

  template <typename T, template <typename> class OffsetT = Offset>
  OffsetT<Vector<const T *>> EndVectorOfStructs(size_t vector_size) {
    return OffsetT<Vector<const T *>>(
      EndVector<
	typename Vector<const T *>::size_type,
	typename OffsetT<Vector<const T *>>::offset_type>(vector_size)
    );
  }

  template <typename T>
  typename std::enable_if<std::is_same<T, uoffset_t>::value, T>::type
  CalculateOffset() {
    return GetSizeRelative32BitRegion();
  }

  template <typename T>
  typename std::enable_if<std::is_same<T, uoffset64_t>::value, T>::type
  CalculateOffset() {
    static_assert(Is64Aware, "invalid 64-bit offset in 32-bit builder");

    length_of_64_bit_region_ = GetSize();

    return length_of_64_bit_region_;
  }
};

using FlatBufferBuilder = FlatBufferBuilderImpl<false>;
using FlatBufferBuilder64 = FlatBufferBuilderImpl<true>;

template <>
template <>
inline Offset64<String>
FlatBufferBuilder64::CreateString(const char *str, size_t len) {
  CanAddOffset64();
  CreateStringImpl(str, len);
  return Offset64<String>(
    CalculateOffset<typename Offset64<String>::offset_type>()
  );
}

template <typename T = void> struct EmptyOffset { };

template <>
template <>
inline void FlatBufferBuilder64::StartVector<Offset64, uint32_t>(
  size_t len, size_t elemsize, size_t alignment
) {
  CanAddOffset64();
  StartVector<EmptyOffset, uint32_t>(len, elemsize, alignment);
}

template <>
template <>
inline void FlatBufferBuilder64::StartVector<Offset64, uint64_t>(
  size_t len, size_t elemsize, size_t alignment
) {
  CanAddOffset64();
  StartVector<EmptyOffset, uint64_t>(len, elemsize, alignment);
}

template <typename T>
T *GetMutableTemporaryPointer(FlatBufferBuilder &fbb, Offset<T> offset) {
  return reinterpret_cast<T *>(
    fbb.GetCurrentBufferPointer() + fbb.GetSize() - offset.o
  );
}

template <typename T>
const T *GetTemporaryPointer(const FlatBufferBuilder &fbb, Offset<T> offset) {
  return GetMutableTemporaryPointer<T>(fbb, offset);
}

} // namespace flatbuffers

namespace flatbuffers {

inline const uint8_t *GetBufferStartFromRootPointer(const void *root) {
  auto table = reinterpret_cast<const Table *>(root);
  auto vtable = table->GetVTable();

  auto start = (std::min)(vtable, reinterpret_cast<const uint8_t *>(root));

  start = reinterpret_cast<const uint8_t *>(
    reinterpret_cast<uintptr_t>(start) & ~(sizeof(uoffset_t) - 1)
  );

  static_assert(
    flatbuffers::kFileIdentifierLength == sizeof(uoffset_t),
    "file_identifier is assumed to be the same size as uoffset_t"
  );
  for (auto possible_roots = 32 / sizeof(uoffset_t) + 1; possible_roots;
       possible_roots--) {
    start -= sizeof(uoffset_t);
    if (ReadScalar<uoffset_t>(start) + start ==
	reinterpret_cast<const uint8_t *>(root))
      return start;
  }

  (static_cast<bool>(false) ? void(0) :
			      __assert_fail(
				"false", __builtin_FILE(), __builtin_LINE(),
				__extension__ __PRETTY_FUNCTION__
			      ));
  return nullptr;
}

template <typename SizeT = uoffset_t>
inline SizeT GetPrefixedSize(const uint8_t *buf) {
  return ReadScalar<SizeT>(buf);
}

template <typename SizeT = uoffset_t>
inline SizeT GetSizePrefixedBufferLength(const uint8_t *const buf) {
  return ReadScalar<SizeT>(buf) + sizeof(SizeT);
}

struct NativeTable { };

typedef uint64_t hash_value_t;
typedef std::function<void(void **pointer_adr, hash_value_t hash)>
  resolver_function_t;
typedef std::function<hash_value_t(void *pointer)> rehasher_function_t;

template <typename T>
bool IsFieldPresent(const T *table, typename T::FlatBuffersVTableOffset field) {
  return reinterpret_cast<const Table *>(table)->CheckField(
    static_cast<voffset_t>(field)
  );
}

inline int LookupEnum(const char **names, const char *name) {
  for (const char **p = names; *p; p++)
    if (!strcmp(*p, name)) return static_cast<int>(p - names);
  return -1;
}

enum SequenceType { ST_TABLE, ST_STRUCT, ST_UNION, ST_ENUM };

enum ElementaryType {

  ET_UTYPE,
  ET_BOOL,
  ET_CHAR,
  ET_UCHAR,
  ET_SHORT,
  ET_USHORT,
  ET_INT,
  ET_UINT,
  ET_LONG,
  ET_ULONG,
  ET_FLOAT,
  ET_DOUBLE,
  ET_STRING,
  ET_SEQUENCE,

};

inline const char *const *ElementaryTypeNames() {
  static const char *const names[] = {

    "ET_UTYPE",  "ET_BOOL",   "ET_CHAR",   "ET_UCHAR",    "ET_SHORT",
    "ET_USHORT", "ET_INT",    "ET_UINT",   "ET_LONG",     "ET_ULONG",
    "ET_FLOAT",  "ET_DOUBLE", "ET_STRING", "ET_SEQUENCE",

  };
  return names;
}

struct TypeCode {
  unsigned short base_type:4;

  unsigned short is_repeating:1;

  signed short sequence_ref:11;
};

static_assert(sizeof(TypeCode) == 2, "TypeCode");

struct TypeTable;

typedef const TypeTable *(*TypeFunction)();

struct TypeTable {
  SequenceType st;
  size_t num_elems;
  const TypeCode *type_codes;
  const TypeFunction *type_refs;
  const int16_t *array_sizes;
  const int64_t *values;
  const char *const *names;
};

inline const char *flatbuffers_version_string() {
  return "FlatBuffers "
	 "24"
	 "."
	 "3"
	 "."
	 "25";
}

} // namespace flatbuffers

namespace ZtBitmap_ {

struct Data {
  enum { Fixed = 0 };

  enum { BitShift = 6 };
  enum { ByteShift = 3 };

public:
  Data() = default;
  Data(const Data &b) = default;
  Data &operator=(const Data &b) = default;
  Data(Data &&b) = default;
  Data &operator=(Data &&b) = default;

  Data(unsigned n) {
    n = (n + 63) >> BitShift;
    data = ZtArray<uint64_t>(n);
    data.length(n);
    memset(&data[0], 0, n << (BitShift - ByteShift));
  }

  unsigned combine(const Data &b) {
    unsigned l = data.length();
    unsigned r = b.data.length();
    if (l < r) {
      data.length(r);
      memset(&data[l], 0, (r - l) << (BitShift - ByteShift));
    }
    return r;
  }

  unsigned length() const { return data.length() << BitShift; }
  void length(unsigned n) {
    n = (n + 63) >> BitShift;
    unsigned o = data.length();
    if (n <= o) {
      if (n < o) data.length(n);
      return;
    }
    data.length(n);
    memset(&data[o], 0, (n - o) << (BitShift - ByteShift));
  }

  ZtArray<uint64_t> data;
};

struct Bitmap : public ZuBitmap_::Bitmap_<Data> {
  using Base = ZuBitmap_::Bitmap_<Data>;
  using Base::Base;
  using Base::operator=;
};

} // namespace ZtBitmap_

using ZtBitmap = ZtBitmap_::Bitmap;

inline constexpr const char *ZiIOBuf_HeapID() { return "ZiIOBuf"; }

namespace Zi {

using VHeap = ZmVHeap<ZiIOBuf_HeapID>;

struct IOBuf : private VHeap, public ZmPolymorph {
  mutable void *owner = nullptr;
  uintptr_t data__ = 0;
  uint32_t size = 0;
  uint32_t length = 0;
  uint32_t skip = 0;

  static constexpr const uintptr_t Jumbo = (uintptr_t(1) << 63);

private:
  using VHeap::valloc;
  using VHeap::vfree;

protected:
  IOBuf(uint8_t *data_, uint32_t size_) :
    data__{reinterpret_cast<uintptr_t>(data_)}, size{size_} { }
  IOBuf(uint8_t *data_, uint32_t size_, void *owner_) :
    owner{owner_}, data__{reinterpret_cast<uintptr_t>(data_)}, size{size_} { }
  IOBuf(uint8_t *data_, uint32_t size_, void *owner_, uint32_t length_) :
    owner{owner_}, data__{reinterpret_cast<uintptr_t>(data_)}, size{size_},
    length{length_} { }

public:
  virtual ~IOBuf() {
    if (__builtin_expect(!!(data__ & Jumbo), 0)) vfree(data_());
  }

private:
  IOBuf(const IOBuf &buf) = delete;
  IOBuf &operator=(const IOBuf &buf) = delete;
  IOBuf(IOBuf &&buf) = delete;
  IOBuf &operator=(IOBuf &&buf) = delete;

  inline uint8_t *data_() {
    return reinterpret_cast<uint8_t *>(data__ & ~Jumbo);
  }
  inline const uint8_t *data_() const {
    return const_cast<IOBuf *>(this)->data_();
  }

public:
  bool operator!() const { return !length; }

  const uint8_t *data() const { return data_() + skip; }
  uint8_t *data() { return data_() + skip; }

  const uint8_t *end() const { return data_() + skip + length; }
  uint8_t *end() { return data_() + skip + length; }

  unsigned avail() const { return size - (skip + length); }

  uint8_t *alloc(unsigned newSize) {
    if (__builtin_expect(!!(newSize <= size), 1)) return data();
    if (auto jumbo = static_cast<uint8_t *>(valloc(newSize))) {
      size = newSize;
      if (__builtin_expect(!!(data__ & Jumbo), 0)) vfree(data_());
      data__ = reinterpret_cast<uintptr_t>(jumbo) | Jumbo;
      return jumbo;
    }
    size = 0;
    return nullptr;
  }

  void free(uint8_t *ptr) {
    if (!(data__ & Jumbo) && ptr == data_()) return;
    if (ptr == data_()) {
      data__ = 0;
      length = size = 0;
    }
    vfree(ptr);
  }

  void clear() {
    length = 0;
    skip = 0;
  }

  template <typename T> const T *ptr() const {
    return reinterpret_cast<const T *>(data());
  }
  template <typename T> T *ptr() { return reinterpret_cast<T *>(data()); }

  template <typename T> const T &as() const { return *ptr<T>(); }
  template <typename T> T &as() { return *ptr<T>(); }

  auto buf_() { return ZuSpan{data(), size}; }
  auto cbuf_() const { return ZuSpan{data(), length}; }

  void advance(unsigned n) {
    if (__builtin_expect(!!(!n), 0)) return;
    if (__builtin_expect(!!(n > length), 0)) n = length;
    skip += n, length -= n;
  }
  void rewind(unsigned n) {
    if (__builtin_expect(!!(!n), 0)) return;
    if (__builtin_expect(!!(n > skip), 0)) n = skip;
    skip -= n, length += n;
  }

  template <auto Grow = ZmGrow>
  uint8_t *
  realloc(unsigned oldSize, unsigned newSize, unsigned head, unsigned tail) {
    ((!skip) ?
       void() :
       ZmAssert_fail(
	 "!skip", "../../zi/src/zlib/ZiIOBuf.hh", 148, __PRETTY_FUNCTION__
       ));
    auto old = data_();
    if (__builtin_expect(!!(newSize <= size), 1)) {
      if (tail) memmove(old + newSize - tail, old + oldSize - tail, tail);
      size = newSize;
      return old;
    }
    newSize = Grow(size, newSize);
    auto jumbo = reinterpret_cast<uint8_t *>(valloc(newSize));
    if (__builtin_expect(!!(jumbo), 1)) {
      if (head) memcpy(jumbo, old, head);
      if (tail) memcpy(jumbo + newSize - tail, old + oldSize - tail, tail);
      size = newSize;
    } else
      length = size = 0;
    if (__builtin_expect(!!(data__ & Jumbo), 0)) vfree(old);
    data__ = reinterpret_cast<uintptr_t>(jumbo) | Jumbo;
    return jumbo;
  }

  template <auto Grow = ZmGrow> uint8_t *ensure(unsigned newSize) {
    ((!skip) ?
       void() :
       ZmAssert_fail(
	 "!skip", "../../zi/src/zlib/ZiIOBuf.hh", 171, __PRETTY_FUNCTION__
       ));
    if (__builtin_expect(!!(newSize <= size), 1)) return data();
    newSize = Grow(size, newSize);
    auto old = data_();
    auto jumbo = reinterpret_cast<uint8_t *>(valloc(newSize));
    if (__builtin_expect(!!(!jumbo), 0)) return nullptr;
    if (length) memcpy(jumbo, old, length);
    size = newSize;
    if (__builtin_expect(!!(data__ & Jumbo), 0)) vfree(old);
    data__ = reinterpret_cast<uintptr_t>(jumbo) | Jumbo;
    return jumbo;
  }

  template <auto Grow = ZmGrow> uint8_t *prepend(unsigned length_) {
    ((size == skip + length) ?
       void() :
       ZmAssert_fail(
	 "size == skip + length", "../../zi/src/zlib/ZiIOBuf.hh", 187,
	 __PRETTY_FUNCTION__
       ));
    if (__builtin_expect(!!(skip >= length_), 1)) {
      skip -= length_;
      length += length_;
      return data();
    }
    auto old = data_();
    auto newSize = length + (length_ - skip);
    if (__builtin_expect(!!(newSize <= size), 1)) {
      auto newSkip = size - length;
      if (length) memmove(old + newSkip, old + skip, length);
      skip = newSkip - length_;
      length += length_;
      return data();
    }
    newSize = Grow(size, newSize);
    auto jumbo = reinterpret_cast<uint8_t *>(valloc(newSize));
    if (__builtin_expect(!!(!jumbo), 0)) return nullptr;
    auto newSkip = newSize - length;
    if (length) memcpy(jumbo + newSkip, old + skip, length);
    size = newSize;
    skip = newSkip - length_;
    length += length_;
    if (__builtin_expect(!!(data__ & Jumbo), 0)) vfree(old);
    data__ = reinterpret_cast<uintptr_t>(jumbo) | Jumbo;
    return jumbo + skip;
  }

private:
  void append(const uint8_t *data, unsigned length_) {
    unsigned total = length + length_;
    memcpy(ensure(total) + length, data, length_);
    length = total;
  }

  template <typename U, typename R = void>
  using MatchPDelegate = ZuIfT<ZuPrint<U>::Delegate, R>;
  template <typename U, typename R = void>
  using MatchPBuffer = ZuIfT<ZuPrint<U>::Buffer, R>;

  template <typename P> MatchPDelegate<P> append(const P &p) {
    ZuPrint<P>::print(*this, p);
  }
  template <typename P> MatchPBuffer<P> append(const P &p) {
    unsigned length_ = ZuPrint<P>::length(p);
    length += ZuPrint<P>::print(
      reinterpret_cast<char *>(ensure(length + length_) + length), length_, p
    );
  }

  template <typename U, typename R = void> using MatchChar = ZuSame<U, char, R>;

  template <typename U, typename R = void>
  using MatchString = ZuIfT<
    ZuTraits<U>::IsString && !ZuTraits<U>::IsWString &&
      !ZuTraits<U>::IsPrimitive,
    R>;

  template <typename U, typename R = void>
  using MatchReal = ZuIfT<
    ZuTraits<U>::IsPrimitive && ZuTraits<U>::IsReal &&
      !ZuInspect<U, char>::Same,
    R>;

  template <typename U, typename R = void>
  using MatchPrint = ZuIfT<ZuPrint<U>::OK && !ZuPrint<U>::String, R>;

public:
  IOBuf &operator<<(const ZuSpan<const uint8_t> &buf) {
    append(buf.data(), buf.length());
    return *this;
  }
  template <typename C> MatchChar<C, IOBuf &> operator<<(C c) {
    this->append(&c, 1);
    return *this;
  }
  template <typename S> MatchString<S, IOBuf &> operator<<(S &&s_) {
    ZuCSpan s(ZuFwd<S>(s_));
    append(reinterpret_cast<const uint8_t *>(s.data()), s.length());
    return *this;
  }
  IOBuf &operator<<(const char *s_) {
    ZuCSpan s(s_);
    append(reinterpret_cast<const uint8_t *>(s.data()), s.length());
    return *this;
  }
  template <typename R> MatchReal<R, IOBuf &> operator<<(const R &r) {
    append(ZuBoxed(r));
    return *this;
  }
  template <typename P> MatchPrint<P, IOBuf &> operator<<(const P &p) {
    append(p);
    return *this;
  }

  struct Traits : public ZuBaseTraits<IOBuf> {
    using Elem = char;
    enum { IsCString = 0, IsString = 1, IsWString = 0 };
    static char *data(IOBuf &buf) {
      return reinterpret_cast<char *>(buf.data());
    }
    static const char *data(const IOBuf &buf) {
      return reinterpret_cast<const char *>(buf.data());
    }
    static unsigned length(const IOBuf &buf) { return buf.length; }
  };
  friend Traits ZuTraitsType(IOBuf *);
};

template <typename Base, unsigned Size_, typename Heap>
struct IOBufAlloc__ : public Heap, public Base {
  enum { Size = Size_ };

  uint8_t data_[Size];

  IOBufAlloc__() : Base{&data_[0], Size} { }
  template <typename... Args>
  IOBufAlloc__(Args &&...args) : Base{&data_[0], Size, ZuFwd<Args>(args)...} { }

  ~IOBufAlloc__() = default;

private:
  IOBufAlloc__(const IOBufAlloc__ &) = delete;
  IOBufAlloc__ &operator=(const IOBufAlloc__ &) = delete;
  IOBufAlloc__(IOBufAlloc__ &&) = delete;
  IOBufAlloc__ &operator=(IOBufAlloc__ &&) = delete;
};

template <typename Base, unsigned Size, auto HeapID>
using IOBuf_Heap = ZmHeap<HeapID, IOBufAlloc__<Base, Size, ZuEmpty>>;

template <typename Base, unsigned Size, auto HeapID = ZiIOBuf_HeapID>
using IOBufAlloc_ = IOBufAlloc__<Base, Size, IOBuf_Heap<Base, Size, HeapID>>;

template <typename Base>
inline constexpr const unsigned BuiltinSize(unsigned Size) {
  enum { CacheLineSize = Zm::CacheLineSize };

  enum { MinBufSz = sizeof(uintptr_t) << 1 };

  enum { Overhead = sizeof(IOBufAlloc_<Base, MinBufSz>) - MinBufSz };

  return ((Size + Overhead + CacheLineSize - 1) & ~(CacheLineSize - 1)) -
    Overhead;
};

template <typename Base, unsigned Size, auto HeapID>
using IOBufAlloc = IOBufAlloc_<Base, BuiltinSize<Base>(Size), HeapID>;

} // namespace Zi

using ZiIOBuf = Zi::IOBuf;

template <unsigned Size = 1460, auto HeapID = ZiIOBuf_HeapID>
using ZiIOBufAlloc = Zi::IOBufAlloc<ZiIOBuf, Size, HeapID>;

static_assert(
  (!((sizeof(ZiIOBufAlloc<1>)) & (Zm::CacheLineSize - 1))),
  "!((sizeof(ZiIOBufAlloc<1>)) & (Zm::CacheLineSize - 1))"
);

static_assert(

  24

      == 24 &&

    3

      == 3 &&

    25

      == 25,
  "Non-compatible flatbuffers version included"
);

namespace Zfb {

struct Bytes;
struct BytesBuilder;

struct Bitmap;
struct BitmapBuilder;

struct UInt128;

struct Int128;

struct Fixed;

struct Decimal;

struct Time;

struct DateTime;

struct IP;

struct ID;

struct __attribute__((aligned(

  8

)))

UInt128

  final

{
private:
  uint64_t h_;
  uint64_t l_;

public:
  struct Traits;
  UInt128() : h_(0), l_(0) { }
  UInt128(uint64_t _h, uint64_t _l) :
    h_(::flatbuffers::EndianScalar(_h)), l_(::flatbuffers::EndianScalar(_l)) { }
  uint64_t h() const { return ::flatbuffers::EndianScalar(h_); }
  uint64_t l() const { return ::flatbuffers::EndianScalar(l_); }
};

static_assert(
  sizeof(

    UInt128

  ) ==

    16

  ,
  "compiler breaks packing rules"
);

struct UInt128::Traits {
  using type = UInt128;
};

struct __attribute__((aligned(

  8

)))

Int128

  final

{
private:
  uint64_t h_;
  uint64_t l_;

public:
  struct Traits;
  Int128() : h_(0), l_(0) { }
  Int128(uint64_t _h, uint64_t _l) :
    h_(::flatbuffers::EndianScalar(_h)), l_(::flatbuffers::EndianScalar(_l)) { }
  uint64_t h() const { return ::flatbuffers::EndianScalar(h_); }
  uint64_t l() const { return ::flatbuffers::EndianScalar(l_); }
};

static_assert(
  sizeof(

    Int128

  ) ==

    16

  ,
  "compiler breaks packing rules"
);

struct Int128::Traits {
  using type = Int128;
};

struct __attribute__((aligned(

  8

)))

Fixed

  final

{
private:
  int64_t mantissa_;
  uint8_t ndp_;
  int8_t padding0__;
  int16_t padding1__;
  int32_t padding2__;

public:
  struct Traits;
  Fixed() : mantissa_(0), ndp_(0), padding0__(0), padding1__(0), padding2__(0) {
    (void)padding0__;
    (void)padding1__;
    (void)padding2__;
  }
  Fixed(int64_t _mantissa, uint8_t _ndp) :
    mantissa_(::flatbuffers::EndianScalar(_mantissa)),
    ndp_(::flatbuffers::EndianScalar(_ndp)), padding0__(0), padding1__(0),
    padding2__(0) {
    (void)padding0__;
    (void)padding1__;
    (void)padding2__;
  }
  int64_t mantissa() const { return ::flatbuffers::EndianScalar(mantissa_); }
  uint8_t ndp() const { return ::flatbuffers::EndianScalar(ndp_); }
};

static_assert(
  sizeof(

    Fixed

  ) ==

    16

  ,
  "compiler breaks packing rules"
);

struct Fixed::Traits {
  using type = Fixed;
};

struct __attribute__((aligned(

  8

)))

Decimal

  final

{
private:
  uint64_t h_;
  uint64_t l_;

public:
  struct Traits;
  Decimal() : h_(0), l_(0) { }
  Decimal(uint64_t _h, uint64_t _l) :
    h_(::flatbuffers::EndianScalar(_h)), l_(::flatbuffers::EndianScalar(_l)) { }
  uint64_t h() const { return ::flatbuffers::EndianScalar(h_); }
  uint64_t l() const { return ::flatbuffers::EndianScalar(l_); }
};

static_assert(
  sizeof(

    Decimal

  ) ==

    16

  ,
  "compiler breaks packing rules"
);

struct Decimal::Traits {
  using type = Decimal;
};

struct __attribute__((aligned(

  8

)))

Time

  final

{
private:
  int64_t sec_;
  int32_t nsec_;
  int32_t padding0__;

public:
  struct Traits;
  Time() : sec_(0), nsec_(0), padding0__(0) { (void)padding0__; }
  Time(int64_t _sec, int32_t _nsec) :
    sec_(::flatbuffers::EndianScalar(_sec)),
    nsec_(::flatbuffers::EndianScalar(_nsec)), padding0__(0) {
    (void)padding0__;
  }
  int64_t sec() const { return ::flatbuffers::EndianScalar(sec_); }
  int32_t nsec() const { return ::flatbuffers::EndianScalar(nsec_); }
};

static_assert(
  sizeof(

    Time

  ) ==

    16

  ,
  "compiler breaks packing rules"
);

struct Time::Traits {
  using type = Time;
};

struct __attribute__((aligned(

  4

)))

DateTime

  final

{
private:
  int32_t julian_;
  int32_t sec_;
  int32_t nsec_;

public:
  struct Traits;
  DateTime() : julian_(0), sec_(0), nsec_(0) { }
  DateTime(int32_t _julian, int32_t _sec, int32_t _nsec) :
    julian_(::flatbuffers::EndianScalar(_julian)),
    sec_(::flatbuffers::EndianScalar(_sec)),
    nsec_(::flatbuffers::EndianScalar(_nsec)) { }
  int32_t julian() const { return ::flatbuffers::EndianScalar(julian_); }
  int32_t sec() const { return ::flatbuffers::EndianScalar(sec_); }
  int32_t nsec() const { return ::flatbuffers::EndianScalar(nsec_); }
};

static_assert(
  sizeof(

    DateTime

  ) ==

    12

  ,
  "compiler breaks packing rules"
);

struct DateTime::Traits {
  using type = DateTime;
};

struct __attribute__((aligned(

  1

)))

IP

  final

{
private:
  uint8_t addr_[4];

public:
  struct Traits;
  IP() : addr_() { }
  IP(::flatbuffers::span<const uint8_t, 4> _addr) {
    ::flatbuffers::CastToArray(addr_).CopyFromSpan(_addr);
  }
  const ::flatbuffers::Array<uint8_t, 4> *addr() const {
    return &::flatbuffers::CastToArray(addr_);
  }
};

static_assert(
  sizeof(

    IP

  ) ==

    4

  ,
  "compiler breaks packing rules"
);

struct IP::Traits {
  using type = IP;
};

struct __attribute__((aligned(

  1

)))

ID

  final

{
private:
  uint8_t data_[8];

public:
  struct Traits;
  ID() : data_() { }
  ID(::flatbuffers::span<const uint8_t, 8> _data) {
    ::flatbuffers::CastToArray(data_).CopyFromSpan(_data);
  }
  const ::flatbuffers::Array<uint8_t, 8> *data() const {
    return &::flatbuffers::CastToArray(data_);
  }
};

static_assert(
  sizeof(

    ID

  ) ==

    8

  ,
  "compiler breaks packing rules"
);

struct ID::Traits {
  using type = ID;
};

struct Bytes

  final

  : private ::flatbuffers::Table {
  typedef BytesBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset

    : ::flatbuffers::voffset_t

  {
    VT_DATA = 4
  };
  const ::flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_DATA) &&
      verifier.VerifyVector(data()) && verifier.EndTable();
  }
};

struct BytesBuilder {
  typedef Bytes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(Bytes::VT_DATA, data);
  }
  explicit BytesBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Bytes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Bytes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Bytes> CreateBytes(
  ::flatbuffers::FlatBufferBuilder &_fbb,
  ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data = 0
) {
  BytesBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

struct Bytes::Traits {
  using type = Bytes;
  static constexpr auto Create = CreateBytes;
};

inline ::flatbuffers::Offset<Bytes> CreateBytesDirect(
  ::flatbuffers::FlatBufferBuilder &_fbb,
  const std::vector<uint8_t> *data = nullptr
) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return Zfb::CreateBytes(_fbb, data__);
}

struct Bitmap

  final

  : private ::flatbuffers::Table {
  typedef BitmapBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset

    : ::flatbuffers::voffset_t

  {
    VT_DATA = 4
  };
  const ::flatbuffers::Vector<uint64_t> *data() const {
    return GetPointer<const ::flatbuffers::Vector<uint64_t> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_DATA) &&
      verifier.VerifyVector(data()) && verifier.EndTable();
  }
};

struct BitmapBuilder {
  typedef Bitmap Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> data) {
    fbb_.AddOffset(Bitmap::VT_DATA, data);
  }
  explicit BitmapBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Bitmap> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Bitmap>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Bitmap> CreateBitmap(
  ::flatbuffers::FlatBufferBuilder &_fbb,
  ::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> data = 0
) {
  BitmapBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

struct Bitmap::Traits {
  using type = Bitmap;
  static constexpr auto Create = CreateBitmap;
};

inline ::flatbuffers::Offset<Bitmap> CreateBitmapDirect(
  ::flatbuffers::FlatBufferBuilder &_fbb,
  const std::vector<uint64_t> *data = nullptr
) {
  auto data__ = data ? _fbb.CreateVector<uint64_t>(*data) : 0;
  return Zfb::CreateBitmap(_fbb, data__);
}

} // namespace Zfb

namespace Zfb {

using namespace flatbuffers;

using Builder = FlatBufferBuilder;

class IOBuilder : public Allocator, public Builder {
public:
  enum { Align = 8 };

  IOBuilder() :
    Builder{ZiIOBufAlloc<>::Size & ~(Align - 1), this, false, Align},
    m_buf{new ZiIOBufAlloc<>{}} { }
  IOBuilder(ZmRef<ZiIOBuf> buf) :
    Builder{buf->size & ~(Align - 1), this, false, Align}, m_buf{ZuMv(buf)} { }

  IOBuilder(IOBuilder &&) = delete;
  IOBuilder &operator=(IOBuilder &&) = delete;

  void buf(ZmRef<ZiIOBuf> buf) {
    buf->clear();
    Builder::operator=(Builder{buf->size & ~(Align - 1), this, false, Align});
    m_buf = ZuMv(buf);
  }

  ZmRef<ZiIOBuf> buf() {
    if (__builtin_expect(!!(!m_buf), 0)) return nullptr;
    auto buf = ZuMv(m_buf);
    size_t size, skip;
    ReleaseRaw(size, skip);
    buf->skip = skip;
    buf->length = size - skip;
    Clear();
    return buf;
  }

  const ZiIOBuf *cbuf() const { return m_buf.ptr(); }

protected:
  uint8_t *allocate(size_t size) {
    if (__builtin_expect(!!(!m_buf), 0)) m_buf = new ZiIOBufAlloc<>{};
    return m_buf->alloc(size);
  }

  void deallocate(uint8_t *ptr, size_t size) {
    if (m_buf) m_buf->free(ptr);
  }

private:
  static unsigned grow(unsigned, unsigned n) { return n; }

protected:
  uint8_t *reallocate_downward(
    uint8_t *old_p, size_t old_size, size_t new_size, size_t in_use_back,
    size_t in_use_front
  ) {
    return m_buf->template realloc<grow>(
      old_size, new_size, in_use_front, in_use_back
    );
  }

private:
  ZmRef<ZiIOBuf> m_buf;
};

namespace Save {

template <typename T, typename I> inline void push_(T *, I) { }
template <typename T, typename I, typename Arg0, typename... Args>
inline void push_(T *buf, I i, Arg0 &&arg0, Args &&...args) {
  buf[i] = ZuFwd<Arg0>(arg0);
  push_(buf, ZuUnsigned<i + 1>{}, ZuFwd<Args>(args)...);
}

template <typename T, typename L, typename I> inline void lpush_(T *, L, I) { }
template <typename T, typename L, typename I, typename Arg0, typename... Args>
inline void lpush_(T *buf, L l, I i, Arg0 &&arg0, Args &&...args) {
  buf[i] = l(ZuFwd<Arg0>(arg0));
  lpush_(buf, ZuMv(l), ZuUnsigned<i + 1>{}, ZuFwd<Args>(args)...);
}

template <typename Builder, typename T>
inline Offset<Vector<T>> pvector_(Builder &fbb, unsigned length, T *&data) {
  return fbb.CreateUninitializedVector(
    length, sizeof(T), AlignOf<T>(), reinterpret_cast<uint8_t **>(&data)
  );
}

template <typename T, typename Builder, typename... Args>
inline Offset<Vector<T>> pvector(Builder &fbb, Args &&...args) {
  auto n = ZuUnsigned<sizeof...(Args)>{};
  T *buf = nullptr;
  auto r = pvector_(fbb, n, buf);
  if (r.IsNull() || !buf) return {};
  lpush_(buf, [](T v) {
    return EndianScalar(v);
  }, ZuUnsigned<0>{}, ZuFwd<Args>(args)...);
  return r;
}

template <typename T, typename Builder, typename L>
inline Offset<Vector<T>> pvectorIter(Builder &fbb, unsigned n, L l) {
  T *buf = nullptr;
  auto r = pvector_(fbb, n, buf);
  if (r.IsNull() || !buf) return {};
  for (unsigned i = 0; i < n; i++) buf[i] = EndianScalar<T>(l(i));
  return r;
}

template <typename T, typename Builder, typename... Args>
inline Offset<Vector<Offset<T>>> vector(Builder &fbb, Args &&...args) {
  auto n = ZuUnsigned<sizeof...(Args)>{};
  auto buf = ZmAlloc_<Offset<T>>{static_cast<Offset<T> *>(
    !(n) ? nullptr :
	   (((ZmStackAvail() >> 1) < ((n) * sizeof(Offset<T>))) ?
	      Zm::alignedAlloc<alignof(Offset<T>)>((n) * sizeof(Offset<T>)) :
	      __builtin_alloca_with_align(
		(n) * sizeof(Offset<T>), (alignof(Offset<T>)) << 3
	      ))
  )};
  if (!buf) return {};
  push_(buf.ptr, ZuUnsigned<0>{}, ZuFwd<Args>(args)...);
  auto r = fbb.CreateVector(buf.ptr, n);
  return r;
}

template <typename T, typename Builder, typename L, typename... Args>
inline Offset<Vector<Offset<T>>> lvector(Builder &fbb, L l, Args &&...args) {
  auto n = ZuUnsigned<sizeof...(Args)>{};
  auto buf = ZmAlloc_<Offset<T>>{static_cast<Offset<T> *>(
    !(n) ? nullptr :
	   (((ZmStackAvail() >> 1) < ((n) * sizeof(Offset<T>))) ?
	      Zm::alignedAlloc<alignof(Offset<T>)>((n) * sizeof(Offset<T>)) :
	      __builtin_alloca_with_align(
		(n) * sizeof(Offset<T>), (alignof(Offset<T>)) << 3
	      ))
  )};
  if (!buf) return {};
  lpush_(buf.ptr, ZuMv(l), ZuUnsigned<0>{}, ZuFwd<Args>(args)...);
  auto r = fbb.CreateVector(buf.ptr, n);
  return r;
}

template <typename T, typename Builder, typename L>
inline Offset<Vector<Offset<T>>> vectorIter(Builder &fbb, unsigned n, L l) {
  auto buf = ZmAlloc_<Offset<T>>{static_cast<Offset<T> *>(
    !(n) ? nullptr :
	   (((ZmStackAvail() >> 1) < ((n) * sizeof(Offset<T>))) ?
	      Zm::alignedAlloc<alignof(Offset<T>)>((n) * sizeof(Offset<T>)) :
	      __builtin_alloca_with_align(
		(n) * sizeof(Offset<T>), (alignof(Offset<T>)) << 3
	      ))
  )};
  if (!buf) return {};
  for (unsigned i = 0; i < n; i++) buf.ptr[i] = l(fbb, i);
  auto r = fbb.CreateVector(buf.ptr, n);
  return r;
}

template <typename T, typename Builder, typename L>
inline Offset<Vector<const T *>> structVecIter(Builder &fbb, unsigned n, L l) {
  return fbb.template CreateVectorOfStructs<T>(
    n, [l = ZuMv(l)](size_t i, T *ptr, void *) { l(ptr, i); },
    static_cast<void *>(nullptr)
  );
}

template <typename T, typename Builder, typename... Args>
inline Offset<Vector<Offset<T>>> keyVec(Builder &fbb, Args &&...args) {
  auto n = ZuUnsigned<sizeof...(Args)>{};
  auto buf = ZmAlloc_<Offset<T>>{static_cast<Offset<T> *>(
    !(n) ? nullptr :
	   (((ZmStackAvail() >> 1) < ((n) * sizeof(Offset<T>))) ?
	      Zm::alignedAlloc<alignof(Offset<T>)>((n) * sizeof(Offset<T>)) :
	      __builtin_alloca_with_align(
		(n) * sizeof(Offset<T>), (alignof(Offset<T>)) << 3
	      ))
  )};
  if (!buf) return {};
  push_(buf.ptr, ZuUnsigned<0>{}, ZuFwd<Args>(args)...);
  auto r = fbb.CreateVectorOfSortedTables(buf.ptr, n);
  return r;
}

template <typename T, typename Builder, typename L, typename... Args>
inline Offset<Vector<Offset<T>>> lkeyVec(Builder &fbb, L l, Args &&...args) {
  auto n = ZuUnsigned<sizeof...(Args)>{};
  auto buf = ZmAlloc_<Offset<T>>{static_cast<Offset<T> *>(
    !(n) ? nullptr :
	   (((ZmStackAvail() >> 1) < ((n) * sizeof(Offset<T>))) ?
	      Zm::alignedAlloc<alignof(Offset<T>)>((n) * sizeof(Offset<T>)) :
	      __builtin_alloca_with_align(
		(n) * sizeof(Offset<T>), (alignof(Offset<T>)) << 3
	      ))
  )};
  if (!buf) return {};
  lpush_(buf.ptr, ZuMv(l), ZuUnsigned<0>{}, ZuFwd<Args>(args)...);
  auto r = fbb.CreateVectorOfSortedTables(buf.ptr, n);
  return r;
}

template <typename T, typename Builder, typename L>
inline Offset<Vector<Offset<T>>> keyVecIter(Builder &fbb, unsigned n, L l) {
  auto buf = ZmAlloc_<Offset<T>>{static_cast<Offset<T> *>(
    !(n) ? nullptr :
	   (((ZmStackAvail() >> 1) < ((n) * sizeof(Offset<T>))) ?
	      Zm::alignedAlloc<alignof(Offset<T>)>((n) * sizeof(Offset<T>)) :
	      __builtin_alloca_with_align(
		(n) * sizeof(Offset<T>), (alignof(Offset<T>)) << 3
	      ))
  )};
  if (!buf) return {};
  for (unsigned i = 0; i < n; i++) buf[i] = l(fbb, i);
  auto r = fbb.CreateVectorOfSortedTables(buf.ptr, n);
  return r;
}

template <typename Builder> inline auto str(Builder &fbb, ZuCSpan s) {
  auto o = fbb.CreateString(s.data(), s.length());
  return o;
}

template <unsigned N> inline auto strN(ZuCSpan s) -> span<const uint8_t, N> {
  return {
    span<const uint8_t, N>{reinterpret_cast<const uint8_t *>(s.data()), N}
  };
}

template <typename Builder, typename... Args>
inline auto strVec(Builder &fbb, Args &&...args) {
  return lvector<String>(fbb, [&fbb](const auto &s) {
    return str(fbb, s);
  }, ZuFwd<Args>(args)...);
}

template <typename Builder, typename L>
inline auto strVecIter(Builder &fbb, unsigned n, L l) {
  return vectorIter<String>(
    fbb, n,
    [l = ZuMv(l)](Builder &fbb, unsigned i) mutable { return str(fbb, l(i)); }
  );
}

template <typename Builder>
inline auto bytes(Builder &fbb, const void *data, unsigned len) {
  return fbb.CreateVector(static_cast<const uint8_t *>(data), len);
}

template <typename Builder> inline auto bytes(Builder &fbb, ZuBytes b) {
  return fbb.CreateVector(b.data(), b.length());
}

inline auto fixed(const ZuFixed &v) {
  return Fixed{static_cast<int64_t>(v.mantissa), static_cast<uint8_t>(v.ndp)};
}

inline auto decimal(const ZuDecimal &v) {
  return Decimal{
    static_cast<uint64_t>(v.value >> 64), static_cast<uint64_t>(v.value)
  };
}

inline Time time(const ZuTime &v) { return {v.sec(), int32_t(v.nsec())}; }

inline DateTime dateTime(const ZuDateTime &v) {
  return {v.julian(), v.sec(), v.nsec()};
}

inline auto int128(const int128_t &v) {
  return Int128{static_cast<uint64_t>(v >> 64), static_cast<uint64_t>(v)};
}

inline auto uint128(const uint128_t &v) {
  return UInt128{static_cast<uint64_t>(v >> 64), static_cast<uint64_t>(v)};
}

template <typename Builder, unsigned Bits>
inline Offset<Bitmap> bitmap(Builder &fbb, const ZuBitmap<Bits> &v) {
  unsigned n = Bits >> 6;
  return CreateBitmap(fbb, pvectorIter<uint64_t>(fbb, n, [&v](unsigned i) {
    return v.data[i];
  }));
}
template <typename Builder>
inline Offset<Bitmap> bitmap(Builder &fbb, const ZmBitmap &v) {
  int n = v.last();
  if (__builtin_expect(!!(n <= 0), 0)) return {};
  n = (n + 0x40) >> 6;
  return CreateBitmap(fbb, pvectorIter<uint64_t>(fbb, n, [&v](unsigned i) {
    return hwloc_bitmap_to_ith_ulong(v, i);
  }));
}
template <typename Builder>
inline Offset<Bitmap> bitmap(Builder &fbb, const ZtBitmap &v) {
  unsigned n = v.data.length();
  return CreateBitmap(fbb, pvectorIter<uint64_t>(fbb, n, [&v](unsigned i) {
    return v.data[i];
  }));
}

inline IP ip(ZiIP addr) {
  return {
    span<const uint8_t, 4>{reinterpret_cast<const uint8_t *>(&addr.s_addr), 4}
  };
}

inline ID id(ZuID id) {
  return {
    span<const uint8_t, 8>{reinterpret_cast<const uint8_t *>(id.data()), 8}
  };
}

extern int save(const Zi::Path &path, Builder &fbb, unsigned mode, ZeError *e);

namespace Nest {

struct Builder : public Zfb::Builder {
  auto alignment() const { return Builder::minalign_; }
};
inline auto alignment(const Zfb::Builder &fbb) {
  return static_cast<const Builder &>(fbb).alignment();
}
}
template <typename L> inline Offset<Vector<uint8_t>> nest(Builder &fbb, L l) {
  auto o = fbb.GetSize();
  uoffset_t root = l(fbb).o;
  fbb.PreAlign(sizeof(uoffset_t), Nest::alignment(fbb));
  fbb.PushElement(fbb.ReferTo(root));
  o = fbb.GetSize() - o;
  return {fbb.PushElement(o)};
}

} // namespace Save

namespace Load {

template <typename T, typename L> inline void all(T *v, L l) {
  if (__builtin_expect(!!(v), 1))
    for (unsigned i = 0, n = v->size(); i < n; i++) l(i, v->Get(i));
}

inline ZuCSpan str(const String *s) {
  if (!s) return {};
  return {reinterpret_cast<const char *>(s->Data()), s->size()};
}

template <unsigned N> inline ZuCSpan strN(const Array<uint8_t, N> *s) {
  if (!s) return {};
  auto data = reinterpret_cast<const char *>(s->Data());
  if (data[N - 1]) return {data, N};
  return {data};
}

inline ZuBytes bytes(const Vector<uint8_t> *v) {
  if (!v) return {};
  return {v->data(), v->size()};
}

inline ZuFixed fixed(const Fixed *v) {
  return ZuFixed{v->mantissa(), v->ndp()};
}

inline ZuDecimal decimal(const Decimal *v) {
  return ZuDecimal{
    ZuDecimal::Unscaled{(static_cast<int128_t>(v->h()) << 64) | v->l()}
  };
}

inline auto time(const Time *v) {
  return ZuTime{int64_t(v->sec()), int32_t(v->nsec())};
}

inline auto dateTime(const DateTime *v) {
  return ZuDateTime{ZuDateTime::Julian{v->julian()}, v->sec(), v->nsec()};
}

inline int128_t int128(const Int128 *v) {
  return (int128_t(v->h()) << 64) | v->l();
}

inline uint128_t uint128(const UInt128 *v) {
  return (uint128_t(v->h()) << 64) | v->l();
}

template <typename T> struct IsZuBitmap : public ZuFalse { };
template <unsigned Bits> struct IsZuBitmap<ZuBitmap<Bits>> : public ZuTrue { };
template <typename T, typename R = void>
using MatchZuBitmap = ZuIfT<IsZuBitmap<T>{}, R>;
template <typename T, decltype(MatchZuBitmap<T>(), int()) = 0>
inline T bitmap(const Bitmap *bitmap) {
  if (!bitmap || !bitmap->data()) return T{};
  auto vec = bitmap->data();
  unsigned n = vec->size();
  T b;
  if (n > T::Words) n = T::Words;
  for (unsigned i = 0; i < n; i++) b.data[i] = vec->Get(i);
  return b;
}
template <typename T, decltype(ZuExact<ZmBitmap, T>(), int()) = 0>
inline T bitmap(const Bitmap *bitmap) {
  if (!bitmap || !bitmap->data()) return T{};
  auto vec = bitmap->data();
  unsigned n = vec->size();
  T b;
  if (n) {
    --n;
    hwloc_bitmap_from_ith_ulong(b, n, vec->Get(n));
    while (n--) hwloc_bitmap_set_ith_ulong(b, n, vec->Get(n));
  }
  return b;
}
template <typename T, decltype(ZuExact<ZtBitmap, T>(), int()) = 0>
inline T bitmap(const Bitmap *bitmap) {
  if (!bitmap || !bitmap->data()) return T{};
  auto vec = bitmap->data();
  unsigned n = vec->size();
  T b;
  b.data.length(n);
  for (unsigned i = 0; i < n; i++) b.data[i] = vec->Get(i);
  return b;
}

inline ZiIP ip(const IP *v) {
  struct in_addr addr;
  addr.s_addr = *reinterpret_cast<const uint32_t *>(v->addr()->data());
  return ZiIP{ZuMv(addr)};
}

inline ZuID id(const ID *v) {
  if (!v) return {};
  return {*reinterpret_cast<const uint64_t *>(v->data()->data())};
}

using LoadFn = ZmFn<bool(ZuBytes)>;
extern int load(const Zi::Path &path, LoadFn, unsigned maxSize, ZeError *e);

} // namespace Load

} // namespace Zfb

static_assert(

  24

      == 24 &&

    3

      == 3 &&

    25

      == 25,
  "Non-compatible flatbuffers version included"
);

namespace Ztel { namespace fbs {

enum class ThreadPriority : int8_t {
  RealTime = 0,
  High = 1,
  Normal = 2,
  Low = 3,
  MIN = RealTime,
  MAX = Low
};

inline const ThreadPriority (&EnumValuesThreadPriority())[4] {
  static const ThreadPriority values[] = {
    ThreadPriority::RealTime, ThreadPriority::High, ThreadPriority::Normal,
    ThreadPriority::Low
  };
  return values;
}

inline const char *const *EnumNamesThreadPriority() {
  static const char *const names[5] = {
    "RealTime", "High", "Normal", "Low", nullptr
  };
  return names;
}

inline const char *EnumNameThreadPriority(ThreadPriority e) {
  if (::flatbuffers::IsOutRange(
	e, ThreadPriority::RealTime, ThreadPriority::Low
      ))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesThreadPriority()[index];
}

}} // namespace Ztel::fbs

namespace ZvThreadPriority {
namespace fbs = Ztel::fbs;
using T = ZuUnder<fbs::ThreadPriority>;
enum _ {
  Invalid = -1,
  RealTime = int(fbs::ThreadPriority::RealTime),
  High = int(fbs::ThreadPriority::High),
  Normal = int(fbs::ThreadPriority::Normal),
  Low = int(fbs::ThreadPriority::Low),
  MIN = int(fbs::ThreadPriority::MIN),
  MAX = int(fbs::ThreadPriority::MAX),
  N = int(fbs::ThreadPriority::MAX) + 1
};
static_assert((N <= 1024), "N <= 1024");
enum {
  Bits = N <= 2 ? 1 :
    N <= 4      ? 2 :
    N <= 8      ? 3 :
    N <= 16     ? 4 :
    N <= 32     ? 5 :
    N <= 64     ? 6 :
    N <= 128    ? 7 :
    N <= 256    ? 8 :
    N <= 512    ? 9 :
		  10
};
template <typename Impl> struct Map_ : public ZuObject {
private:
  using S2V = ZmLHashKV<ZuCSpan, T, ZmLHashStatic<Bits, ZmLHashLock<ZmNoLock>>>;

protected:
  void init(const char *s, int v, ...) {
    if (__builtin_expect(!!(!s), 0)) return;
    add(s, v);
    va_list args;

    __builtin_va_start(

      args

      ,

      v

    );
    while (s =

	     __builtin_va_arg(

	       args

	       ,

	       const char *

	     )

    )
      add(
	s,
	v =

	  __builtin_va_arg(

	    args

	    ,

	    int

	  )

      );

    __builtin_va_end(

      args

    );
  }
  void add(ZuCSpan s, T v) { m_s2v.add(s, v); }

private:
  T s2v_(ZuCSpan s) const { return m_s2v.findVal(s); }
  template <typename L> void all_(L l) const {
    auto i = m_s2v.readIterator();
    while (auto kv = i.iterate()) { l(S2V::KeyAxor(*kv), S2V::ValAxor(*kv)); }
  }

public:
  static constexpr const char *id() { return "ThreadPriority"; }
  using FBEnum = fbs::ThreadPriority;
  Map_() = default;
  static Impl *instance() { return ZmSingleton<Impl>::instance(); }
  static ZuCSpan v2s(int v) {
    return fbs::EnumNameThreadPriority(static_cast<FBEnum>(v));
  }
  static T s2v(ZuCSpan s) { return instance()->s2v_(s); }
  template <typename L> static void all(L l) { instance()->all_(ZuMv(l)); }

private:
  S2V m_s2v;
};
const char *name(int i) {
  return fbs::EnumNameThreadPriority(static_cast<fbs::ThreadPriority>(i));
}
struct Map : public Map_<Map> {
  Map() {
    for (unsigned i = 0; i < N; i++) this->add(name(i), i);
  }
};
template <typename S> T lookup(const S &s) { return Map::s2v(s); }
static_assert(
  (RealTime == ZmThreadPriority::RealTime),
  "RealTime == ZmThreadPriority::RealTime"
);
static_assert(
  (High == ZmThreadPriority::High), "High == ZmThreadPriority::High"
);
static_assert(
  (Normal == ZmThreadPriority::Normal), "Normal == ZmThreadPriority::Normal"
);
static_assert((Low == ZmThreadPriority::Low), "Low == ZmThreadPriority::Low");
;
} // namespace ZvThreadPriority

struct ZvThreadParams : public ZmThreadParams {
  ZvThreadParams(const ZmThreadParams &p) : ZmThreadParams{p} { }
  ZvThreadParams &operator=(const ZmThreadParams &p) {
    ZmThreadParams::operator=(p);
    return *this;
  }
  ZvThreadParams(ZmThreadParams &&p) : ZmThreadParams{ZuMv(p)} { }
  ZvThreadParams &operator=(ZmThreadParams &&p) {
    ZmThreadParams::operator=(ZuMv(p));
    return *this;
  }

  ZvThreadParams(const ZvCf *cf) { init(cf); }
  ZvThreadParams(const ZvCf *cf, ZmThreadParams deflt) :
    ZmThreadParams{ZuMv(deflt)} {
    init(cf);
  }

  void init(const ZvCf *cf) {
    ZmThreadParams::operator=(ZmThreadParams{});

    if (!cf) return;

    static unsigned ncpu = Zm::getncpu();
    stackSize(cf->getInt("stackSize", 16384, 2 << 20, stackSize()));
    priority(
      cf->getEnum<ZvThreadPriority::Map>("priority", ZmThreadPriority::Normal)
    );
    partition(cf->getInt("partition", 0, ncpu - 1, 0));
    cpuset(cf->get("cpuset"));
  }
};

class ZvInvalidMulticastIP : public ZvError {
public:
  ZvInvalidMulticastIP(ZuCSpan s) : m_addr{s} { }

  void print_(ZuVStream &s) const {
    s << "invalid multicast IP \"" << m_addr << '"';
  }

private:
  ZtString m_addr;
};

struct ZvCxnOptions : public ZiCxnOptions {
  ZvCxnOptions() : ZiCxnOptions{} { }

  ZvCxnOptions(const ZiCxnOptions &p) : ZiCxnOptions{p} { }
  ZvCxnOptions &operator=(const ZiCxnOptions &p) {
    ZiCxnOptions::operator=(p);
    return *this;
  }

  ZvCxnOptions(const ZvCf *cf) : ZiCxnOptions{} { init(cf); }

  ZvCxnOptions(const ZvCf *cf, const ZiCxnOptions &deflt) :
    ZiCxnOptions{deflt} {
    init(cf);
  }

  void init(const ZvCf *cf) {
    if (!cf) return;

    flags(cf->getFlags<ZiCxnFlags::Map>("options", 0));

    if (multicast()) {
      if (ZuCSpan s = cf->get("multicastInterface")) mif(s);
      ttl(cf->getInt(
	"multicastTTL", 0, 0x7fffffff

	,
	ttl()
      ));
      if (ZmRef<ZvCf> groups = cf->getCf("multicastGroups")) {
	groups->all([this](const ZvCfNode *node) {
	  ZiIP addr{node->key}, mif{node->get<true>()};
	  if (!addr || !addr.multicast()) throw ZvInvalidMulticastIP{node->key};
	  mreq(ZiMReq(addr, mif));
	});
      }
    }
    if (netlink()) familyName(cf->get("familyName", true));
  }
};

struct ZvMxParams : public ZiMxParams {
  ZvMxParams() = default;
  ZvMxParams(ZuCSpan id, const ZvCf *cf) { init(id, cf); }
  ZvMxParams(ZuCSpan id, const ZvCf *cf, ZiMxParams &&deflt) :
    ZiMxParams{ZuMv(deflt)} {
    init(id, cf);
  }

  void init(ZuCSpan id, const ZvCf *cf) {
    if (!cf) return;

    {
      ZmSchedParams &sched = scheduler();
      static unsigned ncpu = Zm::getncpu();

      sched.id(id);
      sched.nThreads(cf->getInt("nThreads", 1, 1024, sched.nThreads()));
      sched.stackSize(cf->getInt("stackSize", 16384, 2 << 20, sched.stackSize())
      );
      sched.priority(
	cf->getEnum<ZvThreadPriority::Map>("priority", ZmThreadPriority::Normal)
      );
      sched.partition(cf->getInt("partition", 0, ncpu - 1, 0));
      if (ZuCSpan s = cf->get("quantum"))
	sched.quantum((double)ZuBox<double>(s));
      sched.queueSize(
	cf->getInt("queueSize", 8192, (1U << 30U), sched.queueSize())
      );
      sched.ll(cf->getBool("ll", sched.ll()));
      sched.spin(cf->getInt(
	"spin", 0, 0x7fffffff

	,
	sched.spin()
      ));
      sched.timeout(cf->getInt("timeout", 0, 3600, sched.timeout()));
      sched.startTimer(cf->getBool("startTimer", sched.startTimer()));
      if (ZmRef<ZvCf> threadsCf = cf->getCf("threads")) {
	threadsCf->all([&sched](ZvCfNode *node) {
	  if (auto threadCf = node->getCf()) {
	    auto sid = ZvCf_::scanInt(
	      threadCf, "threads", node->key, 1, sched.nThreads()
	    );
	    ZmSchedParams::Thread &thread = sched.thread(sid);
	    thread.isolated(threadCf->getBool("isolated", thread.isolated()));
	    if (ZuCSpan s = threadCf->get("name")) thread.name(s);
	    thread.stackSize(threadCf->getInt(
	      "stackSize", 0, 0x7fffffff

	      ,
	      thread.stackSize()
	    ));
	    if (ZuCSpan s = threadCf->get("priority"))
	      thread.priority(ZvEnum::s2v<ZvThreadPriority::Map, false>(
		"priority", s, ZmThreadPriority::Normal
	      ));
	    thread.partition(threadCf->getInt(
	      "partition", 0, 0x7fffffff

	      ,
	      thread.partition()
	    ));
	    if (ZuCSpan s = threadCf->get("cpuset")) thread.cpuset(s);
	    thread.detached(threadCf->getBool("detached", thread.detached()));
	  }
	});
      }
    }

    if (ZuCSpan s = cf->get("rxThread")) rxThread(scheduler().sid(s));
    if (ZuCSpan s = cf->get("txThread")) txThread(scheduler().sid(s));

    epollMaxFDs(cf->getInt("epollMaxFDs", 1, 100000, epollMaxFDs()));
    epollQuantum(cf->getInt("epollQuantum", 1, 1024, epollQuantum()));

    rxBufSize(cf->getInt(
      "rcvBufSize", 0, 0x7fffffff

      ,
      rxBufSize()
    ));
    txBufSize(cf->getInt(
      "sndBufSize", 0, 0x7fffffff

      ,
      txBufSize()
    ));

    trace(cf->getBool("trace", trace()));
    debug(cf->getBool("debug", debug()));
    frag(cf->getBool("frag", frag()));
    yield(cf->getBool("yield", yield()));
  }
};

namespace ZtCase {

inline bool isupper__(char c) { return c >= 'A' && c <= 'Z'; }
inline char toupper__(char c) {
  return c + (static_cast<int>('A') - static_cast<int>('a'));
}
inline bool islower__(char c) { return c >= 'a' && c <= 'z'; }
inline char tolower__(char c) {
  return c + (static_cast<int>('a') - static_cast<int>('A'));
}

template <typename L> inline void snakeCamel(ZuCSpan s, L l) {
  unsigned n = s.length();
  unsigned o = 0;
  bool underscore = false;
  for (unsigned i = 0; i < n; i++) {
    auto c = s[i];
    if (underscore) {
      if (islower__(c)) ++o;
      underscore = false;
    } else {
      if (c == '_') underscore = true;
    }
  }
  unsigned m = n - o;
  unsigned z = m + 1;
  auto buf = ZmAlloc_<char>{static_cast<char *>(
    !(z) ?
      nullptr :
      (((ZmStackAvail() >> 1) < ((z) * sizeof(char))) ?
	 Zm::alignedAlloc<alignof(char)>((z) * sizeof(char)) :
	 __builtin_alloca_with_align((z) * sizeof(char), (alignof(char)) << 3))
  )};
  buf[m] = 0;
  underscore = false;
  unsigned j = 0;
  for (unsigned i = 0; i < n; i++) {
    auto c = s[i];
    if (underscore) {
      if (islower__(c))
	buf[j++] = toupper__(c);
      else {
	buf[j++] = '_';
	buf[j++] = c;
      }
      underscore = false;
    } else {
      if (c == '_')
	underscore = true;
      else
	buf[j++] = c;
    }
  }
  if (underscore) buf[j++] = '_';
  ((j == m) ? void() :
	      ZmAssert_fail(
		"j == m", "../../zt/src/zlib/ZtCase.hh", 70, __PRETTY_FUNCTION__
	      ));
  ZtString r{&buf[0], m, z, false};
  l(static_cast<const ZtString &>(r));
}

template <typename L> inline void camelSnake(ZuCSpan s, L l) {
  unsigned n = s.length();
  unsigned o = 0;
  for (unsigned i = 0; i < n; i++) {
    auto c = s[i];
    if (isupper__(c)) ++o;
  }
  unsigned m = n + o;
  unsigned z = m + 1;
  auto buf = ZmAlloc_<char>{static_cast<char *>(
    !(z) ?
      nullptr :
      (((ZmStackAvail() >> 1) < ((z) * sizeof(char))) ?
	 Zm::alignedAlloc<alignof(char)>((z) * sizeof(char)) :
	 __builtin_alloca_with_align((z) * sizeof(char), (alignof(char)) << 3))
  )};
  buf[m] = 0;
  unsigned j = 0;
  for (unsigned i = 0; i < n; i++) {
    auto c = s[i];
    if (isupper__(c)) {
      buf[j++] = '_';
      buf[j++] = tolower__(c);
    } else
      buf[j++] = c;
  }
  ((j == m) ? void() :
	      ZmAssert_fail(
		"j == m", "../../zt/src/zlib/ZtCase.hh", 97, __PRETTY_FUNCTION__
	      ));
  ZtString r{&buf[0], m, z, false};
  l(static_cast<const ZtString &>(r));
}

} // namespace ZtCase

extern "C" {

  extern void __assert_fail(
    const char *__assertion, const char *__file, unsigned int __line,
    const char *__function
  ) noexcept(true) __attribute__((__noreturn__));

  extern void __assert_perror_fail(
    int __errnum, const char *__file, unsigned int __line,
    const char *__function
  ) noexcept(true) __attribute__((__noreturn__));

  extern void __assert(
    const char *__assertion, const char *__file, int __line
  ) noexcept(true) __attribute__((__noreturn__));
}

void ZfbBuilder_(...);
void ZfbType_(...);
void ZfbUnder_(...);
void ZfbSchema_(...);

template <typename O>
using Zfb_Builder = decltype(ZfbBuilder_(ZuDeclVal<O *>()));
template <typename O> using Zfb_Type = decltype(ZfbType_(ZuDeclVal<O *>()));
template <typename O> using Zfb_Schema = decltype(ZfbSchema_(ZuDeclVal<O *>()));

template <typename O> struct ZfbUnder__ {
  using T = decltype(ZfbUnder_(ZuDeclVal<O *>()));
};
template <typename O, typename Tuple, typename Fields>
struct ZfbUnder__<ZuFieldTuple_<O, Tuple, Fields>> {
  using T = O;
};
template <typename O> using ZfbUnder = typename ZfbUnder__<O>::T;

template <typename O>
using ZfbBuilder = decltype(ZfbBuilder_(ZuDeclVal<ZfbUnder<O> *>()));
template <typename O>
using ZfbType = decltype(ZfbType_(ZuDeclVal<ZfbUnder<O> *>()));
template <typename O>
using ZfbSchema = decltype(ZfbSchema_(ZuDeclVal<ZfbUnder<O> *>()));

namespace ZfbField {

namespace TypeCode = ZtFieldTypeCode;
namespace Prop = ZuFieldProp;

template <typename T> using Offset = Zfb::Offset<T>;

template <typename Field> struct IsNested : public ZuBool<!Field::Inline> { };
template <
  typename O, typename NestedFields, typename Field, bool = IsNested<Field>{}>
struct SaveFieldFn {
  template <typename Builder>
  static void save(Builder &fbb, const O &o, const Offset<void> *) {
    Field::save(fbb, o);
  }
};
template <typename O, typename NestedFields, typename Field>
struct SaveFieldFn<O, NestedFields, Field, true> {
  template <typename Builder>
  static void save(Builder &fbb, const O &, const Offset<void> *offsets) {
    using OffsetIndex = ZuTypeIndex<Field, NestedFields>;
    Field::save(fbb, offsets[OffsetIndex{}]);
  }
};
template <
  typename O, typename Fields,
  typename NestedFields = ZuTypeGrep<IsNested, Fields>, unsigned = Fields::N,
  unsigned = NestedFields::N>
struct SaveFieldsFn {
  using Builder = ZfbBuilder<O>;
  using FBType = ZfbType<O>;
  static Offset<FBType> save(Zfb::Builder &fbb_, const O &o) {
    Offset<void> offsets[NestedFields::N];
    ZuUnroll::all<NestedFields>([&fbb_, &o,
				 offsets = &offsets[0]]<typename Field>() {
      using OffsetIndex = ZuTypeIndex<Field, NestedFields>;
      offsets[OffsetIndex{}] = Field::save(fbb_, o);
    });
    Builder fbb{fbb_};
    ZuUnroll::all<Fields>([&fbb, &o, offsets = &offsets[0]]<typename Field>() {
      SaveFieldFn<O, NestedFields, Field>::save(fbb, o, offsets);
    });
    return fbb.Finish();
  }
};
template <typename O, typename Fields, typename NestedFields, unsigned N>
struct SaveFieldsFn<O, Fields, NestedFields, N, 0> {
  using Builder = ZfbBuilder<O>;
  using FBType = ZfbType<O>;
  static Offset<FBType> save(Zfb::Builder &fbb_, const O &o) {
    Builder fbb{fbb_};
    ZuUnroll::all<Fields>([&fbb, &o]<typename Field>() { Field::save(fbb, o); }
    );
    return fbb.Finish();
  }
};
template <typename O, typename Fields, typename NestedFields>
struct SaveFieldsFn<O, Fields, NestedFields, 0, 0> {
  using Builder = ZfbBuilder<O>;
  using FBType = ZfbType<O>;
  static Offset<FBType> save(Zfb::Builder &fbb_, const O &) {
    Builder fbb{fbb_};
    return fbb.Finish();
  }
};

template <typename O_> struct Fielded_ {
  using O = O_;

  using AllFields = ZuFields<O>;

  template <typename U> struct LoadFilter : public ZuBool<!U::ReadOnly> { };
  using LoadFields = ZuTypeGrep<LoadFilter, AllFields>;

  template <typename U> using CtorFilter = Prop::HasCtor<typename U::Props>;
  template <typename U> using CtorIndex = Prop::GetCtor<typename U::Props>;
  using CtorFields = ZuTypeSort<CtorIndex, ZuTypeGrep<CtorFilter, AllFields>>;

  template <typename U>
  using InitFilter = ZuBool<!Prop::HasCtor<typename U::Props>{}>;
  using InitFields = ZuTypeGrep<InitFilter, LoadFields>;

  template <typename U>
  using SaveFilter =
    ZuBool<bool(Prop::HasCtor<typename U::Props>{}) || !U::ReadOnly>;
  using SaveFields = ZuTypeGrep<SaveFilter, AllFields>;

  template <typename U>
  using UpdFilter = ZuBool<
    bool(ZuTypeIn<Prop::Mutable, typename U::Props>{}) ||
    bool(ZuFieldProp::Key<typename U::Props, 0>{})>;
  using UpdFields = ZuTypeGrep<UpdFilter, LoadFields>;

  using DelFields = ZuKeyFields<O, 0>;

  using FBType = ZfbType<O>;

  static Offset<FBType> save(Zfb::Builder &fbb, const O &o) {
    return SaveFieldsFn<O, SaveFields>::save(fbb, o);
  }
  static Offset<FBType> saveUpd(Zfb::Builder &fbb, const O &o) {
    return SaveFieldsFn<O, UpdFields>::save(fbb, o);
  }
  static Offset<FBType> saveDel(Zfb::Builder &fbb, const O &o) {
    return SaveFieldsFn<O, DelFields>::save(fbb, o);
  }

  template <typename... Fields> struct Ctor {
    static O ctor(const FBType *fbo) { return O{Fields::load_(fbo)...}; }
    static void ctor(void *o, const FBType *fbo) {
      new (o) O{Fields::load_(fbo)...};
    }
  };
  static O ctor(const FBType *fbo) {
    O o = ZuTypeApply<Ctor, CtorFields>::ctor(fbo);
    ZuUnroll::all<InitFields>([&o, fbo]<typename Field>() {
      Field::load(o, fbo);
    });
    return o;
  }
  static void ctor(void *o_, const FBType *fbo) {
    ZuTypeApply<Ctor, CtorFields>::ctor(o_, fbo);
    O &o = *static_cast<O *>(o_);
    ZuUnroll::all<InitFields>([&o, fbo]<typename Field>() {
      Field::load(o, fbo);
    });
  }

  template <typename... Field> struct Load__ : public O {
    Load__() = default;
    Load__(const FBType *fbo) : O{Field::load_(fbo)...} { }
    template <typename... Args>
    Load__(Args &&...args) : O{ZuFwd<Args>(args)...} { }
  };
  using Load_ = ZuTypeApply<Load__, CtorFields>;
  struct Load : public Load_ {
    Load() = default;
    Load(const FBType *fbo) : Load_{fbo} {
      ZuUnroll::all<InitFields>([this, fbo]<typename Field>() {
	Field::load(*this, fbo);
      });
    }
    template <typename... Args>
    Load(Args &&...args) : Load_{ZuFwd<Args>(args)...} { }
  };

  static void load(O &o, const FBType *fbo) {
    ZuUnroll::all<LoadFields>([&o, fbo]<typename Field>() {
      Field::load(o, fbo);
    });
  }
  static void update(O &o, const FBType *fbo) {
    ZuUnroll::all<UpdFields>([&o, fbo]<typename Field>() {
      Field::load(o, fbo);
    });
  }

  template <typename Base> struct Adapted : public Base {
    using Orig = Base;
    template <template <typename> typename Override>
    using Adapt = Adapted<Override<Orig>>;
    using O = FBType;
    enum { ReadOnly = true };
    enum { I = ZuTypeIndex<Orig, ZuTypeMap<ZuFieldOrig, AllFields>>{} };

  private:
    template <typename> struct CtorFilter : public ZuTrue { };
    template <unsigned J>
    struct CtorFilter<ZuFieldProp::Ctor<J>> : public ZuFalse { };

  public:
    using Props = ZuTypeGrep<CtorFilter, typename Orig::Props>;
    using Field = ZuType<I, AllFields>;
    static decltype(auto) get(const O &o) { return Field::load_(&o); }
    template <typename U> static void set(O &, U &&v);
  };
  template <typename Field> using Map = typename Field::template Adapt<Adapted>;
  using FBFields = ZuTypeMap<Map, AllFields>;
};
template <typename O> using Fielded = Fielded_<ZuFielded<O>>;

template <typename O> inline auto save(Zfb::Builder &fbb, const O &o) {
  return Fielded<O>::save(fbb, o);
}
template <typename O> inline auto saveUpd(Zfb::Builder &fbb, const O &o) {
  return Fielded<O>::saveUpd(fbb, o);
}
template <typename O> inline auto saveDel(Zfb::Builder &fbb, const O &o) {
  return Fielded<O>::saveDel(fbb, o);
}

template <typename O> inline const ZfbType<O> *root(const uint8_t *data) {
  return Zfb::GetRoot<ZfbType<O>>(data);
}

template <typename O> inline const ZfbType<O> *verify(ZuBytes data) {
  if (!Zfb::Verifier{&data[0], data.length()}.VerifyBuffer<ZfbType<O>>())
    return nullptr;
  return root<O>(&data[0]);
}

template <typename O> inline O ctor(const ZfbType<O> *fbo) {
  return Fielded<O>::ctor(fbo);
}
template <typename O> inline void ctor(void *o_, const ZfbType<O> *fbo) {
  Fielded<O>::ctor(o_, fbo);
}

template <typename O> using Load = typename Fielded<O>::Load;

template <typename O> inline void load(O &o, const ZfbType<O> *fbo) {
  Fielded<O>::load(o, fbo);
}
template <typename O> inline void update(O &o, const ZfbType<O> *fbo) {
  Fielded<O>::update(o, fbo);
}

template <typename O> using Fields = typename Fielded<O>::FBFields;

} // namespace ZfbField

namespace Zfb {

namespace Save {

template <typename Builder, typename O>
inline auto object(Builder &fbb, const O &o) {
  return ZfbField::save(fbb, o);
}

template <typename Builder>
inline auto cstringVec(Builder &fbb, ZtField_::CStringVec a) {
  using CString = const char *;
  return vectorIter<String>(
    fbb, a.length(),
    [&a](Builder &fbb, unsigned i) mutable { return str(fbb, CString(a[i])); }
  );
}
template <typename Builder>
inline auto stringVec(Builder &fbb, ZtField_::StringVec a) {
  return vectorIter<String>(
    fbb, a.length(),
    [&a](Builder &fbb, unsigned i) mutable { return str(fbb, ZuCSpan(a[i])); }
  );
}

template <typename Builder>
inline auto bytesVec(Builder &fbb, ZtField_::BytesVec a) {
  return vectorIter<Bytes>(
    fbb, a.length(),
    [&a](Builder &fbb, unsigned i) mutable {
    return Zfb::CreateBytes(fbb, bytes(fbb, ZuBytes(a[i])));
  }
  );
}

template <typename Builder>
inline auto int8Vec(Builder &fbb, ZtField_::Int8Vec a) {
  return pvectorIter<int8_t>(fbb, a.length(), [&a](unsigned i) mutable {
    return int8_t(a[i]);
  });
}
template <typename Builder>
inline auto uint8Vec(Builder &fbb, ZtField_::UInt8Vec a) {
  return pvectorIter<uint8_t>(fbb, a.length(), [&a](unsigned i) mutable {
    return uint8_t(a[i]);
  });
}
template <typename Builder>
inline auto int16Vec(Builder &fbb, ZtField_::Int16Vec a) {
  return pvectorIter<int16_t>(fbb, a.length(), [&a](unsigned i) mutable {
    return int16_t(a[i]);
  });
}
template <typename Builder>
inline auto uint16Vec(Builder &fbb, ZtField_::UInt16Vec a) {
  return pvectorIter<uint16_t>(fbb, a.length(), [&a](unsigned i) mutable {
    return uint16_t(a[i]);
  });
}
template <typename Builder>
inline auto int32Vec(Builder &fbb, ZtField_::Int32Vec a) {
  return pvectorIter<int32_t>(fbb, a.length(), [&a](unsigned i) mutable {
    return int32_t(a[i]);
  });
}
template <typename Builder>
inline auto uint32Vec(Builder &fbb, ZtField_::UInt32Vec a) {
  return pvectorIter<uint32_t>(fbb, a.length(), [&a](unsigned i) mutable {
    return uint32_t(a[i]);
  });
}
template <typename Builder>
inline auto int64Vec(Builder &fbb, ZtField_::Int64Vec a) {
  return pvectorIter<int64_t>(fbb, a.length(), [&a](unsigned i) mutable {
    return int64_t(a[i]);
  });
}
template <typename Builder>
inline auto uint64Vec(Builder &fbb, ZtField_::UInt64Vec a) {
  return pvectorIter<uint64_t>(fbb, a.length(), [&a](unsigned i) mutable {
    return uint64_t(a[i]);
  });
}

template <typename Builder>
inline auto int128Vec(Builder &fbb, ZtField_::Int128Vec a) {
  return structVecIter<Int128>(
    fbb, a.length(),
    [&a](Int128 *ptr, unsigned i) mutable {
    new (ptr) Int128{int128(int128_t(a[i]))};
  }
  );
}
template <typename Builder>
inline auto uint128Vec(Builder &fbb, ZtField_::UInt128Vec a) {
  return structVecIter<UInt128>(
    fbb, a.length(),
    [&a](UInt128 *ptr, unsigned i) mutable {
    new (ptr) UInt128{uint128(uint128_t(a[i]))};
  }
  );
}
template <typename Builder>
inline auto floatVec(Builder &fbb, ZtField_::FloatVec a) {
  return pvectorIter<double>(fbb, a.length(), [&a](unsigned i) mutable {
    return double(a[i]);
  });
}
template <typename Builder>
inline auto fixedVec(Builder &fbb, ZtField_::FixedVec a) {
  return structVecIter<Fixed>(
    fbb, a.length(),
    [&a](Fixed *ptr, unsigned i) mutable {
    new (ptr) Fixed{fixed(ZuFixed(a[i]))};
  }
  );
}
template <typename Builder>
inline auto decimalVec(Builder &fbb, ZtField_::DecimalVec a) {
  return structVecIter<Decimal>(
    fbb, a.length(),
    [&a](Decimal *ptr, unsigned i) mutable {
    new (ptr) Decimal{decimal(ZuDecimal(a[i]))};
  }
  );
}
template <typename Builder>
inline auto timeVec(Builder &fbb, ZtField_::TimeVec a) {
  return structVecIter<Time>(
    fbb, a.length(),
    [&a](Time *ptr, unsigned i) mutable { new (ptr) Time{time(ZuTime(a[i]))}; }
  );
}
template <typename Builder>
inline auto dateTimeVec(Builder &fbb, ZtField_::DateTimeVec a) {
  return structVecIter<DateTime>(
    fbb, a.length(),
    [&a](DateTime *ptr, unsigned i) mutable {
    new (ptr) DateTime{dateTime(ZuDateTime(a[i]))};
  }
  );
}
} // namespace Save

namespace Load {

template <typename O> inline O object(const ZfbType<O> *fbo) {
  return ZfbField::ctor<O>(fbo);
}

inline const ZtField_::CStringVec cstringVec(const Vector<Offset<String>> *v) {
  if (!v) return {};
  using Vec = Vector<Offset<String>>;
  return ZtField_::CStringVec(
    *const_cast<Vec *>(v), v->size(),
    [](const void *v_, unsigned i) {
    return reinterpret_cast<const char *>(
      static_cast<const Vec *>(v_)->Get(i)->Data()
    );
  }
  );
}
inline const ZtField_::StringVec stringVec(const Vector<Offset<String>> *v) {
  if (!v) return {};
  using Vec = Vector<Offset<String>>;
  return ZtField_::StringVec(
    *const_cast<Vec *>(v), v->size(),
    [](const void *v_, unsigned i) {
    return str(static_cast<const Vec *>(v_)->Get(i));
  }
  );
}
inline const ZtField_::BytesVec bytesVec(const Vector<Offset<Bytes>> *v) {
  if (!v) return {};
  using Vec = Vector<Offset<Bytes>>;
  return ZtField_::BytesVec(
    *const_cast<Vec *>(v), v->size(),
    [](const void *v_, unsigned i) {
    return bytes(static_cast<const Vec *>(v_)->Get(i)->data());
  }
  );
}

inline const ZtField_::Int8Vec int8Vec(const Vector<int8_t> *v) {
  if (!v) return {};
  using Vec = Vector<int8_t>;
  return ZtField_::Int8Vec(
    *const_cast<Vec *>(v), v->size(),
    [](const void *v_, unsigned i) -> int8_t {
    return static_cast<const Vec *>(v_)->Get(i);
  }
  );
}
inline const ZtField_::UInt8Vec uint8Vec(const Vector<uint8_t> *v) {
  if (!v) return {};
  using Vec = Vector<uint8_t>;
  return ZtField_::UInt8Vec(
    *const_cast<Vec *>(v), v->size(),
    [](const void *v_, unsigned i) -> uint8_t {
    return static_cast<const Vec *>(v_)->Get(i);
  }
  );
}
inline const ZtField_::Int16Vec int16Vec(const Vector<int16_t> *v) {
  if (!v) return {};
  using Vec = Vector<int16_t>;
  return ZtField_::Int16Vec(
    *const_cast<Vec *>(v), v->size(),
    [](const void *v_, unsigned i) -> int16_t {
    return static_cast<const Vec *>(v_)->Get(i);
  }
  );
}
inline const ZtField_::UInt16Vec uint16Vec(const Vector<uint16_t> *v) {
  if (!v) return {};
  using Vec = Vector<uint16_t>;
  return ZtField_::UInt16Vec(
    *const_cast<Vec *>(v), v->size(),
    [](const void *v_, unsigned i) -> uint16_t {
    return static_cast<const Vec *>(v_)->Get(i);
  }
  );
}
inline const ZtField_::Int32Vec int32Vec(const Vector<int32_t> *v) {
  if (!v) return {};
  using Vec = Vector<int32_t>;
  return ZtField_::Int32Vec(
    *const_cast<Vec *>(v), v->size(),
    [](const void *v_, unsigned i) -> int32_t {
    return static_cast<const Vec *>(v_)->Get(i);
  }
  );
}
inline const ZtField_::UInt32Vec uint32Vec(const Vector<uint32_t> *v) {
  if (!v) return {};
  using Vec = Vector<uint32_t>;
  return ZtField_::UInt32Vec(
    *const_cast<Vec *>(v), v->size(),
    [](const void *v_, unsigned i) -> uint32_t {
    return static_cast<const Vec *>(v_)->Get(i);
  }
  );
}
inline const ZtField_::Int64Vec int64Vec(const Vector<int64_t> *v) {
  if (!v) return {};
  using Vec = Vector<int64_t>;
  return ZtField_::Int64Vec(
    *const_cast<Vec *>(v), v->size(),
    [](const void *v_, unsigned i) -> int64_t {
    return static_cast<const Vec *>(v_)->Get(i);
  }
  );
}
inline const ZtField_::UInt64Vec uint64Vec(const Vector<uint64_t> *v) {
  if (!v) return {};
  using Vec = Vector<uint64_t>;
  return ZtField_::UInt64Vec(
    *const_cast<Vec *>(v), v->size(),
    [](const void *v_, unsigned i) -> uint64_t {
    return static_cast<const Vec *>(v_)->Get(i);
  }
  );
}

inline const ZtField_::Int128Vec int128Vec(const Vector<const Int128 *> *v) {
  if (!v) return {};
  using Vec = Vector<const Int128 *>;
  return ZtField_::Int128Vec(
    *const_cast<Vec *>(v), v->size(),
    [](const void *v_, unsigned i) {
    return int128_t(int128(static_cast<const Vec *>(v_)->Get(i)));
  }
  );
}
inline const ZtField_::UInt128Vec uint128Vec(const Vector<const UInt128 *> *v) {
  if (!v) return {};
  using Vec = Vector<const UInt128 *>;
  return ZtField_::UInt128Vec(
    *const_cast<Vec *>(v), v->size(),
    [](const void *v_, unsigned i) {
    return uint128_t(uint128(static_cast<const Vec *>(v_)->Get(i)));
  }
  );
}

inline const ZtField_::FloatVec floatVec(const Vector<double> *v) {
  if (!v) return {};
  using Vec = Vector<double>;
  return ZtField_::FloatVec(
    *const_cast<Vec *>(v), v->size(),
    [](const void *v_, unsigned i) {
    return static_cast<const Vec *>(v_)->Get(i);
  }
  );
}

inline const ZtField_::FixedVec fixedVec(const Vector<const Fixed *> *v) {
  if (!v) return {};
  using Vec = Vector<const Fixed *>;
  return ZtField_::FixedVec(
    *const_cast<Vec *>(v), v->size(),
    [](const void *v_, unsigned i) {
    return fixed(static_cast<const Vec *>(v_)->Get(i));
  }
  );
}
inline const ZtField_::DecimalVec decimalVec(const Vector<const Decimal *> *v) {
  if (!v) return {};
  using Vec = Vector<const Decimal *>;
  return ZtField_::DecimalVec(
    *const_cast<Vec *>(v), v->size(),
    [](const void *v_, unsigned i) {
    return decimal(static_cast<const Vec *>(v_)->Get(i));
  }
  );
}
inline const ZtField_::TimeVec timeVec(const Vector<const Time *> *v) {
  if (!v) return {};
  using Vec = Vector<const Time *>;
  return ZtField_::TimeVec(
    *const_cast<Vec *>(v), v->size(),
    [](const void *v_, unsigned i) {
    return time(static_cast<const Vec *>(v_)->Get(i));
  }
  );
}
inline const ZtField_::DateTimeVec
dateTimeVec(const Vector<const DateTime *> *v) {
  if (!v) return {};
  using Vec = Vector<const DateTime *>;
  return ZtField_::DateTimeVec(
    *const_cast<Vec *>(v), v->size(),
    [](const void *v_, unsigned i) {
    return dateTime(static_cast<const Vec *>(v_)->Get(i));
  }
  );
}
} // namespace Load

} // namespace Zfb

namespace ZuBitmap_ {
template <unsigned Bits> inline ZuID ZtVFieldTypeID(Bitmap<Bits> *) {
  return "Bitmap";
}
}
namespace ZmBitmap_ {
inline ZuID ZtVFieldTypeID(Bitmap *) { return "Bitmap"; }
}
namespace ZtBitmap_ {
inline ZuID ZtVFieldTypeID(Bitmap *) { return "Bitmap"; }
}

inline ZuID ZtVFieldTypeID(ZiIP *) { return "IP"; }

inline ZuID ZtVFieldTypeID(ZuID *) { return "ID"; }

static_assert(
  24 == 24 && 3 == 3 && 25 == 25, "Non-compatible flatbuffers version included"
);

namespace reflection {

struct Type;
struct TypeBuilder;

struct KeyValue;
struct KeyValueBuilder;

struct EnumVal;
struct EnumValBuilder;

struct Enum;
struct EnumBuilder;

struct Field;
struct FieldBuilder;

struct Object;
struct ObjectBuilder;

struct RPCCall;
struct RPCCallBuilder;

struct Service;
struct ServiceBuilder;

struct SchemaFile;
struct SchemaFileBuilder;

struct Schema;
struct SchemaBuilder;

enum BaseType {
  None = 0,
  UType = 1,
  Bool = 2,
  Byte = 3,
  UByte = 4,
  Short = 5,
  UShort = 6,
  Int = 7,
  UInt = 8,
  Long = 9,
  ULong = 10,
  Float = 11,
  Double = 12,
  String = 13,
  Vector = 14,
  Obj = 15,
  Union = 16,
  Array = 17,
  Vector64 = 18,
  MaxBaseType = 19
};

inline const BaseType (&EnumValuesBaseType())[20] {
  static const BaseType values[] = {None,   UType,  Bool,     Byte,
				    UByte,  Short,  UShort,   Int,
				    UInt,   Long,   ULong,    Float,
				    Double, String, Vector,   Obj,
				    Union,  Array,  Vector64, MaxBaseType};
  return values;
}

inline const char *const *EnumNamesBaseType() {
  static const char *const names[21] = {
    "None",   "UType", "Bool",  "Byte",  "UByte",    "Short",       "UShort",
    "Int",    "UInt",  "Long",  "ULong", "Float",    "Double",      "String",
    "Vector", "Obj",   "Union", "Array", "Vector64", "MaxBaseType", nullptr
  };
  return names;
}

inline const char *EnumNameBaseType(BaseType e) {
  if (::flatbuffers::IsOutRange(e, None, MaxBaseType)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBaseType()[index];
}

enum AdvancedFeatures {
  AdvancedArrayFeatures = 1ULL,
  AdvancedUnionFeatures = 2ULL,
  OptionalScalars = 4ULL,
  DefaultVectorsAndStrings = 8ULL
};

inline const AdvancedFeatures (&EnumValuesAdvancedFeatures())[4] {
  static const AdvancedFeatures values[] = {
    AdvancedArrayFeatures, AdvancedUnionFeatures, OptionalScalars,
    DefaultVectorsAndStrings
  };
  return values;
}

inline const char *const *EnumNamesAdvancedFeatures() {
  static const char *const names[9] = {
    "AdvancedArrayFeatures",
    "AdvancedUnionFeatures",
    "",
    "OptionalScalars",
    "",
    "",
    "",
    "DefaultVectorsAndStrings",
    nullptr
  };
  return names;
}

inline const char *EnumNameAdvancedFeatures(AdvancedFeatures e) {
  if (::flatbuffers::IsOutRange(
	e, AdvancedArrayFeatures, DefaultVectorsAndStrings
      ))
    return "";
  const size_t index =
    static_cast<size_t>(e) - static_cast<size_t>(AdvancedArrayFeatures);
  return EnumNamesAdvancedFeatures()[index];
}

struct Type final : private ::flatbuffers::Table {
  typedef TypeBuilder Builder;
  enum FlatBuffersVTableOffset : ::flatbuffers::voffset_t {
    VT_BASE_TYPE = 4,
    VT_ELEMENT = 6,
    VT_INDEX = 8,
    VT_FIXED_LENGTH = 10,
    VT_BASE_SIZE = 12,
    VT_ELEMENT_SIZE = 14
  };
  reflection::BaseType base_type() const {
    return static_cast<reflection::BaseType>(GetField<int8_t>(VT_BASE_TYPE, 0));
  }
  reflection::BaseType element() const {
    return static_cast<reflection::BaseType>(GetField<int8_t>(VT_ELEMENT, 0));
  }
  int32_t index() const { return GetField<int32_t>(VT_INDEX, -1); }
  uint16_t fixed_length() const {
    return GetField<uint16_t>(VT_FIXED_LENGTH, 0);
  }

  uint32_t base_size() const { return GetField<uint32_t>(VT_BASE_SIZE, 4); }

  uint32_t element_size() const {
    return GetField<uint32_t>(VT_ELEMENT_SIZE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
      VerifyField<int8_t>(verifier, VT_BASE_TYPE, 1) &&
      VerifyField<int8_t>(verifier, VT_ELEMENT, 1) &&
      VerifyField<int32_t>(verifier, VT_INDEX, 4) &&
      VerifyField<uint16_t>(verifier, VT_FIXED_LENGTH, 2) &&
      VerifyField<uint32_t>(verifier, VT_BASE_SIZE, 4) &&
      VerifyField<uint32_t>(verifier, VT_ELEMENT_SIZE, 4) &&
      verifier.EndTable();
  }
};

struct TypeBuilder {
  typedef Type Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_base_type(reflection::BaseType base_type) {
    fbb_.AddElement<int8_t>(
      Type::VT_BASE_TYPE, static_cast<int8_t>(base_type), 0
    );
  }
  void add_element(reflection::BaseType element) {
    fbb_.AddElement<int8_t>(Type::VT_ELEMENT, static_cast<int8_t>(element), 0);
  }
  void add_index(int32_t index) {
    fbb_.AddElement<int32_t>(Type::VT_INDEX, index, -1);
  }
  void add_fixed_length(uint16_t fixed_length) {
    fbb_.AddElement<uint16_t>(Type::VT_FIXED_LENGTH, fixed_length, 0);
  }
  void add_base_size(uint32_t base_size) {
    fbb_.AddElement<uint32_t>(Type::VT_BASE_SIZE, base_size, 4);
  }
  void add_element_size(uint32_t element_size) {
    fbb_.AddElement<uint32_t>(Type::VT_ELEMENT_SIZE, element_size, 0);
  }
  explicit TypeBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Type> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Type>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Type> CreateType(
  ::flatbuffers::FlatBufferBuilder &_fbb,
  reflection::BaseType base_type = reflection::None,
  reflection::BaseType element = reflection::None, int32_t index = -1,
  uint16_t fixed_length = 0, uint32_t base_size = 4, uint32_t element_size = 0
) {
  TypeBuilder builder_(_fbb);
  builder_.add_element_size(element_size);
  builder_.add_base_size(base_size);
  builder_.add_index(index);
  builder_.add_fixed_length(fixed_length);
  builder_.add_element(element);
  builder_.add_base_type(base_type);
  return builder_.Finish();
}

struct KeyValue final : private ::flatbuffers::Table {
  typedef KeyValueBuilder Builder;
  enum FlatBuffersVTableOffset : ::flatbuffers::voffset_t {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  const ::flatbuffers::String *key() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KEY);
  }
  bool KeyCompareLessThan(const KeyValue *const o) const {
    return *key() < *o->key();
  }
  int KeyCompareWithValue(const char *_key) const {
    return strcmp(key()->c_str(), _key);
  }
  template <typename StringType>
  int KeyCompareWithValue(const StringType &_key) const {
    if (key()->c_str() < _key) return -1;
    if (_key < key()->c_str()) return 1;
    return 0;
  }
  const ::flatbuffers::String *value() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
      VerifyOffsetRequired(verifier, VT_KEY) && verifier.VerifyString(key()) &&
      VerifyOffset(verifier, VT_VALUE) && verifier.VerifyString(value()) &&
      verifier.EndTable();
  }
};

struct KeyValueBuilder {
  typedef KeyValue Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_key(::flatbuffers::Offset<::flatbuffers::String> key) {
    fbb_.AddOffset(KeyValue::VT_KEY, key);
  }
  void add_value(::flatbuffers::Offset<::flatbuffers::String> value) {
    fbb_.AddOffset(KeyValue::VT_VALUE, value);
  }
  explicit KeyValueBuilder(::flatbuffers::FlatBufferBuilder &_fbb) :
    fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<KeyValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<KeyValue>(end);
    fbb_.Required(o, KeyValue::VT_KEY);
    return o;
  }
};

inline ::flatbuffers::Offset<KeyValue> CreateKeyValue(
  ::flatbuffers::FlatBufferBuilder &_fbb,
  ::flatbuffers::Offset<::flatbuffers::String> key = 0,
  ::flatbuffers::Offset<::flatbuffers::String> value = 0
) {
  KeyValueBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<KeyValue> CreateKeyValueDirect(
  ::flatbuffers::FlatBufferBuilder &_fbb, const char *key = nullptr,
  const char *value = nullptr
) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return reflection::CreateKeyValue(_fbb, key__, value__);
}

struct EnumVal final : private ::flatbuffers::Table {
  typedef EnumValBuilder Builder;
  enum FlatBuffersVTableOffset : ::flatbuffers::voffset_t {
    VT_NAME = 4,
    VT_VALUE = 6,
    VT_UNION_TYPE = 10,
    VT_DOCUMENTATION = 12,
    VT_ATTRIBUTES = 14
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  int64_t value() const { return GetField<int64_t>(VT_VALUE, 0); }
  bool KeyCompareLessThan(const EnumVal *const o) const {
    return value() < o->value();
  }
  int KeyCompareWithValue(int64_t _value) const {
    return static_cast<int>(value() > _value) -
      static_cast<int>(value() < _value);
  }
  const reflection::Type *union_type() const {
    return GetPointer<const reflection::Type *>(VT_UNION_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *
  documentation() const {
    return GetPointer<const ::flatbuffers::Vector<
      ::flatbuffers::Offset<::flatbuffers::String>> *>(VT_DOCUMENTATION);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<reflection::KeyValue>> *
  attributes() const {
    return GetPointer<const ::flatbuffers::Vector<
      ::flatbuffers::Offset<reflection::KeyValue>> *>(VT_ATTRIBUTES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
      VerifyOffsetRequired(verifier, VT_NAME) &&
      verifier.VerifyString(name()) &&
      VerifyField<int64_t>(verifier, VT_VALUE, 8) &&
      VerifyOffset(verifier, VT_UNION_TYPE) &&
      verifier.VerifyTable(union_type()) &&
      VerifyOffset(verifier, VT_DOCUMENTATION) &&
      verifier.VerifyVector(documentation()) &&
      verifier.VerifyVectorOfStrings(documentation()) &&
      VerifyOffset(verifier, VT_ATTRIBUTES) &&
      verifier.VerifyVector(attributes()) &&
      verifier.VerifyVectorOfTables(attributes()) && verifier.EndTable();
  }
};

struct EnumValBuilder {
  typedef EnumVal Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(EnumVal::VT_NAME, name);
  }
  void add_value(int64_t value) {
    fbb_.AddElement<int64_t>(EnumVal::VT_VALUE, value, 0);
  }
  void add_union_type(::flatbuffers::Offset<reflection::Type> union_type) {
    fbb_.AddOffset(EnumVal::VT_UNION_TYPE, union_type);
  }
  void add_documentation(
    ::flatbuffers::Offset<
      ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>>
      documentation
  ) {
    fbb_.AddOffset(EnumVal::VT_DOCUMENTATION, documentation);
  }
  void add_attributes(
    ::flatbuffers::Offset<
      ::flatbuffers::Vector<::flatbuffers::Offset<reflection::KeyValue>>>
      attributes
  ) {
    fbb_.AddOffset(EnumVal::VT_ATTRIBUTES, attributes);
  }
  explicit EnumValBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EnumVal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EnumVal>(end);
    fbb_.Required(o, EnumVal::VT_NAME);
    return o;
  }
};

inline ::flatbuffers::Offset<EnumVal> CreateEnumVal(
  ::flatbuffers::FlatBufferBuilder &_fbb,
  ::flatbuffers::Offset<::flatbuffers::String> name = 0, int64_t value = 0,
  ::flatbuffers::Offset<reflection::Type> union_type = 0,
  ::flatbuffers::Offset<
    ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>>
    documentation = 0,
  ::flatbuffers::Offset<
    ::flatbuffers::Vector<::flatbuffers::Offset<reflection::KeyValue>>>
    attributes = 0
) {
  EnumValBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_attributes(attributes);
  builder_.add_documentation(documentation);
  builder_.add_union_type(union_type);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<EnumVal> CreateEnumValDirect(
  ::flatbuffers::FlatBufferBuilder &_fbb, const char *name = nullptr,
  int64_t value = 0, ::flatbuffers::Offset<reflection::Type> union_type = 0,
  const std::vector<::flatbuffers::Offset<::flatbuffers::String>>
    *documentation = nullptr,
  std::vector<::flatbuffers::Offset<reflection::KeyValue>> *attributes = nullptr
) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto documentation__ = documentation ?
    _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(
      *documentation
    ) :
    0;
  auto attributes__ = attributes ?
    _fbb.CreateVectorOfSortedTables<reflection::KeyValue>(attributes) :
    0;
  return reflection::CreateEnumVal(
    _fbb, name__, value, union_type, documentation__, attributes__
  );
}

struct Enum final : private ::flatbuffers::Table {
  typedef EnumBuilder Builder;
  enum FlatBuffersVTableOffset : ::flatbuffers::voffset_t {
    VT_NAME = 4,
    VT_VALUES = 6,
    VT_IS_UNION = 8,
    VT_UNDERLYING_TYPE = 10,
    VT_ATTRIBUTES = 12,
    VT_DOCUMENTATION = 14,
    VT_DECLARATION_FILE = 16
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  bool KeyCompareLessThan(const Enum *const o) const {
    return *name() < *o->name();
  }
  int KeyCompareWithValue(const char *_name) const {
    return strcmp(name()->c_str(), _name);
  }
  template <typename StringType>
  int KeyCompareWithValue(const StringType &_name) const {
    if (name()->c_str() < _name) return -1;
    if (_name < name()->c_str()) return 1;
    return 0;
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<reflection::EnumVal>> *
  values() const {
    return GetPointer<const ::flatbuffers::Vector<
      ::flatbuffers::Offset<reflection::EnumVal>> *>(VT_VALUES);
  }
  bool is_union() const { return GetField<uint8_t>(VT_IS_UNION, 0) != 0; }
  const reflection::Type *underlying_type() const {
    return GetPointer<const reflection::Type *>(VT_UNDERLYING_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<reflection::KeyValue>> *
  attributes() const {
    return GetPointer<const ::flatbuffers::Vector<
      ::flatbuffers::Offset<reflection::KeyValue>> *>(VT_ATTRIBUTES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *
  documentation() const {
    return GetPointer<const ::flatbuffers::Vector<
      ::flatbuffers::Offset<::flatbuffers::String>> *>(VT_DOCUMENTATION);
  }

  const ::flatbuffers::String *declaration_file() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DECLARATION_FILE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
      VerifyOffsetRequired(verifier, VT_NAME) &&
      verifier.VerifyString(name()) &&
      VerifyOffsetRequired(verifier, VT_VALUES) &&
      verifier.VerifyVector(values()) &&
      verifier.VerifyVectorOfTables(values()) &&
      VerifyField<uint8_t>(verifier, VT_IS_UNION, 1) &&
      VerifyOffsetRequired(verifier, VT_UNDERLYING_TYPE) &&
      verifier.VerifyTable(underlying_type()) &&
      VerifyOffset(verifier, VT_ATTRIBUTES) &&
      verifier.VerifyVector(attributes()) &&
      verifier.VerifyVectorOfTables(attributes()) &&
      VerifyOffset(verifier, VT_DOCUMENTATION) &&
      verifier.VerifyVector(documentation()) &&
      verifier.VerifyVectorOfStrings(documentation()) &&
      VerifyOffset(verifier, VT_DECLARATION_FILE) &&
      verifier.VerifyString(declaration_file()) && verifier.EndTable();
  }
};

struct EnumBuilder {
  typedef Enum Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Enum::VT_NAME, name);
  }
  void
  add_values(::flatbuffers::Offset<
	     ::flatbuffers::Vector<::flatbuffers::Offset<reflection::EnumVal>>>
	       values) {
    fbb_.AddOffset(Enum::VT_VALUES, values);
  }
  void add_is_union(bool is_union) {
    fbb_.AddElement<uint8_t>(
      Enum::VT_IS_UNION, static_cast<uint8_t>(is_union), 0
    );
  }
  void
  add_underlying_type(::flatbuffers::Offset<reflection::Type> underlying_type) {
    fbb_.AddOffset(Enum::VT_UNDERLYING_TYPE, underlying_type);
  }
  void add_attributes(
    ::flatbuffers::Offset<
      ::flatbuffers::Vector<::flatbuffers::Offset<reflection::KeyValue>>>
      attributes
  ) {
    fbb_.AddOffset(Enum::VT_ATTRIBUTES, attributes);
  }
  void add_documentation(
    ::flatbuffers::Offset<
      ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>>
      documentation
  ) {
    fbb_.AddOffset(Enum::VT_DOCUMENTATION, documentation);
  }
  void add_declaration_file(
    ::flatbuffers::Offset<::flatbuffers::String> declaration_file
  ) {
    fbb_.AddOffset(Enum::VT_DECLARATION_FILE, declaration_file);
  }
  explicit EnumBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Enum> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Enum>(end);
    fbb_.Required(o, Enum::VT_NAME);
    fbb_.Required(o, Enum::VT_VALUES);
    fbb_.Required(o, Enum::VT_UNDERLYING_TYPE);
    return o;
  }
};

inline ::flatbuffers::Offset<Enum> CreateEnum(
  ::flatbuffers::FlatBufferBuilder &_fbb,
  ::flatbuffers::Offset<::flatbuffers::String> name = 0,
  ::flatbuffers::Offset<
    ::flatbuffers::Vector<::flatbuffers::Offset<reflection::EnumVal>>>
    values = 0,
  bool is_union = false,
  ::flatbuffers::Offset<reflection::Type> underlying_type = 0,
  ::flatbuffers::Offset<
    ::flatbuffers::Vector<::flatbuffers::Offset<reflection::KeyValue>>>
    attributes = 0,
  ::flatbuffers::Offset<
    ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>>
    documentation = 0,
  ::flatbuffers::Offset<::flatbuffers::String> declaration_file = 0
) {
  EnumBuilder builder_(_fbb);
  builder_.add_declaration_file(declaration_file);
  builder_.add_documentation(documentation);
  builder_.add_attributes(attributes);
  builder_.add_underlying_type(underlying_type);
  builder_.add_values(values);
  builder_.add_name(name);
  builder_.add_is_union(is_union);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Enum> CreateEnumDirect(
  ::flatbuffers::FlatBufferBuilder &_fbb, const char *name = nullptr,
  std::vector<::flatbuffers::Offset<reflection::EnumVal>> *values = nullptr,
  bool is_union = false,
  ::flatbuffers::Offset<reflection::Type> underlying_type = 0,
  std::vector<::flatbuffers::Offset<reflection::KeyValue>> *attributes =
    nullptr,
  const std::vector<::flatbuffers::Offset<::flatbuffers::String>>
    *documentation = nullptr,
  const char *declaration_file = nullptr
) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto values__ =
    values ? _fbb.CreateVectorOfSortedTables<reflection::EnumVal>(values) : 0;
  auto attributes__ = attributes ?
    _fbb.CreateVectorOfSortedTables<reflection::KeyValue>(attributes) :
    0;
  auto documentation__ = documentation ?
    _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(
      *documentation
    ) :
    0;
  auto declaration_file__ =
    declaration_file ? _fbb.CreateString(declaration_file) : 0;
  return reflection::CreateEnum(
    _fbb, name__, values__, is_union, underlying_type, attributes__,
    documentation__, declaration_file__
  );
}

struct Field final : private ::flatbuffers::Table {
  typedef FieldBuilder Builder;
  enum FlatBuffersVTableOffset : ::flatbuffers::voffset_t {
    VT_NAME = 4,
    VT_TYPE = 6,
    VT_ID = 8,
    VT_OFFSET = 10,
    VT_DEFAULT_INTEGER = 12,
    VT_DEFAULT_REAL = 14,
    VT_DEPRECATED = 16,
    VT_REQUIRED = 18,
    VT_KEY = 20,
    VT_ATTRIBUTES = 22,
    VT_DOCUMENTATION = 24,
    VT_OPTIONAL = 26,
    VT_PADDING = 28,
    VT_OFFSET64 = 30
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  bool KeyCompareLessThan(const Field *const o) const {
    return *name() < *o->name();
  }
  int KeyCompareWithValue(const char *_name) const {
    return strcmp(name()->c_str(), _name);
  }
  template <typename StringType>
  int KeyCompareWithValue(const StringType &_name) const {
    if (name()->c_str() < _name) return -1;
    if (_name < name()->c_str()) return 1;
    return 0;
  }
  const reflection::Type *type() const {
    return GetPointer<const reflection::Type *>(VT_TYPE);
  }
  uint16_t id() const { return GetField<uint16_t>(VT_ID, 0); }
  uint16_t offset() const { return GetField<uint16_t>(VT_OFFSET, 0); }
  int64_t default_integer() const {
    return GetField<int64_t>(VT_DEFAULT_INTEGER, 0);
  }
  double default_real() const { return GetField<double>(VT_DEFAULT_REAL, 0.0); }
  bool deprecated() const { return GetField<uint8_t>(VT_DEPRECATED, 0) != 0; }
  bool required() const { return GetField<uint8_t>(VT_REQUIRED, 0) != 0; }
  bool key() const { return GetField<uint8_t>(VT_KEY, 0) != 0; }
  const ::flatbuffers::Vector<::flatbuffers::Offset<reflection::KeyValue>> *
  attributes() const {
    return GetPointer<const ::flatbuffers::Vector<
      ::flatbuffers::Offset<reflection::KeyValue>> *>(VT_ATTRIBUTES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *
  documentation() const {
    return GetPointer<const ::flatbuffers::Vector<
      ::flatbuffers::Offset<::flatbuffers::String>> *>(VT_DOCUMENTATION);
  }
  bool optional() const { return GetField<uint8_t>(VT_OPTIONAL, 0) != 0; }

  uint16_t padding() const { return GetField<uint16_t>(VT_PADDING, 0); }

  bool offset64() const { return GetField<uint8_t>(VT_OFFSET64, 0) != 0; }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
      VerifyOffsetRequired(verifier, VT_NAME) &&
      verifier.VerifyString(name()) &&
      VerifyOffsetRequired(verifier, VT_TYPE) && verifier.VerifyTable(type()) &&
      VerifyField<uint16_t>(verifier, VT_ID, 2) &&
      VerifyField<uint16_t>(verifier, VT_OFFSET, 2) &&
      VerifyField<int64_t>(verifier, VT_DEFAULT_INTEGER, 8) &&
      VerifyField<double>(verifier, VT_DEFAULT_REAL, 8) &&
      VerifyField<uint8_t>(verifier, VT_DEPRECATED, 1) &&
      VerifyField<uint8_t>(verifier, VT_REQUIRED, 1) &&
      VerifyField<uint8_t>(verifier, VT_KEY, 1) &&
      VerifyOffset(verifier, VT_ATTRIBUTES) &&
      verifier.VerifyVector(attributes()) &&
      verifier.VerifyVectorOfTables(attributes()) &&
      VerifyOffset(verifier, VT_DOCUMENTATION) &&
      verifier.VerifyVector(documentation()) &&
      verifier.VerifyVectorOfStrings(documentation()) &&
      VerifyField<uint8_t>(verifier, VT_OPTIONAL, 1) &&
      VerifyField<uint16_t>(verifier, VT_PADDING, 2) &&
      VerifyField<uint8_t>(verifier, VT_OFFSET64, 1) && verifier.EndTable();
  }
};

struct FieldBuilder {
  typedef Field Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Field::VT_NAME, name);
  }
  void add_type(::flatbuffers::Offset<reflection::Type> type) {
    fbb_.AddOffset(Field::VT_TYPE, type);
  }
  void add_id(uint16_t id) { fbb_.AddElement<uint16_t>(Field::VT_ID, id, 0); }
  void add_offset(uint16_t offset) {
    fbb_.AddElement<uint16_t>(Field::VT_OFFSET, offset, 0);
  }
  void add_default_integer(int64_t default_integer) {
    fbb_.AddElement<int64_t>(Field::VT_DEFAULT_INTEGER, default_integer, 0);
  }
  void add_default_real(double default_real) {
    fbb_.AddElement<double>(Field::VT_DEFAULT_REAL, default_real, 0.0);
  }
  void add_deprecated(bool deprecated) {
    fbb_.AddElement<uint8_t>(
      Field::VT_DEPRECATED, static_cast<uint8_t>(deprecated), 0
    );
  }
  void add_required(bool required) {
    fbb_.AddElement<uint8_t>(
      Field::VT_REQUIRED, static_cast<uint8_t>(required), 0
    );
  }
  void add_key(bool key) {
    fbb_.AddElement<uint8_t>(Field::VT_KEY, static_cast<uint8_t>(key), 0);
  }
  void add_attributes(
    ::flatbuffers::Offset<
      ::flatbuffers::Vector<::flatbuffers::Offset<reflection::KeyValue>>>
      attributes
  ) {
    fbb_.AddOffset(Field::VT_ATTRIBUTES, attributes);
  }
  void add_documentation(
    ::flatbuffers::Offset<
      ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>>
      documentation
  ) {
    fbb_.AddOffset(Field::VT_DOCUMENTATION, documentation);
  }
  void add_optional(bool optional) {
    fbb_.AddElement<uint8_t>(
      Field::VT_OPTIONAL, static_cast<uint8_t>(optional), 0
    );
  }
  void add_padding(uint16_t padding) {
    fbb_.AddElement<uint16_t>(Field::VT_PADDING, padding, 0);
  }
  void add_offset64(bool offset64) {
    fbb_.AddElement<uint8_t>(
      Field::VT_OFFSET64, static_cast<uint8_t>(offset64), 0
    );
  }
  explicit FieldBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Field> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Field>(end);
    fbb_.Required(o, Field::VT_NAME);
    fbb_.Required(o, Field::VT_TYPE);
    return o;
  }
};

inline ::flatbuffers::Offset<Field> CreateField(
  ::flatbuffers::FlatBufferBuilder &_fbb,
  ::flatbuffers::Offset<::flatbuffers::String> name = 0,
  ::flatbuffers::Offset<reflection::Type> type = 0, uint16_t id = 0,
  uint16_t offset = 0, int64_t default_integer = 0, double default_real = 0.0,
  bool deprecated = false, bool required = false, bool key = false,
  ::flatbuffers::Offset<
    ::flatbuffers::Vector<::flatbuffers::Offset<reflection::KeyValue>>>
    attributes = 0,
  ::flatbuffers::Offset<
    ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>>
    documentation = 0,
  bool optional = false, uint16_t padding = 0, bool offset64 = false
) {
  FieldBuilder builder_(_fbb);
  builder_.add_default_real(default_real);
  builder_.add_default_integer(default_integer);
  builder_.add_documentation(documentation);
  builder_.add_attributes(attributes);
  builder_.add_type(type);
  builder_.add_name(name);
  builder_.add_padding(padding);
  builder_.add_offset(offset);
  builder_.add_id(id);
  builder_.add_offset64(offset64);
  builder_.add_optional(optional);
  builder_.add_key(key);
  builder_.add_required(required);
  builder_.add_deprecated(deprecated);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Field> CreateFieldDirect(
  ::flatbuffers::FlatBufferBuilder &_fbb, const char *name = nullptr,
  ::flatbuffers::Offset<reflection::Type> type = 0, uint16_t id = 0,
  uint16_t offset = 0, int64_t default_integer = 0, double default_real = 0.0,
  bool deprecated = false, bool required = false, bool key = false,
  std::vector<::flatbuffers::Offset<reflection::KeyValue>> *attributes =
    nullptr,
  const std::vector<::flatbuffers::Offset<::flatbuffers::String>>
    *documentation = nullptr,
  bool optional = false, uint16_t padding = 0, bool offset64 = false
) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto attributes__ = attributes ?
    _fbb.CreateVectorOfSortedTables<reflection::KeyValue>(attributes) :
    0;
  auto documentation__ = documentation ?
    _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(
      *documentation
    ) :
    0;
  return reflection::CreateField(
    _fbb, name__, type, id, offset, default_integer, default_real, deprecated,
    required, key, attributes__, documentation__, optional, padding, offset64
  );
}

struct Object final : private ::flatbuffers::Table {
  typedef ObjectBuilder Builder;
  enum FlatBuffersVTableOffset : ::flatbuffers::voffset_t {
    VT_NAME = 4,
    VT_FIELDS = 6,
    VT_IS_STRUCT = 8,
    VT_MINALIGN = 10,
    VT_BYTESIZE = 12,
    VT_ATTRIBUTES = 14,
    VT_DOCUMENTATION = 16,
    VT_DECLARATION_FILE = 18
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  bool KeyCompareLessThan(const Object *const o) const {
    return *name() < *o->name();
  }
  int KeyCompareWithValue(const char *_name) const {
    return strcmp(name()->c_str(), _name);
  }
  template <typename StringType>
  int KeyCompareWithValue(const StringType &_name) const {
    if (name()->c_str() < _name) return -1;
    if (_name < name()->c_str()) return 1;
    return 0;
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<reflection::Field>> *
  fields() const {
    return GetPointer<
      const ::flatbuffers::Vector<::flatbuffers::Offset<reflection::Field>> *>(
      VT_FIELDS
    );
  }
  bool is_struct() const { return GetField<uint8_t>(VT_IS_STRUCT, 0) != 0; }
  int32_t minalign() const { return GetField<int32_t>(VT_MINALIGN, 0); }
  int32_t bytesize() const { return GetField<int32_t>(VT_BYTESIZE, 0); }
  const ::flatbuffers::Vector<::flatbuffers::Offset<reflection::KeyValue>> *
  attributes() const {
    return GetPointer<const ::flatbuffers::Vector<
      ::flatbuffers::Offset<reflection::KeyValue>> *>(VT_ATTRIBUTES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *
  documentation() const {
    return GetPointer<const ::flatbuffers::Vector<
      ::flatbuffers::Offset<::flatbuffers::String>> *>(VT_DOCUMENTATION);
  }

  const ::flatbuffers::String *declaration_file() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DECLARATION_FILE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
      VerifyOffsetRequired(verifier, VT_NAME) &&
      verifier.VerifyString(name()) &&
      VerifyOffsetRequired(verifier, VT_FIELDS) &&
      verifier.VerifyVector(fields()) &&
      verifier.VerifyVectorOfTables(fields()) &&
      VerifyField<uint8_t>(verifier, VT_IS_STRUCT, 1) &&
      VerifyField<int32_t>(verifier, VT_MINALIGN, 4) &&
      VerifyField<int32_t>(verifier, VT_BYTESIZE, 4) &&
      VerifyOffset(verifier, VT_ATTRIBUTES) &&
      verifier.VerifyVector(attributes()) &&
      verifier.VerifyVectorOfTables(attributes()) &&
      VerifyOffset(verifier, VT_DOCUMENTATION) &&
      verifier.VerifyVector(documentation()) &&
      verifier.VerifyVectorOfStrings(documentation()) &&
      VerifyOffset(verifier, VT_DECLARATION_FILE) &&
      verifier.VerifyString(declaration_file()) && verifier.EndTable();
  }
};

struct ObjectBuilder {
  typedef Object Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Object::VT_NAME, name);
  }
  void
  add_fields(::flatbuffers::Offset<
	     ::flatbuffers::Vector<::flatbuffers::Offset<reflection::Field>>>
	       fields) {
    fbb_.AddOffset(Object::VT_FIELDS, fields);
  }
  void add_is_struct(bool is_struct) {
    fbb_.AddElement<uint8_t>(
      Object::VT_IS_STRUCT, static_cast<uint8_t>(is_struct), 0
    );
  }
  void add_minalign(int32_t minalign) {
    fbb_.AddElement<int32_t>(Object::VT_MINALIGN, minalign, 0);
  }
  void add_bytesize(int32_t bytesize) {
    fbb_.AddElement<int32_t>(Object::VT_BYTESIZE, bytesize, 0);
  }
  void add_attributes(
    ::flatbuffers::Offset<
      ::flatbuffers::Vector<::flatbuffers::Offset<reflection::KeyValue>>>
      attributes
  ) {
    fbb_.AddOffset(Object::VT_ATTRIBUTES, attributes);
  }
  void add_documentation(
    ::flatbuffers::Offset<
      ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>>
      documentation
  ) {
    fbb_.AddOffset(Object::VT_DOCUMENTATION, documentation);
  }
  void add_declaration_file(
    ::flatbuffers::Offset<::flatbuffers::String> declaration_file
  ) {
    fbb_.AddOffset(Object::VT_DECLARATION_FILE, declaration_file);
  }
  explicit ObjectBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Object> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Object>(end);
    fbb_.Required(o, Object::VT_NAME);
    fbb_.Required(o, Object::VT_FIELDS);
    return o;
  }
};

inline ::flatbuffers::Offset<Object> CreateObject(
  ::flatbuffers::FlatBufferBuilder &_fbb,
  ::flatbuffers::Offset<::flatbuffers::String> name = 0,
  ::flatbuffers::Offset<
    ::flatbuffers::Vector<::flatbuffers::Offset<reflection::Field>>>
    fields = 0,
  bool is_struct = false, int32_t minalign = 0, int32_t bytesize = 0,
  ::flatbuffers::Offset<
    ::flatbuffers::Vector<::flatbuffers::Offset<reflection::KeyValue>>>
    attributes = 0,
  ::flatbuffers::Offset<
    ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>>
    documentation = 0,
  ::flatbuffers::Offset<::flatbuffers::String> declaration_file = 0
) {
  ObjectBuilder builder_(_fbb);
  builder_.add_declaration_file(declaration_file);
  builder_.add_documentation(documentation);
  builder_.add_attributes(attributes);
  builder_.add_bytesize(bytesize);
  builder_.add_minalign(minalign);
  builder_.add_fields(fields);
  builder_.add_name(name);
  builder_.add_is_struct(is_struct);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Object> CreateObjectDirect(
  ::flatbuffers::FlatBufferBuilder &_fbb, const char *name = nullptr,
  std::vector<::flatbuffers::Offset<reflection::Field>> *fields = nullptr,
  bool is_struct = false, int32_t minalign = 0, int32_t bytesize = 0,
  std::vector<::flatbuffers::Offset<reflection::KeyValue>> *attributes =
    nullptr,
  const std::vector<::flatbuffers::Offset<::flatbuffers::String>>
    *documentation = nullptr,
  const char *declaration_file = nullptr
) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto fields__ =
    fields ? _fbb.CreateVectorOfSortedTables<reflection::Field>(fields) : 0;
  auto attributes__ = attributes ?
    _fbb.CreateVectorOfSortedTables<reflection::KeyValue>(attributes) :
    0;
  auto documentation__ = documentation ?
    _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(
      *documentation
    ) :
    0;
  auto declaration_file__ =
    declaration_file ? _fbb.CreateString(declaration_file) : 0;
  return reflection::CreateObject(
    _fbb, name__, fields__, is_struct, minalign, bytesize, attributes__,
    documentation__, declaration_file__
  );
}

struct RPCCall final : private ::flatbuffers::Table {
  typedef RPCCallBuilder Builder;
  enum FlatBuffersVTableOffset : ::flatbuffers::voffset_t {
    VT_NAME = 4,
    VT_REQUEST = 6,
    VT_RESPONSE = 8,
    VT_ATTRIBUTES = 10,
    VT_DOCUMENTATION = 12
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  bool KeyCompareLessThan(const RPCCall *const o) const {
    return *name() < *o->name();
  }
  int KeyCompareWithValue(const char *_name) const {
    return strcmp(name()->c_str(), _name);
  }
  template <typename StringType>
  int KeyCompareWithValue(const StringType &_name) const {
    if (name()->c_str() < _name) return -1;
    if (_name < name()->c_str()) return 1;
    return 0;
  }
  const reflection::Object *request() const {
    return GetPointer<const reflection::Object *>(VT_REQUEST);
  }
  const reflection::Object *response() const {
    return GetPointer<const reflection::Object *>(VT_RESPONSE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<reflection::KeyValue>> *
  attributes() const {
    return GetPointer<const ::flatbuffers::Vector<
      ::flatbuffers::Offset<reflection::KeyValue>> *>(VT_ATTRIBUTES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *
  documentation() const {
    return GetPointer<const ::flatbuffers::Vector<
      ::flatbuffers::Offset<::flatbuffers::String>> *>(VT_DOCUMENTATION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
      VerifyOffsetRequired(verifier, VT_NAME) &&
      verifier.VerifyString(name()) &&
      VerifyOffsetRequired(verifier, VT_REQUEST) &&
      verifier.VerifyTable(request()) &&
      VerifyOffsetRequired(verifier, VT_RESPONSE) &&
      verifier.VerifyTable(response()) &&
      VerifyOffset(verifier, VT_ATTRIBUTES) &&
      verifier.VerifyVector(attributes()) &&
      verifier.VerifyVectorOfTables(attributes()) &&
      VerifyOffset(verifier, VT_DOCUMENTATION) &&
      verifier.VerifyVector(documentation()) &&
      verifier.VerifyVectorOfStrings(documentation()) && verifier.EndTable();
  }
};

struct RPCCallBuilder {
  typedef RPCCall Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(RPCCall::VT_NAME, name);
  }
  void add_request(::flatbuffers::Offset<reflection::Object> request) {
    fbb_.AddOffset(RPCCall::VT_REQUEST, request);
  }
  void add_response(::flatbuffers::Offset<reflection::Object> response) {
    fbb_.AddOffset(RPCCall::VT_RESPONSE, response);
  }
  void add_attributes(
    ::flatbuffers::Offset<
      ::flatbuffers::Vector<::flatbuffers::Offset<reflection::KeyValue>>>
      attributes
  ) {
    fbb_.AddOffset(RPCCall::VT_ATTRIBUTES, attributes);
  }
  void add_documentation(
    ::flatbuffers::Offset<
      ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>>
      documentation
  ) {
    fbb_.AddOffset(RPCCall::VT_DOCUMENTATION, documentation);
  }
  explicit RPCCallBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RPCCall> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RPCCall>(end);
    fbb_.Required(o, RPCCall::VT_NAME);
    fbb_.Required(o, RPCCall::VT_REQUEST);
    fbb_.Required(o, RPCCall::VT_RESPONSE);
    return o;
  }
};

inline ::flatbuffers::Offset<RPCCall> CreateRPCCall(
  ::flatbuffers::FlatBufferBuilder &_fbb,
  ::flatbuffers::Offset<::flatbuffers::String> name = 0,
  ::flatbuffers::Offset<reflection::Object> request = 0,
  ::flatbuffers::Offset<reflection::Object> response = 0,
  ::flatbuffers::Offset<
    ::flatbuffers::Vector<::flatbuffers::Offset<reflection::KeyValue>>>
    attributes = 0,
  ::flatbuffers::Offset<
    ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>>
    documentation = 0
) {
  RPCCallBuilder builder_(_fbb);
  builder_.add_documentation(documentation);
  builder_.add_attributes(attributes);
  builder_.add_response(response);
  builder_.add_request(request);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RPCCall> CreateRPCCallDirect(
  ::flatbuffers::FlatBufferBuilder &_fbb, const char *name = nullptr,
  ::flatbuffers::Offset<reflection::Object> request = 0,
  ::flatbuffers::Offset<reflection::Object> response = 0,
  std::vector<::flatbuffers::Offset<reflection::KeyValue>> *attributes =
    nullptr,
  const std::vector<::flatbuffers::Offset<::flatbuffers::String>>
    *documentation = nullptr
) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto attributes__ = attributes ?
    _fbb.CreateVectorOfSortedTables<reflection::KeyValue>(attributes) :
    0;
  auto documentation__ = documentation ?
    _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(
      *documentation
    ) :
    0;
  return reflection::CreateRPCCall(
    _fbb, name__, request, response, attributes__, documentation__
  );
}

struct Service final : private ::flatbuffers::Table {
  typedef ServiceBuilder Builder;
  enum FlatBuffersVTableOffset : ::flatbuffers::voffset_t {
    VT_NAME = 4,
    VT_CALLS = 6,
    VT_ATTRIBUTES = 8,
    VT_DOCUMENTATION = 10,
    VT_DECLARATION_FILE = 12
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  bool KeyCompareLessThan(const Service *const o) const {
    return *name() < *o->name();
  }
  int KeyCompareWithValue(const char *_name) const {
    return strcmp(name()->c_str(), _name);
  }
  template <typename StringType>
  int KeyCompareWithValue(const StringType &_name) const {
    if (name()->c_str() < _name) return -1;
    if (_name < name()->c_str()) return 1;
    return 0;
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<reflection::RPCCall>> *
  calls() const {
    return GetPointer<const ::flatbuffers::Vector<
      ::flatbuffers::Offset<reflection::RPCCall>> *>(VT_CALLS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<reflection::KeyValue>> *
  attributes() const {
    return GetPointer<const ::flatbuffers::Vector<
      ::flatbuffers::Offset<reflection::KeyValue>> *>(VT_ATTRIBUTES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *
  documentation() const {
    return GetPointer<const ::flatbuffers::Vector<
      ::flatbuffers::Offset<::flatbuffers::String>> *>(VT_DOCUMENTATION);
  }

  const ::flatbuffers::String *declaration_file() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DECLARATION_FILE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
      VerifyOffsetRequired(verifier, VT_NAME) &&
      verifier.VerifyString(name()) && VerifyOffset(verifier, VT_CALLS) &&
      verifier.VerifyVector(calls()) &&
      verifier.VerifyVectorOfTables(calls()) &&
      VerifyOffset(verifier, VT_ATTRIBUTES) &&
      verifier.VerifyVector(attributes()) &&
      verifier.VerifyVectorOfTables(attributes()) &&
      VerifyOffset(verifier, VT_DOCUMENTATION) &&
      verifier.VerifyVector(documentation()) &&
      verifier.VerifyVectorOfStrings(documentation()) &&
      VerifyOffset(verifier, VT_DECLARATION_FILE) &&
      verifier.VerifyString(declaration_file()) && verifier.EndTable();
  }
};

struct ServiceBuilder {
  typedef Service Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Service::VT_NAME, name);
  }
  void
  add_calls(::flatbuffers::Offset<
	    ::flatbuffers::Vector<::flatbuffers::Offset<reflection::RPCCall>>>
	      calls) {
    fbb_.AddOffset(Service::VT_CALLS, calls);
  }
  void add_attributes(
    ::flatbuffers::Offset<
      ::flatbuffers::Vector<::flatbuffers::Offset<reflection::KeyValue>>>
      attributes
  ) {
    fbb_.AddOffset(Service::VT_ATTRIBUTES, attributes);
  }
  void add_documentation(
    ::flatbuffers::Offset<
      ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>>
      documentation
  ) {
    fbb_.AddOffset(Service::VT_DOCUMENTATION, documentation);
  }
  void add_declaration_file(
    ::flatbuffers::Offset<::flatbuffers::String> declaration_file
  ) {
    fbb_.AddOffset(Service::VT_DECLARATION_FILE, declaration_file);
  }
  explicit ServiceBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Service> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Service>(end);
    fbb_.Required(o, Service::VT_NAME);
    return o;
  }
};

inline ::flatbuffers::Offset<Service> CreateService(
  ::flatbuffers::FlatBufferBuilder &_fbb,
  ::flatbuffers::Offset<::flatbuffers::String> name = 0,
  ::flatbuffers::Offset<
    ::flatbuffers::Vector<::flatbuffers::Offset<reflection::RPCCall>>>
    calls = 0,
  ::flatbuffers::Offset<
    ::flatbuffers::Vector<::flatbuffers::Offset<reflection::KeyValue>>>
    attributes = 0,
  ::flatbuffers::Offset<
    ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>>
    documentation = 0,
  ::flatbuffers::Offset<::flatbuffers::String> declaration_file = 0
) {
  ServiceBuilder builder_(_fbb);
  builder_.add_declaration_file(declaration_file);
  builder_.add_documentation(documentation);
  builder_.add_attributes(attributes);
  builder_.add_calls(calls);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Service> CreateServiceDirect(
  ::flatbuffers::FlatBufferBuilder &_fbb, const char *name = nullptr,
  std::vector<::flatbuffers::Offset<reflection::RPCCall>> *calls = nullptr,
  std::vector<::flatbuffers::Offset<reflection::KeyValue>> *attributes =
    nullptr,
  const std::vector<::flatbuffers::Offset<::flatbuffers::String>>
    *documentation = nullptr,
  const char *declaration_file = nullptr
) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto calls__ =
    calls ? _fbb.CreateVectorOfSortedTables<reflection::RPCCall>(calls) : 0;
  auto attributes__ = attributes ?
    _fbb.CreateVectorOfSortedTables<reflection::KeyValue>(attributes) :
    0;
  auto documentation__ = documentation ?
    _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(
      *documentation
    ) :
    0;
  auto declaration_file__ =
    declaration_file ? _fbb.CreateString(declaration_file) : 0;
  return reflection::CreateService(
    _fbb, name__, calls__, attributes__, documentation__, declaration_file__
  );
}

struct SchemaFile final : private ::flatbuffers::Table {
  typedef SchemaFileBuilder Builder;
  enum FlatBuffersVTableOffset : ::flatbuffers::voffset_t {
    VT_FILENAME = 4,
    VT_INCLUDED_FILENAMES = 6
  };

  const ::flatbuffers::String *filename() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FILENAME);
  }
  bool KeyCompareLessThan(const SchemaFile *const o) const {
    return *filename() < *o->filename();
  }
  int KeyCompareWithValue(const char *_filename) const {
    return strcmp(filename()->c_str(), _filename);
  }
  template <typename StringType>
  int KeyCompareWithValue(const StringType &_filename) const {
    if (filename()->c_str() < _filename) return -1;
    if (_filename < filename()->c_str()) return 1;
    return 0;
  }

  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *
  included_filenames() const {
    return GetPointer<const ::flatbuffers::Vector<
      ::flatbuffers::Offset<::flatbuffers::String>> *>(VT_INCLUDED_FILENAMES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
      VerifyOffsetRequired(verifier, VT_FILENAME) &&
      verifier.VerifyString(filename()) &&
      VerifyOffset(verifier, VT_INCLUDED_FILENAMES) &&
      verifier.VerifyVector(included_filenames()) &&
      verifier.VerifyVectorOfStrings(included_filenames()) &&
      verifier.EndTable();
  }
};

struct SchemaFileBuilder {
  typedef SchemaFile Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_filename(::flatbuffers::Offset<::flatbuffers::String> filename) {
    fbb_.AddOffset(SchemaFile::VT_FILENAME, filename);
  }
  void add_included_filenames(
    ::flatbuffers::Offset<
      ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>>
      included_filenames
  ) {
    fbb_.AddOffset(SchemaFile::VT_INCLUDED_FILENAMES, included_filenames);
  }
  explicit SchemaFileBuilder(::flatbuffers::FlatBufferBuilder &_fbb) :
    fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SchemaFile> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SchemaFile>(end);
    fbb_.Required(o, SchemaFile::VT_FILENAME);
    return o;
  }
};

inline ::flatbuffers::Offset<SchemaFile> CreateSchemaFile(
  ::flatbuffers::FlatBufferBuilder &_fbb,
  ::flatbuffers::Offset<::flatbuffers::String> filename = 0,
  ::flatbuffers::Offset<
    ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>>
    included_filenames = 0
) {
  SchemaFileBuilder builder_(_fbb);
  builder_.add_included_filenames(included_filenames);
  builder_.add_filename(filename);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SchemaFile> CreateSchemaFileDirect(
  ::flatbuffers::FlatBufferBuilder &_fbb, const char *filename = nullptr,
  const std::vector<::flatbuffers::Offset<::flatbuffers::String>>
    *included_filenames = nullptr
) {
  auto filename__ = filename ? _fbb.CreateString(filename) : 0;
  auto included_filenames__ = included_filenames ?
    _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(
      *included_filenames
    ) :
    0;
  return reflection::CreateSchemaFile(_fbb, filename__, included_filenames__);
}

struct Schema final : private ::flatbuffers::Table {
  typedef SchemaBuilder Builder;
  enum FlatBuffersVTableOffset : ::flatbuffers::voffset_t {
    VT_OBJECTS = 4,
    VT_ENUMS = 6,
    VT_FILE_IDENT = 8,
    VT_FILE_EXT = 10,
    VT_ROOT_TABLE = 12,
    VT_SERVICES = 14,
    VT_ADVANCED_FEATURES = 16,
    VT_FBS_FILES = 18
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<reflection::Object>> *
  objects() const {
    return GetPointer<
      const ::flatbuffers::Vector<::flatbuffers::Offset<reflection::Object>> *>(
      VT_OBJECTS
    );
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<reflection::Enum>> *
  enums() const {
    return GetPointer<
      const ::flatbuffers::Vector<::flatbuffers::Offset<reflection::Enum>> *>(
      VT_ENUMS
    );
  }
  const ::flatbuffers::String *file_ident() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FILE_IDENT);
  }
  const ::flatbuffers::String *file_ext() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FILE_EXT);
  }
  const reflection::Object *root_table() const {
    return GetPointer<const reflection::Object *>(VT_ROOT_TABLE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<reflection::Service>> *
  services() const {
    return GetPointer<const ::flatbuffers::Vector<
      ::flatbuffers::Offset<reflection::Service>> *>(VT_SERVICES);
  }
  reflection::AdvancedFeatures advanced_features() const {
    return static_cast<reflection::AdvancedFeatures>(
      GetField<uint64_t>(VT_ADVANCED_FEATURES, 0)
    );
  }

  const ::flatbuffers::Vector<::flatbuffers::Offset<reflection::SchemaFile>> *
  fbs_files() const {
    return GetPointer<const ::flatbuffers::Vector<
      ::flatbuffers::Offset<reflection::SchemaFile>> *>(VT_FBS_FILES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
      VerifyOffsetRequired(verifier, VT_OBJECTS) &&
      verifier.VerifyVector(objects()) &&
      verifier.VerifyVectorOfTables(objects()) &&
      VerifyOffsetRequired(verifier, VT_ENUMS) &&
      verifier.VerifyVector(enums()) &&
      verifier.VerifyVectorOfTables(enums()) &&
      VerifyOffset(verifier, VT_FILE_IDENT) &&
      verifier.VerifyString(file_ident()) &&
      VerifyOffset(verifier, VT_FILE_EXT) &&
      verifier.VerifyString(file_ext()) &&
      VerifyOffset(verifier, VT_ROOT_TABLE) &&
      verifier.VerifyTable(root_table()) &&
      VerifyOffset(verifier, VT_SERVICES) &&
      verifier.VerifyVector(services()) &&
      verifier.VerifyVectorOfTables(services()) &&
      VerifyField<uint64_t>(verifier, VT_ADVANCED_FEATURES, 8) &&
      VerifyOffset(verifier, VT_FBS_FILES) &&
      verifier.VerifyVector(fbs_files()) &&
      verifier.VerifyVectorOfTables(fbs_files()) && verifier.EndTable();
  }
};

struct SchemaBuilder {
  typedef Schema Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void
  add_objects(::flatbuffers::Offset<
	      ::flatbuffers::Vector<::flatbuffers::Offset<reflection::Object>>>
		objects) {
    fbb_.AddOffset(Schema::VT_OBJECTS, objects);
  }
  void add_enums(::flatbuffers::Offset<
		 ::flatbuffers::Vector<::flatbuffers::Offset<reflection::Enum>>>
		   enums) {
    fbb_.AddOffset(Schema::VT_ENUMS, enums);
  }
  void add_file_ident(::flatbuffers::Offset<::flatbuffers::String> file_ident) {
    fbb_.AddOffset(Schema::VT_FILE_IDENT, file_ident);
  }
  void add_file_ext(::flatbuffers::Offset<::flatbuffers::String> file_ext) {
    fbb_.AddOffset(Schema::VT_FILE_EXT, file_ext);
  }
  void add_root_table(::flatbuffers::Offset<reflection::Object> root_table) {
    fbb_.AddOffset(Schema::VT_ROOT_TABLE, root_table);
  }
  void add_services(
    ::flatbuffers::Offset<
      ::flatbuffers::Vector<::flatbuffers::Offset<reflection::Service>>>
      services
  ) {
    fbb_.AddOffset(Schema::VT_SERVICES, services);
  }
  void add_advanced_features(reflection::AdvancedFeatures advanced_features) {
    fbb_.AddElement<uint64_t>(
      Schema::VT_ADVANCED_FEATURES, static_cast<uint64_t>(advanced_features), 0
    );
  }
  void add_fbs_files(
    ::flatbuffers::Offset<
      ::flatbuffers::Vector<::flatbuffers::Offset<reflection::SchemaFile>>>
      fbs_files
  ) {
    fbb_.AddOffset(Schema::VT_FBS_FILES, fbs_files);
  }
  explicit SchemaBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Schema> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Schema>(end);
    fbb_.Required(o, Schema::VT_OBJECTS);
    fbb_.Required(o, Schema::VT_ENUMS);
    return o;
  }
};

inline ::flatbuffers::Offset<Schema> CreateSchema(
  ::flatbuffers::FlatBufferBuilder &_fbb,
  ::flatbuffers::Offset<
    ::flatbuffers::Vector<::flatbuffers::Offset<reflection::Object>>>
    objects = 0,
  ::flatbuffers::Offset<
    ::flatbuffers::Vector<::flatbuffers::Offset<reflection::Enum>>>
    enums = 0,
  ::flatbuffers::Offset<::flatbuffers::String> file_ident = 0,
  ::flatbuffers::Offset<::flatbuffers::String> file_ext = 0,
  ::flatbuffers::Offset<reflection::Object> root_table = 0,
  ::flatbuffers::Offset<
    ::flatbuffers::Vector<::flatbuffers::Offset<reflection::Service>>>
    services = 0,
  reflection::AdvancedFeatures advanced_features =
    static_cast<reflection::AdvancedFeatures>(0),
  ::flatbuffers::Offset<
    ::flatbuffers::Vector<::flatbuffers::Offset<reflection::SchemaFile>>>
    fbs_files = 0
) {
  SchemaBuilder builder_(_fbb);
  builder_.add_advanced_features(advanced_features);
  builder_.add_fbs_files(fbs_files);
  builder_.add_services(services);
  builder_.add_root_table(root_table);
  builder_.add_file_ext(file_ext);
  builder_.add_file_ident(file_ident);
  builder_.add_enums(enums);
  builder_.add_objects(objects);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Schema> CreateSchemaDirect(
  ::flatbuffers::FlatBufferBuilder &_fbb,
  std::vector<::flatbuffers::Offset<reflection::Object>> *objects = nullptr,
  std::vector<::flatbuffers::Offset<reflection::Enum>> *enums = nullptr,
  const char *file_ident = nullptr, const char *file_ext = nullptr,
  ::flatbuffers::Offset<reflection::Object> root_table = 0,
  std::vector<::flatbuffers::Offset<reflection::Service>> *services = nullptr,
  reflection::AdvancedFeatures advanced_features =
    static_cast<reflection::AdvancedFeatures>(0),
  std::vector<::flatbuffers::Offset<reflection::SchemaFile>> *fbs_files =
    nullptr
) {
  auto objects__ =
    objects ? _fbb.CreateVectorOfSortedTables<reflection::Object>(objects) : 0;
  auto enums__ =
    enums ? _fbb.CreateVectorOfSortedTables<reflection::Enum>(enums) : 0;
  auto file_ident__ = file_ident ? _fbb.CreateString(file_ident) : 0;
  auto file_ext__ = file_ext ? _fbb.CreateString(file_ext) : 0;
  auto services__ = services ?
    _fbb.CreateVectorOfSortedTables<reflection::Service>(services) :
    0;
  auto fbs_files__ = fbs_files ?
    _fbb.CreateVectorOfSortedTables<reflection::SchemaFile>(fbs_files) :
    0;
  return reflection::CreateSchema(
    _fbb, objects__, enums__, file_ident__, file_ext__, root_table, services__,
    advanced_features, fbs_files__
  );
}

inline const reflection::Schema *GetSchema(const void *buf) {
  return ::flatbuffers::GetRoot<reflection::Schema>(buf);
}

inline const reflection::Schema *GetSizePrefixedSchema(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<reflection::Schema>(buf);
}

inline const char *SchemaIdentifier() { return "BFBS"; }

inline bool SchemaBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(buf, SchemaIdentifier());
}

inline bool SizePrefixedSchemaBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(buf, SchemaIdentifier(), true);
}

inline bool VerifySchemaBuffer(::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<reflection::Schema>(SchemaIdentifier());
}

inline bool VerifySizePrefixedSchemaBuffer(::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<reflection::Schema>(SchemaIdentifier(
  ));
}

inline const char *SchemaExtension() { return "bfbs"; }

inline void FinishSchemaBuffer(
  ::flatbuffers::FlatBufferBuilder &fbb,
  ::flatbuffers::Offset<reflection::Schema> root
) {
  fbb.Finish(root, SchemaIdentifier());
}

inline void FinishSizePrefixedSchemaBuffer(
  ::flatbuffers::FlatBufferBuilder &fbb,
  ::flatbuffers::Offset<reflection::Schema> root
) {
  fbb.FinishSizePrefixed(root, SchemaIdentifier());
}

} // namespace reflection

namespace flatbuffers {

inline bool IsScalar(reflection::BaseType t) {
  return t >= reflection::UType && t <= reflection::Double;
}
inline bool IsInteger(reflection::BaseType t) {
  return t >= reflection::UType && t <= reflection::ULong;
}
inline bool IsFloat(reflection::BaseType t) {
  return t == reflection::Float || t == reflection::Double;
}
inline bool IsLong(reflection::BaseType t) {
  return t == reflection::Long || t == reflection::ULong;
}

inline size_t GetTypeSize(reflection::BaseType base_type) {
  static size_t sizes[] = {0, 1, 1, 1, 1, 2, 2, 4, 4, 8, 8, 4, 8, 4, 4, 4, 4, 0,

			   8,

			   0};
  static_assert(
    sizeof(sizes) / sizeof(size_t) == reflection::MaxBaseType + 1,
    "Size of sizes[] array does not match the count of BaseType "
    "enum values."
  );
  return sizes[base_type];
}

inline size_t GetTypeSizeInline(
  reflection::BaseType base_type, int type_index,
  const reflection::Schema &schema
) {
  if (base_type == reflection::Obj &&
      schema.objects()->Get(type_index)->is_struct()) {
    return schema.objects()->Get(type_index)->bytesize();
  } else {
    return GetTypeSize(base_type);
  }
}

inline Table *GetAnyRoot(uint8_t *const flatbuf) {
  return GetMutableRoot<Table>(flatbuf);
}

inline const Table *GetAnyRoot(const uint8_t *const flatbuf) {
  return GetRoot<Table>(flatbuf);
}

inline Table *GetAnySizePrefixedRoot(uint8_t *const flatbuf) {
  return GetMutableSizePrefixedRoot<Table>(flatbuf);
}

inline const Table *GetAnySizePrefixedRoot(const uint8_t *const flatbuf) {
  return GetSizePrefixedRoot<Table>(flatbuf);
}

template <typename T> T GetFieldDefaultI(const reflection::Field &field) {
  (static_cast<bool>(sizeof(T) == GetTypeSize(field.type()->base_type())) ?
     void(0) :
     __assert_fail(
       "sizeof(T) == GetTypeSize(field.type()->base_type())", __builtin_FILE(),
       __builtin_LINE(), __extension__ __PRETTY_FUNCTION__
     ));
  return static_cast<T>(field.default_integer());
}

template <typename T> T GetFieldDefaultF(const reflection::Field &field) {
  (static_cast<bool>(sizeof(T) == GetTypeSize(field.type()->base_type())) ?
     void(0) :
     __assert_fail(
       "sizeof(T) == GetTypeSize(field.type()->base_type())", __builtin_FILE(),
       __builtin_LINE(), __extension__ __PRETTY_FUNCTION__
     ));
  return static_cast<T>(field.default_real());
}

template <typename T>
T GetFieldI(const Table &table, const reflection::Field &field) {
  (static_cast<bool>(sizeof(T) == GetTypeSize(field.type()->base_type())) ?
     void(0) :
     __assert_fail(
       "sizeof(T) == GetTypeSize(field.type()->base_type())", __builtin_FILE(),
       __builtin_LINE(), __extension__ __PRETTY_FUNCTION__
     ));
  return table.GetField<T>(
    field.offset(), static_cast<T>(field.default_integer())
  );
}

template <typename T>
T GetFieldF(const Table &table, const reflection::Field &field) {
  (static_cast<bool>(sizeof(T) == GetTypeSize(field.type()->base_type())) ?
     void(0) :
     __assert_fail(
       "sizeof(T) == GetTypeSize(field.type()->base_type())", __builtin_FILE(),
       __builtin_LINE(), __extension__ __PRETTY_FUNCTION__
     ));
  return table.GetField<T>(
    field.offset(), static_cast<T>(field.default_real())
  );
}

inline const String *
GetFieldS(const Table &table, const reflection::Field &field) {
  (static_cast<bool>(field.type()->base_type() == reflection::String) ?
     void(0) :
     __assert_fail(
       "field.type()->base_type() == reflection::String", __builtin_FILE(),
       __builtin_LINE(), __extension__ __PRETTY_FUNCTION__
     ));
  return table.GetPointer<const String *>(field.offset());
}

template <typename T>
Vector<T> *GetFieldV(const Table &table, const reflection::Field &field) {
  (static_cast<bool>(
     field.type()->base_type() == reflection::Vector &&
     sizeof(T) == GetTypeSize(field.type()->element())
   ) ?
     void(0) :
     __assert_fail(
       "field.type()->base_type() == reflection::Vector && sizeof(T) == "
       "GetTypeSize(field.type()->element())",
       __builtin_FILE(), __builtin_LINE(), __extension__ __PRETTY_FUNCTION__
     ));
  return table.GetPointer<Vector<T> *>(field.offset());
}

inline VectorOfAny *
GetFieldAnyV(const Table &table, const reflection::Field &field) {
  return table.GetPointer<VectorOfAny *>(field.offset());
}

inline Table *GetFieldT(const Table &table, const reflection::Field &field) {
  (static_cast<bool>(
     field.type()->base_type() == reflection::Obj ||
     field.type()->base_type() == reflection::Union
   ) ?
     void(0) :
     __assert_fail(
       "field.type()->base_type() == reflection::Obj || "
       "field.type()->base_type() == reflection::Union",
       __builtin_FILE(), __builtin_LINE(), __extension__ __PRETTY_FUNCTION__
     ));
  return table.GetPointer<Table *>(field.offset());
}

inline const Struct *
GetFieldStruct(const Table &table, const reflection::Field &field) {
  (static_cast<bool>(field.type()->base_type() == reflection::Obj) ?
     void(0) :
     __assert_fail(
       "field.type()->base_type() == reflection::Obj", __builtin_FILE(),
       __builtin_LINE(), __extension__ __PRETTY_FUNCTION__
     ));
  return table.GetStruct<const Struct *>(field.offset());
}

inline const Struct *
GetFieldStruct(const Struct &structure, const reflection::Field &field) {
  (static_cast<bool>(field.type()->base_type() == reflection::Obj) ?
     void(0) :
     __assert_fail(
       "field.type()->base_type() == reflection::Obj", __builtin_FILE(),
       __builtin_LINE(), __extension__ __PRETTY_FUNCTION__
     ));
  return structure.GetStruct<const Struct *>(field.offset());
}

int64_t GetAnyValueI(reflection::BaseType type, const uint8_t *data);

double GetAnyValueF(reflection::BaseType type, const uint8_t *data);

std::string GetAnyValueS(
  reflection::BaseType type, const uint8_t *data,
  const reflection::Schema *schema, int type_index
);

inline int64_t
GetAnyFieldI(const Table &table, const reflection::Field &field) {
  auto field_ptr = table.GetAddressOf(field.offset());
  return field_ptr ? GetAnyValueI(field.type()->base_type(), field_ptr) :
		     field.default_integer();
}

inline double GetAnyFieldF(const Table &table, const reflection::Field &field) {
  auto field_ptr = table.GetAddressOf(field.offset());
  return field_ptr ? GetAnyValueF(field.type()->base_type(), field_ptr) :
		     field.default_real();
}

inline std::string GetAnyFieldS(
  const Table &table, const reflection::Field &field,
  const reflection::Schema *schema
) {
  auto field_ptr = table.GetAddressOf(field.offset());
  return field_ptr ?
    GetAnyValueS(
      field.type()->base_type(), field_ptr, schema, field.type()->index()
    ) :
    "";
}

inline int64_t GetAnyFieldI(const Struct &st, const reflection::Field &field) {
  return GetAnyValueI(
    field.type()->base_type(), st.GetAddressOf(field.offset())
  );
}

inline double GetAnyFieldF(const Struct &st, const reflection::Field &field) {
  return GetAnyValueF(
    field.type()->base_type(), st.GetAddressOf(field.offset())
  );
}

inline std::string
GetAnyFieldS(const Struct &st, const reflection::Field &field) {
  return GetAnyValueS(
    field.type()->base_type(), st.GetAddressOf(field.offset()), nullptr, -1
  );
}

inline int64_t GetAnyVectorElemI(
  const VectorOfAny *vec, reflection::BaseType elem_type, size_t i
) {
  return GetAnyValueI(elem_type, vec->Data() + GetTypeSize(elem_type) * i);
}

inline double GetAnyVectorElemF(
  const VectorOfAny *vec, reflection::BaseType elem_type, size_t i
) {
  return GetAnyValueF(elem_type, vec->Data() + GetTypeSize(elem_type) * i);
}

inline std::string GetAnyVectorElemS(
  const VectorOfAny *vec, reflection::BaseType elem_type, size_t i
) {
  return GetAnyValueS(
    elem_type, vec->Data() + GetTypeSize(elem_type) * i, nullptr, -1
  );
}

template <typename T>
T *GetAnyVectorElemPointer(const VectorOfAny *vec, size_t i) {
  auto elem_ptr = vec->Data() + sizeof(uoffset_t) * i;
  return reinterpret_cast<T *>(elem_ptr + ReadScalar<uoffset_t>(elem_ptr));
}

template <typename T>
T *GetAnyVectorElemAddressOf(
  const VectorOfAny *vec, size_t i, size_t elem_size
) {
  return reinterpret_cast<T *>(vec->Data() + elem_size * i);
}

template <typename T>
T *GetAnyFieldAddressOf(const Table &table, const reflection::Field &field) {
  return reinterpret_cast<T *>(table.GetAddressOf(field.offset()));
}

template <typename T>
T *GetAnyFieldAddressOf(const Struct &st, const reflection::Field &field) {
  return reinterpret_cast<T *>(st.GetAddressOf(field.offset()));
}

void ForAllFields(
  const reflection::Object *object, bool reverse,
  std::function<void(const reflection::Field *)> func
);

template <typename T>
bool SetField(Table *table, const reflection::Field &field, T val) {
  reflection::BaseType type = field.type()->base_type();
  if (!IsScalar(type)) { return false; }
  (static_cast<bool>(sizeof(T) == GetTypeSize(type)) ?
     void(0) :
     __assert_fail(
       "sizeof(T) == GetTypeSize(type)", __builtin_FILE(), __builtin_LINE(),
       __extension__ __PRETTY_FUNCTION__
     ));
  T def;
  if (IsInteger(type)) {
    def = GetFieldDefaultI<T>(field);
  } else {
    (static_cast<bool>(IsFloat(type)) ?
       void(0) :
       __assert_fail(
	 "IsFloat(type)", __builtin_FILE(), __builtin_LINE(),
	 __extension__ __PRETTY_FUNCTION__
       ));
    def = GetFieldDefaultF<T>(field);
  }
  return table->SetField(field.offset(), val, def);
}

void SetAnyValueI(reflection::BaseType type, uint8_t *data, int64_t val);
void SetAnyValueF(reflection::BaseType type, uint8_t *data, double val);
void SetAnyValueS(reflection::BaseType type, uint8_t *data, const char *val);

inline bool
SetAnyFieldI(Table *table, const reflection::Field &field, int64_t val) {
  auto field_ptr = table->GetAddressOf(field.offset());
  if (!field_ptr) return val == GetFieldDefaultI<int64_t>(field);
  SetAnyValueI(field.type()->base_type(), field_ptr, val);
  return true;
}

inline bool
SetAnyFieldF(Table *table, const reflection::Field &field, double val) {
  auto field_ptr = table->GetAddressOf(field.offset());
  if (!field_ptr) return val == GetFieldDefaultF<double>(field);
  SetAnyValueF(field.type()->base_type(), field_ptr, val);
  return true;
}

inline bool
SetAnyFieldS(Table *table, const reflection::Field &field, const char *val) {
  auto field_ptr = table->GetAddressOf(field.offset());
  if (!field_ptr) return false;
  SetAnyValueS(field.type()->base_type(), field_ptr, val);
  return true;
}

inline void
SetAnyFieldI(Struct *st, const reflection::Field &field, int64_t val) {
  SetAnyValueI(
    field.type()->base_type(), st->GetAddressOf(field.offset()), val
  );
}

inline void
SetAnyFieldF(Struct *st, const reflection::Field &field, double val) {
  SetAnyValueF(
    field.type()->base_type(), st->GetAddressOf(field.offset()), val
  );
}

inline void
SetAnyFieldS(Struct *st, const reflection::Field &field, const char *val) {
  SetAnyValueS(
    field.type()->base_type(), st->GetAddressOf(field.offset()), val
  );
}

inline void SetAnyVectorElemI(
  VectorOfAny *vec, reflection::BaseType elem_type, size_t i, int64_t val
) {
  SetAnyValueI(elem_type, vec->Data() + GetTypeSize(elem_type) * i, val);
}

inline void SetAnyVectorElemF(
  VectorOfAny *vec, reflection::BaseType elem_type, size_t i, double val
) {
  SetAnyValueF(elem_type, vec->Data() + GetTypeSize(elem_type) * i, val);
}

inline void SetAnyVectorElemS(
  VectorOfAny *vec, reflection::BaseType elem_type, size_t i, const char *val
) {
  SetAnyValueS(elem_type, vec->Data() + GetTypeSize(elem_type) * i, val);
}

template <typename T, typename U> class pointer_inside_vector {
public:
  pointer_inside_vector(T *ptr, std::vector<U> &vec) :
    offset_(
      reinterpret_cast<uint8_t *>(ptr) - reinterpret_cast<uint8_t *>(vec.data())
    ),
    vec_(vec) { }

  T *operator*() const {
    return reinterpret_cast<T *>(
      reinterpret_cast<uint8_t *>(vec_.data()) + offset_
    );
  }
  T *operator->() const { return operator*(); }

private:
  size_t offset_;
  std::vector<U> &vec_;
};

template <typename T, typename U>
pointer_inside_vector<T, U> piv(T *ptr, std::vector<U> &vec) {
  return pointer_inside_vector<T, U>(ptr, vec);
}

inline const char *UnionTypeFieldSuffix() { return "_type"; }

inline const reflection::Object &GetUnionType(
  const reflection::Schema &schema, const reflection::Object &parent,
  const reflection::Field &unionfield, const Table &table
) {
  auto enumdef = schema.enums()->Get(unionfield.type()->index());

  auto type_field = parent.fields()->LookupByKey(
    (unionfield.name()->str() + UnionTypeFieldSuffix()).c_str()
  );
  (static_cast<bool>(type_field) ?
     void(0) :
     __assert_fail(
       "type_field", __builtin_FILE(), __builtin_LINE(),
       __extension__ __PRETTY_FUNCTION__
     ));
  auto union_type = GetFieldI<uint8_t>(table, *type_field);
  auto enumval = enumdef->values()->LookupByKey(union_type);
  return *schema.objects()->Get(enumval->union_type()->index());
}

void SetString(
  const reflection::Schema &schema, const std::string &val, const String *str,
  std::vector<uint8_t> *flatbuf, const reflection::Object *root_table = nullptr
);

uint8_t *ResizeAnyVector(
  const reflection::Schema &schema, uoffset_t newsize, const VectorOfAny *vec,
  uoffset_t num_elems, uoffset_t elem_size, std::vector<uint8_t> *flatbuf,
  const reflection::Object *root_table = nullptr
);

template <typename T>
void ResizeVector(
  const reflection::Schema &schema, uoffset_t newsize, T val,
  const Vector<T> *vec, std::vector<uint8_t> *flatbuf,
  const reflection::Object *root_table = nullptr
) {
  auto delta_elem = static_cast<int>(newsize) - static_cast<int>(vec->size());
  auto newelems = ResizeAnyVector(
    schema, newsize, reinterpret_cast<const VectorOfAny *>(vec), vec->size(),
    static_cast<uoffset_t>(sizeof(T)), flatbuf, root_table
  );

  for (int i = 0; i < delta_elem; i++) {
    auto loc = newelems + i * sizeof(T);
    auto is_scalar = flatbuffers::is_scalar<T>::value;
    if (is_scalar) {
      WriteScalar(loc, val);
    } else {
      *reinterpret_cast<T *>(loc) = val;
    }
  }
}

const uint8_t *AddFlatBuffer(
  std::vector<uint8_t> &flatbuf, const uint8_t *newbuf, size_t newlen
);

inline bool
SetFieldT(Table *table, const reflection::Field &field, const uint8_t *val) {
  (static_cast<bool>(
     sizeof(uoffset_t) == GetTypeSize(field.type()->base_type())
   ) ?
     void(0) :
     __assert_fail(
       "sizeof(uoffset_t) == GetTypeSize(field.type()->base_type())",
       __builtin_FILE(), __builtin_LINE(), __extension__ __PRETTY_FUNCTION__
     ));
  return table->SetPointer(field.offset(), val);
}

Offset<const Table *> CopyTable(
  FlatBufferBuilder &fbb, const reflection::Schema &schema,
  const reflection::Object &objectdef, const Table &table,
  bool use_string_pooling = false
);

bool Verify(
  const reflection::Schema &schema, const reflection::Object &root,
  const uint8_t *buf, size_t length, uoffset_t max_depth = 64,
  uoffset_t max_tables = 1000000
);

bool VerifySizePrefixed(
  const reflection::Schema &schema, const reflection::Object &root,
  const uint8_t *buf, size_t length, uoffset_t max_depth = 64,
  uoffset_t max_tables = 1000000
);

} // namespace flatbuffers

struct ZmPolyHash_Defaults {
  using Lock = ZmNoLock;
  enum { Shadow = 0 };
  static const char *HeapID() { return "ZmPolyHash"; }
  static constexpr auto ID = HeapID;
  enum { Sharded = 0 };
};

template <typename Lock, typename NTP = ZmPolyHash_Defaults>
using ZmPolyHashLock = ZmHashLock<Lock, NTP>;
template <bool Shadow, typename NTP = ZmPolyHash_Defaults>
using ZmPolyHashShadow = ZmHashShadow<Shadow, NTP>;
template <auto HeapID, typename NTP = ZmPolyHash_Defaults>
using ZmPolyHashHeapID = ZmHashHeapID<HeapID, NTP>;
template <bool Sharded, typename NTP = ZmPolyHash_Defaults>
using ZmPolyHashSharded = ZmHashSharded<Sharded, NTP>;

template <typename KeyID> using ZmPolyHash_KeyIDIndex = ZuInt<-int(KeyID{})>;
template <typename KeyIDs>
using ZmPolyHash_SortKeyIDs =
  ZuTypeSort<ZmPolyHash_KeyIDIndex, ZuSeqTL<KeyIDs>>;

template <typename T_, typename NTP = ZmPolyHash_Defaults> class ZmPolyHash {
public:
  using T = T_;
  using Lock = typename NTP::Lock;
  enum { Shadow = NTP::Shadow };
  static constexpr auto HeapID = NTP::HeapID;
  enum { Sharded = NTP::Sharded };

private:
  template <typename Node, auto Axor, bool Shadow_>
  using Hash___ = ZmHash<
    Node,
    ZmHashNode<
      Node,
      ZmHashKey<
	Axor,
	ZmHashLock<
	  Lock,
	  ZmHashShadow<
	    Shadow_, ZmHashHeapID<HeapID, ZmHashSharded<Sharded>>>>>>>;

  template <unsigned KeyID, typename Node_, typename O = T> struct Hash__ {
    using T__ = Hash___<Node_, ZuFieldAxor<O, KeyID>(), Shadow || KeyID>;
    using NodeFn = ZmNodeFn<Shadow || KeyID, Node_>;
    struct T : public T__ {
      using T__::T__;
      struct Node : public T__::Node {
	using T__::Node::Node;
	using T__::Node::operator=;
      };
      using NodeRef = NodeFn::template Ref<Node>;
      using NodeMvRef = NodeFn::template MvRef<Node>;
    };
  };

  using KeyIDs = ZuSeqTL<ZuFieldKeyIDs<T>>;

  enum { NKeys = KeyIDs::N };

  template <unsigned KeyID, typename O = T> struct Hash_ {
    using T = typename Hash__<KeyID, typename Hash_<KeyID + 1>::T::Node>::T;
  };
  template <typename O> struct Hash_<NKeys - 1, O> {
    enum { KeyID = NKeys - 1 };
    using T = typename Hash__<KeyID, O>::T;
  };
  template <typename KeyID> using Hash = typename Hash_<KeyID{}>::T;

  using HashTL = ZuTypeMap<Hash, KeyIDs>;

  using HashRefTL = ZuTypeMap<ZmRef, HashTL>;

  using HashRefs_ = ZuTypeApply<ZuTuple, HashRefTL>;
  struct HashRefs : public HashRefs_ {
    using HashRefs_::HashRefs_;
    using HashRefs_::operator=;
  };

  using Primary = Hash<ZuUnsigned<0>>;

public:
  using Node = typename Primary::Node;
  using NodeRef = typename Primary::NodeRef;
  using NodeMvRef = typename Primary::NodeMvRef;

  ZmPolyHash(ZuCSpan id) {
    auto params = ZmHashParams{id};
    ZuUnroll::all<KeyIDs>([this, &id, &params]<typename KeyID>() {
      m_hashes.template p<KeyID{}>(new Hash<KeyID>{id, params});
    });
  }

  ZmPolyHash(const ZmPolyHash &) = delete;
  ZmPolyHash &operator=(const ZmPolyHash &) = delete;

  ZmPolyHash(ZmPolyHash &&) = default;
  ZmPolyHash &operator=(ZmPolyHash &&) = default;

  ~ZmPolyHash() { clean(); }

  template <unsigned KeyID> const auto &hash() {
    return m_hashes.template p<KeyID>();
  }

  unsigned size() const { return m_hashes.template p<0>()->size(); }
  unsigned count_() const { return m_hashes.template p<0>()->count_(); }

  void add(NodeRef node) {
    ZuUnroll::all<ZuTypeRev<ZuTypeTail<1, KeyIDs>>>(
      [this, &node]<typename KeyID>() mutable {
      m_hashes.template p<KeyID{}>()->addNode(node);
    }
    );
    m_hashes.template p<0>()->addNode(ZuMv(node));
  }

  template <unsigned KeyID, typename Key> NodeRef find(const Key &key) const {
    auto node = m_hashes.template p<KeyID>()->find(key);
    if constexpr (ZuTraits<NodeRef>::IsPrimitive)
      return static_cast<Node *>(node);
    else
      return node;
  }

  template <unsigned KeyID, typename Key> Node *findPtr(const Key &key) const {
    return static_cast<Node *>(m_hashes.template p<KeyID>()->find(key));
  }

  template <typename KeyIDs_ = ZuSeq<>, typename L>
  ZuIfT<!KeyIDs_::N> update(Node *node, L l) const {
    l(node);
  }
  template <typename KeyIDs_ = ZuSeq<>, typename L>
  ZuIfT<KeyIDs_::N && !ZuTypeIn<ZuUnsigned<0>, ZuSeqTL<KeyIDs_>>{}>
  update(Node *node, L l) const {
    using SortedKeyIDs = ZmPolyHash_SortKeyIDs<KeyIDs_>;
    ZuUnroll::all<SortedKeyIDs>([this, node]<typename KeyID>() mutable {
      m_hashes.template p<KeyID{}>()->delNode(node);
    });
    l(node);
    ZuUnroll::all<SortedKeyIDs>([this, node]<typename KeyID>() mutable {
      m_hashes.template p<KeyID{}>()->addNode(node);
    });
  }
  template <typename KeyIDs_ = ZuSeq<>, typename L>
  ZuIfT<KeyIDs_::N &&bool{ZuTypeIn<ZuUnsigned<0>, ZuSeqTL<KeyIDs_>>{}}>
  update(Node *node, L l) const {
    using SortedKeyIDs = ZmPolyHash_SortKeyIDs<KeyIDs_>;
    if constexpr (SortedKeyIDs::N)
      ZuUnroll::all<SortedKeyIDs>([this, node]<typename KeyID>() mutable {
	m_hashes.template p<KeyID{}>()->delNode(node);
      });
    NodeMvRef node_ = m_hashes.template p<0>()->delNode(node);
    l(node);
    if constexpr (SortedKeyIDs::N)
      ZuUnroll::all<SortedKeyIDs>([this, node]<typename KeyID>() mutable {
	m_hashes.template p<KeyID{}>()->addNode(node);
      });
    m_hashes.template p<0>()->addNode(ZuMv(node_));
  }

  template <unsigned KeyID, typename Key> NodeMvRef del(const Key &key) {
    if (NodeRef node = find<KeyID>(key)) return delNode(node);
    return nullptr;
  }
  NodeMvRef delNode(Node *node) {
    ZuUnroll::all<ZuTypeRev<ZuTypeTail<1, KeyIDs>>>(
      [this, node]<typename KeyID>() mutable {
      m_hashes.template p<KeyID{}>()->delNode(node);
    }
    );
    auto node_ = m_hashes.template p<0>()->delNode(node);
    if constexpr (ZuTraits<NodeMvRef>::IsPrimitive)
      return static_cast<Node *>(node_);
    else
      return node_;
  }

  template <typename Base> struct Iterator : public Base {
    Iterator(Base &&i) : Base{ZuMv(i)} { }

    Node *iterate() { return static_cast<Node *>(Base::iterate()); }
  };
  auto iterator() const {
    using Base = ZuDecay<decltype(ZuDeclVal<const Primary &>().readIterator())>;
    return Iterator<Base>{m_hashes.template p<0>()->readIterator()};
  }
  template <unsigned KeyID, typename Key> auto iterator(Key &&key) const {
    using Base = ZuDecay<decltype(ZuDeclVal<const Hash<ZuUnsigned<KeyID>> &>()
				    .readIterator(ZuFwd<Key>(key)))>;
    return Iterator<Base>{
      m_hashes.template p<KeyID>()->readIterator(ZuFwd<Key>(key))
    };
  }

  void clean() {
    ZuUnroll::all<ZuTypeRev<KeyIDs>>([this]<typename KeyID>() {
      m_hashes.template p<KeyID{}>()->clean();
    });
  }

private:
  HashRefs m_hashes;
};

template <unsigned> struct ZuByteSwap_UInt;
template <> struct ZuByteSwap_UInt<2> {
  using T = uint16_t;
};
template <> struct ZuByteSwap_UInt<4> {
  using T = uint32_t;
};
template <> struct ZuByteSwap_UInt<8> {
  using T = uint64_t;
};
template <> struct ZuByteSwap_UInt<16> {
  using T = uint128_t;
};

template <typename T_> class ZuByteSwap {
public:
  using T = T_;
  using U = ZuUnder<T>;
  using I = typename ZuByteSwap_UInt<sizeof(T)>::T;

  ZuByteSwap() { m_i = 0; }
  ZuByteSwap(const ZuByteSwap &i) { m_i = i.m_i; }
  ZuByteSwap &operator=(const ZuByteSwap &i) {
    if (this != &i) m_i = i.m_i;
    return *this;
  }

  template <typename R> ZuByteSwap(const R &r) { set(r); }
  template <typename R> ZuByteSwap &operator=(const R &r) {
    set(r);
    return *this;
  }

  operator U() const { return get<U>(); }

  ZuByteSwap operator-() { return ZuByteSwap(-get<U>()); }

  template <typename P> ZuByteSwap operator+(const P &p) const {
    return ZuByteSwap(get<U>() + p);
  }
  template <typename P> ZuByteSwap operator-(const P &p) const {
    return ZuByteSwap(get<U>() - p);
  }
  template <typename P> ZuByteSwap operator*(const P &p) const {
    return ZuByteSwap(get<U>() * p);
  }
  template <typename P> ZuByteSwap operator/(const P &p) const {
    return ZuByteSwap(get<U>() / p);
  }
  template <typename P> ZuByteSwap operator%(const P &p) const {
    return ZuByteSwap(get<U>() % p);
  }
  template <typename P> ZuByteSwap operator|(const P &p) const {
    return ZuByteSwap(get<U>() | p);
  }
  template <typename P> ZuByteSwap operator&(const P &p) const {
    return ZuByteSwap(get<U>() & p);
  }
  template <typename P> ZuByteSwap operator^(const P &p) const {
    return ZuByteSwap(get<U>() ^ p);
  }

  ZuByteSwap operator++(int) {
    ZuByteSwap o = *this;
    set(get<U>() + 1);
    return o;
  }
  ZuByteSwap &operator++() {
    set(get<U>() + 1);
    return *this;
  }
  ZuByteSwap operator--(int) {
    ZuByteSwap o = *this;
    set(get<U>() - 1);
    return o;
  }
  ZuByteSwap &operator--() {
    set(get<U>() - 1);
    return *this;
  }

  template <typename P> ZuByteSwap &operator+=(const P &p) {
    set(get<U>() + p);
    return *this;
  }
  template <typename P> ZuByteSwap &operator-=(const P &p) {
    set(get<U>() - p);
    return *this;
  }
  template <typename P> ZuByteSwap &operator*=(const P &p) {
    set(get<U>() * p);
    return *this;
  }
  template <typename P> ZuByteSwap &operator/=(const P &p) {
    set(get<U>() / p);
    return *this;
  }
  template <typename P> ZuByteSwap &operator%=(const P &p) {
    set(get<U>() % p);
    return *this;
  }
  template <typename P> ZuByteSwap &operator|=(const P &p) {
    set(get<U>() | p);
    return *this;
  }
  template <typename P> ZuByteSwap &operator&=(const P &p) {
    set(get<U>() & p);
    return *this;
  }
  template <typename P> ZuByteSwap &operator^=(const P &p) {
    set(get<U>() ^ p);
    return *this;
  }

private:
  template <typename P> ZuExact<P, ZuByteSwap> set(const P &p) { m_i = p.m_i; }
  template <typename P> ZuExact<P, ZuByteSwap, const ZuByteSwap &> get() const {
    return *this;
  }

  template <typename P>
  ZuIfT<bool(ZuIsExact<P, T>{}) || bool(ZuIsExact<P, U>{})> set(const P &p) {
    I i = 0;
    U *__attribute__((__may_alias__)) ptr = reinterpret_cast<U *>(&i);
    *ptr = p;
    m_i = ZuIntrin::bswap(i);
  }
  template <typename P>
  ZuIfT<bool(ZuIsExact<P, T>{}) || bool(ZuIsExact<P, U>{}), P> get() const {
    I i = ZuIntrin::bswap(m_i);
    const U *__attribute__((__may_alias__)) ptr =
      reinterpret_cast<const U *>(&i);
    return *ptr;
  }

  template <typename P>
  ZuIfT<
    !ZuIsExact<P, ZuByteSwap>{} && !ZuIsExact<P, T>{} && !ZuIsExact<P, U>{} &&
    ZuTraits<P>::IsIntegral>
  set(P p) {
    m_i = ZuIntrin::bswap(I(p));
  }
  template <typename P>
  ZuIfT<
    !ZuIsExact<P, ZuByteSwap>{} && !ZuIsExact<P, T>{} && !ZuIsExact<P, U>{} &&
    ZuTraits<P>::IsIntegral>
  get() const {
    return ZuIntrin::bswap(m_i);
  }

  template <typename P>
  ZuIfT<
    !ZuIsExact<P, ZuByteSwap>{} && !ZuIsExact<P, T>{} && !ZuIsExact<P, U>{} &&
    !ZuTraits<P>::IsIntegral && ZuInspect<P, U>::Converts>
  set(P p) {
    I i = 0;
    U *__attribute__((__may_alias__)) ptr = reinterpret_cast<U *>(&i);
    *ptr = p;
    m_i = ZuIntrin::bswap(i);
  }
  template <typename P>
  ZuIfT<
    !ZuIsExact<P, ZuByteSwap>{} && !ZuIsExact<P, T>{} && !ZuIsExact<P, U>{} &&
      !ZuTraits<P>::IsIntegral && ZuInspect<U, P>::Converts,
    P>
  get() const {
    I i = ZuIntrin::bswap(m_i);
    return *reinterpret_cast<const U *>(&i);
  }

  struct Traits : public ZuTraits<I> {
    enum { IsPrimitive = 0 };
  };
  friend Traits ZuTraitsType(ZuByteSwap *);

  friend U ZuUnderType(ZuByteSwap *);

private:
  I m_i;
};

template <typename T> using ZuBigEndian = ZuByteSwap<T>;
template <typename T> using ZuLittleEndian = T;

static_assert(

  24

      == 24 &&

    3

      == 3 &&

    25

      == 25,
  "Non-compatible flatbuffers version included"
);

namespace Ztel { namespace fbs {

enum class DBCacheMode : int8_t {
  Normal = 0,
  All = 1,
  MIN = Normal,
  MAX = All
};

inline const DBCacheMode (&EnumValuesDBCacheMode())[2] {
  static const DBCacheMode values[] = {DBCacheMode::Normal, DBCacheMode::All};
  return values;
}

inline const char *const *EnumNamesDBCacheMode() {
  static const char *const names[3] = {"Normal", "All", nullptr};
  return names;
}

inline const char *EnumNameDBCacheMode(DBCacheMode e) {
  if (::flatbuffers::IsOutRange(e, DBCacheMode::Normal, DBCacheMode::All))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDBCacheMode()[index];
}

}} // namespace Ztel::fbs

static_assert(

  24

      == 24 &&

    3

      == 3 &&

    25

      == 25,
  "Non-compatible flatbuffers version included"
);

namespace Ztel { namespace fbs {

enum class DBHostState : int8_t {
  Instantiated = 0,
  Initialized = 1,
  Electing = 2,
  Active = 3,
  Inactive = 4,
  Stopping = 5,
  MIN = Instantiated,
  MAX = Stopping
};

inline const DBHostState (&EnumValuesDBHostState())[6] {
  static const DBHostState values[] = {
    DBHostState::Instantiated, DBHostState::Initialized, DBHostState::Electing,
    DBHostState::Active,       DBHostState::Inactive,    DBHostState::Stopping
  };
  return values;
}

inline const char *const *EnumNamesDBHostState() {
  static const char *const names[7] = {"Instantiated", "Initialized",
				       "Electing",     "Active",
				       "Inactive",     "Stopping",
				       nullptr};
  return names;
}

inline const char *EnumNameDBHostState(DBHostState e) {
  if (::flatbuffers::IsOutRange(
	e, DBHostState::Instantiated, DBHostState::Stopping
      ))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDBHostState()[index];
}

}} // namespace Ztel::fbs

namespace Zdb_ {

using Shard = uint8_t;

constexpr unsigned maxFields() { return 0x3fff; }
constexpr unsigned maxKeys() { return 0x7ff; }

using UN = uint64_t;
inline constexpr UN maxUN() { return ZuCmp<UN>::maximum(); }
inline constexpr UN nullUN() { return ZuCmp<UN>::null(); }

using SN = uint128_t;
inline constexpr SN maxSN() { return ZuCmp<SN>::maximum(); }
inline constexpr SN nullSN() { return ZuCmp<SN>::null(); }

using VN = int64_t;

namespace CacheMode {
namespace fbs = Ztel::fbs;
using T = ZuUnder<fbs::DBCacheMode>;
enum _ {
  Invalid = -1,
  Normal = int(fbs::DBCacheMode::Normal),
  All = int(fbs::DBCacheMode::All),
  MIN = int(fbs::DBCacheMode::MIN),
  MAX = int(fbs::DBCacheMode::MAX),
  N = int(fbs::DBCacheMode::MAX) + 1
};
static_assert((N <= 1024), "N <= 1024");
enum {
  Bits = N <= 2 ? 1 :
    N <= 4      ? 2 :
    N <= 8      ? 3 :
    N <= 16     ? 4 :
    N <= 32     ? 5 :
    N <= 64     ? 6 :
    N <= 128    ? 7 :
    N <= 256    ? 8 :
    N <= 512    ? 9 :
		  10
};
template <typename Impl> struct Map_ : public ZuObject {
private:
  using S2V = ZmLHashKV<ZuCSpan, T, ZmLHashStatic<Bits, ZmLHashLock<ZmNoLock>>>;

protected:
  void init(const char *s, int v, ...) {
    if (__builtin_expect(!!(!s), 0)) return;
    add(s, v);
    va_list args;

    __builtin_va_start(

      args

      ,

      v

    );
    while (s =

	     __builtin_va_arg(

	       args

	       ,

	       const char *

	     )

    )
      add(
	s,
	v =

	  __builtin_va_arg(

	    args

	    ,

	    int

	  )

      );

    __builtin_va_end(

      args

    );
  }
  void add(ZuCSpan s, T v) { m_s2v.add(s, v); }

private:
  T s2v_(ZuCSpan s) const { return m_s2v.findVal(s); }
  template <typename L> void all_(L l) const {
    auto i = m_s2v.readIterator();
    while (auto kv = i.iterate()) { l(S2V::KeyAxor(*kv), S2V::ValAxor(*kv)); }
  }

public:
  static constexpr const char *id() { return "DBCacheMode"; }
  using FBEnum = fbs::DBCacheMode;
  Map_() = default;
  static Impl *instance() { return ZmSingleton<Impl>::instance(); }
  static ZuCSpan v2s(int v) {
    return fbs::EnumNameDBCacheMode(static_cast<FBEnum>(v));
  }
  static T s2v(ZuCSpan s) { return instance()->s2v_(s); }
  template <typename L> static void all(L l) { instance()->all_(ZuMv(l)); }

private:
  S2V m_s2v;
};
const char *name(int i) {
  return fbs::EnumNameDBCacheMode(static_cast<fbs::DBCacheMode>(i));
}
struct Map : public Map_<Map> {
  Map() {
    for (unsigned i = 0; i < N; i++) this->add(name(i), i);
  }
};
template <typename S> T lookup(const S &s) { return Map::s2v(s); }

} // namespace CacheMode

namespace HostState {
namespace fbs = Ztel::fbs;
using T = ZuUnder<fbs::DBHostState>;
enum _ {
  Invalid = -1,
  Instantiated = int(fbs::DBHostState::Instantiated),
  Initialized = int(fbs::DBHostState::Initialized),
  Electing = int(fbs::DBHostState::Electing),
  Active = int(fbs::DBHostState::Active),
  Inactive = int(fbs::DBHostState::Inactive),
  Stopping = int(fbs::DBHostState::Stopping),
  MIN = int(fbs::DBHostState::MIN),
  MAX = int(fbs::DBHostState::MAX),
  N = int(fbs::DBHostState::MAX) + 1
};
static_assert((N <= 1024), "N <= 1024");
enum {
  Bits = N <= 2 ? 1 :
    N <= 4      ? 2 :
    N <= 8      ? 3 :
    N <= 16     ? 4 :
    N <= 32     ? 5 :
    N <= 64     ? 6 :
    N <= 128    ? 7 :
    N <= 256    ? 8 :
    N <= 512    ? 9 :
		  10
};
template <typename Impl> struct Map_ : public ZuObject {
private:
  using S2V = ZmLHashKV<ZuCSpan, T, ZmLHashStatic<Bits, ZmLHashLock<ZmNoLock>>>;

protected:
  void init(const char *s, int v, ...) {
    if (__builtin_expect(!!(!s), 0)) return;
    add(s, v);
    va_list args;

    __builtin_va_start(

      args

      ,

      v

    );
    while (s =

	     __builtin_va_arg(

	       args

	       ,

	       const char *

	     )

    )
      add(
	s,
	v =

	  __builtin_va_arg(

	    args

	    ,

	    int

	  )

      );

    __builtin_va_end(

      args

    );
  }
  void add(ZuCSpan s, T v) { m_s2v.add(s, v); }

private:
  T s2v_(ZuCSpan s) const { return m_s2v.findVal(s); }
  template <typename L> void all_(L l) const {
    auto i = m_s2v.readIterator();
    while (auto kv = i.iterate()) { l(S2V::KeyAxor(*kv), S2V::ValAxor(*kv)); }
  }

public:
  static constexpr const char *id() { return "DBHostState"; }
  using FBEnum = fbs::DBHostState;
  Map_() = default;
  static Impl *instance() { return ZmSingleton<Impl>::instance(); }
  static ZuCSpan v2s(int v) {
    return fbs::EnumNameDBHostState(static_cast<FBEnum>(v));
  }
  static T s2v(ZuCSpan s) { return instance()->s2v_(s); }
  template <typename L> static void all(L l) { instance()->all_(ZuMv(l)); }

private:
  S2V m_s2v;
};
const char *name(int i) {
  return fbs::EnumNameDBHostState(static_cast<fbs::DBHostState>(i));
}
struct Map : public Map_<Map> {
  Map() {
    for (unsigned i = 0; i < N; i++) this->add(name(i), i);
  }
};
template <typename S> T lookup(const S &s) { return Map::s2v(s); }

} // namespace HostState

namespace ObjState {
using T = int8_t;
enum {
  Invalid = -1,
  Undefined = 0,
  Insert,
  Update,
  Committed,
  Delete,
  Deleted,
  N
};
static_assert((N <= 1024), "N <= 1024");
enum {
  Bits = N <= 2 ? 1 :
    N <= 4      ? 2 :
    N <= 8      ? 3 :
    N <= 16     ? 4 :
    N <= 32     ? 5 :
    N <= 64     ? 6 :
    N <= 128    ? 7 :
    N <= 256    ? 8 :
    N <= 512    ? 9 :
		  10
};
template <typename Impl> struct Map_ : public ZuObject {
private:
  using V2S = ZmLHashKV<T, ZuCSpan, ZmLHashStatic<Bits, ZmLHashLocal<>>>;
  using S2V = ZmLHashKV<ZuCSpan, T, ZmLHashStatic<Bits, ZmLHashLocal<>>>;

protected:
  void init(const char *s, int v, ...) {
    if (__builtin_expect(!!(!s), 0)) return;
    add(s, v);
    va_list args;

    __builtin_va_start(

      args

      ,

      v

    );
    while (s =

	     __builtin_va_arg(

	       args

	       ,

	       const char *

	     )

    )
      add(
	s,
	v =

	  __builtin_va_arg(

	    args

	    ,

	    int

	  )

      );

    __builtin_va_end(

      args

    );
  }
  void add(ZuCSpan s, T v) {
    m_s2v.add(s, v);
    m_v2s.add(v, s);
  }
  static Impl *instance() { return ZmSingleton<Impl>::instance(); }

private:
  T s2v_(ZuCSpan s) const { return m_s2v.findVal(s); }
  ZuCSpan v2s_(T v) const { return m_v2s.findVal(v); }
  template <typename L> void all_(L l) const {
    auto i = m_s2v.readIterator();
    while (auto kv = i.iterate()) {
      l(kv->template p<0>(), kv->template p<1>());
    }
  }

public:
  Map_() = default;
  static T s2v(ZuCSpan s) { return instance()->s2v_(s); }
  static ZuCSpan v2s(T v) { return instance()->v2s_(v); }
  template <typename L> static void all(L l) { instance()->all_(ZuMv(l)); }

private:
  S2V m_s2v;
  V2S m_v2s;
};
inline ZuTuple<const char *const *const, unsigned> names() {
  static const char *names[] = {"Undefined = 0", "Insert", "Update",
				"Committed",     "Delete", "Deleted"};
  return ZuTuple<const char *const *const, unsigned>{
    names, static_cast<unsigned>(sizeof(names) / sizeof(names[0]))
  };
}
inline const char *name(int i) {
  ZuTuple<const char *const *const, unsigned> names_ = names();
  if (i >= (int)names_.p<1>()) return "Unknown";
  if (i < 0) return "";
  return names_.p<0>()[i];
}
struct Map : public Map_<Map> {
  static constexpr const char *id() { return "ObjState"; }
  Map() {
    for (unsigned i = 0; i < N; i++) this->add(name(i), i);
  }
};
template <typename S> inline T lookup(const S &s) { return Map::s2v(s); };
} // namespace ObjState

} // namespace Zdb_

using ZdbShard = Zdb_::Shard;

using ZdbUN = Zdb_::UN;

using ZdbSN = Zdb_::SN;
using ZdbVN = Zdb_::VN;

namespace ZdbCacheMode = Zdb_::CacheMode;
namespace ZdbHostState = Zdb_::HostState;
namespace ZdbObjState = Zdb_::ObjState;

static_assert(

  24

      == 24 &&

    3

      == 3 &&

    25

      == 25,
  "Non-compatible flatbuffers version included"
);

namespace Zdb_ { namespace fbs {

struct MsgSchema {
  static const uint8_t *data() {
    static const uint8_t bfbsData[3360] = {
      0x20, 0x00, 0x00, 0x00, 0x42, 0x46, 0x42, 0x53, 0x00, 0x00, 0x00, 0x00,
      0x14, 0x00, 0x28, 0x00, 0x04, 0x00, 0x08, 0x00, 0x0C, 0x00, 0x10, 0x00,
      0x14, 0x00, 0x18, 0x00, 0x20, 0x00, 0x1C, 0x00, 0x14, 0x00, 0x00, 0x00,
      0x40, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00,
      0x1C, 0x00, 0x00, 0x00, 0x3C, 0x02, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
      0x6C, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x8C, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0xBC, 0x02, 0x00, 0x00,
      0x70, 0x05, 0x00, 0x00, 0xA8, 0x04, 0x00, 0x00, 0xFC, 0x01, 0x00, 0x00,
      0x60, 0x03, 0x00, 0x00, 0x34, 0x06, 0x00, 0x00, 0x8C, 0x0B, 0x00, 0x00,
      0xF0, 0x0B, 0x00, 0x00, 0xCC, 0x07, 0x00, 0x00, 0x10, 0x09, 0x00, 0x00,
      0x90, 0x09, 0x00, 0x00, 0xE4, 0x06, 0x00, 0x00, 0x38, 0x07, 0x00, 0x00,
      0x30, 0x0A, 0x00, 0x00, 0x64, 0x08, 0x00, 0x00, 0xC0, 0x0A, 0x00, 0x00,
      0x02, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0xE4, 0xF4, 0xFF, 0xFF, 0x0C, 0x06, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0xC4, 0x0B, 0x00, 0x00, 0xF8, 0xF4, 0xFF, 0xFF,
      0xBC, 0x0B, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x12, 0x00, 0x18, 0x00, 0x08, 0x00, 0x0C, 0x00, 0x07, 0x00,
      0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x12, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x01, 0x3C, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00,
      0x08, 0x00, 0x00, 0x00, 0xC4, 0x05, 0x00, 0x00, 0x14, 0xFE, 0xFF, 0xFF,
      0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x20, 0x01, 0x00, 0x00,
      0xDC, 0x00, 0x00, 0x00, 0x98, 0x00, 0x00, 0x00, 0x5C, 0x00, 0x00, 0x00,
      0x18, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x5A, 0x64, 0x62, 0x5F,
      0x2E, 0x66, 0x62, 0x73, 0x2E, 0x42, 0x6F, 0x64, 0x79, 0x00, 0x00, 0x00,
      0xCC, 0xFF, 0xFF, 0xFF, 0x24, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0xD4, 0xFA, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x43, 0x6F, 0x6D, 0x6D,
      0x69, 0x74, 0x00, 0x00, 0x0C, 0x00, 0x18, 0x00, 0x04, 0x00, 0x0C, 0x00,
      0x00, 0x00, 0x08, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00,
      0x10, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x14, 0xFB, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x0F,
      0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
      0x52, 0x65, 0x63, 0x6F, 0x76, 0x65, 0x72, 0x79, 0x00, 0x00, 0x00, 0x00,
      0xCC, 0xFF, 0xFF, 0xFF, 0x20, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00,
      0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0xFB, 0xFF, 0xFF,
      0x00, 0x00, 0x00, 0x0F, 0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x0B, 0x00, 0x00, 0x00, 0x52, 0x65, 0x70, 0x6C, 0x69, 0x63, 0x61, 0x74,
      0x69, 0x6F, 0x6E, 0x00, 0x0C, 0x00, 0x14, 0x00, 0x04, 0x00, 0x0C, 0x00,
      0x00, 0x00, 0x08, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00,
      0x0C, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x88, 0xFB, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x0F, 0x02, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x48, 0x65, 0x61, 0x72,
      0x74, 0x62, 0x65, 0x61, 0x74, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x0C, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x0C, 0x00, 0x00, 0x00,
      0x24, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x10, 0x00, 0x0C, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x08, 0x00,
      0x10, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x4E, 0x4F, 0x4E, 0x45, 0x00, 0x00, 0x00, 0x00,
      0x10, 0xF6, 0xFF, 0xFF, 0x1C, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x44, 0x04, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
      0x1C, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00,
      0x5A, 0x64, 0x62, 0x5F, 0x2E, 0x66, 0x62, 0x73, 0x2E, 0x4D, 0x73, 0x67,
      0x00, 0x00, 0x00, 0x00, 0x90, 0xFC, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x01,
      0x01, 0x00, 0x06, 0x00, 0x18, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0x30, 0xFC, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x62, 0x6F, 0x64, 0x79,
      0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x10, 0x00, 0x08, 0x00, 0x0C, 0x00,
      0x00, 0x00, 0x06, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,
      0x2C, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x10, 0x00, 0x14, 0x00,
      0x07, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x10, 0x00,
      0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00,
      0x62, 0x6F, 0x64, 0x79, 0x5F, 0x74, 0x79, 0x70, 0x65, 0x00, 0x00, 0x00,
      0xC4, 0xF6, 0xFF, 0xFF, 0x20, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x90, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
      0x20, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00,
      0x0F, 0x00, 0x00, 0x00, 0x5A, 0x64, 0x62, 0x5F, 0x2E, 0x66, 0x62, 0x73,
      0x2E, 0x43, 0x6F, 0x6D, 0x6D, 0x69, 0x74, 0x00, 0xC0, 0xF7, 0xFF, 0xFF,
      0x02, 0x00, 0x08, 0x00, 0x18, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0x88, 0xF7, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x04, 0x01, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x73, 0x68, 0x61, 0x72,
      0x64, 0x00, 0x00, 0x00, 0xEC, 0xF7, 0xFF, 0xFF, 0x01, 0x00, 0x06, 0x00,
      0x18, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xB4, 0xF7, 0xFF, 0xFF,
      0x00, 0x00, 0x00, 0x0A, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x02, 0x00, 0x00, 0x00, 0x75, 0x6E, 0x00, 0x00, 0xE4, 0xF6, 0xFF, 0xFF,
      0x00, 0x01, 0x04, 0x00, 0x14, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0x70, 0xFA, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x0D, 0x01, 0x00, 0x00, 0x00,
      0x05, 0x00, 0x00, 0x00, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x00, 0x00, 0x00,
      0x78, 0xF7, 0xFF, 0xFF, 0x2C, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0xDC, 0x02, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
      0x2C, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 0xA4, 0x00, 0x00, 0x00,
      0xF4, 0x00, 0x00, 0x00, 0xC8, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00,
      0x0F, 0x00, 0x00, 0x00, 0x5A, 0x64, 0x62, 0x5F, 0x2E, 0x66, 0x62, 0x73,
      0x2E, 0x52, 0x65, 0x63, 0x6F, 0x72, 0x64, 0x00, 0x08, 0xFE, 0xFF, 0xFF,
      0x00, 0x00, 0x00, 0x01, 0x05, 0x00, 0x0E, 0x00, 0x14, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x38, 0xF7, 0xFF, 0xFF, 0x00, 0x00, 0x0E, 0x04,
      0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x64, 0x61, 0x74, 0x61,
      0x00, 0x00, 0x00, 0x00, 0xAC, 0xF8, 0xFF, 0xFF, 0x04, 0x00, 0x0C, 0x00,
      0x18, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x74, 0xF8, 0xFF, 0xFF,
      0x00, 0x00, 0x00, 0x04, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x05, 0x00, 0x00, 0x00, 0x73, 0x68, 0x61, 0x72, 0x64, 0x00, 0x00, 0x00,
      0xD8, 0xF8, 0xFF, 0xFF, 0x03, 0x00, 0x0A, 0x00, 0x18, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0xA0, 0xF8, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x09,
      0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
      0x76, 0x6E, 0x00, 0x00, 0x88, 0xFE, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x01,
      0x02, 0x00, 0x08, 0x00, 0x18, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0x28, 0xFE, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x73, 0x6E, 0x00, 0x00,
      0x2C, 0xF9, 0xFF, 0xFF, 0x01, 0x00, 0x06, 0x00, 0x18, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0xF4, 0xF8, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x0A,
      0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
      0x75, 0x6E, 0x00, 0x00, 0x24, 0xF8, 0xFF, 0xFF, 0x00, 0x01, 0x04, 0x00,
      0x14, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xB0, 0xFB, 0xFF, 0xFF,
      0x00, 0x00, 0x00, 0x0D, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
      0x74, 0x61, 0x62, 0x6C, 0x65, 0x00, 0x00, 0x00, 0xB8, 0xF8, 0xFF, 0xFF,
      0x20, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x9C, 0x01, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00,
      0x7C, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00,
      0x5A, 0x64, 0x62, 0x5F, 0x2E, 0x66, 0x62, 0x73, 0x2E, 0x48, 0x65, 0x61,
      0x72, 0x74, 0x62, 0x65, 0x61, 0x74, 0x00, 0x00, 0x40, 0xFF, 0xFF, 0xFF,
      0x00, 0x00, 0x00, 0x01, 0x02, 0x00, 0x08, 0x00, 0x18, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0xE0, 0xFE, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x0F,
      0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
      0x64, 0x62, 0x5F, 0x73, 0x74, 0x61, 0x74, 0x65, 0x00, 0x00, 0x00, 0x00,
      0xEC, 0xF9, 0xFF, 0xFF, 0x01, 0x00, 0x06, 0x00, 0x14, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x48, 0xFC, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x08,
      0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x73, 0x74, 0x61, 0x74,
      0x65, 0x00, 0x00, 0x00, 0xE4, 0xF8, 0xFF, 0xFF, 0x00, 0x01, 0x04, 0x00,
      0x18, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x38, 0xFF, 0xFF, 0xFF,
      0x00, 0x00, 0x00, 0x0F, 0x0B, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x68, 0x6F, 0x73, 0x74, 0x00, 0x00, 0x00, 0x00,
      0x7C, 0xF9, 0xFF, 0xFF, 0x1C, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0xD8, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
      0x84, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
      0x5A, 0x64, 0x62, 0x5F, 0x2E, 0x66, 0x62, 0x73, 0x2E, 0x44, 0x42, 0x53,
      0x74, 0x61, 0x74, 0x65, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x14, 0x00,
      0x0C, 0x00, 0x10, 0x00, 0x08, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00,
      0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x06, 0x00,
      0x28, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x10, 0x00, 0x10, 0x00,
      0x06, 0x00, 0x07, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00,
      0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x0F, 0x05, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x74, 0x61, 0x62, 0x6C,
      0x65, 0x5F, 0x73, 0x74, 0x61, 0x74, 0x65, 0x73, 0x00, 0x00, 0x00, 0x00,
      0xAC, 0xF9, 0xFF, 0xFF, 0x00, 0x01, 0x04, 0x00, 0x28, 0x00, 0x00, 0x00,
      0x14, 0x00, 0x00, 0x00, 0x10, 0x00, 0x10, 0x00, 0x07, 0x00, 0x00, 0x00,
      0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x10, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x02, 0x00, 0x00, 0x00, 0x73, 0x6E, 0x00, 0x00, 0x50, 0xFA, 0xFF, 0xFF,
      0x30, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x2F, 0x2F, 0x7A, 0x64,
      0x62, 0x5F, 0x2E, 0x66, 0x62, 0x73, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
      0x24, 0x00, 0x00, 0x00, 0x74, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00,
      0x13, 0x00, 0x00, 0x00, 0x5A, 0x64, 0x62, 0x5F, 0x2E, 0x66, 0x62, 0x73,
      0x2E, 0x54, 0x61, 0x62, 0x6C, 0x65, 0x53, 0x74, 0x61, 0x74, 0x65, 0x00,
      0x60, 0xFB, 0xFF, 0xFF, 0x02, 0x00, 0x08, 0x00, 0x18, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x28, 0xFB, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x04,
      0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
      0x73, 0x68, 0x61, 0x72, 0x64, 0x00, 0x00, 0x00, 0x8C, 0xFB, 0xFF, 0xFF,
      0x01, 0x00, 0x06, 0x00, 0x18, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0x54, 0xFB, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x0A, 0x08, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x75, 0x6E, 0x00, 0x00,
      0x84, 0xFA, 0xFF, 0xFF, 0x00, 0x01, 0x04, 0x00, 0x14, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x10, 0xFE, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x0D,
      0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x74, 0x61, 0x62, 0x6C,
      0x65, 0x00, 0x00, 0x00, 0x28, 0xFC, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x01,
      0x1C, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x08, 0x00, 0x00, 0x00, 0xF8, 0x04, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x10, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x5A, 0x66, 0x62, 0x2E,
      0x49, 0x44, 0x00, 0x00, 0xA8, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x01,
      0x14, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x8C, 0xFF, 0xFF, 0xFF,
      0x11, 0x04, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0x00, 0x00, 0x80, 0xFC, 0xFF, 0xFF,
      0x00, 0x00, 0x00, 0x01, 0x1C, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xA0, 0x04, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x2C, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
      0x5A, 0x66, 0x62, 0x2E, 0x49, 0x50, 0x00, 0x00, 0x1C, 0x00, 0x10, 0x00,
      0x08, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00,
      0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x24, 0x00, 0x00, 0x00,
      0x14, 0x00, 0x00, 0x00, 0x10, 0x00, 0x0C, 0x00, 0x04, 0x00, 0x05, 0x00,
      0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x08, 0x00, 0x10, 0x00, 0x00, 0x00,
      0x11, 0x04, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0x61, 0x64, 0x64, 0x72, 0x00, 0x00, 0x00, 0x00, 0x04, 0xFD, 0xFF, 0xFF,
      0x00, 0x00, 0x00, 0x01, 0x24, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x1C, 0x04, 0x00, 0x00,
      0x03, 0x00, 0x00, 0x00, 0x6C, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00,
      0x40, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x5A, 0x66, 0x62, 0x2E,
      0x44, 0x61, 0x74, 0x65, 0x54, 0x69, 0x6D, 0x65, 0x00, 0x00, 0x00, 0x00,
      0xF8, 0xFC, 0xFF, 0xFF, 0x02, 0x00, 0x08, 0x00, 0x14, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x54, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x07,
      0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x6E, 0x73, 0x65, 0x63,
      0x00, 0x00, 0x00, 0x00, 0x20, 0xFD, 0xFF, 0xFF, 0x01, 0x00, 0x04, 0x00,
      0x14, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x7C, 0xFF, 0xFF, 0xFF,
      0x00, 0x00, 0x00, 0x07, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
      0x73, 0x65, 0x63, 0x00, 0x10, 0xFD, 0xFF, 0xFF, 0x14, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x9C, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x07,
      0x01, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x6A, 0x75, 0x6C, 0x69,
      0x61, 0x6E, 0x00, 0x00, 0xB4, 0xFD, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x01,
      0x20, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
      0x10, 0x00, 0x00, 0x00, 0x6C, 0x03, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
      0x18, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
      0x5A, 0x66, 0x62, 0x2E, 0x54, 0x69, 0x6D, 0x65, 0x00, 0x00, 0x00, 0x00,
      0xE6, 0xFE, 0xFF, 0xFF, 0x00, 0x00, 0x01, 0x00, 0x08, 0x00, 0x04, 0x00,
      0x24, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x10, 0x00, 0x0C, 0x00,
      0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
      0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x01, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x6E, 0x73, 0x65, 0x63, 0x00, 0x00, 0x00, 0x00,
      0xA8, 0xFD, 0xFF, 0xFF, 0x18, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0xA0, 0xFD, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x09, 0x08, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x73, 0x65, 0x63, 0x00,
      0x4C, 0xFE, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x01, 0x20, 0x00, 0x00, 0x00,
      0x10, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
      0xD4, 0x02, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
      0x14, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x5A, 0x66, 0x62, 0x2E,
      0x44, 0x65, 0x63, 0x69, 0x6D, 0x61, 0x6C, 0x00, 0x38, 0xFE, 0xFF, 0xFF,
      0x01, 0x00, 0x08, 0x00, 0x18, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0x00, 0xFE, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x0A, 0x08, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x6C, 0x00, 0x00, 0x00,
      0x2C, 0xFE, 0xFF, 0xFF, 0x18, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0x24, 0xFE, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x0A, 0x08, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x68, 0x00, 0x00, 0x00,
      0xD0, 0xFE, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x01, 0x20, 0x00, 0x00, 0x00,
      0x10, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
      0x50, 0x02, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
      0x30, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x5A, 0x66, 0x62, 0x2E,
      0x46, 0x69, 0x78, 0x65, 0x64, 0x00, 0x1E, 0x00, 0x14, 0x00, 0x0C, 0x00,
      0x10, 0x00, 0x06, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x00,
      0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x08, 0x00, 0x07, 0x00,
      0x18, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xA4, 0xFE, 0xFF, 0xFF,
      0x00, 0x00, 0x00, 0x04, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x03, 0x00, 0x00, 0x00, 0x6E, 0x64, 0x70, 0x00, 0xD0, 0xFE, 0xFF, 0xFF,
      0x18, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xC8, 0xFE, 0xFF, 0xFF,
      0x00, 0x00, 0x00, 0x09, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x08, 0x00, 0x00, 0x00, 0x6D, 0x61, 0x6E, 0x74, 0x69, 0x73, 0x73, 0x61,
      0x00, 0x00, 0x00, 0x00, 0x7C, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x01,
      0x20, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
      0x10, 0x00, 0x00, 0x00, 0xA4, 0x01, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
      0x40, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00,
      0x5A, 0x66, 0x62, 0x2E, 0x49, 0x6E, 0x74, 0x31, 0x32, 0x38, 0x00, 0x00,
      0x68, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x08, 0x00, 0x18, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x30, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x0A,
      0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x6C, 0x00, 0x00, 0x00, 0x5C, 0xFF, 0xFF, 0xFF, 0x18, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x54, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x0A,
      0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x68, 0x00, 0x00, 0x00, 0x14, 0x00, 0x1C, 0x00, 0x08, 0x00, 0x0C, 0x00,
      0x07, 0x00, 0x10, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00,
      0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x20, 0x00, 0x00, 0x00,
      0x10, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
      0x0C, 0x01, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00,
      0x20, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x5A, 0x66, 0x62, 0x2E,
      0x55, 0x49, 0x6E, 0x74, 0x31, 0x32, 0x38, 0x00, 0x0C, 0x00, 0x10, 0x00,
      0x08, 0x00, 0x0C, 0x00, 0x04, 0x00, 0x06, 0x00, 0x0C, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x08, 0x00, 0x18, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0xD4, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x0A, 0x08, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x6C, 0x00, 0x00, 0x00,
      0x08, 0x00, 0x0C, 0x00, 0x04, 0x00, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00,
      0x28, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x10, 0x00, 0x10, 0x00,
      0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x0C, 0x00,
      0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x08, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x68, 0x00, 0x00, 0x00,
      0xAC, 0xFF, 0xFF, 0xFF, 0x18, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x6C, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x14, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x5A, 0x66, 0x62, 0x2E,
      0x42, 0x69, 0x74, 0x6D, 0x61, 0x70, 0x00, 0x00, 0x6C, 0xFF, 0xFF, 0xFF,
      0x00, 0x01, 0x04, 0x00, 0x14, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0x50, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x0E, 0x0A, 0x08, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0x00, 0x00,
      0x14, 0x00, 0x14, 0x00, 0x04, 0x00, 0x08, 0x00, 0x00, 0x00, 0x0C, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x14, 0x00, 0x00, 0x00,
      0x44, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x2F, 0x2F, 0x2E, 0x2E,
      0x2F, 0x2E, 0x2E, 0x2F, 0x2E, 0x2E, 0x2F, 0x7A, 0x66, 0x62, 0x2F, 0x73,
      0x72, 0x63, 0x2F, 0x66, 0x62, 0x73, 0x2F, 0x7A, 0x66, 0x62, 0x5F, 0x74,
      0x79, 0x70, 0x65, 0x73, 0x2E, 0x66, 0x62, 0x73, 0x00, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00,
      0x5A, 0x66, 0x62, 0x2E, 0x42, 0x79, 0x74, 0x65, 0x73, 0x00, 0x00, 0x00,
      0x1C, 0x00, 0x10, 0x00, 0x08, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x06, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x05, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x01, 0x04, 0x00,
      0x24, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x10, 0x00, 0x0C, 0x00,
      0x06, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
      0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x04, 0x01, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0x00, 0x00
    };
    return bfbsData;
  }
  static size_t size() { return 3360; }
  const uint8_t *begin() { return data(); }
  const uint8_t *end() { return data() + size(); }
};

}} // namespace Zdb_::fbs

namespace Zdb_ { namespace fbs {

struct TableState;
struct TableStateBuilder;

struct DBState;
struct DBStateBuilder;

struct Heartbeat;
struct HeartbeatBuilder;

struct Record;
struct RecordBuilder;

struct Commit;
struct CommitBuilder;

struct Msg;
struct MsgBuilder;

enum class Body : uint8_t {
  NONE = 0,
  Heartbeat = 1,
  Replication = 2,
  Recovery = 3,
  Commit = 4,
  MIN = NONE,
  MAX = Commit
};

inline const Body (&EnumValuesBody())[5] {
  static const Body values[] = {
    Body::NONE, Body::Heartbeat, Body::Replication, Body::Recovery, Body::Commit
  };
  return values;
}

inline const char *const *EnumNamesBody() {
  static const char *const names[6] = {"NONE",     "Heartbeat", "Replication",
				       "Recovery", "Commit",    nullptr};
  return names;
}

inline const char *EnumNameBody(Body e) {
  if (::flatbuffers::IsOutRange(e, Body::NONE, Body::Commit)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBody()[index];
}

bool VerifyBody(::flatbuffers::Verifier &verifier, const void *obj, Body type);
bool VerifyBodyVector(
  ::flatbuffers::Verifier &verifier,
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values,
  const ::flatbuffers::Vector<Body> *types
);

struct TableState

  final

  : private ::flatbuffers::Table {
  typedef TableStateBuilder Builder;
  typedef Zdb_::fbs::MsgSchema BinarySchema;
  struct Traits;
  enum FlatBuffersVTableOffset

    : ::flatbuffers::voffset_t

  {
    VT_TABLE = 4,
    VT_UN = 6,
    VT_SHARD = 8
  };
  const ::flatbuffers::String *table() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TABLE);
  }
  uint64_t un() const { return GetField<uint64_t>(VT_UN, 0); }
  uint8_t shard() const { return GetField<uint8_t>(VT_SHARD, 0); }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_TABLE) &&
      verifier.VerifyString(table()) &&
      VerifyField<uint64_t>(verifier, VT_UN, 8) &&
      VerifyField<uint8_t>(verifier, VT_SHARD, 1) && verifier.EndTable();
  }
};

struct TableStateBuilder {
  typedef TableState Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_table(::flatbuffers::Offset<::flatbuffers::String> table) {
    fbb_.AddOffset(TableState::VT_TABLE, table);
  }
  void add_un(uint64_t un) {
    fbb_.AddElement<uint64_t>(TableState::VT_UN, un, 0);
  }
  void add_shard(uint8_t shard) {
    fbb_.AddElement<uint8_t>(TableState::VT_SHARD, shard, 0);
  }
  explicit TableStateBuilder(::flatbuffers::FlatBufferBuilder &_fbb) :
    fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TableState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TableState>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TableState> CreateTableState(
  ::flatbuffers::FlatBufferBuilder &_fbb,
  ::flatbuffers::Offset<::flatbuffers::String> table = 0, uint64_t un = 0,
  uint8_t shard = 0
) {
  TableStateBuilder builder_(_fbb);
  builder_.add_un(un);
  builder_.add_table(table);
  builder_.add_shard(shard);
  return builder_.Finish();
}

struct TableState::Traits {
  using type = TableState;
  static constexpr auto Create = CreateTableState;
};

inline ::flatbuffers::Offset<TableState> CreateTableStateDirect(
  ::flatbuffers::FlatBufferBuilder &_fbb, const char *table = nullptr,
  uint64_t un = 0, uint8_t shard = 0
) {
  auto table__ = table ? _fbb.CreateString(table) : 0;
  return Zdb_::fbs::CreateTableState(_fbb, table__, un, shard);
}

struct DBState

  final

  : private ::flatbuffers::Table {
  typedef DBStateBuilder Builder;
  typedef Zdb_::fbs::MsgSchema BinarySchema;
  struct Traits;
  enum FlatBuffersVTableOffset

    : ::flatbuffers::voffset_t

  {
    VT_SN = 4,
    VT_TABLESTATES = 6
  };
  const Zfb::UInt128 *sn() const {
    return GetStruct<const Zfb::UInt128 *>(VT_SN);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Zdb_::fbs::TableState>> *
  tableStates() const {
    return GetPointer<const ::flatbuffers::Vector<
      ::flatbuffers::Offset<Zdb_::fbs::TableState>> *>(VT_TABLESTATES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
      VerifyField<Zfb::UInt128>(verifier, VT_SN, 8) &&
      VerifyOffset(verifier, VT_TABLESTATES) &&
      verifier.VerifyVector(tableStates()) &&
      verifier.VerifyVectorOfTables(tableStates()) && verifier.EndTable();
  }
};

struct DBStateBuilder {
  typedef DBState Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_sn(const Zfb::UInt128 *sn) { fbb_.AddStruct(DBState::VT_SN, sn); }
  void add_tableStates(
    ::flatbuffers::Offset<
      ::flatbuffers::Vector<::flatbuffers::Offset<Zdb_::fbs::TableState>>>
      tableStates
  ) {
    fbb_.AddOffset(DBState::VT_TABLESTATES, tableStates);
  }
  explicit DBStateBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DBState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DBState>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DBState> CreateDBState(
  ::flatbuffers::FlatBufferBuilder &_fbb, const Zfb::UInt128 *sn = nullptr,
  ::flatbuffers::Offset<
    ::flatbuffers::Vector<::flatbuffers::Offset<Zdb_::fbs::TableState>>>
    tableStates = 0
) {
  DBStateBuilder builder_(_fbb);
  builder_.add_tableStates(tableStates);
  builder_.add_sn(sn);
  return builder_.Finish();
}

struct DBState::Traits {
  using type = DBState;
  static constexpr auto Create = CreateDBState;
};

inline ::flatbuffers::Offset<DBState> CreateDBStateDirect(
  ::flatbuffers::FlatBufferBuilder &_fbb, const Zfb::UInt128 *sn = nullptr,
  const std::vector<::flatbuffers::Offset<Zdb_::fbs::TableState>> *tableStates =
    nullptr
) {
  auto tableStates__ = tableStates ?
    _fbb.CreateVector<::flatbuffers::Offset<Zdb_::fbs::TableState>>(*tableStates
    ) :
    0;
  return Zdb_::fbs::CreateDBState(_fbb, sn, tableStates__);
}

struct Heartbeat

  final

  : private ::flatbuffers::Table {
  typedef HeartbeatBuilder Builder;
  typedef Zdb_::fbs::MsgSchema BinarySchema;
  struct Traits;
  enum FlatBuffersVTableOffset

    : ::flatbuffers::voffset_t

  {
    VT_HOST = 4,
    VT_STATE = 6,
    VT_DBSTATE = 8
  };
  const Zfb::ID *host() const { return GetStruct<const Zfb::ID *>(VT_HOST); }
  uint32_t state() const { return GetField<uint32_t>(VT_STATE, 0); }
  const Zdb_::fbs::DBState *dbState() const {
    return GetPointer<const Zdb_::fbs::DBState *>(VT_DBSTATE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
      VerifyField<Zfb::ID>(verifier, VT_HOST, 1) &&
      VerifyField<uint32_t>(verifier, VT_STATE, 4) &&
      VerifyOffset(verifier, VT_DBSTATE) && verifier.VerifyTable(dbState()) &&
      verifier.EndTable();
  }
};

struct HeartbeatBuilder {
  typedef Heartbeat Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_host(const Zfb::ID *host) {
    fbb_.AddStruct(Heartbeat::VT_HOST, host);
  }
  void add_state(uint32_t state) {
    fbb_.AddElement<uint32_t>(Heartbeat::VT_STATE, state, 0);
  }
  void add_dbState(::flatbuffers::Offset<Zdb_::fbs::DBState> dbState) {
    fbb_.AddOffset(Heartbeat::VT_DBSTATE, dbState);
  }
  explicit HeartbeatBuilder(::flatbuffers::FlatBufferBuilder &_fbb) :
    fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Heartbeat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Heartbeat>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Heartbeat> CreateHeartbeat(
  ::flatbuffers::FlatBufferBuilder &_fbb, const Zfb::ID *host = nullptr,
  uint32_t state = 0, ::flatbuffers::Offset<Zdb_::fbs::DBState> dbState = 0
) {
  HeartbeatBuilder builder_(_fbb);
  builder_.add_dbState(dbState);
  builder_.add_state(state);
  builder_.add_host(host);
  return builder_.Finish();
}

struct Heartbeat::Traits {
  using type = Heartbeat;
  static constexpr auto Create = CreateHeartbeat;
};

struct Record

  final

  : private ::flatbuffers::Table {
  typedef RecordBuilder Builder;
  typedef Zdb_::fbs::MsgSchema BinarySchema;
  struct Traits;
  enum FlatBuffersVTableOffset

    : ::flatbuffers::voffset_t

  {
    VT_TABLE = 4,
    VT_UN = 6,
    VT_SN = 8,
    VT_VN = 10,
    VT_SHARD = 12,
    VT_DATA = 14
  };
  const ::flatbuffers::String *table() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TABLE);
  }
  uint64_t un() const { return GetField<uint64_t>(VT_UN, 0); }
  const Zfb::UInt128 *sn() const {
    return GetStruct<const Zfb::UInt128 *>(VT_SN);
  }
  int64_t vn() const { return GetField<int64_t>(VT_VN, 0); }
  uint8_t shard() const { return GetField<uint8_t>(VT_SHARD, 0); }
  const ::flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_TABLE) &&
      verifier.VerifyString(table()) &&
      VerifyField<uint64_t>(verifier, VT_UN, 8) &&
      VerifyField<Zfb::UInt128>(verifier, VT_SN, 8) &&
      VerifyField<int64_t>(verifier, VT_VN, 8) &&
      VerifyField<uint8_t>(verifier, VT_SHARD, 1) &&
      VerifyOffset(verifier, VT_DATA) && verifier.VerifyVector(data()) &&
      verifier.EndTable();
  }
};

struct RecordBuilder {
  typedef Record Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_table(::flatbuffers::Offset<::flatbuffers::String> table) {
    fbb_.AddOffset(Record::VT_TABLE, table);
  }
  void add_un(uint64_t un) { fbb_.AddElement<uint64_t>(Record::VT_UN, un, 0); }
  void add_sn(const Zfb::UInt128 *sn) { fbb_.AddStruct(Record::VT_SN, sn); }
  void add_vn(int64_t vn) { fbb_.AddElement<int64_t>(Record::VT_VN, vn, 0); }
  void add_shard(uint8_t shard) {
    fbb_.AddElement<uint8_t>(Record::VT_SHARD, shard, 0);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(Record::VT_DATA, data);
  }
  explicit RecordBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Record> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Record>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Record> CreateRecord(
  ::flatbuffers::FlatBufferBuilder &_fbb,
  ::flatbuffers::Offset<::flatbuffers::String> table = 0, uint64_t un = 0,
  const Zfb::UInt128 *sn = nullptr, int64_t vn = 0, uint8_t shard = 0,
  ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data = 0
) {
  RecordBuilder builder_(_fbb);
  builder_.add_vn(vn);
  builder_.add_un(un);
  builder_.add_data(data);
  builder_.add_sn(sn);
  builder_.add_table(table);
  builder_.add_shard(shard);
  return builder_.Finish();
}

struct Record::Traits {
  using type = Record;
  static constexpr auto Create = CreateRecord;
};

inline ::flatbuffers::Offset<Record> CreateRecordDirect(
  ::flatbuffers::FlatBufferBuilder &_fbb, const char *table = nullptr,
  uint64_t un = 0, const Zfb::UInt128 *sn = nullptr, int64_t vn = 0,
  uint8_t shard = 0, const std::vector<uint8_t> *data = nullptr
) {
  auto table__ = table ? _fbb.CreateString(table) : 0;
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return Zdb_::fbs::CreateRecord(_fbb, table__, un, sn, vn, shard, data__);
}

struct Commit

  final

  : private ::flatbuffers::Table {
  typedef CommitBuilder Builder;
  typedef Zdb_::fbs::MsgSchema BinarySchema;
  struct Traits;
  enum FlatBuffersVTableOffset

    : ::flatbuffers::voffset_t

  {
    VT_TABLE = 4,
    VT_UN = 6,
    VT_SHARD = 8
  };
  const ::flatbuffers::String *table() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TABLE);
  }
  uint64_t un() const { return GetField<uint64_t>(VT_UN, 0); }
  uint8_t shard() const { return GetField<uint8_t>(VT_SHARD, 0); }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_TABLE) &&
      verifier.VerifyString(table()) &&
      VerifyField<uint64_t>(verifier, VT_UN, 8) &&
      VerifyField<uint8_t>(verifier, VT_SHARD, 1) && verifier.EndTable();
  }
};

struct CommitBuilder {
  typedef Commit Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_table(::flatbuffers::Offset<::flatbuffers::String> table) {
    fbb_.AddOffset(Commit::VT_TABLE, table);
  }
  void add_un(uint64_t un) { fbb_.AddElement<uint64_t>(Commit::VT_UN, un, 0); }
  void add_shard(uint8_t shard) {
    fbb_.AddElement<uint8_t>(Commit::VT_SHARD, shard, 0);
  }
  explicit CommitBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Commit> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Commit>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Commit> CreateCommit(
  ::flatbuffers::FlatBufferBuilder &_fbb,
  ::flatbuffers::Offset<::flatbuffers::String> table = 0, uint64_t un = 0,
  uint8_t shard = 0
) {
  CommitBuilder builder_(_fbb);
  builder_.add_un(un);
  builder_.add_table(table);
  builder_.add_shard(shard);
  return builder_.Finish();
}

struct Commit::Traits {
  using type = Commit;
  static constexpr auto Create = CreateCommit;
};

inline ::flatbuffers::Offset<Commit> CreateCommitDirect(
  ::flatbuffers::FlatBufferBuilder &_fbb, const char *table = nullptr,
  uint64_t un = 0, uint8_t shard = 0
) {
  auto table__ = table ? _fbb.CreateString(table) : 0;
  return Zdb_::fbs::CreateCommit(_fbb, table__, un, shard);
}

struct Msg

  final

  : private ::flatbuffers::Table {
  typedef MsgBuilder Builder;
  typedef Zdb_::fbs::MsgSchema BinarySchema;
  struct Traits;
  enum FlatBuffersVTableOffset

    : ::flatbuffers::voffset_t

  {
    VT_BODY_TYPE = 4,
    VT_BODY = 6
  };
  Zdb_::fbs::Body body_type() const {
    return static_cast<Zdb_::fbs::Body>(GetField<uint8_t>(VT_BODY_TYPE, 0));
  }
  const void *body() const { return GetPointer<const void *>(VT_BODY); }
  const Zdb_::fbs::Heartbeat *body_as_Heartbeat() const {
    return body_type() == Zdb_::fbs::Body::Heartbeat ?
      static_cast<const Zdb_::fbs::Heartbeat *>(body()) :
      nullptr;
  }
  const Zdb_::fbs::Record *body_as_Replication() const {
    return body_type() == Zdb_::fbs::Body::Replication ?
      static_cast<const Zdb_::fbs::Record *>(body()) :
      nullptr;
  }
  const Zdb_::fbs::Record *body_as_Recovery() const {
    return body_type() == Zdb_::fbs::Body::Recovery ?
      static_cast<const Zdb_::fbs::Record *>(body()) :
      nullptr;
  }
  const Zdb_::fbs::Commit *body_as_Commit() const {
    return body_type() == Zdb_::fbs::Body::Commit ?
      static_cast<const Zdb_::fbs::Commit *>(body()) :
      nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
      VerifyField<uint8_t>(verifier, VT_BODY_TYPE, 1) &&
      VerifyOffset(verifier, VT_BODY) &&
      VerifyBody(verifier, body(), body_type()) && verifier.EndTable();
  }
};

struct MsgBuilder {
  typedef Msg Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_body_type(Zdb_::fbs::Body body_type) {
    fbb_.AddElement<uint8_t>(
      Msg::VT_BODY_TYPE, static_cast<uint8_t>(body_type), 0
    );
  }
  void add_body(::flatbuffers::Offset<void> body) {
    fbb_.AddOffset(Msg::VT_BODY, body);
  }
  explicit MsgBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Msg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Msg>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Msg> CreateMsg(
  ::flatbuffers::FlatBufferBuilder &_fbb,
  Zdb_::fbs::Body body_type = Zdb_::fbs::Body::NONE,
  ::flatbuffers::Offset<void> body = 0
) {
  MsgBuilder builder_(_fbb);
  builder_.add_body(body);
  builder_.add_body_type(body_type);
  return builder_.Finish();
}

struct Msg::Traits {
  using type = Msg;
  static constexpr auto Create = CreateMsg;
};

inline bool
VerifyBody(::flatbuffers::Verifier &verifier, const void *obj, Body type) {
  switch (type) {
  case Body::NONE: {
    return true;
  }
  case Body::Heartbeat: {
    auto ptr = reinterpret_cast<const Zdb_::fbs::Heartbeat *>(obj);
    return verifier.VerifyTable(ptr);
  }
  case Body::Replication: {
    auto ptr = reinterpret_cast<const Zdb_::fbs::Record *>(obj);
    return verifier.VerifyTable(ptr);
  }
  case Body::Recovery: {
    auto ptr = reinterpret_cast<const Zdb_::fbs::Record *>(obj);
    return verifier.VerifyTable(ptr);
  }
  case Body::Commit: {
    auto ptr = reinterpret_cast<const Zdb_::fbs::Commit *>(obj);
    return verifier.VerifyTable(ptr);
  }
  default:
    return true;
  }
}

inline bool VerifyBodyVector(
  ::flatbuffers::Verifier &verifier,
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values,
  const ::flatbuffers::Vector<Body> *types
) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyBody(verifier, values->Get(i), types->GetEnum<Body>(i))) {
      return false;
    }
  }
  return true;
}

inline const Zdb_::fbs::Msg *GetMsg(const void *buf) {
  return ::flatbuffers::GetRoot<Zdb_::fbs::Msg>(buf);
}

inline const Zdb_::fbs::Msg *GetSizePrefixedMsg(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Zdb_::fbs::Msg>(buf);
}

inline bool VerifyMsgBuffer(::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Zdb_::fbs::Msg>(nullptr);
}

inline bool VerifySizePrefixedMsgBuffer(::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Zdb_::fbs::Msg>(nullptr);
}

inline const char *MsgExtension() { return "bfbs"; }

inline void FinishMsgBuffer(
  ::flatbuffers::FlatBufferBuilder &fbb,
  ::flatbuffers::Offset<Zdb_::fbs::Msg> root
) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedMsgBuffer(
  ::flatbuffers::FlatBufferBuilder &fbb,
  ::flatbuffers::Offset<Zdb_::fbs::Msg> root
) {
  fbb.FinishSizePrefixed(root);
}

}} // namespace Zdb_::fbs

namespace Zdb_ {

struct Hdr {
  ZuLittleEndian<uint32_t> length;

  const uint8_t *data() const {
    return reinterpret_cast<const uint8_t *>(this) + sizeof(Hdr);
  }
};

template <typename Builder, typename Owner>
inline auto saveHdr(Builder &fbb, Owner *owner) {
  unsigned length = fbb.GetSize();
  auto buf = fbb.buf();
  buf->owner = owner;
  auto ptr = buf->prepend(sizeof(Hdr));
  if (__builtin_expect(!!(!ptr), 0)) return decltype(buf){};
  new (ptr) Hdr{length};
  return buf;
}
template <typename Builder> inline auto saveHdr(Builder &fbb) {
  return saveHdr(fbb, static_cast<void *>(nullptr));
}

template <typename Buf> inline int loadHdr(const Buf *buf) {
  if (__builtin_expect(!!(buf->length < sizeof(Hdr)), 0)) return 0x7fffffff;
  auto hdr = buf->template ptr<Hdr>();
  return sizeof(Hdr) + static_cast<uint32_t>(hdr->length);
}

template <typename Buf, typename L> inline int verifyHdr(ZmRef<Buf> buf, L l) {
  if (__builtin_expect(!!(buf->length < sizeof(Hdr)), 0)) return -1;
  auto hdr = buf->template ptr<Hdr>();
  unsigned length = hdr->length;
  if (length > (buf->length - sizeof(Hdr))) return -1;
  int i = l(hdr, ZuMv(buf));
  if (i < 0) return i;
  return sizeof(Hdr) + i;
}

inline ZuSpan<const uint8_t> msgData(const Hdr *hdr) {
  if (__builtin_expect(!!(!hdr), 0)) return {};
  return {
    reinterpret_cast<const uint8_t *>(hdr),
    static_cast<unsigned>(sizeof(Hdr) + hdr->length)
  };
}

inline const fbs::Msg *msg(const Hdr *hdr) {
  if (__builtin_expect(!!(!hdr), 0)) return nullptr;
  auto data = hdr->data();
  if (__builtin_expect(
	!!((!Zfb::Verifier{data, hdr->length}.VerifyBuffer<fbs::Msg>())), 0
      ))
    return nullptr;
  return Zfb::GetRoot<fbs::Msg>(data);
}
inline const fbs::Msg *msg_(const Hdr *hdr) {
  return Zfb::GetRoot<fbs::Msg>(hdr->data());
}
inline const fbs::Heartbeat *hb_(const fbs::Msg *msg) {
  return static_cast<const fbs::Heartbeat *>(msg->body());
}
inline const fbs::Heartbeat *hb(const fbs::Msg *msg) {
  if (__builtin_expect(!!(!msg), 0)) return nullptr;
  switch (msg->body_type()) {
  default:
    return nullptr;
  case fbs::Body::Heartbeat:
    return hb_(msg);
  }
}
inline bool recovery(const fbs::Msg *msg) {
  if (__builtin_expect(!!(!msg), 0)) return false;
  return msg->body_type() == fbs::Body::Recovery;
}
inline bool recovery_(const fbs::Msg *msg) {
  return msg->body_type() == fbs::Body::Recovery;
}
inline const fbs::Record *record_(const fbs::Msg *msg) {
  return static_cast<const fbs::Record *>(msg->body());
}
inline const fbs::Record *record(const fbs::Msg *msg) {
  if (__builtin_expect(!!(!msg), 0)) return nullptr;
  switch (msg->body_type()) {
  default:
    return nullptr;
  case fbs::Body::Replication:
  case fbs::Body::Recovery:
    return record_(msg);
  }
}
template <typename T> inline const T *data(const fbs::Record *record) {
  if (__builtin_expect(!!(!record), 0)) return nullptr;
  auto data = Zfb::Load::bytes(record->data());
  if (__builtin_expect(!!(!data), 0)) return nullptr;
  if (__builtin_expect(
	!!((!Zfb::Verifier{data.data(), data.length()}.VerifyBuffer<T>())), 0
      ))
    return nullptr;
  return Zfb::GetRoot<T>(data.data());
}
template <typename T> inline const T *data_(const fbs::Record *record) {
  auto data = Zfb::Load::bytes(record->data());
  if (__builtin_expect(!!(!data), 0)) return nullptr;
  return Zfb::GetRoot<T>(data.data());
}
inline const fbs::Commit *commit_(const fbs::Msg *msg) {
  return static_cast<const fbs::Commit *>(msg->body());
}
inline const fbs::Commit *commit(const fbs::Msg *msg) {
  if (__builtin_expect(!!(!msg), 0)) return nullptr;
  switch (msg->body_type()) {
  default:
    return nullptr;
  case fbs::Body::Commit:
    return commit_(msg);
  }
}

} // namespace Zdb_

namespace Zdb_ {

enum { DefltBufSize = 192 };
enum { HBBufSize = 128 };
enum { TelBufSize = 128 };

}

template <typename>
struct ZdbBufSize : public ZuUnsigned<Zdb_::DefltBufSize> { };

template <typename> struct ZdbBufHeapID {
  static constexpr const char *id() { return "Zdb.Buffer"; }
};

namespace Zdb_ {

class AnyTable;
class DB;

inline constexpr const char *IOBuf_HeapID() { return "Zdb.IOBuf"; }

struct IOBuf_ : public ZiIOBuf {
  mutable void *typed = nullptr;

  using ZiIOBuf::ZiIOBuf;

  auto hdr() const { return ptr<Hdr>(); }
  auto hdr() { return ptr<Hdr>(); }

  struct Print {
    const IOBuf_ *buf = nullptr;
    const AnyTable *table = nullptr;
    template <typename S> void print(S &s) const;
    friend ZuPrintFn ZuPrintType(Print *);
  };
  Print print(AnyTable *table = nullptr) { return Print{this, table}; }
};

inline UN IOBuf_UNAxor(const IOBuf_ &buf) {
  return record_(msg_(buf.hdr()))->un();
}

inline constexpr const char *BufCache_ID() { return "Zdb.BufCache"; }

using BufCacheUN = ZmHash<
  IOBuf_,
  ZmHashNode<
    IOBuf_, ZmHashKey<IOBuf_UNAxor, ZmHashLock<ZmPLock, ZmHashShadow<true>>>>>;

struct IOBuf : public BufCacheUN::Node {
  using Base = BufCacheUN::Node;
  using Base::Base;
  using Base::operator=;
  using ZiIOBuf::data;
};

template <typename T = void>
using IOBufAlloc = Zi::IOBufAlloc<IOBuf, ZdbBufSize<T>{}, ZdbBufHeapID<T>::id>;

using RxBufAlloc = IOBufAlloc<>;

typedef ZmRef<IOBuf> (*IOBufAllocFn)();

} // namespace Zdb_

namespace Zdb_ {

class Store;
class StoreTbl;

using Event = ZeVEvent;

using FailFn = ZmFn<void(Event)>;

struct InitData {
  bool replicated = false;
};
using InitResult = ZuUnion<InitData, Event>;

using StartResult = ZuUnion<void, Event>;

using StartFn = ZmFn<void(StartResult)>;

using StopResult = ZuUnion<void, Event>;

using StopFn = ZmFn<void(StopResult)>;

struct OpenData {
  StoreTbl *storeTbl = nullptr;
  uint64_t count = 0;
  ZtArray<UN> un;
  SN sn = 0;
};

using OpenResult = ZuUnion<OpenData, Event>;

using OpenFn = ZmFn<void(OpenResult)>;

using CloseFn = ZmFn<>;

struct CountData {
  uint64_t count;
};

using CountResult = ZuUnion<CountData, Event>;

using CountFn = ZmFn<void(CountResult)>;

struct TupleData {
  int keyID;
  ZmRef<const IOBuf> buf;
  unsigned count;
};

using TupleResult = ZuUnion<void, TupleData, Event>;

using TupleFn = ZmFn<void(TupleResult)>;

struct RowData {
  ZmRef<const IOBuf> buf;
};

using RowResult = ZuUnion<void, RowData, Event>;

using RowFn = ZmFn<void(RowResult)>;

using CommitResult = ZuUnion<void, Event>;

using CommitFn = ZmFn<void(ZmRef<const IOBuf>, CommitResult)>;

class StoreTbl {
public:
  virtual void close(CloseFn) = 0;

  virtual void warmup() = 0;

  virtual void count(unsigned keyID, ZmRef<const IOBuf>, CountFn) = 0;

  virtual void select(
    bool selectRow, bool selectNext, bool inclusive, unsigned keyID,
    ZmRef<const IOBuf>, unsigned limit, TupleFn
  ) = 0;

  virtual void find(unsigned keyID, ZmRef<const IOBuf>, RowFn) = 0;

  virtual void recover(Shard shard, UN, RowFn) = 0;

  virtual void write(ZmRef<const IOBuf>, CommitFn) = 0;
};

class Store : public ZmPolymorph {
public:
  virtual InitResult init(ZvCf *cf, ZiMultiplex *mx, FailFn failFn) = 0;
  virtual void final() = 0;

  virtual void start(StartFn fn) { fn(StartResult{}); }
  virtual void stop(StopFn fn) { fn(StopResult{}); }

  virtual void open(
    ZtString id, unsigned nShards, ZtVFieldArray fields,
    ZtVKeyFieldArray keyFields, const reflection::Schema *schema, IOBufAllocFn,
    OpenFn
  ) = 0;
};

typedef Store *(*StoreFn)();

} // namespace Zdb_

extern "C" {
  typedef Zdb_::StoreFn ZdbStoreFn;
}

namespace ZdbMem {

using namespace Zdb_;

struct UInt8Vec : public ZtArray<uint8_t> {
  using Base = ZtArray<uint8_t>;
  using Base::Base;
  using Base::operator=;
  template <typename... Args>
  UInt8Vec(Args &&...args) : Base{ZuFwd<Args>(args)...} { }
};

using Int8Vec = ZtArray<int8_t>;
using Int16Vec = ZtArray<int16_t>;
using UInt16Vec = ZtArray<uint16_t>;
using Int32Vec = ZtArray<int32_t>;
using UInt32Vec = ZtArray<uint32_t>;
using Int64Vec = ZtArray<int64_t>;
using UInt64Vec = ZtArray<uint64_t>;
using Int128Vec = ZtArray<int128_t>;
using UInt128Vec = ZtArray<uint128_t>;

using Value_ = ZuUnion<
  void, ZtString, ZtBytes, bool, int8_t, uint8_t, int16_t, uint16_t, int32_t,
  uint32_t, int64_t, uint64_t, double, ZuFixed, ZuDecimal, ZuTime, ZuDateTime,
  int128_t, uint128_t, ZtBitmap, ZiIP, ZuID,

  ZtArray<ZtString>, ZtArray<ZtBytes>, Int8Vec, UInt8Vec, Int16Vec, UInt16Vec,
  Int32Vec, UInt32Vec, Int64Vec, UInt64Vec, Int128Vec, UInt128Vec,
  ZtArray<double>, ZtArray<ZuFixed>, ZtArray<ZuDecimal>, ZtArray<ZuTime>,
  ZtArray<ZuDateTime>>;

enum { VecBase = Value_::Index<ZtArray<ZtString>>{} };

inline constexpr bool isVec(unsigned i) { return i >= VecBase; }

struct Value : public Value_ {
  using Value_::Value_;
  using Value_::operator=;

  template <unsigned I, typename S>
  ZuIfT<I == Value_::Index<void>{}> print_(S &s) const { }

  template <unsigned I, typename S>
  ZuIfT<I == Value_::Index<ZtString>{}> print_(S &s) const {
    s << ZtField_::Print::String{p<I>()};
  }

  template <unsigned I, typename S>
  ZuIfT<I == Value_::Index<ZtBytes>{}> print_(S &s) const {
    s << ZtField_::Print::Bytes{p<I>()};
  }

  template <unsigned I, typename S>
  ZuIfT<
    I == Value_::Index<bool>{} || I == Value_::Index<int8_t>{} ||
    I == Value_::Index<uint8_t>{} || I == Value_::Index<int16_t>{} ||
    I == Value_::Index<uint16_t>{} || I == Value_::Index<int32_t>{} ||
    I == Value_::Index<uint32_t>{} || I == Value_::Index<int64_t>{} ||
    I == Value_::Index<uint64_t>{} || I == Value_::Index<int128_t>{} ||
    I == Value_::Index<uint128_t>{} || I == Value_::Index<double>{}>
  print_(S &s) const {
    s << ZuBoxed(p<I>());
  }

  template <unsigned I, typename S>
  ZuIfT<
    I == Value_::Index<ZuFixed>{} || I == Value_::Index<ZuDecimal>{} ||
    I == Value_::Index<ZuTime>{} || I == Value_::Index<ZtBitmap>{} ||
    I == Value_::Index<ZiIP>{} || I == Value_::Index<ZuID>{}>
  print_(S &s) const {
    s << p<I>();
  }

  template <unsigned I, typename S>
  ZuIfT<I == Value_::Index<ZuDateTime>{}> print_(S &s) const {
    auto &fmt = ZmTLS<ZuDateTimeFmt::CSV, (int Value_::*){}>();
    s << p<I>().fmt(fmt);
  }

  template <unsigned I, typename S>
  ZuIfT<I == Value_::Index<ZtArray<ZtString>>{}> print_(S &s) const {
    s << '[';
    bool first = true;
    p<I>().all([&s, &first](const ZtString &v) {
      if (!first)
	s << ',';
      else
	first = false;
      s << ZtField_::Print::String{v};
    });
    s << ']';
  }

  template <unsigned I, typename S>
  ZuIfT<I == Value_::Index<ZtArray<ZtBytes>>{}> print_(S &s) const {
    s << '[';
    bool first = true;
    p<I>().all([&s, &first](const ZtBytes &v) {
      if (!first)
	s << ',';
      else
	first = false;
      s << ZtField_::Print::Bytes{v};
    });
    s << ']';
  }

  template <unsigned I, typename S>
  ZuIfT<
    I == Value_::Index<ZtArray<int8_t>>{} || I == Value_::Index<UInt8Vec>{} ||
    I == Value_::Index<ZtArray<int16_t>>{} ||
    I == Value_::Index<ZtArray<uint16_t>>{} ||
    I == Value_::Index<ZtArray<int32_t>>{} ||
    I == Value_::Index<ZtArray<uint32_t>>{} ||
    I == Value_::Index<ZtArray<int64_t>>{} ||
    I == Value_::Index<ZtArray<uint64_t>>{} ||
    I == Value_::Index<ZtArray<int128_t>>{} ||
    I == Value_::Index<ZtArray<uint128_t>>{} ||
    I == Value_::Index<ZtArray<double>>{}>
  print_(S &s) const {
    using Elem = typename ZuTraits<Type<I>>::Elem;
    s << '[';
    bool first = true;
    p<I>().all([&s, &first](const Elem &v) {
      if (!first)
	s << ',';
      else
	first = false;
      s << ZuBoxed(v);
    });
    s << ']';
  }

  template <unsigned I, typename S>
  ZuIfT<
    I == Value_::Index<ZtArray<ZuFixed>>{} ||
    I == Value_::Index<ZtArray<ZuDecimal>>{} ||
    I == Value_::Index<ZtArray<ZuTime>>{}>
  print_(S &s) const {
    using Elem = typename ZuTraits<Type<I>>::Elem;
    s << '[';
    bool first = true;
    p<I>().all([&s, &first](const Elem &v) {
      if (!first)
	s << ',';
      else
	first = false;
      s << v;
    });
    s << ']';
  }

  template <unsigned I, typename S>
  ZuIfT<I == Value_::Index<ZtArray<ZuDateTime>>{}> print_(S &s) const {
    s << '[';
    bool first = true;
    p<I>().all([&s, &first](const ZuDateTime &v) {
      auto &fmt = ZmTLS<ZuDateTimeFmt::CSV, (int Value_::*){}>();
      if (!first)
	s << ',';
      else
	first = false;
      s << v.fmt(fmt);
    });
    s << ']';
  }

  template <typename S> void print(S &s) const {
    ZuSwitch::dispatch<Value_::N>(this->type(), [this, &s](auto I) {
      this->print_<I>(s);
    });
  }
  friend ZuPrintFn ZuPrintType(Value *);
};

struct XField {
  const reflection::Field *field;
  unsigned type;
};
using XFields = ZtArray<XField>;
using XKeyFields = ZtArray<XFields>;

XField xField(
  const Zfb::Vector<Zfb::Offset<reflection::Field>> *fbFields_,
  const ZtVField *field, const ZtString &id
) {
  const reflection::Field *fbField = fbFields_->LookupByKey(id);
  if (!fbField) return {nullptr, 0};
  unsigned type = 0;
  auto ftype = field->type;
  switch (fbField->type()->base_type()) {
  case reflection::String:
    if (ftype->code == ZtFieldTypeCode::CString ||
	ftype->code == ZtFieldTypeCode::String)
      type = Value::Index<ZtString>{};
    break;
  case reflection::Bool:
    if (ftype->code == ZtFieldTypeCode::Bool) type = Value::Index<bool>{};
    break;
  case reflection::Byte:
    if (ftype->code == ZtFieldTypeCode::Int8) type = Value::Index<int8_t>{};
    break;
  case reflection::UByte:
    if (ftype->code == ZtFieldTypeCode::UInt8) type = Value::Index<uint8_t>{};
    break;
  case reflection::Short:
    if (ftype->code == ZtFieldTypeCode::Int16) type = Value::Index<int16_t>{};
    break;
  case reflection::UShort:
    if (ftype->code == ZtFieldTypeCode::UInt16) type = Value::Index<uint16_t>{};
    break;
  case reflection::Int:
    if (ftype->code == ZtFieldTypeCode::Int32) type = Value::Index<int32_t>{};
    break;
  case reflection::UInt:
    if (ftype->code == ZtFieldTypeCode::UInt32) type = Value::Index<uint32_t>{};
    break;
  case reflection::Long:
    if (ftype->code == ZtFieldTypeCode::Int64) type = Value::Index<int64_t>{};
    break;
  case reflection::ULong:
    if (ftype->code == ZtFieldTypeCode::UInt64) type = Value::Index<uint64_t>{};
    break;
  case reflection::Double:
    if (ftype->code == ZtFieldTypeCode::Float) type = Value::Index<double>{};
    break;
  case reflection::Obj: {
    switch (ftype->code) {
    case ZtFieldTypeCode::Int128:
      type = Value::Index<int128_t>{};
      break;
    case ZtFieldTypeCode::UInt128:
      type = Value::Index<uint128_t>{};
      break;
    case ZtFieldTypeCode::Fixed:
      type = Value::Index<ZuFixed>{};
      break;
    case ZtFieldTypeCode::Decimal:
      type = Value::Index<ZuDecimal>{};
      break;
    case ZtFieldTypeCode::Time:
      type = Value::Index<ZuTime>{};
      break;
    case ZtFieldTypeCode::DateTime:
      type = Value::Index<ZuDateTime>{};
      break;
    case ZtFieldTypeCode::UDT: {
      ZuID typeID = ftype->info.udt()->id;
      if (typeID == ZuID("Bitmap")) {
	type = Value::Index<ZtBitmap>{};
	break;
      }
      if (typeID == ZuID("IP")) {
	type = Value::Index<ZiIP>{};
	break;
      }
      if (typeID == ZuID("ID")) {
	type = Value::Index<ZuID>{};
	break;
      }
    }
    }
  } break;
  case reflection::Vector:
    switch (fbField->type()->element()) {
    default:
      break;
    case reflection::String:
      if (ftype->code == ZtFieldTypeCode::StringVec)
	type = Value::Index<ZtArray<ZtString>>{};
      break;
    case reflection::Byte:
      if (ftype->code == ZtFieldTypeCode::Int8Vec)
	type = Value::Index<ZtArray<int8_t>>{};
      break;
    case reflection::UByte:
      if (ftype->code == ZtFieldTypeCode::Bytes)
	type = Value::Index<ZtBytes>{};
      else if (ftype->code == ZtFieldTypeCode::UInt8Vec)
	type = Value::Index<UInt8Vec>{};
      break;
    case reflection::Short:
      if (ftype->code == ZtFieldTypeCode::Int16Vec)
	type = Value::Index<ZtArray<int16_t>>{};
      break;
    case reflection::UShort:
      if (ftype->code == ZtFieldTypeCode::UInt16Vec)
	type = Value::Index<ZtArray<uint16_t>>{};
      break;
    case reflection::Int:
      if (ftype->code == ZtFieldTypeCode::Int32Vec)
	type = Value::Index<ZtArray<int32_t>>{};
      break;
    case reflection::UInt:
      if (ftype->code == ZtFieldTypeCode::UInt32Vec)
	type = Value::Index<ZtArray<uint32_t>>{};
      break;
    case reflection::Long:
      if (ftype->code == ZtFieldTypeCode::Int64Vec)
	type = Value::Index<ZtArray<int64_t>>{};
      break;
    case reflection::ULong:
      if (ftype->code == ZtFieldTypeCode::UInt64Vec)
	type = Value::Index<ZtArray<uint64_t>>{};
      break;
    case reflection::Double:
      if (ftype->code == ZtFieldTypeCode::FloatVec)
	type = Value::Index<ZtArray<double>>{};
      break;
    case reflection::Obj:
      switch (ftype->code) {
      case ZtFieldTypeCode::BytesVec:
	type = Value::Index<ZtArray<ZtBytes>>{};
	break;
      case ZtFieldTypeCode::Int128Vec:
	type = Value::Index<ZtArray<int128_t>>{};
	break;
      case ZtFieldTypeCode::UInt128Vec:
	type = Value::Index<ZtArray<uint128_t>>{};
	break;
      case ZtFieldTypeCode::FixedVec:
	type = Value::Index<ZtArray<ZuFixed>>{};
	break;
      case ZtFieldTypeCode::DecimalVec:
	type = Value::Index<ZtArray<ZuDecimal>>{};
	break;
      case ZtFieldTypeCode::TimeVec:
	type = Value::Index<ZtArray<ZuTime>>{};
	break;
      case ZtFieldTypeCode::DateTimeVec:
	type = Value::Index<ZtArray<ZuDateTime>>{};
	break;
      }
      break;
    }
    break;
  default:
    break;
  }
  return {fbField, type};
}

template <unsigned Type>
inline ZuIfT<Type == Value::Index<void>{}>
loadValue(void *, const reflection::Field *, const Zfb::Table *) { }

template <unsigned Type>
inline ZuIfT<Type == Value::Index<ZtString>{}>
loadValue(void *ptr, const reflection::Field *field, const Zfb::Table *fbo) {
  new (ptr) ZtString{Zfb::Load::str(Zfb::GetFieldS(*fbo, *field))};
}

template <unsigned Type>
inline ZuIfT<Type == Value::Index<ZtBytes>{}>
loadValue(void *ptr, const reflection::Field *field, const Zfb::Table *fbo) {
  new (ptr) ZtBytes{Zfb::Load::bytes(Zfb::GetFieldV<uint8_t>(*fbo, *field))};
}

template <unsigned Type>
inline ZuIfT<Type == Value::Index<bool>{}>
loadValue(void *ptr, const reflection::Field *field, const Zfb::Table *fbo) {
  *static_cast<bool *>(ptr) = Zfb::GetFieldI<bool>(*fbo, *field);
}

template <unsigned Type>
inline ZuIfT<Type == Value::Index<int8_t>{}>
loadValue(void *ptr, const reflection::Field *field, const Zfb::Table *fbo) {
  *static_cast<int8_t *>(ptr) = Zfb::GetFieldI<int8_t>(*fbo, *field);
}
template <unsigned Type>
inline ZuIfT<Type == Value::Index<uint8_t>{}>
loadValue(void *ptr, const reflection::Field *field, const Zfb::Table *fbo) {
  *static_cast<uint8_t *>(ptr) = Zfb::GetFieldI<uint8_t>(*fbo, *field);
}
template <unsigned Type>
inline ZuIfT<Type == Value::Index<int16_t>{}>
loadValue(void *ptr, const reflection::Field *field, const Zfb::Table *fbo) {
  *static_cast<int16_t *>(ptr) = Zfb::GetFieldI<int16_t>(*fbo, *field);
}
template <unsigned Type>
inline ZuIfT<Type == Value::Index<uint16_t>{}>
loadValue(void *ptr, const reflection::Field *field, const Zfb::Table *fbo) {
  *static_cast<uint16_t *>(ptr) = Zfb::GetFieldI<uint16_t>(*fbo, *field);
}
template <unsigned Type>
inline ZuIfT<Type == Value::Index<int32_t>{}>
loadValue(void *ptr, const reflection::Field *field, const Zfb::Table *fbo) {
  *static_cast<int32_t *>(ptr) = Zfb::GetFieldI<int32_t>(*fbo, *field);
}
template <unsigned Type>
inline ZuIfT<Type == Value::Index<uint32_t>{}>
loadValue(void *ptr, const reflection::Field *field, const Zfb::Table *fbo) {
  *static_cast<uint32_t *>(ptr) = Zfb::GetFieldI<uint32_t>(*fbo, *field);
}
template <unsigned Type>
inline ZuIfT<Type == Value::Index<int64_t>{}>
loadValue(void *ptr, const reflection::Field *field, const Zfb::Table *fbo) {
  *static_cast<int64_t *>(ptr) = Zfb::GetFieldI<int64_t>(*fbo, *field);
}
template <unsigned Type>
inline ZuIfT<Type == Value::Index<uint64_t>{}>
loadValue(void *ptr, const reflection::Field *field, const Zfb::Table *fbo) {
  *static_cast<uint64_t *>(ptr) = Zfb::GetFieldI<uint64_t>(*fbo, *field);
}

template <unsigned Type>
inline ZuIfT<Type == Value::Index<double>{}>
loadValue(void *ptr, const reflection::Field *field, const Zfb::Table *fbo) {
  *static_cast<double *>(ptr) = Zfb::GetFieldF<double>(*fbo, *field);
}

template <unsigned Type>
inline ZuIfT<Type == Value::Index<ZuFixed>{}>
loadValue(void *ptr, const reflection::Field *field, const Zfb::Table *fbo) {
  new (ptr) ZuFixed{
    Zfb::Load::fixed(fbo->GetStruct<const Zfb::Fixed *>(field->offset()))
  };
}

template <unsigned Type>
inline ZuIfT<Type == Value::Index<ZuDecimal>{}>
loadValue(void *ptr, const reflection::Field *field, const Zfb::Table *fbo) {
  new (ptr) ZuDecimal{
    Zfb::Load::decimal(fbo->GetStruct<const Zfb::Decimal *>(field->offset()))
  };
}

template <unsigned Type>
inline ZuIfT<Type == Value::Index<ZuTime>{}>
loadValue(void *ptr, const reflection::Field *field, const Zfb::Table *fbo) {
  new (ptr)
    ZuTime{Zfb::Load::time(fbo->GetStruct<const Zfb::Time *>(field->offset()))};
}

template <unsigned Type>
inline ZuIfT<Type == Value::Index<ZuDateTime>{}>
loadValue(void *ptr, const reflection::Field *field, const Zfb::Table *fbo) {
  new (ptr) ZuDateTime{
    Zfb::Load::dateTime(fbo->GetStruct<const Zfb::DateTime *>(field->offset()))
  };
}

template <unsigned Type>
inline ZuIfT<Type == Value::Index<int128_t>{}>
loadValue(void *ptr, const reflection::Field *field, const Zfb::Table *fbo) {
  *static_cast<int128_t *>(ptr) =
    Zfb::Load::int128(fbo->GetPointer<const Zfb::Int128 *>(field->offset()));
}

template <unsigned Type>
inline ZuIfT<Type == Value::Index<uint128_t>{}>
loadValue(void *ptr, const reflection::Field *field, const Zfb::Table *fbo) {
  *static_cast<uint128_t *>(ptr) =
    Zfb::Load::uint128(fbo->GetPointer<const Zfb::UInt128 *>(field->offset()));
}

template <unsigned Type>
inline ZuIfT<Type == Value::Index<ZtBitmap>{}>
loadValue(void *ptr, const reflection::Field *field, const Zfb::Table *fbo) {
  new (ptr) ZtBitmap{Zfb::Load::bitmap<ZtBitmap>(
    fbo->GetPointer<const Zfb::Bitmap *>(field->offset())
  )};
}

template <unsigned Type>
inline ZuIfT<Type == Value::Index<ZiIP>{}>
loadValue(void *ptr, const reflection::Field *field, const Zfb::Table *fbo) {
  new (ptr)
    ZiIP{Zfb::Load::ip(fbo->GetStruct<const Zfb::IP *>(field->offset()))};
}

template <unsigned Type>
inline ZuIfT<Type == Value::Index<ZuID>{}>
loadValue(void *ptr, const reflection::Field *field, const Zfb::Table *fbo) {
  new (ptr)
    ZuID{Zfb::Load::id(fbo->GetStruct<const Zfb::ID *>(field->offset()))};
}

template <unsigned Type>
inline ZuIfT<Type == Value::Index<ZtArray<ZtString>>{}>
loadValue(void *ptr, const reflection::Field *field, const Zfb::Table *fbo) {
  auto v = Zfb::GetFieldV<Zfb::Offset<Zfb::String>>(*fbo, *field);
  unsigned n = v ? v->size() : 0;
  auto array = new (ptr) ZtArray<ZtString>(n);
  for (unsigned i = 0; i < n; i++) array->push(Zfb::Load::str(v->Get(i)));
}

template <unsigned Type>
inline ZuIfT<Type == Value::Index<ZtArray<ZtBytes>>{}>
loadValue(void *ptr, const reflection::Field *field, const Zfb::Table *fbo) {
  auto v = Zfb::GetFieldV<Zfb::Offset<Zfb::Vector<uint8_t>>>(*fbo, *field);
  unsigned n = v ? v->size() : 0;
  auto array = new (ptr) ZtArray<ZtBytes>(n);
  for (unsigned i = 0; i < n; i++) array->push(Zfb::Load::bytes(v->Get(i)));
}

template <unsigned Type>
inline ZuIfT<Type == Value::Index<Int8Vec>{}>
loadValue(void *ptr, const reflection::Field *field, const Zfb::Table *fbo) {
  auto v = Zfb::GetFieldV<int8_t>(*fbo, *field);
  unsigned n = v ? v->size() : 0;
  auto array = new (ptr) Int8Vec(n);
  for (unsigned i = 0; i < n; i++) array->push(v->Get(i));
}
template <unsigned Type>
inline ZuIfT<Type == Value::Index<UInt8Vec>{}>
loadValue(void *ptr, const reflection::Field *field, const Zfb::Table *fbo) {
  auto v = Zfb::GetFieldV<uint8_t>(*fbo, *field);
  unsigned n = v ? v->size() : 0;
  auto array = new (ptr) UInt8Vec(n);
  for (unsigned i = 0; i < n; i++) array->push(v->Get(i));
}
template <unsigned Type>
inline ZuIfT<Type == Value::Index<Int16Vec>{}>
loadValue(void *ptr, const reflection::Field *field, const Zfb::Table *fbo) {
  auto v = Zfb::GetFieldV<int16_t>(*fbo, *field);
  unsigned n = v ? v->size() : 0;
  auto array = new (ptr) Int16Vec(n);
  for (unsigned i = 0; i < n; i++) array->push(v->Get(i));
}
template <unsigned Type>
inline ZuIfT<Type == Value::Index<UInt16Vec>{}>
loadValue(void *ptr, const reflection::Field *field, const Zfb::Table *fbo) {
  auto v = Zfb::GetFieldV<uint16_t>(*fbo, *field);
  unsigned n = v ? v->size() : 0;
  auto array = new (ptr) UInt16Vec(n);
  for (unsigned i = 0; i < n; i++) array->push(v->Get(i));
}
template <unsigned Type>
inline ZuIfT<Type == Value::Index<Int32Vec>{}>
loadValue(void *ptr, const reflection::Field *field, const Zfb::Table *fbo) {
  auto v = Zfb::GetFieldV<int32_t>(*fbo, *field);
  unsigned n = v ? v->size() : 0;
  auto array = new (ptr) Int32Vec(n);
  for (unsigned i = 0; i < n; i++) array->push(v->Get(i));
}
template <unsigned Type>
inline ZuIfT<Type == Value::Index<UInt32Vec>{}>
loadValue(void *ptr, const reflection::Field *field, const Zfb::Table *fbo) {
  auto v = Zfb::GetFieldV<uint32_t>(*fbo, *field);
  unsigned n = v ? v->size() : 0;
  auto array = new (ptr) UInt32Vec(n);
  for (unsigned i = 0; i < n; i++) array->push(v->Get(i));
}
template <unsigned Type>
inline ZuIfT<Type == Value::Index<Int64Vec>{}>
loadValue(void *ptr, const reflection::Field *field, const Zfb::Table *fbo) {
  auto v = Zfb::GetFieldV<int64_t>(*fbo, *field);
  unsigned n = v ? v->size() : 0;
  auto array = new (ptr) Int64Vec(n);
  for (unsigned i = 0; i < n; i++) array->push(v->Get(i));
}
template <unsigned Type>
inline ZuIfT<Type == Value::Index<UInt64Vec>{}>
loadValue(void *ptr, const reflection::Field *field, const Zfb::Table *fbo) {
  auto v = Zfb::GetFieldV<uint64_t>(*fbo, *field);
  unsigned n = v ? v->size() : 0;
  auto array = new (ptr) UInt64Vec(n);
  for (unsigned i = 0; i < n; i++) array->push(v->Get(i));
}

template <unsigned Type>
inline ZuIfT<Type == Value::Index<Int128Vec>{}>
loadValue(void *ptr, const reflection::Field *field, const Zfb::Table *fbo) {
  auto v = Zfb::GetFieldV<Zfb::Int128 *>(*fbo, *field);
  unsigned n = v ? v->size() : 0;
  auto array = new (ptr) Int128Vec(n);
  for (unsigned i = 0; i < n; i++) array->push(Zfb::Load::int128(v->Get(i)));
}

template <unsigned Type>
inline ZuIfT<Type == Value::Index<UInt128Vec>{}>
loadValue(void *ptr, const reflection::Field *field, const Zfb::Table *fbo) {
  auto v = Zfb::GetFieldV<Zfb::UInt128 *>(*fbo, *field);
  unsigned n = v ? v->size() : 0;
  auto array = new (ptr) UInt128Vec(n);
  for (unsigned i = 0; i < n; i++) array->push(Zfb::Load::uint128(v->Get(i)));
}

template <unsigned Type>
inline ZuIfT<Type == Value::Index<ZtArray<double>>{}>
loadValue(void *ptr, const reflection::Field *field, const Zfb::Table *fbo) {
  auto v = Zfb::GetFieldV<double>(*fbo, *field);
  unsigned n = v ? v->size() : 0;
  auto array = new (ptr) ZtArray<double>(n);
  for (unsigned i = 0; i < n; i++) array->push(v->Get(i));
}

template <unsigned Type>
inline ZuIfT<Type == Value::Index<ZtArray<ZuFixed>>{}>
loadValue(void *ptr, const reflection::Field *field, const Zfb::Table *fbo) {
  auto v = Zfb::GetFieldV<Zfb::Fixed *>(*fbo, *field);
  unsigned n = v ? v->size() : 0;
  auto array = new (ptr) ZtArray<ZuFixed>(n);
  for (unsigned i = 0; i < n; i++) array->push(Zfb::Load::fixed(v->Get(i)));
}

template <unsigned Type>
inline ZuIfT<Type == Value::Index<ZtArray<ZuDecimal>>{}>
loadValue(void *ptr, const reflection::Field *field, const Zfb::Table *fbo) {
  auto v = Zfb::GetFieldV<Zfb::Decimal *>(*fbo, *field);
  unsigned n = v ? v->size() : 0;
  auto array = new (ptr) ZtArray<ZuDecimal>(n);
  for (unsigned i = 0; i < n; i++) array->push(Zfb::Load::decimal(v->Get(i)));
}

template <unsigned Type>
inline ZuIfT<Type == Value::Index<ZtArray<ZuTime>>{}>
loadValue(void *ptr, const reflection::Field *field, const Zfb::Table *fbo) {
  auto v = Zfb::GetFieldV<Zfb::Time *>(*fbo, *field);
  unsigned n = v ? v->size() : 0;
  auto array = new (ptr) ZtArray<ZuTime>(n);
  for (unsigned i = 0; i < n; i++) array->push(Zfb::Load::time(v->Get(i)));
}

template <unsigned Type>
inline ZuIfT<Type == Value::Index<ZtArray<ZuDateTime>>{}>
loadValue(void *ptr, const reflection::Field *field, const Zfb::Table *fbo) {
  auto v = Zfb::GetFieldV<Zfb::DateTime *>(*fbo, *field);
  unsigned n = v ? v->size() : 0;
  auto array = new (ptr) ZtArray<ZuDateTime>(n);
  for (unsigned i = 0; i < n; i++) array->push(Zfb::Load::dateTime(v->Get(i)));
}

using Offset = Zfb::Offset<void>;

struct Offsets {
  ZmAlloc_<Offset> data;
  unsigned in = 0;
  mutable unsigned out = 0;

  void push(Offset o) { data[in++] = o; }
  Offset shift() const { return data[out++]; }
};

template <unsigned Type>
inline ZuIfT<Type == Value::Index<ZtString>{}>
saveOffset(Zfb::Builder &fbb, Offsets &offsets, const Value &value) {
  offsets.push(Zfb::Save::str(fbb, value.p<Type>()).Union());
}

template <unsigned Type>
inline ZuIfT<Type == Value::Index<ZtBytes>{}>
saveOffset(Zfb::Builder &fbb, Offsets &offsets, const Value &value) {
  offsets.push(Zfb::Save::bytes(fbb, value.p<Type>()).Union());
}

template <unsigned Type>
inline ZuIfT<Type == Value::Index<ZtArray<ZtString>>{}>
saveOffset(Zfb::Builder &fbb, Offsets &offsets, const Value &value) {
  const auto &array = value.p<ZtArray<ZtString>>();
  unsigned n = array.length();
  offsets.push(Zfb::Save::strVecIter(fbb, n, [&array](unsigned i) {
    return array[i];
  }).Union());
}

template <unsigned Type>
inline ZuIfT<Type == Value::Index<ZtArray<ZtBytes>>{}>
saveOffset(Zfb::Builder &fbb, Offsets &offsets, const Value &value) {
  const auto &array = value.p<ZtArray<ZtBytes>>();
  unsigned n = array.length();
  offsets.push(Zfb::Save::vectorIter<Zfb::Vector<uint8_t>>(
		 fbb, n,
		 [&array](Zfb::Builder &fbb, unsigned i) {
    return Zfb::Save::bytes(fbb, array[i]);
  }
  ).Union());
}

template <unsigned Type>
inline ZuIfT<Type == Value::Index<Int8Vec>{}>
saveOffset(Zfb::Builder &fbb, Offsets &offsets, const Value &value) {
  const auto &array = value.p<Int8Vec>();
  unsigned n = array.length();
  offsets.push(Zfb::Save::pvectorIter<int8_t>(fbb, n, [&array](unsigned i) {
    return array[i];
  }).Union());
}
template <unsigned Type>
inline ZuIfT<Type == Value::Index<UInt8Vec>{}>
saveOffset(Zfb::Builder &fbb, Offsets &offsets, const Value &value) {
  const auto &array = value.p<UInt8Vec>();
  unsigned n = array.length();
  offsets.push(Zfb::Save::pvectorIter<uint8_t>(fbb, n, [&array](unsigned i) {
    return array[i];
  }).Union());
}
template <unsigned Type>
inline ZuIfT<Type == Value::Index<Int16Vec>{}>
saveOffset(Zfb::Builder &fbb, Offsets &offsets, const Value &value) {
  const auto &array = value.p<Int16Vec>();
  unsigned n = array.length();
  offsets.push(Zfb::Save::pvectorIter<int16_t>(fbb, n, [&array](unsigned i) {
    return array[i];
  }).Union());
}
template <unsigned Type>
inline ZuIfT<Type == Value::Index<UInt16Vec>{}>
saveOffset(Zfb::Builder &fbb, Offsets &offsets, const Value &value) {
  const auto &array = value.p<UInt16Vec>();
  unsigned n = array.length();
  offsets.push(Zfb::Save::pvectorIter<uint16_t>(fbb, n, [&array](unsigned i) {
    return array[i];
  }).Union());
}
template <unsigned Type>
inline ZuIfT<Type == Value::Index<Int32Vec>{}>
saveOffset(Zfb::Builder &fbb, Offsets &offsets, const Value &value) {
  const auto &array = value.p<Int32Vec>();
  unsigned n = array.length();
  offsets.push(Zfb::Save::pvectorIter<int32_t>(fbb, n, [&array](unsigned i) {
    return array[i];
  }).Union());
}
template <unsigned Type>
inline ZuIfT<Type == Value::Index<UInt32Vec>{}>
saveOffset(Zfb::Builder &fbb, Offsets &offsets, const Value &value) {
  const auto &array = value.p<UInt32Vec>();
  unsigned n = array.length();
  offsets.push(Zfb::Save::pvectorIter<uint32_t>(fbb, n, [&array](unsigned i) {
    return array[i];
  }).Union());
}
template <unsigned Type>
inline ZuIfT<Type == Value::Index<Int64Vec>{}>
saveOffset(Zfb::Builder &fbb, Offsets &offsets, const Value &value) {
  const auto &array = value.p<Int64Vec>();
  unsigned n = array.length();
  offsets.push(Zfb::Save::pvectorIter<int64_t>(fbb, n, [&array](unsigned i) {
    return array[i];
  }).Union());
}
template <unsigned Type>
inline ZuIfT<Type == Value::Index<UInt64Vec>{}>
saveOffset(Zfb::Builder &fbb, Offsets &offsets, const Value &value) {
  const auto &array = value.p<UInt64Vec>();
  unsigned n = array.length();
  offsets.push(Zfb::Save::pvectorIter<uint64_t>(fbb, n, [&array](unsigned i) {
    return array[i];
  }).Union());
}

template <unsigned Type>
inline ZuIfT<Type == Value::Index<Int128Vec>{}>
saveOffset(Zfb::Builder &fbb, Offsets &offsets, const Value &value) {
  const auto &array = value.p<Int128Vec>();
  unsigned n = array.length();
  offsets.push(Zfb::Save::structVecIter<Zfb::Int128>(
		 fbb, n,
		 [&array](Zfb::Int128 *ptr, unsigned i) {
    *ptr = Zfb::Save::int128(array[i]);
  }
  ).Union());
}
template <unsigned Type>
inline ZuIfT<Type == Value::Index<UInt128Vec>{}>
saveOffset(Zfb::Builder &fbb, Offsets &offsets, const Value &value) {
  const auto &array = value.p<UInt128Vec>();
  unsigned n = array.length();
  offsets.push(Zfb::Save::structVecIter<Zfb::UInt128>(
		 fbb, n,
		 [&array](Zfb::UInt128 *ptr, unsigned i) {
    *ptr = Zfb::Save::uint128(array[i]);
  }
  ).Union());
}

template <unsigned Type>
inline ZuIfT<Type == Value::Index<ZtArray<double>>{}>
saveOffset(Zfb::Builder &fbb, Offsets &offsets, const Value &value) {
  const auto &array = value.p<ZtArray<double>>();
  unsigned n = array.length();
  offsets.push(Zfb::Save::pvectorIter<double>(fbb, n, [&array](unsigned i) {
    return array[i];
  }).Union());
}

template <unsigned Type>
inline ZuIfT<Type == Value::Index<ZtArray<ZuFixed>>{}>
saveOffset(Zfb::Builder &fbb, Offsets &offsets, const Value &value) {
  const auto &array = value.p<ZtArray<ZuFixed>>();
  unsigned n = array.length();
  offsets.push(Zfb::Save::structVecIter<Zfb::Fixed>(
		 fbb, n,
		 [&array](Zfb::Fixed *ptr, unsigned i) {
    *ptr = Zfb::Save::fixed(array[i]);
  }
  ).Union());
}

template <unsigned Type>
inline ZuIfT<Type == Value::Index<ZtArray<ZuDecimal>>{}>
saveOffset(Zfb::Builder &fbb, Offsets &offsets, const Value &value) {
  const auto &array = value.p<ZtArray<ZuDecimal>>();
  unsigned n = array.length();
  offsets.push(Zfb::Save::structVecIter<Zfb::Decimal>(
		 fbb, n,
		 [&array](Zfb::Decimal *ptr, unsigned i) {
    *ptr = Zfb::Save::decimal(array[i]);
  }
  ).Union());
}

template <unsigned Type>
inline ZuIfT<Type == Value::Index<ZtArray<ZuTime>>{}>
saveOffset(Zfb::Builder &fbb, Offsets &offsets, const Value &value) {
  const auto &array = value.p<ZtArray<ZuTime>>();
  unsigned n = array.length();
  offsets.push(Zfb::Save::structVecIter<Zfb::Time>(
		 fbb, n,
		 [&array](Zfb::Time *ptr, unsigned i) {
    *ptr = Zfb::Save::time(array[i]);
  }
  ).Union());
}

template <unsigned Type>
inline ZuIfT<Type == Value::Index<ZtArray<ZuDateTime>>{}>
saveOffset(Zfb::Builder &fbb, Offsets &offsets, const Value &value) {
  const auto &array = value.p<ZtArray<ZuDateTime>>();
  unsigned n = array.length();
  offsets.push(Zfb::Save::structVecIter<Zfb::DateTime>(
		 fbb, n,
		 [&array](Zfb::DateTime *ptr, unsigned i) {
    *ptr = Zfb::Save::dateTime(array[i]);
  }
  ).Union());
}

template <unsigned Type>
inline ZuIfT<Type == Value::Index<ZtBitmap>{}>
saveOffset(Zfb::Builder &fbb, Offsets &offsets, const Value &value) {
  offsets.push(Zfb::Save::bitmap(fbb, value.p<Type>()).Union());
}

template <unsigned Type>
inline ZuIfT<
  Type != Value::Index<ZtString>{} && Type != Value::Index<ZtBytes>{} &&
  Type != Value::Index<ZtBitmap>{} && !isVec(Type)>
saveOffset(Zfb::Builder &, Offsets &, const Value &) { }

template <unsigned Type>
inline ZuIfT<Type == Value::Index<void>{}>
saveValue(Zfb::Builder &, const Offsets &, const reflection::Field *, const Value &) {
}

template <unsigned Type>
inline ZuIfT<
  Type == Value::Index<ZtString>{} || Type == Value::Index<ZtBytes>{} ||
  Type == Value::Index<ZtBitmap>{} || isVec(Type)>
saveValue(
  Zfb::Builder &fbb, const Offsets &offsets, const reflection::Field *field,
  const Value &value
) {
  fbb.AddOffset(field->offset(), offsets.shift());
}

template <unsigned Type>
inline ZuIfT<Type == Value::Index<bool>{}> saveValue(
  Zfb::Builder &fbb, const Offsets &, const reflection::Field *field,
  const Value &value
) {
  fbb.AddElement<bool>(
    field->offset(), value.p<Type>(), field->default_integer()
  );
}

template <unsigned Type>
inline ZuIfT<Type == Value::Index<int8_t>{}> saveValue(
  Zfb::Builder &fbb, const Offsets &, const reflection::Field *field,
  const Value &value
) {
  fbb.AddElement<int8_t>(
    field->offset(), value.p<Type>(), field->default_integer()
  );
}
template <unsigned Type>
inline ZuIfT<Type == Value::Index<uint8_t>{}> saveValue(
  Zfb::Builder &fbb, const Offsets &, const reflection::Field *field,
  const Value &value
) {
  fbb.AddElement<uint8_t>(
    field->offset(), value.p<Type>(), field->default_integer()
  );
}
template <unsigned Type>
inline ZuIfT<Type == Value::Index<int16_t>{}> saveValue(
  Zfb::Builder &fbb, const Offsets &, const reflection::Field *field,
  const Value &value
) {
  fbb.AddElement<int16_t>(
    field->offset(), value.p<Type>(), field->default_integer()
  );
}
template <unsigned Type>
inline ZuIfT<Type == Value::Index<uint16_t>{}> saveValue(
  Zfb::Builder &fbb, const Offsets &, const reflection::Field *field,
  const Value &value
) {
  fbb.AddElement<uint16_t>(
    field->offset(), value.p<Type>(), field->default_integer()
  );
}
template <unsigned Type>
inline ZuIfT<Type == Value::Index<int32_t>{}> saveValue(
  Zfb::Builder &fbb, const Offsets &, const reflection::Field *field,
  const Value &value
) {
  fbb.AddElement<int32_t>(
    field->offset(), value.p<Type>(), field->default_integer()
  );
}
template <unsigned Type>
inline ZuIfT<Type == Value::Index<uint32_t>{}> saveValue(
  Zfb::Builder &fbb, const Offsets &, const reflection::Field *field,
  const Value &value
) {
  fbb.AddElement<uint32_t>(
    field->offset(), value.p<Type>(), field->default_integer()
  );
}
template <unsigned Type>
inline ZuIfT<Type == Value::Index<int64_t>{}> saveValue(
  Zfb::Builder &fbb, const Offsets &, const reflection::Field *field,
  const Value &value
) {
  fbb.AddElement<int64_t>(
    field->offset(), value.p<Type>(), field->default_integer()
  );
}
template <unsigned Type>
inline ZuIfT<Type == Value::Index<uint64_t>{}> saveValue(
  Zfb::Builder &fbb, const Offsets &, const reflection::Field *field,
  const Value &value
) {
  fbb.AddElement<uint64_t>(
    field->offset(), value.p<Type>(), field->default_integer()
  );
}

template <unsigned Type>
inline ZuIfT<Type == Value::Index<double>{}> saveValue(
  Zfb::Builder &fbb, const Offsets &, const reflection::Field *field,
  const Value &value
) {
  fbb.AddElement<double>(
    field->offset(), value.p<Type>(), field->default_real()
  );
}

template <unsigned Type>
inline ZuIfT<Type == Value::Index<ZuFixed>{}> saveValue(
  Zfb::Builder &fbb, const Offsets &, const reflection::Field *field,
  const Value &value
) {
  auto v = Zfb::Save::fixed(value.p<Type>());
  fbb.AddStruct(field->offset(), &v);
}

template <unsigned Type>
inline ZuIfT<Type == Value::Index<ZuDecimal>{}> saveValue(
  Zfb::Builder &fbb, const Offsets &, const reflection::Field *field,
  const Value &value
) {
  auto v = Zfb::Save::decimal(value.p<Type>());
  fbb.AddStruct(field->offset(), &v);
}

template <unsigned Type>
inline ZuIfT<Type == Value::Index<ZuTime>{}> saveValue(
  Zfb::Builder &fbb, const Offsets &, const reflection::Field *field,
  const Value &value
) {
  auto v = Zfb::Save::time(value.p<Type>());
  fbb.AddStruct(field->offset(), &v);
}

template <unsigned Type>
inline ZuIfT<Type == Value::Index<ZuDateTime>{}> saveValue(
  Zfb::Builder &fbb, const Offsets &, const reflection::Field *field,
  const Value &value
) {
  auto v = Zfb::Save::dateTime(value.p<Type>());
  fbb.AddStruct(field->offset(), &v);
}

template <unsigned Type>
inline ZuIfT<Type == Value::Index<int128_t>{}> saveValue(
  Zfb::Builder &fbb, const Offsets &, const reflection::Field *field,
  const Value &value
) {
  auto v = Zfb::Save::int128(value.p<Type>());
  fbb.AddStruct(field->offset(), &v);
}

template <unsigned Type>
inline ZuIfT<Type == Value::Index<uint128_t>{}> saveValue(
  Zfb::Builder &fbb, const Offsets &, const reflection::Field *field,
  const Value &value
) {
  auto v = Zfb::Save::uint128(value.p<Type>());
  fbb.AddStruct(field->offset(), &v);
}

template <unsigned Type>
inline ZuIfT<Type == Value::Index<ZiIP>{}> saveValue(
  Zfb::Builder &fbb, const Offsets &, const reflection::Field *field,
  const Value &value
) {
  auto v = Zfb::Save::ip(value.p<Type>());
  fbb.AddStruct(field->offset(), &v);
}

template <unsigned Type>
inline ZuIfT<Type == Value::Index<ZuID>{}> saveValue(
  Zfb::Builder &fbb, const Offsets &, const reflection::Field *field,
  const Value &value
) {
  auto v = Zfb::Save::id(value.p<Type>());
  fbb.AddStruct(field->offset(), &v);
}

using Tuple = ZtArray<Value>;

template <typename Filter>
Tuple loadTuple_(
  unsigned nParams, const ZtVFieldArray &fields, const XFields &xFields,
  const Zfb::Table *fbo, Filter filter
) {
  Tuple tuple(nParams);
  for (unsigned i = 0; i < nParams; i++)
    if (filter(fields[i])) {
      auto value = static_cast<Value *>(tuple.push());
      auto type = xFields[i].type;
      ZuSwitch::dispatch<Value::N>(
	type,
	[value, field = xFields[i].field, fbo](auto I) {
	loadValue<I>(value->new_<I, true>(), field, fbo);
      }
      );
    } else
      new (tuple.push()) Value{};
  return tuple;
}
Tuple loadTuple_(
  unsigned nParams, const ZtVFieldArray &fields, const XFields &xFields,
  const Zfb::Table *fbo
) {
  return loadTuple_(nParams, fields, xFields, fbo, [](const ZtVField *) {
    return true;
  });
}
Tuple loadTuple(
  const ZtVFieldArray &fields, const XFields &xFields, const Zfb::Table *fbo
) {
  return loadTuple_(fields.length(), fields, xFields, fbo);
}
Tuple loadUpdTuple(
  const ZtVFieldArray &fields, const XFields &xFields, const Zfb::Table *fbo
) {
  return loadTuple_(
    fields.length(), fields, xFields, fbo,
    [](const ZtVField *field) -> bool {
    return bool(field->props & ZtVFieldProp::Mutable()) || (field->keys & 1);
  }
  );
}
Tuple loadDelTuple(
  const ZtVFieldArray &fields, const XFields &xFields, const Zfb::Table *fbo
) {
  return loadTuple_(
    fields.length(), fields, xFields, fbo,
    [](const ZtVField *field) -> bool { return (field->keys & 1); }
  );
}

Offset saveTuple(
  Zfb::Builder &fbb, const XFields &xFields, ZuSpan<const Value> tuple
) {
  unsigned n = xFields.length();
  ((tuple.length() == n) ?
     void() :
     ZmAssert_fail(
       "tuple.length() == n", "../../zdb/src/zlib/ZdbMemStore.hh", 1034,
       __PRETTY_FUNCTION__
     ));
  Offsets offsets{ZmAlloc_<Offset>{static_cast<Offset *>(
    !(n) ? nullptr :
	   (((ZmStackAvail() >> 1) < ((n) * sizeof(Offset))) ?
	      Zm::alignedAlloc<alignof(Offset)>((n) * sizeof(Offset)) :
	      __builtin_alloca_with_align(
		(n) * sizeof(Offset), (alignof(Offset)) << 3
	      ))
  )}};
  for (unsigned i = 0; i < n; i++) {
    auto type = xFields[i].type;
    const auto &value = tuple[i];
    ZuSwitch::dispatch<Value::N>(type, [&fbb, &offsets, &value](auto I) {
      saveOffset<I>(fbb, offsets, value);
    });
  }
  auto start = fbb.StartTable();
  for (unsigned i = 0; i < n; i++) {
    auto type = xFields[i].type;
    const auto &value = tuple[i];
    ZuSwitch::dispatch<Value::N>(
      type,
      [&fbb, &offsets, field = xFields[i].field, &value](auto I) {
      saveValue<I>(fbb, offsets, field, value);
    }
    );
  }
  auto end = fbb.EndTable(start);
  return Offset{end};
}

void updTuple(const ZtVFieldArray &fields, Tuple &data, Tuple &&update) {
  ((fields.length() == data.length()) ?
     void() :
     ZmAssert_fail(
       "fields.length() == data.length()", "../../zdb/src/zlib/ZdbMemStore.hh",
       1059, __PRETTY_FUNCTION__
     ));
  ((data.length() == update.length()) ?
     void() :
     ZmAssert_fail(
       "data.length() == update.length()", "../../zdb/src/zlib/ZdbMemStore.hh",
       1060, __PRETTY_FUNCTION__
     ));
  unsigned n = data.length();
  for (unsigned i = 0; i < n; i++)
    if (fields[i]->props & ZtVFieldProp::Mutable()) {
      ((update[i].type()) ?
	 void() :
	 ZmAssert_fail(
	   "update[i].type()", "../../zdb/src/zlib/ZdbMemStore.hh", 1064,
	   __PRETTY_FUNCTION__
	 ));
      data[i] = ZuMv(update[i]);
    }
}

Tuple extractKey(
  const ZtVFieldArray &fields, const ZtVKeyFieldArray &keyFields,
  unsigned keyID, const Tuple &data
) {
  ((fields.length() == data.length()) ?
     void() :
     ZmAssert_fail(
       "fields.length() == data.length()", "../../zdb/src/zlib/ZdbMemStore.hh",
       1075, __PRETTY_FUNCTION__
     ));
  Tuple key(keyFields[keyID].length());
  unsigned m = fields.length();
  for (unsigned j = 0; j < m; j++)
    if (fields[j]->keys & (uint64_t(1) << keyID)) key.push(data[j]);
  ((key.length() == key.size()) ?
     void() :
     ZmAssert_fail(
       "key.length() == key.size()", "../../zdb/src/zlib/ZdbMemStore.hh", 1080,
       __PRETTY_FUNCTION__
     ));
  return key;
}

struct MemRow__ {
  Shard shard;
  UN un;
  SN sn;
  VN vn;
  Tuple data;

  static ZuTuple<unsigned, ZdbUN> UNAxor(const MemRow__ &row) {
    return {row.shard, row.un};
  }
};

struct MemRow_ : public ZuObject, public MemRow__ {
  using MemRow__::MemRow__;
  template <typename... Args>
  MemRow_(Args &&...args) : MemRow__{ZuFwd<Args>(args)...} { }
};
inline constexpr const char *Row_HeapID() { return "MemRow"; }
using IndexUN = ZmRBTree<
  MemRow_,
  ZmRBTreeNode<
    MemRow_,
    ZmRBTreeKey<
      MemRow_::UNAxor, ZmRBTreeUnique<true, ZmRBTreeHeapID<Row_HeapID>>>>>;
struct MemRow : public IndexUN::Node {
  using Base = IndexUN::Node;
  using Base::Base;
  using MemRow__::data;
};

inline bool equals_(const Tuple &l, const Tuple &r, unsigned n) {
  for (unsigned i = 0; i < n; i++)
    if (!l[i].equals(r[i])) return false;
  return true;
}
template <typename T = Tuple> struct TupleCmp {
  uint64_t descending = 0;

  int cmp(const T &l, const T &r) const {
    unsigned ln = l.length();
    unsigned rn = r.length();
    unsigned i, n = ln < rn ? ln : rn;
    for (i = 0; i < n; i++) {
      if (int j = l[i].cmp(r[i])) {
	if (descending & (uint64_t(1) << i)) j = -j;
	return j;
      }
    }
    return ZuCmp<int>::cmp(ln, rn);
  }
  static bool equals(const T &l, const T &r) {
    unsigned ln = l.length();
    unsigned rn = r.length();
    return equals_(l, r, ln < rn ? ln : rn);
  }
};
inline constexpr const char *MemRowIndex_HeapID() { return "MemRowIndex"; }
using Index = ZmRBTreeKV<
  Tuple, ZmRef<const MemRow>,
  ZmRBTreeCmp<
    TupleCmp, ZmRBTreeUnique<true, ZmRBTreeHeapID<MemRowIndex_HeapID>>>>;

class Store__ {
public:
  void init(ZiMultiplex *mx, unsigned sid) {
    m_mx = mx;
    m_sid = sid;
  }

  template <typename... Args> void run(Args &&...args) {
    m_mx->run(m_sid, ZuFwd<Args>(args)...);
  }
  template <typename... Args> void invoke(Args &&...args) {
    m_mx->invoke(m_sid, ZuFwd<Args>(args)...);
  }

private:
  ZiMultiplex *m_mx = nullptr;
  unsigned m_sid = ZuCmp<unsigned>::null();
};

class StoreTbl : public Zdb_::StoreTbl {
public:
  using Store = Store__;

  StoreTbl(
    Store *store, ZtString id, unsigned nShards, ZtVFieldArray fields,
    ZtVKeyFieldArray keyFields, const reflection::Schema *schema,
    IOBufAllocFn bufAllocFn
  ) :
    m_store{store}, m_id{ZuMv(id)}, m_fields{ZuMv(fields)},
    m_keyFields{ZuMv(keyFields)}, m_bufAllocFn{ZuMv(bufAllocFn)} {
    for (unsigned i = 0, n = keyFields.length(); i < n; i++) {
      uint64_t descending = 0;
      unsigned m = keyFields[i].length();
      ((m < 64) ? void() :
		  ZmAssert_fail(
		    "m < 64", "../../zdb/src/zlib/ZdbMemStore.hh", 1194,
		    __PRETTY_FUNCTION__
		  ));
      for (unsigned j = 0; j < m; j++)
	if (keyFields[i][j]->descend & (uint64_t(1) << i))
	  descending |= (uint64_t(1) << j);
      new (m_indices.push()) Index{TupleCmp<>{descending}};
    }
    const reflection::Object *rootTbl = schema->root_table();
    const Zfb::Vector<Zfb::Offset<reflection::Field>> *fbFields_ =
      rootTbl->fields();
    unsigned n = m_fields.length();
    m_xFields.size(n);
    for (unsigned i = 0; i < n; i++)
      ZtCase::camelSnake(
	m_fields[i]->id,
	[this, fbFields_, i](const ZtString &id) {
	m_xFields.push(xField(fbFields_, m_fields[i], id));
      }
      );
    n = m_keyFields.length();
    m_xKeyFields.size(n);
    m_keyGroup.length(n);
    for (unsigned i = 0; i < n; i++) {
      unsigned m = m_keyFields[i].length();
      new (m_xKeyFields.push()) XFields{m};
      m_keyGroup[i] = 0;
      for (unsigned j = 0; j < m; j++) {
	if (m_keyFields[i][j]->group & (uint64_t(1) << i))
	  m_keyGroup[i] = j + 1;
	ZtCase::camelSnake(
	  m_keyFields[i][j]->id,
	  [this, fbFields_, i, j](const ZtString &id) {
	  m_xKeyFields[i].push(xField(fbFields_, m_keyFields[i][j], id));
	}
	);
      }
    }
    m_maxUN.length(nShards);
    for (unsigned i = 0; i < nShards; i++) m_maxUN[i] = Zdb_::nullUN();
  }

  Store *store() const { return m_store; }
  const auto &id() const { return m_id; }

  bool opened() const { return m_opened; }

  auto count() const { return m_indices[0].count_(); }
  unsigned nShards() const { return m_maxUN.length(); }
  const auto &maxUN() const { return m_maxUN; }
  auto maxUN(Shard shard) const { return m_maxUN[shard]; }
  auto maxSN() const { return m_maxSN; }

protected:
  ~StoreTbl() = default;

private:
  ZmRef<const MemRow> loadRow(const ZmRef<const IOBuf> &buf) {
    auto record = record_(msg_(buf->hdr()));
    auto sn = Zfb::Load::uint128(record->sn());
    auto data = Zfb::Load::bytes(record->data());
    auto fbo = Zfb::GetAnyRoot(data.data());
    Tuple tuple;
    if (!record->vn())
      tuple = loadTuple(m_fields, m_xFields, fbo);
    else if (record->vn() > 0)
      tuple = loadUpdTuple(m_fields, m_xFields, fbo);
    else
      tuple = loadDelTuple(m_fields, m_xFields, fbo);
    return new MemRow{
      record->shard(), record->un(), sn, record->vn(), ZuMv(tuple)
    };
  }

  template <bool Recovery>
  ZmRef<IOBuf> saveRow(const ZmRef<const MemRow> &row) {
    Zfb::IOBuilder fbb{m_bufAllocFn()};
    auto data = Zfb::Save::nest(fbb, [this, &row](Zfb::Builder &fbb) {
      return saveTuple(fbb, m_xFields, row->data);
    });
    {
      auto sn = Zfb::Save::uint128(row->sn);
      auto msg = fbs::CreateMsg(
	fbb, Recovery ? fbs::Body::Recovery : fbs::Body::Replication,
	fbs::CreateRecord(
	  fbb, Zfb::Save::str(fbb, this->id()), row->un, &sn, row->vn,
	  row->shard, data
	)
	  .Union()
      );
      fbb.Finish(msg);
    }
    return saveHdr(fbb);
  }

public:
  void open() { m_opened = true; }
  void close(CloseFn fn) {
    m_opened = false;
    fn();
  }

  void warmup() { }

  void count(unsigned keyID, ZmRef<const IOBuf>, CountFn);

  void select(
    bool selectRow, bool selectNext, bool inclusive, unsigned keyID,
    ZmRef<const IOBuf>, unsigned limit, TupleFn
  );

  void find(unsigned keyID, ZmRef<const IOBuf>, RowFn);

  void recover(Shard shard, UN, RowFn);

  void write(ZmRef<const IOBuf>, CommitFn);

private:
  void insert(ZmRef<MemRow>, ZmRef<const IOBuf>, CommitFn);
  void update(ZmRef<MemRow>, ZmRef<const IOBuf>, CommitFn);
  void del(ZmRef<MemRow>, ZmRef<const IOBuf>, CommitFn);

private:
  Store *m_store;
  ZtString m_id;
  ZtVFieldArray m_fields;
  ZtVKeyFieldArray m_keyFields;
  XFields m_xFields;
  XKeyFields m_xKeyFields;
  ZtArray<unsigned> m_keyGroup;
  IndexUN m_indexUN;
  ZtArray<Index> m_indices;
  IOBufAllocFn m_bufAllocFn;

  bool m_opened = false;

  ZtArray<UN> m_maxUN;
  SN m_maxSN = Zdb_::nullSN();
};

template <typename StoreTbl_>
inline ZuCSpan StoreTbl_IDAxor(const StoreTbl_ &tbl) {
  return tbl.id();
}
inline constexpr const char *StoreTbls_HeapID() { return "ZdbMem.StoreTbl"; }
template <typename StoreTbl_>
using StoreTbls_ = ZmHash<
  StoreTbl_,
  ZmHashNode<
    StoreTbl_,
    ZmHashKey<
      StoreTbl_IDAxor<StoreTbl_>,
      ZmHashLock<ZmPLock, ZmHashHeapID<StoreTbls_HeapID>>>>>;

template <typename StoreTbl_>
class Store_ : public Zdb_::Store, public Store__ {
public:
  using StoreTbl = StoreTbl_;

private:
  using StoreTbls = StoreTbls_<StoreTbl>;
  using StoreTblNode = typename StoreTbls::Node;

public:
  InitResult init(ZvCf *cf, ZiMultiplex *mx, FailFn failFn) {
    if (!m_storeTbls) m_storeTbls = new StoreTbls{};
    m_failFn = ZuMv(failFn);
    try {
      const ZtString &tid = cf->get<true>("thread");
      auto sid = mx->sid(tid);
      if (!sid || sid > mx->params().nThreads() || sid == mx->rxThread() ||
	  sid == mx->txThread())
	return {ZeMkVEvent(
	  Ze::Fatal, "../../zdb/src/zlib/ZdbMemStore.hh", 1355,
	  __PRETTY_FUNCTION__, ([tid = ZtString{tid}](auto &s, const auto &) {
	  s << "Store::init() failed: invalid thread configuration \"" << tid
	    << '"';
	})
	)

	};
      Store__::init(mx, sid);
    } catch (const ZvError &e_) {
      ZtString e;
      e << e_;
      return {ZeMkVEvent(
	Ze::Fatal, "../../zdb/src/zlib/ZdbMemStore.hh", 1363,
	__PRETTY_FUNCTION__, ([e = ZuMv(e)](auto &s, const auto &) {
	s << "Store::init() failed: invalid configuration: " << e;
      })
      )

      };
    }
    return {InitData{.replicated = false}};
  }
  void final() {
    m_failFn = FailFn{};
    if (!m_preserve) {
      m_storeTbls->clean();
      m_storeTbls = nullptr;
    }
  }

  void fail(ZeVEvent e) { m_failFn(ZuMv(e)); }

  void preserve() { m_preserve = true; }

  void open(
    ZtString id, unsigned nShards, ZtVFieldArray fields,
    ZtVKeyFieldArray keyFields, const reflection::Schema *schema,
    IOBufAllocFn bufAllocFn, OpenFn openFn
  ) {
    StoreTblNode *storeTbl = m_storeTbls->find(id);
    if (storeTbl && storeTbl->opened()) {
      openFn(OpenResult{ZeMkVEvent(
	Ze::Error, "../../zdb/src/zlib/ZdbMemStore.hh", 1391,
	__PRETTY_FUNCTION__, ([id = ZuMv(id)](auto &s, const auto &) {
	s << "open(" << id << ") failed - already open";
      })
      )

      });
      return;
    }
    if (storeTbl) {
      if (nShards != storeTbl->nShards()) {
	openFn(OpenResult{ZeMkVEvent(
	  Ze::Error, "../../zdb/src/zlib/ZdbMemStore.hh", 1399,
	  __PRETTY_FUNCTION__, ([id = ZuMv(id)](auto &s, const auto &) {
	  s << "open(" << id << ") failed - inconsistent nShards";
	})
	)

	});
	return;
      }
    } else {
      storeTbl = new StoreTblNode{
	this,   ZuMv(id),        nShards, ZuMv(fields), ZuMv(keyFields),
	schema, ZuMv(bufAllocFn)
      };
      m_storeTbls->addNode(storeTbl);
    }
    storeTbl->open();
    openFn(OpenResult{
      OpenData{
	       .storeTbl = storeTbl,
	       .count = storeTbl->count(),
	       .un = storeTbl->maxUN(),
	       .sn = storeTbl->maxSN()
      }
    });
  }

private:
  ZmRef<StoreTbls> m_storeTbls;
  FailFn m_failFn;
  bool m_preserve = false;
};

using Store = Store_<StoreTbl>;

} // namespace ZdbMem

extern "C" {
  extern Zdb_::Store *ZdbStore();
}

class ZuIBitStream {
public:
  ZuIBitStream() = default;
  ZuIBitStream(const ZuIBitStream &) = default;
  ZuIBitStream &operator=(const ZuIBitStream &) = default;
  ZuIBitStream(ZuIBitStream &&) = default;
  ZuIBitStream &operator=(ZuIBitStream &&) = default;

  ZuIBitStream(const uint8_t *start, const uint8_t *end) :
    m_pos{start}, m_end{end} { }

  bool operator!() const { return !m_pos; }
  operator const void *() const {
    return !*this ? reinterpret_cast<const void *>(0) :
		    static_cast<const void *>(this);
  }

  const uint8_t *pos() const { return m_pos; }
  const uint8_t *end() const { return m_end; }
  unsigned inBits() const { return m_inBits; }

  ZuTuple<const uint8_t *, unsigned> save() const { return {m_pos, m_inBits}; }

  void load(const ZuTuple<const uint8_t *, unsigned> &saved) {
    m_pos = saved.p<0>();
    m_inBits = saved.p<1>();
  }

  template <unsigned Bits> bool avail() {
    return m_pos + ((m_inBits + Bits + 7) >> 3) <= m_end;
  }
  bool avail(unsigned bits) {
    return m_pos + ((m_inBits + bits + 7) >> 3) <= m_end;
  }

  template <unsigned Bits> uint8_t in() {
    uint8_t v;
    if (__builtin_expect(!!(!m_inBits), 0)) {
      m_inBits = Bits;
      return (*m_pos) & ~(uint8_t(0xff) << Bits);
    }
    unsigned bits;
    unsigned lbits = 8 - m_inBits;
    if (__builtin_expect(!!(Bits < lbits), 0)) lbits = Bits;
    v = ((*m_pos) >> m_inBits) & ~(uint8_t(0xff) << lbits);
    if ((m_inBits += lbits) >= 8) {
      m_pos++;
      m_inBits = 0;
    }
    if (!(bits = Bits - lbits)) return v;

    v |= ((*m_pos) & ~(uint8_t(0xff) << bits)) << lbits;
    m_inBits = bits;
    return v;
  }
  uint64_t in(unsigned bits) {
    uint64_t v = 0;
    unsigned lbits = 0;
    if (__builtin_expect(!!(m_inBits > 0), 1)) {
      lbits = 8 - m_inBits;
      if (__builtin_expect(!!(bits < lbits), 0)) lbits = bits;
      v = ((*m_pos) >> m_inBits) & ~(uint8_t(0xff) << lbits);
      if ((m_inBits += lbits) >= 8) {
	m_pos++;
	m_inBits = 0;
      }
      if (!(bits -= lbits)) return v;
      v <<= (64 - lbits);
    }
    switch (bits >> 3) {
    case 8:
      v = uint64_t(*m_pos++) << 56;
    case 7:
      v = (v >> 8) | (uint64_t(*m_pos++) << 56);
    case 6:
      v = (v >> 8) | (uint64_t(*m_pos++) << 56);
    case 5:
      v = (v >> 8) | (uint64_t(*m_pos++) << 56);
    case 4:
      v = (v >> 8) | (uint64_t(*m_pos++) << 56);
    case 3:
      v = (v >> 8) | (uint64_t(*m_pos++) << 56);
    case 2:
      v = (v >> 8) | (uint64_t(*m_pos++) << 56);
    case 1:
      v = (v >> 8) | (uint64_t(*m_pos++) << 56);
    }
    unsigned hbits = bits & 7;
    bits -= hbits;
    v >>= (64 - (bits + lbits));
    if (hbits) {
      m_inBits = hbits;
      v |= ((*m_pos) & ~(uint8_t(0xff) << hbits)) << (bits + lbits);
    }
    return v;
  }

private:
  const uint8_t *m_pos = nullptr;
  const uint8_t *m_end = nullptr;
  unsigned m_inBits = 0;
};

class ZuOBitStream {
  ZuOBitStream(const ZuOBitStream &) = delete;
  ZuOBitStream &operator=(const ZuOBitStream &) = delete;

public:
  ZuOBitStream() = default;

  ZuOBitStream(uint8_t *start, uint8_t *end) : m_pos{start}, m_end{end} { }

  ZuOBitStream(ZuOBitStream &&w) :
    m_pos{w.m_pos}, m_end{w.m_end}, m_outBits{w.m_outBits} {
    w.m_pos = nullptr;
    w.m_end = nullptr;
    w.m_outBits = 0;
  }
  ZuOBitStream &operator=(ZuOBitStream &&w) {
    if (__builtin_expect(!!(this != &w), 1)) {
      this->~ZuOBitStream();
      new (this) ZuOBitStream{ZuMv(w)};
    }
    return *this;
  }

  ZuOBitStream(const ZuIBitStream &in, uint8_t *end) :
    m_pos{const_cast<uint8_t *>(in.pos())}, m_end{end} {
    m_outBits = in.inBits();
    *m_pos <<= (8 - m_outBits);
  }

  uint8_t *pos() const { return m_pos; }
  uint8_t *end() const { return m_end; }

  bool operator!() const { return !m_pos; }
  operator const void *() const {
    return !*this ? reinterpret_cast<const void *>(0) :
		    static_cast<const void *>(this);
  }

  template <unsigned Bits> bool avail() {
    return m_pos + ((m_outBits + Bits + 7) >> 3) <= m_end;
  }
  bool avail(unsigned bits) {
    return m_pos + ((m_outBits + bits + 7) >> 3) <= m_end;
  }

  template <unsigned Bits> void out(uint8_t v) {
    if (__builtin_expect(!!(m_outBits == 0), 0)) {
      m_outBits = Bits;
      *m_pos = v << (8 - Bits);
      return;
    }
    unsigned lbits = 8 - m_outBits;
    if (__builtin_expect(!!(Bits < lbits), 0)) lbits = Bits;
    *m_pos = ((*m_pos) >> lbits) | (v << (8 - lbits));
    if ((m_outBits += lbits) >= 8) {
      m_pos++;
      m_outBits = 0;
    }
    v >>= lbits;
    if (uint8_t bits = Bits - lbits) {
      m_outBits = bits;
      *m_pos = v << (8 - bits);
    }
  }
  void out(uint64_t v, unsigned bits) {
    if (__builtin_expect(!!(m_outBits > 0), 1)) {
      unsigned lbits = 8 - m_outBits;
      if (__builtin_expect(!!(bits < lbits), 0)) lbits = bits;
      *m_pos = ((*m_pos) >> lbits) | (v << (8 - lbits));
      if ((m_outBits += lbits) >= 8) {
	m_pos++;
	m_outBits = 0;
      }
      v >>= lbits;
      if (!(bits -= lbits)) return;
    }
    switch (bits >> 3) {
    case 8:
      *m_pos++ = v;
      v >>= 8;
    case 7:
      *m_pos++ = v;
      v >>= 8;
    case 6:
      *m_pos++ = v;
      v >>= 8;
    case 5:
      *m_pos++ = v;
      v >>= 8;
    case 4:
      *m_pos++ = v;
      v >>= 8;
    case 3:
      *m_pos++ = v;
      v >>= 8;
    case 2:
      *m_pos++ = v;
      v >>= 8;
    case 1:
      *m_pos++ = v;
      v >>= 8;
    }
    bits &= 7;
    if (bits) {
      m_outBits = bits;
      *m_pos = v << (8 - bits);
    }
  }

  void finish() {
    if (__builtin_expect(!!(m_pos < m_end && m_outBits), 1)) {
      (*m_pos) >>= (8 - m_outBits);
      m_pos++;
      m_outBits = 0;
    }
  }

private:
  uint8_t *m_pos = nullptr;
  uint8_t *m_end = nullptr;
  unsigned m_outBits = 0;
};

namespace Zdf {

class Decoder {
public:
  using Value = int64_t;

  Decoder() = default;
  Decoder(const Decoder &) = default;
  Decoder &operator=(const Decoder &) = default;
  Decoder(Decoder &&) = default;
  Decoder &operator=(Decoder &&) = default;

  Decoder(const uint8_t *start, const uint8_t *end) :
    m_pos{start}, m_end{end} { }

  bool operator!() const { return !m_pos; }
  operator const void *() const {
    return !*this ? reinterpret_cast<const void *>(0) :
		    static_cast<const void *>(this);
  }

  const uint8_t *pos() const { return m_pos; }
  const uint8_t *end() const { return m_end; }
  unsigned offset() const { return m_offset; }

  bool seek(unsigned offset) {
    while (offset) {
      if (m_rle) {
	if (m_rle >= offset) {
	  m_offset += offset;
	  m_rle -= offset;
	  return true;
	}
	m_offset += m_rle;
	offset -= m_rle;
	m_rle = 0;
      } else {
	if (!read_(nullptr)) return false;
	++m_offset;
	--offset;
      }
    }
    return true;
  }

  template <typename L> bool seek(unsigned offset, L l) {
    while (offset) {
      if (m_rle) {
	if (m_rle >= offset) {
	  l(m_prev, offset);
	  m_offset += offset;
	  m_rle -= offset;
	  return true;
	}
	l(m_prev, m_rle);
	m_offset += m_rle;
	offset -= m_rle;
	m_rle = 0;
      } else {
	int64_t value;
	if (!read_(&value)) return false;
	l(value, 1);
	++m_offset;
	--offset;
      }
    }
    return true;
  }

  template <typename L> bool search(L l) {
    const uint8_t *origPos;
    unsigned skip;
    if (m_rle) {
      skip = l(m_prev, m_rle);
      m_offset += skip;
      if (m_rle -= skip) return true;
    }
    int64_t value;
    for (;;) {
      origPos = m_pos;
      if (!read_(&value)) return false;
      skip = l(value, 1 + m_rle);
      if (!skip) {
	m_pos = origPos;
	return true;
      }
      ++m_offset;
      --skip;
      if (m_rle) {
	if (!skip) return true;
	m_offset += skip;
	if (m_rle -= skip) return true;
      }
    }
  }

  bool read(int64_t &value) {
    if (m_rle) {
      ++m_offset;
      --m_rle;
      value = m_prev;
      return true;
    }
    if (read_(&value)) {
      ++m_offset;
      return true;
    }
    return false;
  }

  bool skip() {
    if (m_rle) {
      ++m_offset;
      --m_rle;
      return true;
    }
    if (read_(nullptr)) {
      ++m_offset;
      return true;
    }
    return false;
  }

private:
  bool read_(int64_t *value_) {
again:
    if (__builtin_expect(!!(m_pos >= m_end), 0)) return false;
    unsigned byte = *m_pos;
    if (byte & 0x80) {
      ++m_pos;
      if (byte == 0x80) {
	m_prev = 0;
	goto again;
      } else {
	m_rle = (byte & 0x7f) - 1;
	if (value_) *value_ = m_prev;
	return true;
      }
    }
    int64_t value;
    if (!(byte & 0x20)) {
      ++m_pos;
      value = byte & 0x1f;
    } else if ((byte & 0x30) == 0x20) {
      if (m_pos + 2 > m_end) return false;
      ++m_pos;
      value = byte & 0xf;
      value |= int64_t(*m_pos++) << 4;
    } else if ((byte & 0x38) == 0x30) {
      if (m_pos + 3 > m_end) return false;
      ++m_pos;
      value = byte & 0x7;
      value |= int64_t(*m_pos++) << 3;
      value |= int64_t(*m_pos++) << 11;
    } else if ((byte & 0x3c) == 0x38) {
      if (m_pos + 4 > m_end) return false;
      ++m_pos;
      value = byte & 0x3;
      value |= int64_t(*m_pos++) << 2;
      value |= int64_t(*m_pos++) << 10;
      value |= int64_t(*m_pos++) << 18;
    } else if ((byte & 0x3e) == 0x3c) {
      if (m_pos + 5 > m_end) return false;
      ++m_pos;
      value = byte & 0x1;
      value |= int64_t(*m_pos++) << 1;
      value |= int64_t(*m_pos++) << 9;
      value |= int64_t(*m_pos++) << 17;
      value |= int64_t(*m_pos++) << 25;
    } else if ((byte & 0x3f) == 0x3e) {
      if (m_pos + 6 > m_end) return false;
      ++m_pos;
      value = *m_pos++;
      value |= int64_t(*m_pos++) << 8;
      value |= int64_t(*m_pos++) << 16;
      value |= int64_t(*m_pos++) << 24;
      value |= int64_t(*m_pos++) << 32;
    } else {
      if (m_pos + 9 > m_end) return false;
      ++m_pos;

      value = *reinterpret_cast<const ZuLittleEndian<uint64_t> *>(m_pos);

      m_pos += 8;
    }
    if (byte & 0x40) value = ~value;
    if (value_) *value_ = m_prev = value;
    return true;
  }

private:
  const uint8_t *m_pos = nullptr;
  const uint8_t *m_end = nullptr;
  int64_t m_prev = 0;
  unsigned m_rle = 0;
  unsigned m_offset = 0;
};

template <typename> class Encoder;

template <> class Encoder<Decoder> {
  Encoder(const Encoder &) = delete;
  Encoder &operator=(const Encoder &) = delete;

public:
  Encoder(uint8_t *start, uint8_t *end) : m_pos{start}, m_end{end} { }

  Encoder() { }
  Encoder(Encoder &&w) :
    m_pos{w.m_pos}, m_end{w.m_end}, m_rle{w.m_rle}, m_prev{w.m_prev},
    m_offset{w.m_offset} {
    w.m_pos = nullptr;
    w.m_end = nullptr;
    w.m_rle = nullptr;
    w.m_prev = 0;
    w.m_offset = 0;
  }
  Encoder &operator=(Encoder &&w) {
    if (__builtin_expect(!!(this != &w), 1)) {
      this->~Encoder();
      new (this) Encoder{ZuMv(w)};
    }
    return *this;
  }
  ~Encoder() = default;

  Encoder(const Decoder &decoder, uint8_t *end) :
    m_pos{const_cast<uint8_t *>(decoder.pos())}, m_end{end},
    m_offset{decoder.offset()} {
    ((m_pos < m_end) ? void() :
		       ZmAssert_fail(
			 "m_pos < m_end", "../../zdf/src/zlib/ZdfCompress.hh",
			 284, __PRETTY_FUNCTION__
		       ));
    *m_pos++ = 0x80;
  }

  uint8_t *pos() const { return m_pos; }
  uint8_t *end() const { return m_end; }
  unsigned offset() const { return m_offset; }

  bool operator!() const { return !m_pos; }
  operator const void *() const {
    return !*this ? reinterpret_cast<const void *>(0) :
		    static_cast<const void *>(this);
  }

  bool write(int64_t value_) {
    if (__builtin_expect(!!(value_ == m_prev), 1)) {
      if (m_rle) {
	if (++*m_rle == 0xff) m_rle = nullptr;
	++m_offset;
	return true;
      }
      if (m_pos >= m_end) return false;
      *(m_rle = m_pos++) = 0x81;
      ++m_offset;
      return true;
    } else
      m_rle = nullptr;
    unsigned negative = value_ < 0;
    int64_t value = value_;
    if (negative) value = ~value;
    unsigned n = !value ? 0 : 64 - ZuIntrin::clz(value);
    n = (n + 1) / 7;
    if (n >= 6) n = 8;
    if (m_pos + n >= m_end) return false;
    if (n == 8) n = 6;
    negative <<= 6;
    switch (n) {
    case 0:
      *m_pos++ = negative | value;
      break;
    case 1:
      *m_pos++ = negative | 0x20 | (value & 0xf);
      value >>= 4;
      *m_pos++ = value;
      break;
    case 2:
      *m_pos++ = negative | 0x30 | (value & 0x7);
      value >>= 3;
      *m_pos++ = value & 0xff;
      value >>= 8;
      *m_pos++ = value;
      break;
    case 3:
      *m_pos++ = negative | 0x38 | (value & 0x3);
      value >>= 2;
      *m_pos++ = value & 0xff;
      value >>= 8;
      *m_pos++ = value & 0xff;
      value >>= 8;
      *m_pos++ = value;
      break;
    case 4:
      *m_pos++ = negative | 0x3c | (value & 0x1);
      value >>= 1;
      *m_pos++ = value & 0xff;
      value >>= 8;
      *m_pos++ = value & 0xff;
      value >>= 8;
      *m_pos++ = value & 0xff;
      value >>= 8;
      *m_pos++ = value;
      break;
    case 5:
      *m_pos++ = negative | 0x3e;
      *m_pos++ = value & 0xff;
      value >>= 8;
      *m_pos++ = value & 0xff;
      value >>= 8;
      *m_pos++ = value & 0xff;
      value >>= 8;
      *m_pos++ = value & 0xff;
      value >>= 8;
      *m_pos++ = value;
      break;
    case 6:
      *m_pos++ = negative | 0x3f;

      *reinterpret_cast<ZuLittleEndian<uint64_t> *>(m_pos) = value;

      m_pos += 8;
      break;
    }
    m_prev = value_;
    ++m_offset;
    return true;
  }

  int64_t last() const { return m_prev; }

  void finish() { }

private:
  uint8_t *m_pos = nullptr;
  uint8_t *m_end = nullptr;
  uint8_t *m_rle = nullptr;
  int64_t m_prev = 0;
  unsigned m_offset = 0;
};

template <typename Base = Decoder> class DeltaDecoder : public Base {
  static_assert(
    ((ZuIsExact<typename Base::Value, int64_t>{})),
    "(ZuIsExact<typename Base::Value, int64_t>{})"
  );

public:
  DeltaDecoder() : Base{} { }
  DeltaDecoder(const DeltaDecoder &) = default;
  DeltaDecoder &operator=(const DeltaDecoder &) = default;
  DeltaDecoder(DeltaDecoder &&) = default;
  DeltaDecoder &operator=(DeltaDecoder &&) = default;

  DeltaDecoder(const uint8_t *start, const uint8_t *end) : Base{start, end} { }

  bool seek(unsigned offset) {
    return Base::seek(offset, [this](int64_t skip, unsigned offset) {
      m_base += skip * offset;
    });
  }

  template <typename L> bool seek(unsigned offset, L l) {
    return Base::seek(
      offset,
      [this, l = ZuMv(l)](int64_t skip, unsigned offset) {
      for (unsigned i = 0; i < offset; i++) l(m_base += skip, 1);
    }
    );
  }

  template <typename L> bool search(L l) {
    return Base::search([this, l = ZuMv(l)](int64_t skip, unsigned rle) {
      int64_t value;
      for (unsigned i = 0; i < rle; i++) {
	value = m_base + skip;
	if (!l(value, 1)) return i;
	m_base = value;
      }
      return rle;
    });
  }

  bool read(int64_t &value_) {
    int64_t value;
    if (__builtin_expect(!!(!Base::read(value)), 0)) return false;
    value_ = (m_base += value);
    return true;
  }

  int64_t base() const { return m_base; }

private:
  int64_t m_base = 0;
};

template <typename Base_>
class Encoder<DeltaDecoder<Base_>> : public Encoder<Base_> {
  Encoder(const Encoder &) = delete;
  Encoder &operator=(const Encoder &) = delete;

public:
  using Base = Encoder<Base_>;
  using Decoder = DeltaDecoder<Base_>;

  Encoder(uint8_t *start, uint8_t *end) : Base{start, end} { }

  Encoder() { }
  Encoder(Encoder &&w) : Base{static_cast<Base &&>(w)}, m_base{w.m_base} {
    w.m_base = 0;
  }
  Encoder &operator=(Encoder &&w) {
    if (__builtin_expect(!!(this != &w), 1)) {
      this->~Encoder();
      new (this) Encoder{ZuMv(w)};
    }
    return *this;
  }

  Encoder(const Decoder &decoder, uint8_t *end) :
    Base{decoder, end}, m_base{decoder.base()} { }

  bool write(int64_t value) {
    int64_t delta = value - m_base;
    if (__builtin_expect(!!(!Base::write(delta)), 0)) return false;
    m_base = value;
    return true;
  }

  int64_t last() const { return m_base + Base::last(); }

private:
  int64_t m_base = 0;
};

class FloatDecoder : public ZuIBitStream {
public:
  using Value = double;

  static_assert((sizeof(Value) == 8), "sizeof(Value) == 8");

  FloatDecoder() = default;
  FloatDecoder(const FloatDecoder &) = default;
  FloatDecoder &operator=(const FloatDecoder &) = default;
  FloatDecoder(FloatDecoder &&) = default;
  FloatDecoder &operator=(FloatDecoder &&) = default;

  FloatDecoder(const uint8_t *start, const uint8_t *end) :
    ZuIBitStream{start, end} { }

  unsigned offset() const { return m_offset; }

  bool seek(unsigned offset) {
    while (offset) {
      if (!read_(nullptr)) return false;
      ++m_offset;
      --offset;
    }
    return true;
  }

  template <typename L> bool seek(unsigned offset, L l) {
    while (offset) {
      double value;
      if (!read_(&value)) return false;
      l(value, 1);
      ++m_offset;
      --offset;
    }
    return true;
  }

  template <typename L> bool search(L l) {
    double value;
    for (;;) {
      auto orig = save();
      if (!read_(&value)) return false;
      if (!l(value, 1)) {
	load(orig);
	return true;
      }
      ++m_offset;
    }
  }

  bool read(double &value) {
    if (read_(&value)) {
      ++m_offset;
      return true;
    }
    return false;
  }

  bool skip() {
    if (read_(nullptr)) {
      ++m_offset;
      return true;
    }
    return false;
  }

private:
  bool read_(double *out) {
    static uint8_t lzmap[] = {0, 8, 12, 16, 18, 20, 22, 24};

    auto saved = save();
again:
    if (__builtin_expect(!!(!avail<2>()), 0)) goto eob;
    uint64_t value;
    switch (in<2>()) {
    case 0:
      value = 0;
      break;
    case 1: {
      if (__builtin_expect(!!(!avail<9>()), 0)) goto eob;
      unsigned lz = lzmap[in<3>()];
      unsigned sb = in<6>();
      if (!sb) {
	m_prev = 0;
	m_prevLZ = 0;
	goto again;
      }
      if (__builtin_expect(!!(!avail(sb)), 0)) goto eob;
      value = in(sb) << (64 - sb - lz);
      m_prevLZ = lz;
    } break;
    case 2: {
      unsigned sb = 64 - m_prevLZ;
      if (__builtin_expect(!!(!avail(sb)), 0)) goto eob;
      value = in(sb);
    } break;
    case 3: {
      if (__builtin_expect(!!(!avail<3>()), 0)) goto eob;
      unsigned lz = lzmap[in<3>()];
      unsigned sb = 64 - lz;
      if (__builtin_expect(!!(!avail(sb)), 0)) goto eob;
      value = in(sb);
      m_prevLZ = lz;
    } break;
    }
    value ^= m_prev;
    m_prev ^= value;
    if (out) {
      const double *__attribute__((__may_alias__)) ptr =
	reinterpret_cast<const double *>(&value);
      *out = *ptr;
    }
    return true;
eob:
    load(saved);
    return false;
  }

private:
  uint64_t m_prev = 0;
  unsigned m_prevLZ = 0;
  unsigned m_offset = 0;
};

template <> class Encoder<FloatDecoder> : public ZuOBitStream {
  Encoder(const Encoder &) = delete;
  Encoder &operator=(const Encoder &) = delete;

public:
  using Decoder = FloatDecoder;

  Encoder(uint8_t *start, uint8_t *end) : ZuOBitStream{start, end} { }

  Encoder() { }
  Encoder(Encoder &&w) :
    ZuOBitStream{ZuMv(w)}, m_prev{w.m_prev}, m_prevLZ{w.m_prevLZ},
    m_offset{w.m_offset} {
    w.m_prev = 0;
    w.m_prevLZ = 0;
    w.m_offset = 0;
  }
  Encoder &operator=(Encoder &&w) {
    if (__builtin_expect(!!(this != &w), 1)) {
      this->~Encoder();
      new (this) Encoder{ZuMv(w)};
    }
    return *this;
  }

  Encoder(const Decoder &decoder, uint8_t *end) :
    ZuOBitStream{decoder, end}, m_offset{decoder.offset()} {
    ((pos() + 2 < end) ?
       void() :
       ZmAssert_fail(
	 "pos() + 2 < end", "../../zdf/src/zlib/ZdfCompress.hh", 639,
	 __PRETTY_FUNCTION__
       ));
    out(1, 11);
  }

  unsigned offset() const { return m_offset; }

public:
  bool write(double in) {
    static uint8_t lzround[] = {0,  0,  0,  0,  0,  0,  0,  0,  8,  8,  8,
				8,  12, 12, 12, 12, 16, 16, 18, 18, 20, 20,
				22, 22, 24, 24, 24, 24, 24, 24, 24, 24, 24,
				24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
				24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
				24, 24, 24, 24, 24, 24, 24, 24, 24};
    static uint8_t lzmap[] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2,
			      2, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7};

    const uint64_t *__attribute__((__may_alias__)) ptr =
      reinterpret_cast<const uint64_t *>(&in);
    uint64_t value = *ptr;
    value ^= m_prev;
    if (__builtin_expect(!!(!value), 0)) {
      if (__builtin_expect(!!(!this->avail<2>()), 0)) return false;
      out<2>(0);
      return true;
    }
    unsigned lz = lzround[ZuIntrin::clz(value)];
    unsigned tz = ZuIntrin::ctz(value);
    if (tz > 6) {
      unsigned sb = 64 - lz - tz;
      if (__builtin_expect(!!(!this->avail(sb + 11)), 0)) return false;
      out((uint64_t(sb) << 5) | (lzmap[lz] << 2) | 1, 11);
      out(value >> tz, sb);
      m_prevLZ = lz;
    } else if (lz == m_prevLZ) {
      unsigned sb = 64 - lz;
      if (__builtin_expect(!!(!this->avail(sb + 2)), 0)) return false;
      out<2>(2);
      out(value, sb);
    } else {
      unsigned sb = 64 - lz;
      if (__builtin_expect(!!(!this->avail(sb + 5)), 0)) return false;
      out<5>((lzmap[lz] << 2) | 3);
      out(value, sb);
      m_prevLZ = lz;
    }
    m_prev ^= value;
    return true;
  }

  double last() const {
    const double *__attribute__((__may_alias__)) ptr =
      reinterpret_cast<const double *>(&m_prev);
    return *ptr;
  }

  void finish() {
    if (avail<2>()) out<2>(1);
    ZuOBitStream::finish();
  }

private:
  uint64_t m_prev = 0;
  unsigned m_prevLZ = 0;
  unsigned m_offset = 0;
};

} // namespace Zdf

template <typename T, typename Cmp, unsigned N> struct ZuSort_Fn {
  using Fn = ZuArrayFn<T>;

  static void isort_(T *base, unsigned n, Cmp &cmp) {
    using std::swap;
    T *end = base + n;
    T *minimum = base, *ptr = base;

    while (++ptr < end)
      if (cmp(*minimum, *ptr) > 0) minimum = ptr;

    if (minimum != base) {
      swap(*minimum, *base);
      minimum = base;
    }

    while ((ptr = ++minimum) < end) {
      while (cmp(*--ptr, *minimum) > 0);
      if (++ptr != minimum) {
	T tmp = ZuMv(*minimum);
	Fn::moveItems(ptr + 1, ptr, minimum - ptr);
	*ptr = ZuMv(tmp);
      }
    }
  }

  static void qsort_(T *base, unsigned n, Cmp &cmp) {
    using std::swap;
loop:
    T *middle = base + (n >> 1);
    {
      T *end = base + (n - 1);

      T *ptr;
      if (cmp(*base, *middle) >= 0)
	ptr = base;
      else
	ptr = middle, middle = base;
      if (cmp(*ptr, *end) > 0) ptr = cmp(*middle, *end) >= 0 ? middle : end;

      if (ptr != base) {
	swap(*ptr, *base);
	ptr = base;
      }

      middle = base;
      unsigned j = 1;
      int k;
      while (++ptr <= end) {
	if (!(k = cmp(*ptr, *base))) j++;
	if (k < 0) {
	  if (++middle != ptr) { swap(*middle, *ptr); }
	}
      }
      if (j == n) return;
    }
    if (base != middle) swap(*base, *middle);
    unsigned i = middle - base;
    if (i < (n >> 1)) {
      if (i > N)
	qsort_(base, i, cmp);
      else if (i > 1)
	isort_(base, i, cmp);
      ++middle;
      i = n - i - 1;

      if (i > N) {
	base = middle;
	n = i;
	goto loop;
      }
    } else {
      ++middle;
      i = n - i - 1;
      if (i > N)
	qsort_(middle, i, cmp);
      else if (i > 1)
	isort_(middle, i, cmp);
      middle = base;
      i = n - i - 1;

      if (i > N) {
	n = i;
	goto loop;
      }
    }
    if (i > 1) isort_(middle, i, cmp);
  }
};

template <unsigned N = 8, typename T> inline void ZuSort(T *data, unsigned n) {
  auto cmp = [](const T &v1, const T &v2) { return ZuCmp<T>::cmp(v1, v2); };
  using Cmp = decltype(cmp);
  using Fn = ZuSort_Fn<T, Cmp, N>;
  if (n > N)
    Fn::qsort_(data, n, cmp);
  else if (n > 1)
    Fn::isort_(data, n, cmp);
}

template <unsigned N = 8, typename T, typename Cmp>
inline void ZuSort(T *data, unsigned n, Cmp cmp) {
  using Fn = ZuSort_Fn<T, Cmp, N>;
  if (n > N)
    Fn::qsort_(data, n, cmp);
  else if (n > 1)
    Fn::isort_(data, n, cmp);
}

inline bool ZuSearchFound(uint64_t i) { return i & 1; }
inline uint64_t ZuSearchPos(uint64_t i) { return i >> 1; }

template <bool Match = true, typename Cmp>
inline uint64_t ZuSearch(uint64_t n, Cmp cmp) {
  if (!n) return 0;
  uint64_t o = 0;
  uint64_t p = n >> 1;
  int l = cmp(p);
  while (n > 2) {
    n -= p;
    if (l > 0) o += p;
    l = cmp(o + (p = n >> 1));
  }
  int r;
  if (n == 2) {
    if (l > 0) return (o + 2) << 1;
    r = l;
    l = cmp(o);
  }
  if constexpr (Match)
    if (!l) return (o << 1) | 1;
  if (l <= 0) return o << 1;
  if (n == 1) return (o + 1) << 1;
  if constexpr (Match)
    if (!r) return ((o + 1) << 1) | 1;
  return (o + 1) << 1;
}
template <bool Match = true, typename Array, typename T>
inline auto ZuSearch(const Array &data, uint64_t n, const T &v)
  -> ZuExact<
    ZuDecay<T>, ZuDecay<decltype(ZuDeclVal<const Array &>()[0])>, uint64_t> {
  return ZuSearch<Match>(n, [&data, &v](uint64_t i) {
    return ZuCmp<T>::cmp(v, data[i]);
  });
}

template <bool Match = true, typename Cmp>
inline uint64_t ZuInterSearch(uint64_t n, Cmp cmp) {
  if (!n) return 0;
  if (n <= 2) {
    double l = cmp(0);
    if constexpr (Match)
      if (l == 0) return 1;
    if (l <= 0) return 0;
    if (n == 1) return 2;

    double r = cmp(1);
    if constexpr (Match)
      if (r == 0) return 3;
    if (r <= 0) return 2;
    return 4;
  }

  double l = cmp(0);

  double r = cmp(n - 1);
  if constexpr (Match)
    if (l == 0) return 1;
  if (l <= 0) return 0;
  if (r > 0) return n << 1;
  uint64_t o = 0;
  do {
    uint64_t p;
    if (n <= 8)
      p = n >> 1;
    else {
      double d = l - r;
      p = (l * (n - 3) + (d / 2)) / d;
    }
    double m = cmp(o + p);

    if (m <= 0) {
      n = p + 1;
      r = m;
    } else {
      o += p;
      n -= p;
      l = m;
    }
  } while (n > 2);
  if constexpr (Match) {
    if (l == 0) return (o << 1) | 1;
    if (n > 1 && r == 0) return ((o + n - 1) << 1) | 1;
  }
  if (l <= 0) return o << 1;
  if (r > 0) return (o + n) << 1;
  return (o + 1) << 1;
}
template <bool Match = true, typename Array, typename T>
inline auto ZuInterSearch(const Array &data, uint64_t n, const T &v)
  -> ZuExact<
    ZuDecay<T>, ZuDecay<decltype(ZuDeclVal<const Array &>()[0])>, uint64_t> {
  return ZuInterSearch<Match>(n, [&data, v](uint64_t i) {
    return double(v) - double(data[i]);
  });
}

inline constexpr auto ZmPQueueDefaultKeyAxor() {
  return []<typename T>(T &&v) -> decltype(auto) { return ZuFwd<T>(v).key(); };
}
inline constexpr auto ZmPQueueDefaultLenAxor() {
  return []<typename T>(const T &v) -> unsigned { return v.length(); };
}
template <
  typename Item, auto KeyAxor_ = ZmPQueueDefaultKeyAxor(),
  auto LenAxor_ = ZmPQueueDefaultLenAxor()>
class ZmPQueueDefaultFn {
public:
  static constexpr auto KeyAxor = KeyAxor_;

  static constexpr auto LenAxor = LenAxor_;

  using Key = ZuRDecay<decltype(KeyAxor(ZuDeclVal<const Item &>()))>;

  ZmPQueueDefaultFn(Item &item) : m_item(item) { }

  inline Key key() const { return KeyAxor(m_item); }
  inline unsigned length() const { return LenAxor(m_item); }

  unsigned clipHead(unsigned n) { return m_item.clipHead(n); }
  unsigned clipTail(unsigned n) { return m_item.clipTail(n); }

  void write(const ZmPQueueDefaultFn &item) { m_item.write(item.m_item); }

private:
  Item &m_item;
};

struct ZmPQueue_Defaults {
  enum { Bits = 3, Levels = 3 };
  template <typename Item> using ZmPQueueFnT = ZmPQueueDefaultFn<Item>;
  enum { Stats = 1 };
  enum { Overlap = 1 };
  using Lock = ZmNoLock;
  using Node = ZuEmpty;
  enum { Shadow = 0 };
  static const char *HeapID() { return "ZmPQueue"; }
  enum { Sharded = 0 };
};

template <unsigned Bits_, class NTP = ZmPQueue_Defaults>
struct ZmPQueueBits : public NTP {
  enum { Bits = Bits_ };
};

template <unsigned Levels_, class NTP = ZmPQueue_Defaults>
struct ZmPQueueLevels : public NTP {
  enum { Levels = Levels_ };
};

template <typename Fn_, class NTP = ZmPQueue_Defaults>
struct ZmPQueueFn : public NTP {
  template <typename> using ZmPQueueFnT = Fn_;
};

template <bool Stats_, class NTP = ZmPQueue_Defaults>
struct ZmPQueueStats : public NTP {
  enum { Stats = Stats_ };
};

template <bool Overlap_, class NTP = ZmPQueue_Defaults>
struct ZmPQueueOverlap : public NTP {
  enum { Overlap = Overlap_ };
};

template <class Lock_, class NTP = ZmPQueue_Defaults>
struct ZmPQueueLock : public NTP {
  using Lock = Lock_;
};

template <typename Node_, typename NTP = ZmPQueue_Defaults>
struct ZmPQueueNode : public NTP {
  using Node = Node_;
};

template <bool Shadow_, typename NTP = ZmPQueue_Defaults> struct ZmPQueueShadow;
template <typename NTP> struct ZmPQueueShadow<true, NTP> : public NTP {
  enum { Shadow = true };
  static constexpr auto HeapID = ZmHeapDisable();
};
template <typename NTP> struct ZmPQueueShadow<false, NTP> : public NTP {
  enum { Shadow = false };
};

template <auto HeapID_, class NTP = ZmPQueue_Defaults>
struct ZmPQueueHeapID : public NTP {
  static constexpr auto HeapID = HeapID_;
};

template <bool Sharded_, typename NTP = ZmPQueue_Defaults>
struct ZmPQueueSharded : public NTP {
  enum { Sharded = Sharded_ };
};

template <typename Node, unsigned Levels> struct ZmPQueue_NodeExt {
  ZmPQueue_NodeExt() {
    memset(m_next, 0, sizeof(Node *) * Levels);
    memset(m_prev, 0, sizeof(Node *) * Levels);
  }

  Node *next(unsigned i) { return m_next[i]; }
  Node *prev(unsigned i) { return m_prev[i]; }

  void next(unsigned i, Node *n) { m_next[i] = n; }
  void prev(unsigned i, Node *n) { m_prev[i] = n; }

  Node *m_next[Levels];
  Node *m_prev[Levels];
};

namespace ZmPQueue_ {
template <int, int, typename = void> struct First;
template <int Levels, typename T_> struct First<0, Levels, T_> {
  using T = T_;
};
template <int, int, typename T_ = void> struct Next {
  using T = T_;
};
template <int Levels, typename T_> struct Next<0, Levels, T_> { };
template <int Levels, typename T_> struct Next<Levels, Levels, T_> { };
template <int, int, typename T_ = void> struct NotLast {
  using T = T_;
};
template <int Levels, typename T_> struct NotLast<Levels, Levels, T_> { };
template <int, int, typename = void> struct Last;
template <int Levels, typename T_> struct Last<Levels, Levels, T_> {
  using T = void;
};
}; // namespace ZmPQueue_

template <bool Stats> class ZmPQueue_Stats {
public:
  void stats(
    uint64_t &inCount, uint64_t &inElems, uint64_t &outCount, uint64_t &outElems
  ) const {
    inCount = m_inCount;
    inElems = m_inElems;
    outCount = m_outCount;
    outElems = m_outElems;
  }

protected:
  void inCount(unsigned length) {
    ++m_inCount;
    m_inElems += length;
  }
  void outCount(unsigned length) {
    ++m_outCount;
    m_outElems += length;
  }

private:
  uint64_t m_inCount = 0;
  uint64_t m_inElems = 0;
  uint64_t m_outCount = 0;
  uint64_t m_outElems = 0;
};
template <> class ZmPQueue_Stats<false> {
protected:
  inline void inCount(unsigned) { }
  inline void outCount(unsigned) { }
};

template <typename Item_, class NTP = ZmPQueue_Defaults>
class ZmPQueue :
  public ZmNodeFn<NTP::Shadow, typename NTP::Node>,
  public ZmPQueue_Stats<NTP::Stats> {
public:
  using Item = Item_;
  enum { Bits = NTP::Bits };
  enum { Levels = NTP::Levels };
  using Fn = typename NTP::template ZmPQueueFnT<Item>;
  static constexpr auto KeyAxor = Fn::KeyAxor;
  using Key = typename Fn::Key;
  enum { Stats = NTP::Stats };
  enum { Overlap = NTP::Overlap };
  using Lock = typename NTP::Lock;
  using NodeBase = typename NTP::Node;
  enum { Shadow = NTP::Shadow };
  static constexpr auto HeapID = NTP::HeapID;
  enum { Sharded = NTP::Sharded };

  using Gap_ =
    ZuTuple<ZuBox<Key, ZuBoxCmp<ZuCmp0>>, ZuBox<unsigned, ZuBoxCmp<ZuCmp0>>>;
  class Gap : public Gap_ {
    using Tuple = Gap_;

  public:
    Gap() = default;
    Gap(const Gap &) = default;
    Gap &operator=(const Gap &) = default;
    Gap(Gap &&) = default;
    Gap &operator=(Gap &&) = default;
    ~Gap() = default;
    template <typename... Ts> Gap(Ts &&...args) : Tuple{ZuFwd<Ts>(args)...} { }
    template <typename T> Gap &operator=(T &&v) {
      Tuple::operator=(ZuFwd<T>(v));
      return *this;
    }
    decltype(ZuDeclVal<const Tuple &>().Tuple::template p<0>()) key() const & {
      return this->Tuple::template p<0>();
    }
    decltype(ZuDeclVal<Tuple &>().Tuple::template p<0>()) key() & {
      return this->Tuple::template p<0>();
    }
    decltype(ZuDeclVal<Tuple &&>().Tuple::template p<0>()) key() && {
      return ZuMv(ZuMv(*this).Tuple::template p<0>());
    }
    template <typename P> auto &key(P &&v) {
      this->template p<0>(ZuFwd<P>(v));
      return *this;
    }
    decltype(ZuDeclVal<const Tuple &>().Tuple::template p<(0 + 1)>())
    length() const & {
      return this->Tuple::template p<(0 + 1)>();
    }
    decltype(ZuDeclVal<Tuple &>().Tuple::template p<(0 + 1)>()) length() & {
      return this->Tuple::template p<(0 + 1)>();
    }
    decltype(ZuDeclVal<Tuple &&>().Tuple::template p<(0 + 1)>()) length() && {
      return ZuMv(ZuMv(*this).Tuple::template p<(0 + 1)>());
    }
    template <typename P> auto &length(P &&v) {
      this->template p<(0 + 1)>(ZuFwd<P>(v));
      return *this;
    }
  };

private:
  using NodeFn = ZmNodeFn<Shadow, NodeBase>;

  using Guard = ZmGuard<Lock>;
  using ReadGuard = ZmReadGuard<Lock>;

public:
  struct Node;
  using Node_ = ZmNode<
    Item, KeyAxor, ZuDefaultAxor(), NodeBase, ZmPQueue_NodeExt<Node, Levels>,
    HeapID, Sharded>;
  struct Node : public Node_ {
    using Node_::Node_;
    using Node_::operator=;
  };
  using NodeExt = ZmPQueue_NodeExt<Node, Levels>;
  using NodeRef = typename NodeFn::template Ref<Node>;
  using NodePtr = Node *;

private:
  using NodeFn::nodeRef;
  using NodeFn::nodeDeref;
  using NodeFn::nodeDelete;
  using NodeFn::nodeRelease;

public:
  ZmPQueue() : m_headKey(Key{}), m_tailKey(Key{}) {
    memset(m_head, 0, sizeof(Node *) * Levels);
    memset(m_tail, 0, sizeof(Node *) * Levels);
  }
  ZmPQueue(Key head) : m_headKey(head), m_tailKey(head) {
    memset(m_head, 0, sizeof(Node *) * Levels);
    memset(m_tail, 0, sizeof(Node *) * Levels);
  }
  ZmPQueue(const ZmPQueue &) = delete;
  ZmPQueue &operator=(const ZmPQueue &) = delete;
  ZmPQueue(ZmPQueue &&) = delete;
  ZmPQueue &operator=(ZmPQueue &&) = delete;

  ~ZmPQueue() { clean_(); }

private:
  template <int Level>
  typename ZmPQueue_::First<Level, Levels>::T
  addTail__(Node *node, unsigned addSeqNo) {
    Node *prev;
    node->NodeExt::next(0, nullptr);
    node->NodeExt::prev(0, prev = m_tail[0]);
    m_tail[0] = node;
    if (!prev)
      m_head[0] = node;
    else
      prev->next(0, node);
    addTail__<1>(node, addSeqNo);
  }
  template <int Level>
  typename ZmPQueue_::Next<Level, Levels>::T
  addTail__(Node *node, unsigned addSeqNo) {
    node->NodeExt::next(Level, nullptr);
    if (__builtin_expect(!!(!(addSeqNo & ((1U << (Bits * Level)) - 1))), 0)) {
      Node *prev;
      node->NodeExt::prev(Level, prev = m_tail[Level]);
      m_tail[Level] = node;
      if (!prev)
	m_head[Level] = node;
      else
	prev->next(Level, node);
      addTail__<Level + 1>(node, addSeqNo);
      return;
    }
    node->NodeExt::prev(Level, nullptr);
    addTailEnd_<Level + 1>(node, addSeqNo);
  }
  template <int Level>
  typename ZmPQueue_::Next<Level, Levels>::T
  addTailEnd_(Node *node, unsigned addSeqNo) {
    node->NodeExt::next(Level, nullptr);
    node->NodeExt::prev(Level, nullptr);
    addTailEnd_<Level + 1>(node, addSeqNo);
  }
  template <int Level>
  typename ZmPQueue_::Last<Level, Levels>::T addTail__(Node *, unsigned) { }
  template <int Level>
  typename ZmPQueue_::Last<Level, Levels>::T addTailEnd_(Node *, unsigned) { }

  template <int Level>
  typename ZmPQueue_::First<Level, Levels>::T
  addHead__(Node *node, unsigned addSeqNo) {
    Node *next;
    node->NodeExt::prev(0, nullptr);
    node->NodeExt::next(0, next = m_head[0]);
    m_head[0] = node;
    if (!next)
      m_tail[0] = node;
    else
      next->prev(0, node);
    addHead__<1>(node, addSeqNo);
  }
  template <int Level>
  typename ZmPQueue_::Next<Level, Levels>::T
  addHead__(Node *node, unsigned addSeqNo) {
    node->NodeExt::prev(Level, nullptr);
    if (__builtin_expect(!!(!(addSeqNo & ((1U << (Bits * Level)) - 1))), 0)) {
      Node *next;
      node->NodeExt::next(Level, next = m_head[Level]);
      m_head[Level] = node;
      if (!next)
	m_tail[Level] = node;
      else
	next->prev(Level, node);
      addHead__<Level + 1>(node, addSeqNo);
      return;
    }
    node->NodeExt::next(Level, nullptr);
    addHeadEnd_<Level + 1>(node, addSeqNo);
  }
  template <int Level>
  typename ZmPQueue_::Next<Level, Levels>::T
  addHeadEnd_(Node *node, unsigned addSeqNo) {
    node->NodeExt::prev(Level, nullptr);
    node->NodeExt::next(Level, nullptr);
    addHeadEnd_<Level + 1>(node, addSeqNo);
  }
  template <int Level>
  typename ZmPQueue_::Last<Level, Levels>::T addHead__(Node *, unsigned) { }
  template <int Level>
  typename ZmPQueue_::Last<Level, Levels>::T addHeadEnd_(Node *, unsigned) { }

  template <int Level>
  typename ZmPQueue_::First<Level, Levels>::T
  addAt_(Node *node, Node **next_, unsigned addSeqNo) {
    Node *next = next_[0];
    Node *prev = next ? next->prev(0) : m_tail[0];
    node->NodeExt::next(0, next);
    if (__builtin_expect(!!(!next), 0))
      m_tail[0] = node;
    else
      next->prev(0, node);
    node->NodeExt::prev(0, prev);
    if (__builtin_expect(!!(!prev), 0))
      m_head[0] = node;
    else
      prev->next(0, node);
    addAt_<1>(node, next_, addSeqNo);
  }
  template <int Level>
  typename ZmPQueue_::Next<Level, Levels>::T
  addAt_(Node *node, Node **next_, unsigned addSeqNo) {
    if (__builtin_expect(!!(!(addSeqNo & ((1U << (Bits * Level)) - 1))), 0)) {
      Node *next = next_[Level];
      Node *prev = next ? next->prev(Level) : m_tail[Level];
      node->NodeExt::next(Level, next);
      if (__builtin_expect(!!(!next), 0))
	m_tail[Level] = node;
      else
	next->prev(Level, node);
      node->NodeExt::prev(Level, prev);
      if (__builtin_expect(!!(!prev), 0))
	m_head[Level] = node;
      else
	prev->next(Level, node);
      addAt_<Level + 1>(node, next_, addSeqNo);
    } else {
      node->NodeExt::prev(Level, nullptr);
      node->NodeExt::next(Level, nullptr);
      addAtEnd_<Level + 1>(node, next_, addSeqNo);
    }
  }
  template <int Level>
  typename ZmPQueue_::Next<Level, Levels>::T
  addAtEnd_(Node *node, Node **next_, unsigned addSeqNo) {
    node->NodeExt::prev(Level, nullptr);
    node->NodeExt::next(Level, nullptr);
    addAtEnd_<Level + 1>(node, next_, addSeqNo);
  }
  template <int Level>
  typename ZmPQueue_::Last<Level, Levels>::T addAt_(Node *, Node **, unsigned) {
  }
  template <int Level>
  typename ZmPQueue_::Last<Level, Levels>::T
  addAtEnd_(Node *, Node **, unsigned) { }

  template <int Level> void delHead__() {
    Node *next(m_head[Level]->next(Level));
    if (!(m_head[Level] = next))
      m_tail[Level] = 0;
    else
      next->prev(Level, nullptr);
  }
  template <int Level> typename ZmPQueue_::First<Level, Levels>::T delHead_() {
    delHead_<1>();
    delHead__<0>();
  }
  template <int Level> typename ZmPQueue_::Next<Level, Levels>::T delHead_() {
    if (m_head[Level] != m_head[0]) return;
    delHead_<Level + 1>();
    delHead__<Level>();
  }
  template <int Level> typename ZmPQueue_::Last<Level, Levels>::T delHead_() { }

  template <int Level> Node *del__(Node *node) {
    Node *next(node->NodeExt::next(Level));
    Node *prev(node->NodeExt::prev(Level));
    if (__builtin_expect(!!(!prev), 0))
      m_head[Level] = next;
    else
      prev->next(Level, next);
    if (__builtin_expect(!!(!next), 0))
      m_tail[Level] = prev;
    else
      next->prev(Level, prev);
    return next;
  }
  template <int Level>
  typename ZmPQueue_::First<Level, Levels>::T del_(Node **next) {
    del_<1>(next);
    next[0] = del__<Level>(next[0]);
  }
  template <int Level>
  typename ZmPQueue_::Next<Level, Levels>::T del_(Node **next) {
    if (next[Level] != next[0]) return;
    del_<Level + 1>(next);
    next[Level] = del__<Level>(next[Level]);
  }
  template <int Level>
  typename ZmPQueue_::Last<Level, Levels>::T del_(Node **) { }

  bool findDir_(Key key) const {
    if (key < m_headKey) return true;
    if (key >= m_tailKey) return false;
    return key - m_headKey <= m_tailKey - key;
  }
  bool findDir_(Key key, Node *prev, Node *next) const {
    if (!prev) return true;
    if (!next) return false;
    return key - Fn{prev->Node::data()}.key() <=
      Fn{next->Node::data()}.key() - key;
  }
  template <int Level>
  typename ZmPQueue_::First<Level, Levels>::T
  findFwd_(Key key, Node **next) const {
    next[Levels - 1] = m_head[Levels - 1];
    findFwd__<Level>(key, next);
  }
  template <int Level>
  typename ZmPQueue_::Next<Level, Levels>::T
  findFwd_(Key key, Node **next) const {
    Node *node;
    if (!(node = next[Levels - Level]) ||
	!(node = node->NodeExt::prev(Levels - Level)))
      next[Levels - Level - 1] = m_head[Levels - Level - 1];
    else
      next[Levels - Level - 1] = node;
    findFwd__<Level>(key, next);
  }
  template <int Level>
  typename ZmPQueue_::Last<Level, Levels>::T findFwd_(Key, Node **) const { }

  template <int Level>
  typename ZmPQueue_::First<Level, Levels>::T
  findRev_(Key key, Node **next) const {
    next[Levels - 1] = m_tail[Levels - 1];
    findRev__<Level>(key, next);
  }
  template <int Level>
  typename ZmPQueue_::Next<Level, Levels>::T
  findRev_(Key key, Node **next) const {
    Node *node;
    if (!(node = next[Levels - Level]))
      next[Levels - Level - 1] = m_tail[Levels - Level - 1];
    else
      next[Levels - Level - 1] = node;
    findRev__<Level>(key, next);
  }
  template <int Level>
  typename ZmPQueue_::Last<Level, Levels>::T findRev_(Key, Node **) const { }

  template <int Level>
  typename ZmPQueue_::NotLast<Level, Levels>::T
  findFwd__(Key key, Node **next) const {
    Node *node = next[Levels - Level - 1];
    if (node) {
      do {
	Fn item{node->Node::data()};
	if (item.key() == key) goto found;
	if (item.key() > key) goto passed;
      } while (node = node->NodeExt::next(Levels - Level - 1));
      next[Levels - Level - 1] = node;
    }
    findRev_<Level + 1>(key, next);
    return;
found:
    found_<Level>(node, next);
    return;
passed:
    Node *prev = node->NodeExt::prev(Levels - Level - 1);
    next[Levels - Level - 1] = node;
    if (findDir_(key, prev, node))
      findFwd_<Level + 1>(key, next);
    else
      findRev_<Level + 1>(key, next);
  }
  template <int Level>
  typename ZmPQueue_::Last<Level, Levels>::T
  findFwd__(Key key, Node **next) const {
    Node *node = next[0];
    if (node) {
      do {
	Fn item{node->Node::data()};
	if (item.key() >= key) break;
      } while (node = node->NodeExt::next(0));
      next[0] = node;
    }
  }
  template <int Level>
  typename ZmPQueue_::NotLast<Level, Levels>::T
  findRev__(Key key, Node **next) const {
    Node *node = next[Levels - Level - 1];
    if (node) {
      do {
	Fn item{node->Node::data()};
	if (item.key() == key) goto found;
	if (item.key() < key) goto passed;
      } while (node = node->NodeExt::prev(Levels - Level - 1));
    }
    next[Levels - Level - 1] = m_head[Levels - Level - 1];
    findFwd_<Level + 1>(key, next);
    return;
found:
    found_<Level>(node, next);
    return;
passed:
    Node *prev = node;
    next[Levels - Level - 1] = node = node->NodeExt::next(Levels - Level - 1);
    if (findDir_(key, prev, node))
      findFwd_<Level + 1>(key, next);
    else
      findRev_<Level + 1>(key, next);
  }
  template <int Level>
  typename ZmPQueue_::Last<Level, Levels>::T
  findRev__(Key key, Node **next) const {
    Node *node = next[0];
    if (node) {
      do {
	Fn item{node->Node::data()};
	if (item.key() == key) {
	  next[0] = node;
	  return;
	}
	if (item.key() < key) {
	  next[0] = node->NodeExt::next(0);
	  return;
	}
      } while (node = node->NodeExt::prev(0));
    }
    next[0] = m_head[0];
  }

  template <int Level>
  typename ZmPQueue_::NotLast<Level, Levels>::T
  found_(Node *node, Node **next) const {
    next[Levels - Level - 1] = node;
    found_<Level + 1>(node, next);
  }
  template <int Level>
  typename ZmPQueue_::Last<Level, Levels>::T found_(Node *, Node **) const { }

  void find_(Key key, Node **next) const {
    if (findDir_(key))
      findFwd_<0>(key, next);
    else
      findRev_<0>(key, next);
  }

public:
  unsigned count_() const { return m_count; }
  unsigned length_() const { return m_length; }

  bool empty_() const { return (!m_count); }

  void reset(Key head) {
    Guard guard(m_lock);
    m_headKey = m_tailKey = head;
    clean_();
  }

  void skip() {
    Guard guard(m_lock);
    m_headKey = m_tailKey;
    clean_();
  }

  Key head() const {
    ReadGuard guard(m_lock);
    return m_headKey;
  }

  Key tail() const {
    ReadGuard guard(m_lock);
    return m_tailKey;
  }

  Gap gap() const {
    ReadGuard guard(m_lock);
    Node *node = m_head[0];
    Key tail = m_headKey;
    while (node) {
      Fn item{node->Node::data()};
      Key key = item.key();
      if (key > tail) return Gap(tail, key - tail);
      Key end = key + item.length();
      if (end > tail) tail = end;
      node = node->NodeExt::next(0);
    }
    if (m_tailKey > tail) return Gap(tail, m_tailKey - tail);
    return Gap();
  };

private:
  void purge(Key key) {
    while (Node *node = m_head[0]) {
      Fn item{node->Node::data()};
      Key key_ = item.key();
      if (key_ >= key) return;
      Key end_ = key_ + item.length();
      if (end_ > key) {
	if constexpr (Overlap)
	  if (unsigned length = item.clipHead(key - key_))
	    m_length -= (end_ - key_) - length;
	return;
      }
      delHead_<0>();
      nodeDeref(node);
      nodeDelete(node);
      m_length -= end_ - key_;
      --m_count;
    }
  }

public:
  void head(Key key) {
    Guard guard(m_lock);
    if (key == m_headKey) return;
    if (key < m_headKey) {
      clean_();
      m_headKey = m_tailKey = key;
    } else {
      purge(key);

      if (m_head[0]) key = Fn{m_head[0]->Node::data()}.key();
      m_headKey = key;
      if (key > m_tailKey) m_tailKey = key;
    }
  }

  template <typename _ = ZuBool<Stats>> ZuIfT<_{}> bypass(unsigned length) {
    Guard guard(m_lock);
    this->inCount(length);
    this->outCount(length);
  }

  void add(NodeRef node) { add_<false>(ZuMv(node)); }

  NodeRef rotate(NodeRef node) { return add_<true>(ZuMv(node)); }

  void unshift(NodeRef node) {
    Guard guard(m_lock);

    Fn item{node->Node::data()};
    Key key = item.key();
    unsigned length = item.length();
    Key end = key + length;

    if (__builtin_expect(!!(key >= m_headKey), 0)) return;

    if constexpr (Overlap)
      if (__builtin_expect(!!(end > m_headKey), 0)) {
	length = item.clipTail(end - m_headKey);
	end = key + length;
      }

    if (__builtin_expect(!!(!length), 0)) return;

    unsigned addSeqNo = m_addSeqNo++;

    Node *next[Levels];

    findFwd_<0>(key, next);

    addAt_<0>(nodeRelease(ZuMv(node)), next, addSeqNo);
    m_headKey = key;
    m_length += end - key;
    ++m_count;
  }

private:
  template <bool Dequeue> NodeRef add_(NodeRef node) {
    Guard guard(m_lock);

    Fn item{node->Node::data()};
    Key key = item.key();
    unsigned length = item.length();
    Key end = key + length;

    if (__builtin_expect(!!(end <= m_headKey), 0)) return nullptr;

    if constexpr (Overlap)
      if (__builtin_expect(!!(key < m_headKey), 0)) {
	length = item.clipHead(m_headKey - key);
	key = end - length;
      }

    if (__builtin_expect(!!(!length), 0)) {
      if (end > m_tailKey) m_tailKey = end;
      return nullptr;
    }

    unsigned addSeqNo = m_addSeqNo++;

    if (__builtin_expect(!!(key == m_tailKey), 1))
      return addTail_<Dequeue>(ZuMv(node), end, length, addSeqNo);

    if (__builtin_expect(!!(key == m_headKey), 1)) {
      purge(end);
      return addHead_<Dequeue>(ZuMv(node), end, length, addSeqNo);
    }

    if constexpr (Stats) this->inCount(length);

    Node *next[Levels];

    find_(key, next);

    if constexpr (Overlap) {
      Node *node_ = next[0];

      if (node_) {
	Fn item_(node_->Node::data());
	Key key_ = item_.key();
	Key end_ = key_ + item_.length();

	((key_ >= key) ? void() :
			 ZmAssert_fail(
			   "key_ >= key", "../../zm/src/zlib/ZmPQueue.hh", 855,
			   __PRETTY_FUNCTION__
			 ));

	if (key_ == key && end_ >= end) {
	  item_.write(item);
	  return nullptr;
	}

	if (key_ == key)
	  node_ = nullptr;
	else
	  node_ = node_->NodeExt::prev(0);
      } else
	node_ = m_tail[0];

      if (node_) {
	Fn item_(node_->Node::data());
	Key key_ = item_.key();
	Key end_ = key_ + item_.length();

	((key_ < key) ? void() :
			ZmAssert_fail(
			  "key_ < key", "../../zm/src/zlib/ZmPQueue.hh", 877,
			  __PRETTY_FUNCTION__
			));

	if (end_ >= end) {
	  item_.write(item);
	  return nullptr;
	}

	if (end_ > key) m_length -= (end_ - key_) - item_.clipTail(end_ - key);
      }

      while (Node *node_ = next[0]) {
	Fn item_(node_->Node::data());
	Key key_ = item_.key();
	Key end_ = key_ + item_.length();

	((key_ >= key) ? void() :
			 ZmAssert_fail(
			   "key_ >= key", "../../zm/src/zlib/ZmPQueue.hh", 897,
			   __PRETTY_FUNCTION__
			 ));

	if (key_ >= end) break;

	if (end_ > end) {
	  if (unsigned length = item_.clipHead(end - key_)) {
	    m_length -= (end_ - key_) - length;
	    break;
	  }
	}

	del_<0>(next);
	nodeDeref(node_);
	nodeDelete(node_);
	m_length -= end_ - key_;
	--m_count;
      }
    }

    addAt_<0>(nodeRelease(ZuMv(node)), next, addSeqNo);
    if (end > m_tailKey) m_tailKey = end;
    m_length += end - key;
    ++m_count;

    return nullptr;
  }
  template <bool Dequeue>
  ZuIfT<Dequeue, NodeRef>
  addTail_(NodeRef node, Key end, unsigned length, unsigned addSeqNo) {
    m_tailKey = end;
    if constexpr (Stats) this->inCount(length);
    if (end == m_headKey + length) {
      m_headKey = end;
      if constexpr (Stats) this->outCount(length);
      return node;
    } else {
      addTail__<0>(nodeRelease(ZuMv(node)), addSeqNo);
      m_length += length;
      ++m_count;
      return nullptr;
    }
  }
  template <bool Dequeue>
  ZuIfT<!Dequeue, NodeRef>
  addTail_(NodeRef node, Key end, unsigned length, unsigned addSeqNo) {
    addTail__<0>(nodeRelease(ZuMv(node)), addSeqNo);
    m_tailKey = end;
    m_length += length;
    ++m_count;
    if constexpr (Stats) this->inCount(length);
    return nullptr;
  }
  template <bool Dequeue>
  ZuIfT<Dequeue, NodeRef>
  addHead_(NodeRef node, Key end, unsigned length, unsigned) {
    m_headKey = end;
    if (end > m_tailKey) m_tailKey = end;
    if constexpr (Stats) this->inCount(length);
    if constexpr (Stats) this->outCount(length);
    return node;
  }
  template <bool Dequeue>
  ZuIfT<!Dequeue, NodeRef>
  addHead_(NodeRef node, Key end, unsigned length, unsigned addSeqNo) {
    addHead__<0>(nodeRelease(ZuMv(node)), addSeqNo);
    if (end > m_tailKey) m_tailKey = end;
    m_length += length;
    ++m_count;
    if constexpr (Stats) this->inCount(length);
    return nullptr;
  }

  NodeRef dequeue_() {
loop:
    NodeRef node = m_head[0];
    if (!node) return nullptr;
    Fn item{node->Node::data()};
    Key key = item.key();
    ((key >= m_headKey) ? void() :
			  ZmAssert_fail(
			    "key >= m_headKey", "../../zm/src/zlib/ZmPQueue.hh",
			    980, __PRETTY_FUNCTION__
			  ));
    if (key != m_headKey) return nullptr;
    unsigned length = item.length();
    delHead_<0>();
    nodeDeref(node);
    m_length -= length;
    --m_count;
    if (!length) goto loop;
    Key end = key + length;
    m_headKey = end;
    if constexpr (Stats) this->outCount(length);
    return node;
  }

public:
  NodeRef dequeue() {
    Guard guard(m_lock);
    return dequeue_();
  }

  NodeRef dequeue(Key key) {
    Guard guard(m_lock);
    if (m_headKey >= key) return nullptr;
    return dequeue_();
  }

private:
  NodeRef shift_() {
loop:
    NodeRef node = m_head[0];
    if (!node) return nullptr;
    Fn item{node->Node::data()};
    unsigned length = item.length();
    delHead_<0>();
    nodeDeref(node);
    m_length -= length;
    --m_count;
    if (!length) goto loop;
    Key end = item.key() + length;
    m_headKey = end;
    if constexpr (Stats) this->outCount(length);
    return node;
  }

public:
  NodeRef shift() {
    Guard guard(m_lock);
    return shift_();
  }

  NodeRef shift(Key key) {
    Guard guard(m_lock);
    if (m_headKey >= key) return nullptr;
    if (NodeRef node = shift_()) return node;
    return nullptr;
  }

  NodeRef abort(Key key) {
    Guard guard(m_lock);

    Node *next[Levels];

    find_(key, next);

    NodeRef node = next[0];

    if (!node) return nullptr;

    Fn item{node->Node::data()};

    if (item.key() != key) return nullptr;

    del_<0>(next);
    nodeDeref(node);
    m_length -= item.length();
    --m_count;

    return node;
  }

  NodeRef find(Key key) const {
    ReadGuard guard(m_lock);

    Node *next[Levels];

    find_(key, next);

    NodeRef node;

    {
      Node *node_ = next[0];

      if (node_) {
	Fn item_(node_->Node::data());
	Key key_ = item_.key();

	((key_ >= key) ? void() :
			 ZmAssert_fail(
			   "key_ >= key", "../../zm/src/zlib/ZmPQueue.hh", 1080,
			   __PRETTY_FUNCTION__
			 ));

	if (__builtin_expect(!!(key_ == key), 1)) return node = node_;

	node_ = node_->NodeExt::prev(0);
      } else
	node_ = m_tail[0];

      if (node_) {
	Fn item_(node_->Node::data());
	Key key_ = item_.key();
	Key end_ = key_ + item_.length();

	((key_ < key) ? void() :
			ZmAssert_fail(
			  "key_ < key", "../../zm/src/zlib/ZmPQueue.hh", 1095,
			  __PRETTY_FUNCTION__
			));

	if (__builtin_expect(!!(end_ > key), 1)) return node = node_;
      }
    }

    return node;
  }

  void clean_() {
    while (Node *node = m_head[0]) {
      delHead_<0>();
      nodeDeref(node);
      nodeDelete(node);
    }
    m_length = 0;
    m_count = 0;
  }

public:
  template <typename S> void print(S &s) const {
    ReadGuard guard(m_lock);
    s << "head=" << m_headKey << " tail=" << m_tailKey << " length=" << m_length
      << " count=" << m_count;
  }
  friend ZuPrintFn ZuPrintType(ZmPQueue *);

private:
  Lock m_lock;
  Key m_headKey;
  Node *m_head[Levels];
  Key m_tailKey;
  Node *m_tail[Levels];
  unsigned m_length = 0;
  unsigned m_count = 0;
  unsigned m_addSeqNo = 0;
};

template <class App, class Queue, class Lock_ = ZmNoLock>
class ZmPQRx : public ZuPrintable {
  enum { Queuing = 0x01, Dequeuing = 0x02 };

public:
  template <typename S> static void printFlags(S &s, unsigned v) {
    static const char *flagNames[] = {"Queuing", "Dequeuing"};
    bool first = true;
    for (unsigned i = 0; i < sizeof(flagNames) / sizeof(flagNames[0]); i++)
      if (v & (1U << i)) {
	if (!first) s << ',';
	first = false;
	s << flagNames[i];
      }
  }
  struct PrintFlags : public ZuPrintable {
    PrintFlags(unsigned v_) : v(v_) { }
    PrintFlags(const PrintFlags &) = default;
    PrintFlags &operator=(const PrintFlags &) = default;
    PrintFlags(PrintFlags &&) = default;
    PrintFlags &operator=(PrintFlags &&) = default;
    template <typename S> void print(S &s) const { printFlags(s, v); }
    unsigned v;
  };

  using Msg = typename Queue::Node;
  using Key = typename Queue::Key;
  using Gap = typename Queue::Gap;

  using Lock = Lock_;
  using Guard = ZmGuard<Lock>;
  using ReadGuard = ZmReadGuard<Lock>;

  void rxReset(Key key) {
    App *app = static_cast<App *>(this);
    Guard guard(m_lock);
    app->cancelReRequest();
    m_flags &= ~(Queuing | Dequeuing);
    app->rxQueue()->reset(key);
    m_gap = {};
  }

  void startQueuing() {
    Guard guard(m_lock);
    m_flags |= Queuing;
  }

  void stopQueuing(Key key) {
    App *app = static_cast<App *>(this);
    bool scheduleDequeue;
    {
      Guard guard(m_lock);
      m_flags &= ~Queuing;
      app->rxQueue()->head(key);
      scheduleDequeue = !(m_flags & Dequeuing) && app->rxQueue()->count_();
      if (scheduleDequeue) m_flags |= Dequeuing;
    }
    if (scheduleDequeue) app->scheduleDequeue();
  }

  void received(ZmRef<Msg> msg) {
    App *app = static_cast<App *>(this);
    Guard guard(m_lock);
    if (__builtin_expect(!!(m_flags & (Queuing | Dequeuing)), 0)) {
      app->rxQueue()->add(ZuMv(msg));
      return;
    }
    msg = app->rxQueue()->rotate(ZuMv(msg));
    bool scheduleDequeue = msg && app->rxQueue()->count_();
    if (scheduleDequeue) m_flags |= Dequeuing;
    guard.unlock();
    if (__builtin_expect(!!(!msg), 0)) {
      stalled();
      return;
    }
    app->process(msg);
    if (scheduleDequeue) app->scheduleDequeue();
  }

  void dequeue() {
    App *app = static_cast<App *>(this);
    Guard guard(m_lock);
    ZmRef<Msg> msg = app->rxQueue()->dequeue();
    bool scheduleDequeue = msg && app->rxQueue()->count_();
    if (!scheduleDequeue) m_flags &= ~Dequeuing;
    guard.unlock();
    if (__builtin_expect(!!(!msg), 0)) {
      stalled();
      return;
    }
    app->process(msg);
    if (scheduleDequeue)
      app->rescheduleDequeue();
    else
      app->idleDequeue();
  }

  void reRequest() {
    App *app = static_cast<App *>(this);
    Gap gap;
    {
      Guard guard(m_lock);
      gap = m_gap;
    }
    app->cancelReRequest();
    if (!gap.length()) return;
    app->reRequest(gap);
    app->rescheduleReRequest();
  }

  unsigned flags() const {
    ReadGuard guard(m_lock);
    return m_flags;
  }

  template <typename S> void print(S &s) const {
    ReadGuard guard(m_lock);
    s << "gap: (" << m_gap.key() << " +" << m_gap.length()
      << ")  flags: " << PrintFlags{m_flags};
  }

private:
  void stalled() {
    App *app = static_cast<App *>(this);
    Gap old, gap;
    {
      Guard guard(m_lock);
      if (!app->rxQueue()->count_()) return;
      gap = app->rxQueue()->gap();
      if (gap == m_gap) return;
      old = m_gap;
      m_gap = gap;
    }
    app->cancelReRequest();
    if (!gap.length()) return;
    app->request(old, gap);
    app->scheduleReRequest();
  }

  Lock m_lock;
  Gap m_gap;
  uint8_t m_flags = 0;
};

template <class App, class Queue, class Lock_ = ZmNoLock>
class ZmPQTx : public ZuPrintable {
private:
  enum {
    Running = 0x01,
    Sending = 0x02,
    SendFailed = 0x04,
    Archiving = 0x08,
    Resending = 0x10,
    ResendFailed = 0x20
  };

public:
  template <typename S> static void printFlags(S &s, unsigned v) {
    static const char *flagNames[] = {"Running",   "Sending",   "SendFailed",
				      "Archiving", "Resending", "ResendFailed"};
    bool comma = false;
    for (unsigned i = 0; i < sizeof(flagNames) / sizeof(flagNames[0]); i++)
      if (v & (1U << i)) {
	if (comma) s << ',';
	comma = true;
	s << flagNames[i];
      }
  }
  struct PrintFlags : public ZuPrintable {
    PrintFlags(unsigned v_) : v(v_) { }
    PrintFlags(const PrintFlags &) = default;
    PrintFlags &operator=(const PrintFlags &) = default;
    PrintFlags(PrintFlags &&) = default;
    PrintFlags &operator=(PrintFlags &&) = default;
    template <typename S> void print(S &s) const { printFlags(s, v); }
    unsigned v;
  };

public:
  using Msg = typename Queue::Node;
  using Fn = typename Queue::Fn;
  using Key = typename Queue::Key;
  using Gap = typename Queue::Gap;

  using Lock = Lock_;
  using Guard = ZmGuard<Lock>;
  using ReadGuard = ZmReadGuard<Lock>;

  void start() {
    App *app = static_cast<App *>(this);
    bool scheduleSend = false;
    bool scheduleArchive = false;
    bool scheduleResend = false;
    {
      Guard guard(m_lock);

      bool alreadyRunning = m_flags & Running;
      if (!alreadyRunning) m_flags |= Running;
      if (alreadyRunning && (m_flags & SendFailed))
	scheduleSend = true;
      else if (scheduleSend =
		 !(m_flags & Sending) && m_sendKey < app->txQueue()->tail())
	m_flags |= Sending;
      if (scheduleArchive = !(m_flags & Archiving) && m_ackdKey > m_archiveKey)
	m_flags |= Archiving;
      if (alreadyRunning && (m_flags & ResendFailed))
	scheduleResend = true;
      else if (scheduleResend = !(m_flags & Resending) && m_gap.length())
	m_flags |= Resending;
      m_flags &= ~(SendFailed | ResendFailed);
    }
    if (scheduleSend)
      app->scheduleSend();
    else
      app->idleSend();
    if (scheduleArchive) app->scheduleArchive();
    if (scheduleResend)
      app->scheduleResend();
    else
      app->idleResend();
  }

  void start(Key key) {
    App *app = static_cast<App *>(this);
    bool scheduleSend = false;
    bool scheduleArchive = false;
    bool scheduleResend = false;
    {
      Guard guard(m_lock);

      bool alreadyRunning = m_flags & Running;
      if (!alreadyRunning) m_flags |= Running;
      m_sendKey = m_ackdKey = key;
      if (alreadyRunning && (m_flags & SendFailed))
	scheduleSend = true;
      else if (scheduleSend =
		 !(m_flags & Sending) && key < app->txQueue()->tail())
	m_flags |= Sending;
      if (scheduleArchive = !(m_flags & Archiving) && key > m_archiveKey)
	m_flags |= Archiving;
      if (alreadyRunning && (m_flags & ResendFailed))
	scheduleResend = true;
      else if (scheduleResend = !(m_flags & Resending) && m_gap.length())
	m_flags |= Resending;
      m_flags &= ~(SendFailed | ResendFailed);
    }
    if (scheduleSend)
      app->scheduleSend();
    else
      app->idleSend();
    if (scheduleArchive) app->scheduleArchive();
    if (scheduleResend)
      app->scheduleResend();
    else
      app->idleResend();
  }

  void stop() {
    Guard guard(m_lock);
    if (!(m_flags & Running)) return;
    m_flags &= ~(Running | Sending | Resending);
  }

  void txReset(Key key) {
    App *app = static_cast<App *>(this);
    Guard guard(m_lock);
    m_sendKey = m_ackdKey = m_archiveKey = key;
    m_gap = Gap();
    app->txQueue()->reset(key);
  }

  void send(ZmRef<Msg> msg) {
    App *app = static_cast<App *>(this);
    bool scheduleSend = false;
    auto key = Fn{msg->data()}.key();
    {
      Guard guard(m_lock);
      if (__builtin_expect(!!(key < m_ackdKey), 0)) { return; }
      app->txQueue()->add(ZuMv(msg));
      if (scheduleSend =
	    (m_flags & (Running | Sending)) == Running && m_sendKey <= key)
	m_flags |= Sending;
    }
    if (scheduleSend) app->scheduleSend();
  }

  ZmRef<Msg> abort(Key key) {
    if (key < m_sendKey) return nullptr;
    App *app = static_cast<App *>(this);
    ZmRef<Msg> msg;
    {
      Guard guard(m_lock);
      msg = app->txQueue()->abort(key);
    }
    return msg;
  }

  void ackd(Key key) {
    App *app = static_cast<App *>(this);
    bool scheduleArchive = false;
    {
      Guard guard(m_lock);
      if (__builtin_expect(!!(key < m_ackdKey), 0)) { return; }
      m_ackdKey = key;
      if (key > m_sendKey) m_sendKey = key;
      if (scheduleArchive = !(m_flags & Archiving) && key > m_archiveKey)
	m_flags |= Archiving;
    }
    if (scheduleArchive) app->scheduleArchive();
  }

private:
  bool resend_(const Gap &gap) {
    bool scheduleResend = false;
    if (!m_gap.length()) {
      m_gap = gap;
      scheduleResend = !(m_flags & Resending);
    } else {
      if (gap.key() < m_gap.key()) {
	m_gap.length() += (m_gap.key() - gap.key());
	m_gap.key() = gap.key();
	scheduleResend = !(m_flags & Resending);
      }
      if ((gap.key() + gap.length()) > (m_gap.key() + m_gap.length())) {
	m_gap.length() = (gap.key() - m_gap.key()) + gap.length();
	if (!scheduleResend) scheduleResend = !(m_flags & Resending);
      }
    }
    if (scheduleResend) m_flags |= Resending;
    return scheduleResend;
  }

public:
  void resend(const Gap &gap) {
    if (!gap.length()) return;
    App *app = static_cast<App *>(this);
    bool scheduleResend = false;
    {
      Guard guard(m_lock);
      scheduleResend = resend_(gap);
    }
    if (scheduleResend) app->scheduleResend();
  }

  void send() {
    App *app = static_cast<App *>(this);
    bool scheduleSend = false;
    Gap sendGap;
    Key prevKey;
    ZmRef<Msg> msg;
    {
      Guard guard(m_lock);
      auto txQueue = app->txQueue();

      if (!(m_flags & Running)) {
	m_flags &= ~Sending;
	return;
      }
      prevKey = m_sendKey;
      scheduleSend = prevKey < txQueue->tail();
      while (scheduleSend) {
	unsigned length;
	if (msg = txQueue->find(m_sendKey))
	  length = Fn{msg->data()}.length();
	else if (msg = app->retrieve_(m_sendKey, txQueue->head()))
	  length = Fn{msg->data()}.length();
	else {
	  if (!sendGap.length()) sendGap.key() = m_sendKey;
	  sendGap.length() += (length = 1);
	}
	m_sendKey += length;
	scheduleSend = m_sendKey < txQueue->tail();
	if (msg) break;
      }
      if (!scheduleSend) m_flags &= ~Sending;
    }
    if (__builtin_expect(!!(sendGap.length()), 0)) {
      if (__builtin_expect(!!(!app->sendGap_(sendGap, scheduleSend)), 0))
	goto sendFailed;
      prevKey += sendGap.length();
    }
    if (__builtin_expect(!!(msg), 1))
      if (__builtin_expect(!!(!app->send_(msg, scheduleSend)), 0))
	goto sendFailed;
    if (scheduleSend)
      app->rescheduleSend();
    else
      app->idleSend();
    return;
sendFailed: {
  Guard guard(m_lock);
  m_flags |= Sending | SendFailed;
  m_sendKey = prevKey;
}
  }

  void archive() {
    App *app = static_cast<App *>(this);
    bool scheduleArchive;
    ZmRef<Msg> msg;
    {
      Guard guard(m_lock);
      if (!(m_flags & Running)) {
	m_flags &= ~Archiving;
	return;
      }
      scheduleArchive = m_archiveKey < m_ackdKey;
      while (scheduleArchive) {
	msg = app->txQueue()->find(m_archiveKey);
	m_archiveKey += msg ? (unsigned)Fn{msg->data()}.length() : 1U;
	scheduleArchive = m_archiveKey < m_ackdKey;
	if (msg) break;
      }
      if (!scheduleArchive) m_flags &= ~Archiving;
    }
    if (msg) app->archive_(msg);
    if (scheduleArchive)
      app->rescheduleArchive();
    else
      app->idleArchive();
  }

  void archived(Key key) {
    App *app = static_cast<App *>(this);
    ZmRef<Msg> msg;
    do {
      Guard guard(m_lock);
      msg = app->txQueue()->shift(key);
    } while (msg);
  }

  void resend() {
    App *app = static_cast<App *>(this);
    bool scheduleResend = false;
    Gap sendGap, prevGap;
    ZmRef<Msg> msg;
    {
      Guard guard(m_lock);
      if (!(m_flags & Running)) {
	m_flags &= ~Resending;
	return;
      }
      prevGap = m_gap;
      while (m_gap.length()) {
	unsigned length;
	if (msg = app->txQueue()->find(m_gap.key())) {
	  Fn item{msg->data()};
	  auto end = item.key() + item.length();
	  length = end - m_gap.key();
	  if (end <= m_archiveKey)
	    while (app->txQueue()->shift(end));
	} else if (msg = app->retrieve_(m_gap.key(), app->txQueue()->head())) {
	  Fn item{msg->data()};
	  auto end = item.key() + item.length();
	  length = end - m_gap.key();
	} else {
	  if (!sendGap.length()) sendGap.key() = m_gap.key();
	  sendGap.length() += (length = 1);
	}
	if (m_gap.length() <= length) {
	  m_gap = {};
	  scheduleResend = false;
	} else {
	  m_gap.key() += length;
	  m_gap.length() -= length;
	  scheduleResend = true;
	}
	if (msg) break;
      }
      if (!scheduleResend) m_flags &= ~Resending;
    }
    if (__builtin_expect(!!(sendGap.length()), 0)) {
      if (__builtin_expect(!!(!app->resendGap_(sendGap, scheduleResend)), 0))
	goto resendFailed;
      unsigned length = sendGap.length();
      if (__builtin_expect(!!(prevGap.length() > length), 1)) {
	prevGap.key() += length;
	prevGap.length() -= length;
      } else
	prevGap = {};
    }
    if (__builtin_expect(!!(msg), 1))
      if (__builtin_expect(!!(!app->resend_(msg, scheduleResend)), 0))
	goto resendFailed;
    if (scheduleResend)
      app->rescheduleResend();
    else
      app->idleResend();
    return;
resendFailed: {
  Guard guard(m_lock);
  m_flags |= Resending | ResendFailed;
  m_gap = prevGap;
}
  }

  unsigned flags() const {
    ReadGuard guard(m_lock);
    return m_flags;
  }

  template <typename S> void print(S &s) const {
    ReadGuard guard(m_lock);
    s << "gap={" << m_gap.key() << ", " << m_gap.length()
      << "} flags=" << PrintFlags{m_flags} << " send=" << m_sendKey
      << " ackd=" << m_ackdKey << " archive=" << m_archiveKey;
  }

private:
  Lock m_lock;
  Key m_sendKey = 0;
  Key m_ackdKey = 0;
  Key m_archiveKey = 0;
  Gap m_gap;
  uint8_t m_flags = 0;
};

namespace Zdf {

enum { BlkSize = 4096 };

using Shard = uint8_t;

using DFID = uint32_t;

using SeriesID = uint32_t;

using BlkOffset = uint64_t;
using Offset = uint64_t;
constexpr const Offset maxOffset() { return ~uint64_t(0); }

using Fixed0 = ZuBox<int64_t, ZuBoxCmp<ZuCmp0>>;
using Float0 = ZuBox<double, ZuBoxCmp<ZuCmp0>>;
using NDP = ZuFixedNDP;

using BlkCount = uint16_t;

using Event = ZeVEvent;

} // namespace Zdf

struct ZmCacheStats {
  unsigned size;
  unsigned count;
  uint64_t loads;
  uint64_t misses;
  uint64_t evictions;

  template <typename S> void print(S &s) const {
    s << "size=" << size << " count=" << count << " loads=" << loads
      << " misses=" << misses << " evictions=" << evictions;
  }
  friend ZuPrintFn ZuPrintType(ZmCacheStats *);
};

struct ZmPolyCache_Defaults : public ZmPolyHash_Defaults {
  static const char *HeapID() { return "ZmPolyCache"; }
  static constexpr auto ID = HeapID;
  enum { Evict = 1 };
};

template <typename Lock, typename NTP = ZmPolyCache_Defaults>
using ZmPolyCacheLock = ZmPolyHashLock<Lock, NTP>;
template <bool Shadow, typename NTP = ZmPolyCache_Defaults>
using ZmPolyCacheShadow = ZmPolyHashShadow<Shadow, NTP>;
template <auto HeapID, typename NTP = ZmPolyCache_Defaults>
using ZmPolyCacheHeapID = ZmPolyHashHeapID<HeapID, NTP>;
template <bool Sharded, typename NTP = ZmPolyCache_Defaults>
using ZmPolyCacheSharded = ZmPolyHashSharded<Sharded, NTP>;

template <bool Evict_, typename NTP = ZmPolyCache_Defaults>
struct ZmPolyCacheEvict : public NTP {
  enum { Evict = Evict_ };
};

template <typename T_, typename NTP = ZmPolyCache_Defaults> class ZmPolyCache {
public:
  using T = T_;
  using Lock = typename NTP::Lock;
  enum { Evict = NTP::Evict };

private:
  using Guard = ZmGuard<Lock>;
  using ReadGuard = ZmReadGuard<Lock>;
  using LRUList = ZmList<T, ZmListNode<T, ZmListShadow<true>>>;
  struct LRUDisable {
    using Node = T;
    Node *delNode(Node *node) { return node; }
    Node *shift() { return nullptr; }
    void pushNode(Node *) { }
  };
  using LRU = ZuIf<Evict, LRUList, LRUDisable>;
  using PolyHash =
    ZmPolyHash<typename LRU::Node, ZmPolyHashLock<ZmNoLock, NTP>>;

public:
  static constexpr auto HeapID = PolyHash::HeapID;

  using Node = typename PolyHash::Node;
  using NodeRef = typename PolyHash::NodeRef;
  using NodeMvRef = typename PolyHash::NodeMvRef;

private:
  using FindFn = ZmFn<void(Node *)>;
  using FindFnList = ZmList<FindFn, ZmHashHeapID<HeapID>>;

  using KeyIDs = ZuSeqTL<ZuFieldKeyIDs<T>>;

  template <int KeyID> using Key = ZuFieldKeyT<T, KeyID>;
  template <typename KeyID> using KeyT = ZuFieldKeyT<T, KeyID{}>;
  using Keys = ZuTypeMap<KeyT, KeyIDs>;

  template <typename KeyID>
  using LoadHash = ZmHashKV<KeyT<KeyID>, FindFnList, ZmHashHeapID<HeapID>>;

  template <int KeyID>
  using LoadHashNode = typename LoadHash<ZuUnsigned<KeyID>>::Node;

  using LoadHashTL = ZuTypeMap<LoadHash, KeyIDs>;

  using LoadHashes = ZuTypeApply<ZuTuple, ZuTypeMap<ZmRef, LoadHashTL>>;

private:
  ZmPolyCache() : m_size(0) { }

public:
  ZmPolyCache(ZuCSpan id) : m_hash{id} {
    if constexpr (KeyIDs::N) {
      ((id.length() + 5 +
	  ZuBoxed(unsigned(ZuType<KeyIDs::N - 1, KeyIDs>{})).length() <
	60) ?
	 void() :
	 ZmAssert_fail(
	   "id.length() + 5 + ZuBoxed(unsigned(ZuType<KeyIDs::N - 1, "
	   "KeyIDs>{})).length() < ZmIDStrSize",
	   "../../zm/src/zlib/ZmPolyCache.hh", 104, __PRETTY_FUNCTION__
	 ));
    }
    m_size = m_hash.size();
    auto params = ZmHashParams{id};
    ZuUnroll::all<KeyIDs>([this, &id, &params]<typename KeyID>() {
      ZmIDString loadHashID = id;
      loadHashID << ".ld." << unsigned(KeyID{});
      m_loadHashes.template p<KeyID{}>(
	new ZuType<KeyID{}, LoadHashTL>{loadHashID, params}
      );
    });
  }

  ZmPolyCache(ZmPolyCache &) = delete;
  ZmPolyCache &operator=(ZmPolyCache &) = delete;

  ZmPolyCache(ZmPolyCache &&c) :
    m_size{c.m_size}, m_hash{ZuMv(c.m_hash)}, m_lru{ZuMv(c.m_lru)},
    m_loadHashes{ZuMv(c.m_loadHashes)}, m_loads{c.m_loads},
    m_misses{c.m_misses}, m_evictions{c.m_evictions} {
    c.m_size = 0;
    c.m_loads = c.m_misses = c.m_evictions = 0;
  }
  ZmPolyCache &operator=(ZmPolyCache &&c) {
    this->~ZmPolyCache();
    new (this) ZmPolyCache{ZuMv(c)};
    return *this;
  }

  unsigned size() const { return m_size; }

  using Stats = ZmCacheStats;

private:
  void stats_(Stats &r) const {
    r.size = m_hash.size();
    r.count = m_hash.count_();
    r.loads = m_loads;
    r.misses = m_misses;
    r.evictions = m_evictions;
  }

public:
  template <bool Reset = false> ZuIfT<!Reset> stats(Stats &r) const {
    ReadGuard guard{m_lock};
    stats_(r);
  }
  template <bool Reset = false> ZuIfT<Reset> stats(Stats &r) {
    Guard guard{m_lock};
    stats_(r);
    m_loads = m_misses = m_evictions = 0;
  }

  template <int KeyID = 0, bool UpdateLRU = Evict, typename Key>
  NodeRef find(const Key &key) {
    Guard guard{m_lock};
    ++m_loads;
    if (NodeRef node = find_<KeyID, UpdateLRU>(key)) return node;
    ++m_misses;
    return nullptr;
  }

  template <
    int KeyID = 0, bool UpdateLRU = Evict, bool Evict_ = Evict,
    typename FindFn_, typename LoadFn>
  void find(Key<KeyID> key, FindFn_ findFn, LoadFn loadFn) {
    Guard guard{m_lock};
    ++m_loads;
    if (NodeRef node = find_<KeyID, UpdateLRU>(key)) {
      findFn(ZuMv(node));
      return;
    }
    ++m_misses;
    const auto &loadHash = m_loadHashes.template p<KeyID>();
    LoadHashNode<KeyID> *load = loadHash->find(key);
    bool pending = load;
    if (!pending)
      loadHash->addNode(load = new LoadHashNode<KeyID>{key, FindFnList{}});
    load->val().push(FindFn{ZuMv(findFn)});
    guard.unlock();
    if (!pending)
      loadFn(ZuMv(key), [this, key](NodeRef node) {
	Guard guard{m_lock};
	if (node) add_<Evict_>(node);
	const auto &loadHash = m_loadHashes.template p<KeyID>();
	if (auto load = loadHash->del(key)) {
	  guard.unlock();
	  while (auto findFn = load->val().shiftVal()) findFn(node);
	}
      });
  }

  template <
    int KeyID = 0, bool UpdateLRU = Evict, typename FindFn_, typename LoadFn,
    typename EvictFn>
  void find(Key<KeyID> key, FindFn_ findFn, LoadFn loadFn, EvictFn evictFn) {
    Guard guard{m_lock};
    ++m_loads;
    if (NodeRef node = find_<KeyID, UpdateLRU>(key)) {
      findFn(ZuMv(node));
      return;
    }
    ++m_misses;
    const auto &loadHash = m_loadHashes.template p<KeyID>();
    LoadHashNode<KeyID> *load = loadHash->find(key);
    bool pending = load;
    if (!pending)
      loadHash->addNode(load = new LoadHashNode<KeyID>{key, FindFnList{}});
    load->val().push(FindFn{ZuMv(findFn)});
    guard.unlock();
    if (!pending)
      loadFn(key, [this, key, evictFn = ZuMv(evictFn)](NodeRef node) {
	Guard guard{m_lock};
	if (node) add_<true>(node, ZuMv(evictFn));
	const auto &loadHash = m_loadHashes.template p<KeyID>();
	if (auto load = loadHash->del(key)) {
	  guard.unlock();
	  while (auto findFn = load->val().shiftVal()) findFn(node);
	}
      });
  }

  template <bool Evict_ = Evict> ZuIfT<!Evict_ || !Evict> add(NodeRef node) {
    Guard guard{m_lock};
    add_<false>(ZuMv(node));
  }

  template <bool Evict_ = Evict> ZuIfT<Evict_ && Evict> add(NodeRef node) {
    Guard guard{m_lock};
    add_<true>(ZuMv(node), [](Node *) { return true; });
  }

  template <bool Evict_ = Evict, typename EvictFn>
  ZuIfT<Evict_ && Evict> add(NodeRef node, EvictFn evictFn) {
    Guard guard{m_lock};
    add_<true>(ZuMv(node), ZuMv(evictFn));
  }

  template <typename KeyIDs_ = ZuSeq<>, typename L>
  void update(Node *node, L l) const {
    Guard guard{m_lock};
    m_hash.template update<KeyIDs_>(
      node,
      [this, &guard, l = ZuMv(l)](Node *node) mutable {
      guard = Guard{};
      l(node);
      guard = Guard{m_lock};
    }
    );
  }

  template <int KeyID, typename Key> NodeMvRef del(const Key &key) {
    Guard guard{m_lock};
    NodeMvRef node = m_hash.template del<KeyID>(key);
    if constexpr (Evict)
      if (node) m_lru.delNode(node);
    return node;
  }

  NodeMvRef delNode(Node *node_) {
    Guard guard{m_lock};
    NodeMvRef node = m_hash.delNode(node_);
    if constexpr (Evict)
      if (node) m_lru.delNode(node);
    return node;
  }

private:
  template <int KeyID, bool UpdateLRU = Evict, typename Key>
  NodeRef find_(const Key &key) {
    if (auto node = m_hash.template find<KeyID>(key)) {
      if constexpr (UpdateLRU && Evict) m_lru.pushNode(m_lru.delNode(node));
      return node;
    }
    return nullptr;
  }

  template <bool Evict_ = Evict> ZuIfT<!Evict_ || !Evict> add_(NodeRef node) {
    Node *nodePtr = node;
    m_hash.add(ZuMv(node));
    if constexpr (Evict) m_lru.pushNode(nodePtr);
  }

  template <bool Evict_ = Evict> ZuIfT<Evict_ && Evict> add_(NodeRef node) {
    add_(ZuMv(node), [](Node *) { return true; });
  }

  template <bool Evict_ = Evict, typename EvictFn>
  ZuIfT<Evict_ && Evict> add_(NodeRef node, EvictFn evictFn) {
    Node *nodePtr = node;
    if (m_hash.count_() >= m_size) {
      if (NodeMvRef evicted = m_lru.shift()) {
	if (evictFn(evicted)) {
	  ++m_evictions;
	  m_hash.delNode(evicted);
	} else {
	  if constexpr (ZuIsExact<ZuPtr<Node>, NodeMvRef>{})
	    m_lru.pushNode(ZuMv(evicted).release());
	  else
	    m_lru.pushNode(ZuMv(evicted));
	}
      }
    }
    m_hash.add(ZuMv(node));
    m_lru.pushNode(nodePtr);
  }

public:
  template <typename L> void all(L l) const {
    m_lock.lock();
    const_cast<ZmPolyCache *>(this)->all_<false>(ZuMv(l));
  }

  template <typename L> void allSync(L l) const {
    m_lock.lock();
    const_cast<ZmPolyCache *>(this)->all_<true>(ZuMv(l));
  }

private:
  template <bool Sync, typename L> bool all_(L l) {
    unsigned n = m_hash.count_();
    auto buf = ZmAlloc_<NodeRef>{static_cast<NodeRef *>(
      !(n) ? nullptr :
	     (((ZmStackAvail() >> 1) < ((n) * sizeof(NodeRef))) ?
		Zm::alignedAlloc<alignof(NodeRef)>((n) * sizeof(NodeRef)) :
		__builtin_alloca_with_align(
		  (n) * sizeof(NodeRef), (alignof(NodeRef)) << 3
		))
    )};
    if (!buf) return false;
    all__<Sync>(ZuMv(l), buf, n);
    return true;
  }
  template <typename NodeRef> struct NodeRefFn {
    static void ctor(NodeRef *ptr, NodeRef ref) {
      new (ptr) NodeRef{ZuMv(ref)};
    }
    static void dtor(NodeRef &ref) { ref.~NodeRef(); }
  };
  template <typename Node> struct NodeRefFn<Node *> {
    using NodeRef = Node *;
    static void ctor(NodeRef *ptr, NodeRef ref) { *ptr = ref; }
    static constexpr void dtor(NodeRef &) { }
  };
  template <bool Sync, typename L> void all__(L l, NodeRef *buf, unsigned n) {
    using Fn = NodeRefFn<NodeRef>;
    {
      auto i = m_hash.iterator();
      unsigned j = 0;
      for (j = 0; j < n; j++) {
	Fn::ctor(&buf[j], i.iterate());
	if (__builtin_expect(!!(!buf[j]), 0)) {
	  Fn::dtor(buf[j]);
	  break;
	}
      }
      n = j;
    }
    m_lock.unlock();
    if constexpr (Sync)
      ZmBlock<>{}(n, [&l, buf](unsigned j, auto wake) {
	l(ZuMv(buf[j]), ZuMv(wake));
	Fn::dtor(buf[j]);
      });
    else
      for (unsigned j = 0; j < n; j++) {
	l(ZuMv(buf[j]));
	Fn::dtor(buf[j]);
      }
  }

private:
  unsigned m_size;

  mutable Lock m_lock;
  PolyHash m_hash;
  LRU m_lru;
  LoadHashes m_loadHashes;
  uint64_t m_loads = 0;
  uint64_t m_misses = 0;
  uint64_t m_evictions = 0;
};

template <typename T> struct ZtHexDump_Size {
  enum { N = sizeof(T) };
};
template <> struct ZtHexDump_Size<void> {
  enum { N = 1 };
};
class ZtHexDump_ {
protected:
  ZtHexDump_() = default;

public:
  template <typename T, typename Cmp>
  ZtHexDump_(ZuSpan<T, Cmp> data) :
    m_data{reinterpret_cast<const uint8_t *>(data.data())},
    m_length(data.length() * sizeof(T)) { }

  template <typename T>
  ZtHexDump_(const T *data, unsigned length) :
    m_data{reinterpret_cast<const uint8_t *>(data)},
    m_length{length * ZtHexDump_Size<T>::N} { }

  ZtHexDump_(const ZtHexDump_ &d) : m_data{d.m_data}, m_length{d.m_length} { }
  ZtHexDump_ &operator=(const ZtHexDump_ &d) {
    if (__builtin_expect(!!(this != &d), 1)) {
      m_data = d.m_data;
      m_length = d.m_length;
    }
    return *this;
  }

public:
  void print(ZuVStream &s) const;
  struct Print : public ZuPrintDelegate {
    template <typename S> static void print(S &s_, const ZtHexDump_ &d) {
      ZuVStream s{s_};
      d.print(s);
    }
    static void print(ZuVStream &s, const ZtHexDump_ &d) { d.print(s); }
  };
  friend Print ZuPrintType(ZtHexDump_ *);

protected:
  const uint8_t *m_data = nullptr;
  unsigned m_length = 0;
};

inline constexpr const char *ZtHexDump_ID() { return "ZtHexDump"; }
class ZtHexDump : private ZmVHeap<ZtHexDump_ID>, public ZtHexDump_ {
  ZtHexDump() = delete;

public:
  template <typename T, typename Cmp>
  ZtHexDump(ZuCSpan prefix, ZuSpan<T, Cmp> data) : m_prefix{prefix} {
    m_length = data.length() * sizeof(T);
    init_(reinterpret_cast<const uint8_t *>(data.data()));
  }

  template <typename T>
  ZtHexDump(ZuCSpan prefix, const T *data, unsigned length) : m_prefix{prefix} {
    m_length = length * ZtHexDump_Size<T>::N;
    init_(reinterpret_cast<const uint8_t *>(data));
  }

  ~ZtHexDump() {
    if (__builtin_expect(!!(m_data), 1)) vfree(m_data);
  }

  ZtHexDump(ZtHexDump &&d) noexcept : m_prefix{ZuMv(d.m_prefix)} {
    m_data = d.m_data;
    m_length = d.m_length;
    d.m_prefix = {};
    d.m_data = nullptr;
    d.m_length = 0;
  }
  ZtHexDump &operator=(ZtHexDump &&d) noexcept {
    if (__builtin_expect(!!(this != &d), 1)) {
      m_prefix = ZuMv(d.m_prefix);
      m_data = d.m_data;
      m_length = d.m_length;
      d.m_prefix = {};
      d.m_data = nullptr;
      d.m_length = 0;
    }
    return *this;
  }
  ZtHexDump(const ZtHexDump &) = delete;
  ZtHexDump &operator=(const ZtHexDump &) = delete;

private:
  void init_(const uint8_t *data_) {
    uint8_t *data;
    if (__builtin_expect(
	  !!(data = static_cast<uint8_t *>(valloc(m_length))), 1
	)) {
      memcpy(data, data_, m_length);
      m_data = data;
    } else {
      m_data = nullptr;
      m_length = 0;
    }
  }

public:
  struct Print : public ZuPrintDelegate {
    template <typename S> static void print(S &s, const ZtHexDump &d) {
      s << d.m_prefix << static_cast<const ZtHexDump_ &>(d);
    }
  };
  friend Print ZuPrintType(ZtHexDump *);

private:
  ZtString m_prefix;
};

template <auto Fn, typename O, typename Ts, typename = void>
struct ZuInvoke_MemberFn_;
template <auto Fn, typename O, typename... Ts>
struct ZuInvoke_MemberFn_<
  Fn, O, ZuTypeList<Ts...>,
  decltype((ZuDeclVal<O *>()->*Fn)(ZuDeclVal<Ts>()...), void())> {
  using T = decltype((ZuDeclVal<O *>()->*Fn)(ZuDeclVal<Ts>()...));
};
template <auto Fn, typename O, typename... Ts>
using ZuInvoke_MemberFn =
  typename ZuInvoke_MemberFn_<Fn, O, ZuTypeList<Ts...>>::T;
template <auto Fn, typename O, typename... Ts>
auto ZuInvoke(O *ptr, Ts &&...args) -> ZuInvoke_MemberFn<Fn, O, Ts...> {
  return (ptr->*Fn)(ZuFwd<Ts>(args)...);
}

template <auto Fn, typename O, typename Ts, typename = void>
struct ZuInvoke_BoundFn_;
template <auto Fn, typename O, typename... Ts>
struct ZuInvoke_BoundFn_<
  Fn, O, ZuTypeList<Ts...>,
  decltype(Fn(ZuDeclVal<O *>(), ZuDeclVal<Ts>()...), void())> {
  using T = decltype(Fn(ZuDeclVal<O *>(), ZuDeclVal<Ts>()...));
};
template <auto Fn, typename O, typename... Ts>
using ZuInvoke_BoundFn =
  typename ZuInvoke_BoundFn_<Fn, O, ZuTypeList<Ts...>>::T;
template <auto Fn, typename O, typename... Ts>
auto ZuInvoke(O *ptr, Ts &&...args) -> ZuInvoke_BoundFn<Fn, O, Ts...> {
  return Fn(ptr, ZuFwd<Ts>(args)...);
}

template <auto Fn, typename O, typename Ts, typename = void>
struct ZuInvoke_UnboundFn_;
template <auto Fn, typename O, typename... Ts>
struct ZuInvoke_UnboundFn_<
  Fn, O, ZuTypeList<Ts...>, decltype(Fn(ZuDeclVal<Ts>()...), void())> {
  using T = decltype(Fn(ZuDeclVal<Ts>()...));
};
template <auto Fn, typename O, typename... Ts>
using ZuInvoke_UnboundFn =
  typename ZuInvoke_UnboundFn_<Fn, O, ZuTypeList<Ts...>>::T;
template <auto Fn, typename O, typename... Ts>
auto ZuInvoke(O *, Ts &&...args) -> ZuInvoke_UnboundFn<Fn, O, Ts...> {
  return Fn(ZuFwd<Ts>(args)...);
}

template <typename Impl_, typename BufAlloc_> class ZiRx {
public:
  using Impl = Impl_;
  using BufAlloc = BufAlloc_;

  auto impl() const { return static_cast<const Impl *>(this); }
  auto impl() { return static_cast<Impl *>(this); }

  static auto impl(const ZiIOBuf *buf) {
    return static_cast<Impl *>(buf->owner);
  }

  template <auto Hdr, auto Body> void recv(ZiIOContext &io) {
    ZmRef<ZiIOBuf> buf = new BufAlloc{impl()};
    auto ptr = buf->data();
    auto size = buf->size;
    io.init(
      ZiIOFn{
	ZuMv(buf),
	[](ZiIOBuf *buf, ZiIOContext &io) {
      unsigned len = io.offset += io.length;
      io.length = 0;

      buf->length = len;
      int frameLen = ZuInvoke<Hdr>(impl(buf), io, buf);
      if (__builtin_expect(!!(frameLen < 0), 0)) {
	io.disconnect();
	return true;
      }
      if (len < static_cast<unsigned>(frameLen)) return true;
      if (__builtin_expect(
	    !!(static_cast<unsigned>(frameLen) > buf->size), 0
	  )) {
	ZeLogEvent(ZeMkEvent(
	  Ze::Error, "../../zi/src/zlib/ZiRx.hh", 69, __PRETTY_FUNCTION__,
	  "ZiRx::recv TCP message too big / corrupt"
	));
	io.disconnect();
	return true;
      }

      ZmRef<ZiIOBuf> next;
      unsigned nextLen = len - frameLen;
      uint8_t *nextPtr = nullptr;

      if (nextLen) {
	next = new BufAlloc{impl(buf)};
	nextPtr = next->ensure(nextLen);
	memcpy(nextPtr, io.ptr + frameLen, nextLen);
	next->length = nextLen;
	buf->length = frameLen;
      }

      frameLen = ZuInvoke<Body>(impl(buf), io, io.fn.mvObject<ZiIOBuf>());
      if (__builtin_expect(!!(frameLen < 0), 0)) {
	io.disconnect();
	return true;
      }
      if (!frameLen) return true;

      if (!next) {
	next = new BufAlloc{impl(buf)};
	nextPtr = next->data();
      }

      io.ptr = nextPtr;
      io.size = next->size;
      io.offset = 0;
      io.length = nextLen;
      io.fn.object(ZuMv(next));
      return false;
    }
      },
      ptr, size, 0
    );
  }

  template <auto Hdr, auto Body> void recvSync(ZiIOContext &io) {
    ZmRef<ZiIOBuf> buf = new BufAlloc{impl()};
    auto ptr = buf->data();
    auto size = buf->size;
    io.init(
      ZiIOFn{
	ZuMv(buf),
	[](ZiIOBuf *buf, ZiIOContext &io) {
      unsigned len = io.offset += io.length;
      io.length = 0;

      buf->length = len;
      int frameLen = ZuInvoke<Hdr>(impl(buf), io, buf);
      if (__builtin_expect(!!(frameLen < 0), 0)) {
	io.disconnect();
	return true;
      }
      if (len < static_cast<unsigned>(frameLen)) return true;
      if (__builtin_expect(
	    !!(static_cast<unsigned>(frameLen) > buf->size), 0
	  )) {
	ZeLogEvent(ZeMkEvent(
	  Ze::Error, "../../zi/src/zlib/ZiRx.hh", 136, __PRETTY_FUNCTION__,
	  "ZiRx::recv TCP message too big / corrupt"
	));
	io.disconnect();
	return true;
      }

      frameLen = ZuInvoke<Body>(impl(buf), io, buf, frameLen);
      if (__builtin_expect(!!(frameLen < 0), 0)) {
	io.disconnect();
	return true;
      }
      if (!frameLen) return true;

      unsigned nextLen = len - frameLen;

      if (nextLen) memmove(io.ptr, io.ptr + frameLen, nextLen);

      io.offset = 0;
      io.length = buf->length = nextLen;
      return false;
    }
      },
      ptr, size, 0
    );
  }

  template <auto Hdr, auto Body>
  int recvMem(const uint8_t *data, unsigned rxLen, ZmRef<ZiIOBuf> &buf) {
    if (!buf) buf = new BufAlloc{impl()};
    unsigned oldLen = buf->length;
    unsigned len = oldLen + rxLen;
    auto rxData = buf->ensure(len);
    memcpy(rxData + oldLen, data, rxLen);
    buf->length = len;

    while (len) {
      int frameLen = ZuInvoke<Hdr>(impl(buf), buf);
      if (__builtin_expect(!!(frameLen < 0), 0)) return -1;
      if (len < static_cast<unsigned>(frameLen)) return 0;

      ZmRef<ZiIOBuf> next;
      unsigned nextLen = len - frameLen;
      uint8_t *nextPtr = nullptr;

      if (nextLen) {
	next = new BufAlloc{impl()};
	nextPtr = next->ensure(nextLen);
	memcpy(nextPtr, buf->data() + frameLen, nextLen);
	next->length = nextLen;
	buf->length = frameLen;
      }

      frameLen = ZuInvoke<Body>(impl(buf), ZuMv(buf));
      if (__builtin_expect(!!(frameLen < 0), 0)) return -1;
      if (!frameLen) return rxLen;

      buf = ZuMv(next);
      len = nextLen;
    }
    return rxLen;
  }

  template <auto Hdr, auto Body>
  int recvMemSync(const uint8_t *data, unsigned rxLen, ZmRef<ZiIOBuf> &buf) {
    if (!buf) buf = new BufAlloc{impl()};
    unsigned oldLen = buf->length;
    unsigned len = oldLen + rxLen;
    auto rxData = buf->ensure(len);
    memcpy(rxData + oldLen, data, rxLen);
    buf->length = len;

    while (len) {
      int frameLen = ZuInvoke<Hdr>(impl(buf), buf);
      if (__builtin_expect(!!(frameLen < 0), 0)) return frameLen;
      if (len < static_cast<unsigned>(frameLen)) {
	buf->ensure(frameLen);
	return 0;
      }

      frameLen = ZuInvoke<Body>(impl(buf), buf.ptr(), frameLen);
      if (__builtin_expect(!!(frameLen < 0), 0)) return frameLen;
      if (__builtin_expect(!!(!frameLen), 0)) return rxLen;

      buf->skip += frameLen;
      rxData += frameLen;
      buf->length = (len -= frameLen);
    }
    if (len && buf->skip) {
      buf->skip = 0;
      memmove(buf->data(), rxData, len);
    } else
      buf->skip = 0;
    buf->length = len;
    return rxLen;
  }
};

template <typename Impl_> class ZiTx {
public:
  using Impl = Impl_;

  auto impl() const { return static_cast<const Impl *>(this); }
  auto impl() { return static_cast<Impl *>(this); }

  static auto impl(const ZiIOBuf *buf) {
    return static_cast<Impl *>(buf->owner);
  }

  void sent(ZmRef<const ZiIOBuf>) { }

  void send(ZmRef<const ZiIOBuf> buf) {
    buf->owner = impl();
    impl()->ZiConnection::send(ZiIOFn{
      ZuMv(buf),
      [](const ZiIOBuf *buf, ZiIOContext &io) {
      io.init(
	ZiIOFn{
	  io.fn.mvObject<const ZiIOBuf>(),
	  [](const ZiIOBuf *buf, ZiIOContext &io) {
	if (__builtin_expect(!!((io.offset += io.length) < io.size), 0))
	  return true;
	auto buf_ = io.fn.mvObject<const ZiIOBuf>();
	io.complete();
	auto impl_ = impl(buf_);
	impl_->sent(ZuMv(buf_));
	return true;
      }
	},
	buf->data(), buf->length, 0
      );
      return true;
    }
    });
  }
};

static_assert(

  24

      == 24 &&

    3

      == 3 &&

    25

      == 25,
  "Non-compatible flatbuffers version included"
);

namespace Ztel { namespace fbs {

struct DBTable;
struct DBTableBuilder;

struct DBHost;
struct DBHostBuilder;

struct DB;
struct DBBuilder;

struct DBTable

  final

  : private ::flatbuffers::Table {
  typedef DBTableBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset

    : ::flatbuffers::voffset_t

  {
    VT_NAME = 4,
    VT_SHARDS = 6,
    VT_THREAD = 8,
    VT_COUNT = 10,
    VT_CACHELOADS = 12,
    VT_CACHEMISSES = 14,
    VT_CACHEEVICTIONS = 16,
    VT_CACHESIZE = 18,
    VT_CACHEMODE = 20,
    VT_WARMUP = 22
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  uint16_t shards() const { return GetField<uint16_t>(VT_SHARDS, 0); }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *
  thread() const {
    return GetPointer<const ::flatbuffers::Vector<
      ::flatbuffers::Offset<::flatbuffers::String>> *>(VT_THREAD);
  }
  uint64_t count() const { return GetField<uint64_t>(VT_COUNT, 0); }
  uint64_t cacheLoads() const { return GetField<uint64_t>(VT_CACHELOADS, 0); }
  uint64_t cacheMisses() const { return GetField<uint64_t>(VT_CACHEMISSES, 0); }
  uint64_t cacheEvictions() const {
    return GetField<uint64_t>(VT_CACHEEVICTIONS, 0);
  }
  uint32_t cacheSize() const { return GetField<uint32_t>(VT_CACHESIZE, 0); }
  Ztel::fbs::DBCacheMode cacheMode() const {
    return static_cast<Ztel::fbs::DBCacheMode>(GetField<int8_t>(VT_CACHEMODE, 0)
    );
  }
  uint8_t warmup() const { return GetField<uint8_t>(VT_WARMUP, 0); }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_NAME) &&
      verifier.VerifyString(name()) &&
      VerifyField<uint16_t>(verifier, VT_SHARDS, 2) &&
      VerifyOffset(verifier, VT_THREAD) && verifier.VerifyVector(thread()) &&
      verifier.VerifyVectorOfStrings(thread()) &&
      VerifyField<uint64_t>(verifier, VT_COUNT, 8) &&
      VerifyField<uint64_t>(verifier, VT_CACHELOADS, 8) &&
      VerifyField<uint64_t>(verifier, VT_CACHEMISSES, 8) &&
      VerifyField<uint64_t>(verifier, VT_CACHEEVICTIONS, 8) &&
      VerifyField<uint32_t>(verifier, VT_CACHESIZE, 4) &&
      VerifyField<int8_t>(verifier, VT_CACHEMODE, 1) &&
      VerifyField<uint8_t>(verifier, VT_WARMUP, 1) && verifier.EndTable();
  }
};

struct DBTableBuilder {
  typedef DBTable Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(DBTable::VT_NAME, name);
  }
  void add_shards(uint16_t shards) {
    fbb_.AddElement<uint16_t>(DBTable::VT_SHARDS, shards, 0);
  }
  void add_thread(
    ::flatbuffers::Offset<
      ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>>
      thread
  ) {
    fbb_.AddOffset(DBTable::VT_THREAD, thread);
  }
  void add_count(uint64_t count) {
    fbb_.AddElement<uint64_t>(DBTable::VT_COUNT, count, 0);
  }
  void add_cacheLoads(uint64_t cacheLoads) {
    fbb_.AddElement<uint64_t>(DBTable::VT_CACHELOADS, cacheLoads, 0);
  }
  void add_cacheMisses(uint64_t cacheMisses) {
    fbb_.AddElement<uint64_t>(DBTable::VT_CACHEMISSES, cacheMisses, 0);
  }
  void add_cacheEvictions(uint64_t cacheEvictions) {
    fbb_.AddElement<uint64_t>(DBTable::VT_CACHEEVICTIONS, cacheEvictions, 0);
  }
  void add_cacheSize(uint32_t cacheSize) {
    fbb_.AddElement<uint32_t>(DBTable::VT_CACHESIZE, cacheSize, 0);
  }
  void add_cacheMode(Ztel::fbs::DBCacheMode cacheMode) {
    fbb_.AddElement<int8_t>(
      DBTable::VT_CACHEMODE, static_cast<int8_t>(cacheMode), 0
    );
  }
  void add_warmup(uint8_t warmup) {
    fbb_.AddElement<uint8_t>(DBTable::VT_WARMUP, warmup, 0);
  }
  explicit DBTableBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DBTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DBTable>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DBTable> CreateDBTable(
  ::flatbuffers::FlatBufferBuilder &_fbb,
  ::flatbuffers::Offset<::flatbuffers::String> name = 0, uint16_t shards = 0,
  ::flatbuffers::Offset<
    ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>>
    thread = 0,
  uint64_t count = 0, uint64_t cacheLoads = 0, uint64_t cacheMisses = 0,
  uint64_t cacheEvictions = 0, uint32_t cacheSize = 0,
  Ztel::fbs::DBCacheMode cacheMode = Ztel::fbs::DBCacheMode::Normal,
  uint8_t warmup = 0
) {
  DBTableBuilder builder_(_fbb);
  builder_.add_cacheEvictions(cacheEvictions);
  builder_.add_cacheMisses(cacheMisses);
  builder_.add_cacheLoads(cacheLoads);
  builder_.add_count(count);
  builder_.add_cacheSize(cacheSize);
  builder_.add_thread(thread);
  builder_.add_name(name);
  builder_.add_shards(shards);
  builder_.add_warmup(warmup);
  builder_.add_cacheMode(cacheMode);
  return builder_.Finish();
}

struct DBTable::Traits {
  using type = DBTable;
  static constexpr auto Create = CreateDBTable;
};

inline ::flatbuffers::Offset<DBTable> CreateDBTableDirect(
  ::flatbuffers::FlatBufferBuilder &_fbb, const char *name = nullptr,
  uint16_t shards = 0,
  const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *thread =
    nullptr,
  uint64_t count = 0, uint64_t cacheLoads = 0, uint64_t cacheMisses = 0,
  uint64_t cacheEvictions = 0, uint32_t cacheSize = 0,
  Ztel::fbs::DBCacheMode cacheMode = Ztel::fbs::DBCacheMode::Normal,
  uint8_t warmup = 0
) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto thread__ = thread ?
    _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*thread) :
    0;
  return Ztel::fbs::CreateDBTable(
    _fbb, name__, shards, thread__, count, cacheLoads, cacheMisses,
    cacheEvictions, cacheSize, cacheMode, warmup
  );
}

struct DBHost

  final

  : private ::flatbuffers::Table {
  typedef DBHostBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset

    : ::flatbuffers::voffset_t

  {
    VT_IP = 4,
    VT_ID = 6,
    VT_PRIORITY = 8,
    VT_PORT = 10,
    VT_STATE = 12,
    VT_VOTED = 14
  };
  const Zfb::IP *ip() const { return GetStruct<const Zfb::IP *>(VT_IP); }
  const Zfb::ID *id() const { return GetStruct<const Zfb::ID *>(VT_ID); }
  uint32_t priority() const { return GetField<uint32_t>(VT_PRIORITY, 0); }
  uint16_t port() const { return GetField<uint16_t>(VT_PORT, 0); }
  Ztel::fbs::DBHostState state() const {
    return static_cast<Ztel::fbs::DBHostState>(GetField<int8_t>(VT_STATE, 0));
  }
  uint8_t voted() const { return GetField<uint8_t>(VT_VOTED, 0); }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
      VerifyField<Zfb::IP>(verifier, VT_IP, 1) &&
      VerifyField<Zfb::ID>(verifier, VT_ID, 1) &&
      VerifyField<uint32_t>(verifier, VT_PRIORITY, 4) &&
      VerifyField<uint16_t>(verifier, VT_PORT, 2) &&
      VerifyField<int8_t>(verifier, VT_STATE, 1) &&
      VerifyField<uint8_t>(verifier, VT_VOTED, 1) && verifier.EndTable();
  }
};

struct DBHostBuilder {
  typedef DBHost Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ip(const Zfb::IP *ip) { fbb_.AddStruct(DBHost::VT_IP, ip); }
  void add_id(const Zfb::ID *id) { fbb_.AddStruct(DBHost::VT_ID, id); }
  void add_priority(uint32_t priority) {
    fbb_.AddElement<uint32_t>(DBHost::VT_PRIORITY, priority, 0);
  }
  void add_port(uint16_t port) {
    fbb_.AddElement<uint16_t>(DBHost::VT_PORT, port, 0);
  }
  void add_state(Ztel::fbs::DBHostState state) {
    fbb_.AddElement<int8_t>(DBHost::VT_STATE, static_cast<int8_t>(state), 0);
  }
  void add_voted(uint8_t voted) {
    fbb_.AddElement<uint8_t>(DBHost::VT_VOTED, voted, 0);
  }
  explicit DBHostBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DBHost> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DBHost>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DBHost> CreateDBHost(
  ::flatbuffers::FlatBufferBuilder &_fbb, const Zfb::IP *ip = nullptr,
  const Zfb::ID *id = nullptr, uint32_t priority = 0, uint16_t port = 0,
  Ztel::fbs::DBHostState state = Ztel::fbs::DBHostState::Instantiated,
  uint8_t voted = 0
) {
  DBHostBuilder builder_(_fbb);
  builder_.add_priority(priority);
  builder_.add_id(id);
  builder_.add_ip(ip);
  builder_.add_port(port);
  builder_.add_voted(voted);
  builder_.add_state(state);
  return builder_.Finish();
}

struct DBHost::Traits {
  using type = DBHost;
  static constexpr auto Create = CreateDBHost;
};

struct DB

  final

  : private ::flatbuffers::Table {
  typedef DBBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset

    : ::flatbuffers::voffset_t

  {
    VT_THREAD = 4,
    VT_SELF = 6,
    VT_LEADER = 8,
    VT_PREV = 10,
    VT_NEXT = 12,
    VT_NCXNS = 14,
    VT_HEARTBEATFREQ = 16,
    VT_HEARTBEATTIMEOUT = 18,
    VT_RECONNECTFREQ = 20,
    VT_ELECTIONTIMEOUT = 22,
    VT_NTABLES = 24,
    VT_NHOSTS = 26,
    VT_NPEERS = 28,
    VT_STATE = 30,
    VT_ACTIVE = 32,
    VT_RECOVERING = 34,
    VT_REPLICATING = 36
  };
  const ::flatbuffers::String *thread() const {
    return GetPointer<const ::flatbuffers::String *>(VT_THREAD);
  }
  const Zfb::ID *self() const { return GetStruct<const Zfb::ID *>(VT_SELF); }
  const Zfb::ID *leader() const {
    return GetStruct<const Zfb::ID *>(VT_LEADER);
  }
  const Zfb::ID *prev() const { return GetStruct<const Zfb::ID *>(VT_PREV); }
  const Zfb::ID *next() const { return GetStruct<const Zfb::ID *>(VT_NEXT); }
  uint32_t nCxns() const { return GetField<uint32_t>(VT_NCXNS, 0); }
  uint32_t heartbeatFreq() const {
    return GetField<uint32_t>(VT_HEARTBEATFREQ, 0);
  }
  uint32_t heartbeatTimeout() const {
    return GetField<uint32_t>(VT_HEARTBEATTIMEOUT, 0);
  }
  uint32_t reconnectFreq() const {
    return GetField<uint32_t>(VT_RECONNECTFREQ, 0);
  }
  uint32_t electionTimeout() const {
    return GetField<uint32_t>(VT_ELECTIONTIMEOUT, 0);
  }
  uint16_t nTables() const { return GetField<uint16_t>(VT_NTABLES, 0); }
  uint8_t nHosts() const { return GetField<uint8_t>(VT_NHOSTS, 0); }
  uint8_t nPeers() const { return GetField<uint8_t>(VT_NPEERS, 0); }
  int8_t state() const { return GetField<int8_t>(VT_STATE, 0); }
  uint8_t active() const { return GetField<uint8_t>(VT_ACTIVE, 0); }
  uint8_t recovering() const { return GetField<uint8_t>(VT_RECOVERING, 0); }
  uint8_t replicating() const { return GetField<uint8_t>(VT_REPLICATING, 0); }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_THREAD) &&
      verifier.VerifyString(thread()) &&
      VerifyField<Zfb::ID>(verifier, VT_SELF, 1) &&
      VerifyField<Zfb::ID>(verifier, VT_LEADER, 1) &&
      VerifyField<Zfb::ID>(verifier, VT_PREV, 1) &&
      VerifyField<Zfb::ID>(verifier, VT_NEXT, 1) &&
      VerifyField<uint32_t>(verifier, VT_NCXNS, 4) &&
      VerifyField<uint32_t>(verifier, VT_HEARTBEATFREQ, 4) &&
      VerifyField<uint32_t>(verifier, VT_HEARTBEATTIMEOUT, 4) &&
      VerifyField<uint32_t>(verifier, VT_RECONNECTFREQ, 4) &&
      VerifyField<uint32_t>(verifier, VT_ELECTIONTIMEOUT, 4) &&
      VerifyField<uint16_t>(verifier, VT_NTABLES, 2) &&
      VerifyField<uint8_t>(verifier, VT_NHOSTS, 1) &&
      VerifyField<uint8_t>(verifier, VT_NPEERS, 1) &&
      VerifyField<int8_t>(verifier, VT_STATE, 1) &&
      VerifyField<uint8_t>(verifier, VT_ACTIVE, 1) &&
      VerifyField<uint8_t>(verifier, VT_RECOVERING, 1) &&
      VerifyField<uint8_t>(verifier, VT_REPLICATING, 1) && verifier.EndTable();
  }
};

struct DBBuilder {
  typedef DB Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_thread(::flatbuffers::Offset<::flatbuffers::String> thread) {
    fbb_.AddOffset(DB::VT_THREAD, thread);
  }
  void add_self(const Zfb::ID *self) { fbb_.AddStruct(DB::VT_SELF, self); }
  void add_leader(const Zfb::ID *leader) {
    fbb_.AddStruct(DB::VT_LEADER, leader);
  }
  void add_prev(const Zfb::ID *prev) { fbb_.AddStruct(DB::VT_PREV, prev); }
  void add_next(const Zfb::ID *next) { fbb_.AddStruct(DB::VT_NEXT, next); }
  void add_nCxns(uint32_t nCxns) {
    fbb_.AddElement<uint32_t>(DB::VT_NCXNS, nCxns, 0);
  }
  void add_heartbeatFreq(uint32_t heartbeatFreq) {
    fbb_.AddElement<uint32_t>(DB::VT_HEARTBEATFREQ, heartbeatFreq, 0);
  }
  void add_heartbeatTimeout(uint32_t heartbeatTimeout) {
    fbb_.AddElement<uint32_t>(DB::VT_HEARTBEATTIMEOUT, heartbeatTimeout, 0);
  }
  void add_reconnectFreq(uint32_t reconnectFreq) {
    fbb_.AddElement<uint32_t>(DB::VT_RECONNECTFREQ, reconnectFreq, 0);
  }
  void add_electionTimeout(uint32_t electionTimeout) {
    fbb_.AddElement<uint32_t>(DB::VT_ELECTIONTIMEOUT, electionTimeout, 0);
  }
  void add_nTables(uint16_t nTables) {
    fbb_.AddElement<uint16_t>(DB::VT_NTABLES, nTables, 0);
  }
  void add_nHosts(uint8_t nHosts) {
    fbb_.AddElement<uint8_t>(DB::VT_NHOSTS, nHosts, 0);
  }
  void add_nPeers(uint8_t nPeers) {
    fbb_.AddElement<uint8_t>(DB::VT_NPEERS, nPeers, 0);
  }
  void add_state(int8_t state) {
    fbb_.AddElement<int8_t>(DB::VT_STATE, state, 0);
  }
  void add_active(uint8_t active) {
    fbb_.AddElement<uint8_t>(DB::VT_ACTIVE, active, 0);
  }
  void add_recovering(uint8_t recovering) {
    fbb_.AddElement<uint8_t>(DB::VT_RECOVERING, recovering, 0);
  }
  void add_replicating(uint8_t replicating) {
    fbb_.AddElement<uint8_t>(DB::VT_REPLICATING, replicating, 0);
  }
  explicit DBBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DB> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DB>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DB> CreateDB(
  ::flatbuffers::FlatBufferBuilder &_fbb,
  ::flatbuffers::Offset<::flatbuffers::String> thread = 0,
  const Zfb::ID *self = nullptr, const Zfb::ID *leader = nullptr,
  const Zfb::ID *prev = nullptr, const Zfb::ID *next = nullptr,
  uint32_t nCxns = 0, uint32_t heartbeatFreq = 0, uint32_t heartbeatTimeout = 0,
  uint32_t reconnectFreq = 0, uint32_t electionTimeout = 0,
  uint16_t nTables = 0, uint8_t nHosts = 0, uint8_t nPeers = 0,
  int8_t state = 0, uint8_t active = 0, uint8_t recovering = 0,
  uint8_t replicating = 0
) {
  DBBuilder builder_(_fbb);
  builder_.add_electionTimeout(electionTimeout);
  builder_.add_reconnectFreq(reconnectFreq);
  builder_.add_heartbeatTimeout(heartbeatTimeout);
  builder_.add_heartbeatFreq(heartbeatFreq);
  builder_.add_nCxns(nCxns);
  builder_.add_next(next);
  builder_.add_prev(prev);
  builder_.add_leader(leader);
  builder_.add_self(self);
  builder_.add_thread(thread);
  builder_.add_nTables(nTables);
  builder_.add_replicating(replicating);
  builder_.add_recovering(recovering);
  builder_.add_active(active);
  builder_.add_state(state);
  builder_.add_nPeers(nPeers);
  builder_.add_nHosts(nHosts);
  return builder_.Finish();
}

struct DB::Traits {
  using type = DB;
  static constexpr auto Create = CreateDB;
};

inline ::flatbuffers::Offset<DB> CreateDBDirect(
  ::flatbuffers::FlatBufferBuilder &_fbb, const char *thread = nullptr,
  const Zfb::ID *self = nullptr, const Zfb::ID *leader = nullptr,
  const Zfb::ID *prev = nullptr, const Zfb::ID *next = nullptr,
  uint32_t nCxns = 0, uint32_t heartbeatFreq = 0, uint32_t heartbeatTimeout = 0,
  uint32_t reconnectFreq = 0, uint32_t electionTimeout = 0,
  uint16_t nTables = 0, uint8_t nHosts = 0, uint8_t nPeers = 0,
  int8_t state = 0, uint8_t active = 0, uint8_t recovering = 0,
  uint8_t replicating = 0
) {
  auto thread__ = thread ? _fbb.CreateString(thread) : 0;
  return Ztel::fbs::CreateDB(
    _fbb, thread__, self, leader, prev, next, nCxns, heartbeatFreq,
    heartbeatTimeout, reconnectFreq, electionTimeout, nTables, nHosts, nPeers,
    state, active, recovering, replicating
  );
}

}} // namespace Ztel::fbs

template <typename> struct ZdbHeapID {
  static constexpr const char *id() { return "Zdb.Object"; }
};

namespace Zdb_ {

class DB;
class Host;
class AnyTable;
template <typename T> class Table;
struct Record_Print;

class Cxn_ :
  public ZiConnection,
  public ZiRx<Cxn_, RxBufAlloc>,
  public ZiTx<Cxn_> {
  friend DB;
  friend Host;
  friend AnyTable;

  using BufAlloc = Zdb_::RxBufAlloc;

  using Rx = ZiRx<Cxn_, BufAlloc>;
  using Tx = ZiTx<Cxn_>;

  using Rx::recv;
  using Tx::send;

protected:
  Cxn_(DB *db, Host *host, const ZiCxnInfo &ci);

private:
  DB *db() const { return m_db; }
  void host(Host *host) { m_host = host; }
  Host *host() const { return m_host; }

  void connected(ZiIOContext &);
  void disconnected();

  void msgRead(ZiIOContext &);
  int msgRead2(ZmRef<IOBuf>);
  void msgRead3(ZmRef<IOBuf>);

  void hbRcvd(const fbs::Heartbeat *);
  void hbTimeout();
  void hbSend();

  void repRecordRcvd(ZmRef<const IOBuf>);
  void repCommitRcvd(ZmRef<const IOBuf>);

  DB *m_db;
  Host *m_host;

  ZmScheduler::Timer m_hbTimer;
};
inline constexpr const char *CxnHeapID() { return "Zdb.Cxn"; }
using CxnList = ZmList<Cxn_, ZmListNode<Cxn_, ZmListHeapID<CxnHeapID>>>;
using Cxn = CxnList::Node;

using DBState_ = ZmLHashKV<ZuTuple<ZtString, Shard>, UN, ZmLHashLocal<>>;
struct DBState : public DBState_ {
  SN sn = 0;

  DBState() = delete;

  DBState(unsigned size) : DBState_{ZmHashParams{size}} { }

  DBState(const fbs::DBState *dbState) :
    DBState_{ZmHashParams{dbState->tableStates()->size()}},
    sn{Zfb::Load::uint128(dbState->sn())} {
    Zfb::Load::all(
      dbState->tableStates(),
      [this](unsigned, const fbs::TableState *tableState) {
      add(Zfb::Load::str(tableState->table()), tableState->un());
    }
    );
  }
  void load(const fbs::DBState *dbState) {
    sn = Zfb::Load::uint128(dbState->sn());
    Zfb::Load::all(
      dbState->tableStates(),
      [this](unsigned, const fbs::TableState *tableState) {
      update(Zfb::Load::str(tableState->table()), tableState->un());
    }
    );
  }
  Zfb::Offset<fbs::DBState> save(Zfb::Builder &fbb) const {
    auto sn_ = Zfb::Save::uint128(sn);
    auto i = readIterator();
    return fbs::CreateDBState(
      fbb, &sn_,
      Zfb::Save::vectorIter<fbs::TableState>(
	fbb, i.count(),
	[&i](Zfb::Builder &fbb, unsigned) {
      if (auto state = i.iterate())
	return fbs::CreateTableState(
	  fbb, Zfb::Save::str(fbb, state->template p<0>().template p<0>()),
	  state->template p<1>(), state->template p<0>().template p<1>()
	);
      else
	return Zfb::Offset<fbs::TableState>{};
    }
      )
    );
  }

  void reset() {
    sn = 0;
    clean();
  }

  bool updateSN(SN sn_) {
    if (sn < sn_) {
      sn = sn_;
      return true;
    }
    return false;
  }
  bool update(ZuTuple<ZuCSpan, Shard> key, UN un_) {
    auto state = find(key);
    if (!state) {
      add(key, un_);
      return true;
    }
    auto &un = const_cast<T *>(state)->template p<1>();
    if (un < un_) {
      un = un_;
      return true;
    }
    return false;
  }
  DBState &operator|=(const DBState &r) {
    if (__builtin_expect(!!(this != &r), 1)) {
      updateSN(r.sn);
      auto i = r.readIterator();
      while (auto rstate = i.iterate())
	update(rstate->template p<0>(), rstate->template p<1>());
    }
    return *this;
  }
  DBState &operator=(const DBState &r) {
    if (__builtin_expect(!!(this != &r), 1)) {
      clean();
      this->operator|=(r);
    }
    return *this;
  }

  int cmp(const DBState &r) const { return (sn > r.sn) - (sn < r.sn); }

  template <typename S> void print(S &) const;
  friend ZuPrintFn ZuPrintType(DBState *);
};

class AnyObject : public ZmPolymorph {
  AnyObject() = delete;
  AnyObject(const AnyObject &) = delete;
  AnyObject &operator=(const AnyObject &) = delete;
  AnyObject(AnyObject &&) = delete;
  AnyObject &operator=(AnyObject &&) = delete;

  friend AnyTable;
  template <typename> friend class Table;

public:
  AnyObject(AnyTable *table, Shard shard) : m_table{table}, m_shard{shard} { }

  AnyTable *table() const { return m_table; }
  Shard shard() const { return m_shard; }
  UN un() const { return m_un; }
  SN sn() const { return m_sn; }
  VN vn() const { return m_vn; }
  int state() const { return m_state; }
  UN origUN() const { return m_origUN; }
  bool evicted() const { return m_pinCount < 0; }
  bool pinned() const { return m_pinCount > 0; }

  ZmRef<const IOBuf> replicate(int type);

  virtual void *ptr_() { return nullptr; }
  const void *ptr_() const { return const_cast<AnyObject *>(this)->ptr_(); }

  virtual void evict() {
    ((m_pinCount <= 0) ? void() :
			 ZmAssert_fail(
			   "m_pinCount <= 0", "../../zdb/src/zlib/Zdb.hh", 350,
			   __PRETTY_FUNCTION__
			 ));
    m_pinCount = -1;
  }
  void pin() {
    ((m_pinCount >= 0) ? void() :
			 ZmAssert_fail(
			   "m_pinCount >= 0", "../../zdb/src/zlib/Zdb.hh", 354,
			   __PRETTY_FUNCTION__
			 ));
    ++m_pinCount;
  }
  void unpin() {
    ((m_pinCount > 0) ?
       void() :
       ZmAssert_fail(
	 "m_pinCount > 0", "../../zdb/src/zlib/Zdb.hh", 358, __PRETTY_FUNCTION__
       ));
    --m_pinCount;
  }

  template <typename S> void print(S &s) const;
  friend ZuPrintFn ZuPrintType(AnyObject *);

private:
  void init(Shard shard, UN un, SN sn, VN vn) {
    m_shard = shard;
    m_un = un;
    m_sn = sn;
    m_vn = vn;
    m_state = ObjState::Committed;
  }

  bool insert_(UN un);
  bool update_(UN un);
  bool del_(UN un);
  bool commit_();
  bool abort_();

  AnyTable *m_table;
  UN m_un = nullUN();
  SN m_sn = nullSN();
  VN m_vn = 0;
  UN m_origUN = nullUN();
  int64_t m_pinCount = 0;
  Shard m_shard = 0;
  int8_t m_state = ObjState::Undefined;
};

inline UN AnyObject_UNAxor(const ZmRef<AnyObject> &object) {
  return object->un();
}

inline constexpr const char *CacheUN_HeapID() { return "Zdb.UpdCache"; }

using CacheUN = ZmHashKV<
  UN, ZmRef<AnyObject>, ZmHashLock<ZmPLock, ZmHashHeapID<CacheUN_HeapID>>>;

template <typename Field>
struct FieldFilter :
  public ZuBool<!ZuTypeIn<ZuFieldProp::Series, typename Field::Props>{}> { };

template <typename T> using Fields = ZuTypeGrep<FieldFilter, ZuFields<T>>;

template <typename T> class Table;

template <typename T_> class Object_ : public AnyObject {
  Object_() = delete;
  Object_(const Object_ &) = delete;
  Object_ &operator=(const Object_ &) = delete;
  Object_(Object_ &&) = delete;
  Object_ &operator=(Object_ &&) = delete;

public:
  using T = T_;

  Object_(Table<T> *table_, Shard shard) : AnyObject{table_, shard} { }

  Table<T> *table() const {
    return static_cast<Table<T> *>(AnyObject::table());
  }

  void *ptr_() { return &m_data[0]; }
  const void *ptr_() const { return &m_data[0]; }

  T *ptr() { return reinterpret_cast<T *>(&m_data[0]); }
  const T *ptr() const { return reinterpret_cast<const T *>(&m_data[0]); }

  ~Object_() { ptr()->~T(); }

  const T &data() const & { return *ptr(); }
  T &data() & { return *ptr(); }
  T &&data() && { return ZuMv(*ptr()); }

  void commit();
  bool abort();

  using Fields_ = Zdb_::Fields<T>;
  template <typename Base> struct Adapted : public Base {
    using Orig = Base;
    template <template <typename> typename Override>
    using Adapt = Adapted<Override<Orig>>;
    using O = Object_;

    static decltype(Orig::get(ZuDeclVal<const T &>())) get(const O &o) {
      return Orig::get(o.data());
    }
    static decltype(Orig::get(ZuDeclVal<T &>())) get(O &o) {
      return Orig::get(o.data());
    }
    static decltype(Orig::get(ZuDeclVal<T &&>())) get(O &&o) {
      return Orig::get(ZuMv(o).data());
    }
    template <typename U> static void set(O &o, U &&v) {
      return Orig::set(o.data(), ZuFwd<U>(v));
    }

  private:
    template <typename> struct CtorFilter : public ZuTrue { };
    template <unsigned J>
    struct CtorFilter<ZuFieldProp::Ctor<J>> : public ZuFalse { };

  public:
    using Props = ZuTypeGrep<CtorFilter, typename Orig::Props>;
  };
  template <typename Field> using Map = typename Field::template Adapt<Adapted>;
  using Fields = ZuTypeMap<Map, Fields_>;

  friend Object_ ZuFielded_(Object_ *);
  friend Fields ZuFields_(Object_ *);

private:
  uint8_t m_data[sizeof(T)];
}

__attribute__((aligned(alignof(T_))));

template <typename T>
using Cache = ZmPolyCache<Object_<T>, ZmPolyCacheHeapID<ZdbHeapID<T>::id>>;

template <typename T> struct Object : public Cache<T>::Node {
  using Base = Cache<T>::Node;
  using Base::Base;
  using Base::operator=;
  using Object_<T>::data;
};

struct TableCf {
  using ThreadArray = ZtArray<ZtString>;
  using SIDArray = ZtArray<unsigned>;

  ZtString id;
  unsigned nShards = 1;
  ThreadArray threads;
  mutable SIDArray sids = 0;
  int cacheMode = CacheMode::Normal;

  class InvalidNThreads : public ZvError {
  public:
    InvalidNThreads(unsigned nThreads, unsigned nShards) :
      m_nThreads{nThreads}, m_nShards{nShards} { }

    void print_(ZuVStream &s) const {
      s << "invalid threads array size " << m_nThreads << " (" << m_nShards
	<< " shards)";
    }

  private:
    unsigned m_nThreads;
    unsigned m_nShards;
  };

  TableCf() = default;
  TableCf(ZtString id_) : id{ZuMv(id_)} { }
  TableCf(ZtString id_, const ZvCf *cf) : id{ZuMv(id_)} {
    nShards = cf->getScalar<unsigned>("shards", 1, 64, 1);
    const auto &threads_ = cf->getStrArray("threads");
    if (threads_) {
      auto nThreads = threads_.length();

      if ((nThreads & (nThreads - 1)) || nThreads > nShards)
	throw InvalidNThreads{nThreads, nShards};
      threads = threads_;
    }
    cacheMode = cf->getEnum<CacheMode::Map>("cacheMode", CacheMode::Normal);
  }

  static const ZtString &IDAxor(const TableCf &cf) { return cf.id; }
};

inline constexpr const char *TableCfs_HeapID() { return "Zdb.TableCf"; }
using TableCfs = ZmRBTree<
  TableCf,
  ZmRBTreeKey<
    TableCf::IDAxor, ZmRBTreeUnique<true, ZmRBTreeHeapID<TableCfs_HeapID>>>>;

class AnyTable : public ZmPolymorph {
  friend DB;
  friend Cxn_;
  friend AnyObject;
  friend Record_Print;

protected:
  AnyTable(DB *db, TableCf *cf, IOBufAllocFn);

public:
  ~AnyTable();

private:
  template <typename L> void open(L l);
  bool opened(OpenResult);
  template <typename L> void close(L l);

protected:
  void warmup() { m_storeTbl->warmup(); }

public:
  DB *db() const { return m_db; }
  ZiMultiplex *mx() const { return m_mx; }
  const TableCf &config() const { return *m_cf; }
  IOBufAllocFn bufAllocFn() const { return m_bufAllocFn; }

  static const ZtString &IDAxor(AnyTable *table) { return table->config().id; }

  const ZtString &id() const { return config().id; }
  auto sid(Shard shard) const {
    const auto &config = this->config();
    return config.sids[shard & (config.sids.length() - 1)];
  }

  template <typename... Args> void run(Shard shard, Args &&...args) const {
    m_mx->run(sid(shard), ZuFwd<Args>(args)...);
  }
  template <typename... Args> void invoke(Shard shard, Args &&...args) const {
    m_mx->invoke(sid(shard), ZuFwd<Args>(args)...);
  }
  bool invoked(Shard shard) const { return m_mx->invoked(sid(shard)); }

  uint64_t count() const { return m_count.load_(); }

  ZmRef<IOBuf> allocBuf() { return m_bufAllocFn(); }

private:
  IOBuf *findBufUN(Shard shard, UN un) {
    return static_cast<IOBuf *>(m_bufCacheUN[shard]->find(un));
  }

protected:
  void cacheBufUN(Shard shard, IOBuf *buf) {
    m_bufCacheUN[shard]->addNode(buf);
  }
  auto evictBufUN(Shard shard, UN un) { return m_bufCacheUN[shard]->del(un); }

public:
  UN nextUN(Shard shard) const { return m_nextUN[shard]; }

  void writeCache(bool enabled) { m_writeCache = enabled; }

protected:
  virtual Zfb::Offset<void> objSave(Zfb::Builder &, const void *) const = 0;
  virtual Zfb::Offset<void> objSaveUpd(Zfb::Builder &, const void *) const = 0;
  virtual Zfb::Offset<void> objSaveDel(Zfb::Builder &, const void *) const = 0;

  virtual void objRecover(const fbs::Record *) = 0;

  virtual ZtVFieldArray objFields() const = 0;

  virtual ZtVKeyFieldArray objKeyFields() const = 0;

  virtual const reflection::Schema *objSchema() const = 0;

  virtual void objPrint(ZuVStream &, const void *) const = 0;

  virtual void objPrintFB(ZuVStream &, ZuBytes) const = 0;

  virtual void cacheBuf_(Shard shard, ZmRef<const IOBuf>) = 0;
  virtual ZmRef<const IOBuf> evictBuf_(Shard shard, IOBuf *) = 0;

  virtual void cacheStats(Shard shard, ZmCacheStats &stats) const = 0;

public:
  Zfb::Offset<void> telemetry(Zfb::Builder &fbb, bool update) const;

protected:
  bool writeCache() const { return m_writeCache; }

  auto findUN(Shard shard, UN un) const {
    return m_cacheUN[shard]->findVal(un);
  }
  void cacheUN(Shard shard, UN un, AnyObject *object) {
    m_cacheUN[shard]->add(un, object);
  }
  void evictUN(Shard shard, UN un) { m_cacheUN[shard]->del(un); }

  StoreTbl *storeTbl() const { return m_storeTbl; }

protected:
  void cacheBuf(Shard shard, ZmRef<const IOBuf>);

  void evictBuf(Shard shard, UN un);

  void write(Shard shard, ZmRef<const IOBuf> buf, bool active);

  void incCount() { ++m_count; }
  void decCount() { --m_count; }

private:
  void store(Shard shard, ZmRef<const IOBuf>);
  void store_(Shard shard, ZmRef<const IOBuf>);
  void committed(ZmRef<const IOBuf>, CommitResult);

  void recSend(ZmRef<Cxn> cxn, Shard shard, UN un, UN endUN);
  void recSend_(
    ZmRef<Cxn> cxn, Shard shard, UN un, UN endUN, ZmRef<const IOBuf> buf
  );
  void recNext(ZmRef<Cxn> cxn, Shard shard, UN un, UN endUN);
  ZmRef<const IOBuf> mkBuf(Shard shard, UN un);
  void commitSend(Shard shard, UN un);

  void repRecordRcvd(Shard shard, ZmRef<const IOBuf> buf);
  void repCommitRcvd(Shard shard, UN un);

  void recover(Shard shard, const fbs::Record *record);

  bool allocUN(Shard shard, UN un) {
    if (__builtin_expect(!!(un != m_nextUN[shard]), 0)) return false;
    ++m_nextUN[shard];
    return true;
  }
  void recoveredUN(Shard shard, UN un) {
    if (__builtin_expect(!!(un == nullUN()), 0)) return;
    if (m_nextUN[shard] <= un) m_nextUN[shard] = un + 1;
  }

  DB *m_db;
  const TableCf *m_cf;
  ZiMultiplex *m_mx;

  ZtArray<ZmAtomic<UN>> m_nextUN;

  ZmAtomic<unsigned> m_open = 0;
  ZmAtomic<uint64_t> m_count = 0;

  StoreTbl *m_storeTbl = nullptr;

  using CacheUNArray = ZtArray<ZmRef<CacheUN>>;
  bool m_writeCache = true;
  CacheUNArray m_cacheUN;

  using BufCacheUNArray = ZtArray<ZmRef<BufCacheUN>>;
  BufCacheUNArray m_bufCacheUN;

  IOBufAllocFn m_bufAllocFn;
};

template <typename T_> struct Buf_ : public ZmPolymorph {
  ZmRef<const IOBuf> buf;
  bool stale = false;

  Buf_(ZmRef<const IOBuf> buf_) : buf{ZuMv(buf_)} { buf->typed = this; }

  using T = T_;
  using FB = ZfbType<T>;
  const FB *fbo() const {
    auto record = record_(msg_(buf->hdr()));
    auto data = Zfb::Load::bytes(record->data());
    return ZfbField::verify<T>(data);
  }
  const FB *fbo_() const {
    auto record = record_(msg_(buf->hdr()));
    auto data = Zfb::Load::bytes(record->data());
    return ZfbField::root<T>(&data[0]);
  }

  using Fields_ = Zdb_::Fields<FB>;
  template <typename Base> struct Adapted : public Base {
    using Orig = Base;
    template <template <typename> typename Override>
    using Adapt = Adapted<Override<Orig>>;
    using O = Buf_;
    enum { ReadOnly = true };

    static decltype(Orig::get(ZuDeclVal<const FB &>())) get(const O &o) {
      return Orig::get(*(o.fbo_()));
    }
    template <typename U> static void set(O &, U &&);
  };
  template <typename Field> using Map = typename Field::template Adapt<Adapted>;
  using Fields = ZuTypeMap<Map, Fields_>;

  friend Buf_ ZuFielded_(Buf_ *);
  friend Fields ZuFields_(Buf_ *);

  friend ZtFieldPrint ZuPrintType(Buf_ *);
};

inline constexpr const char *Buf_HeapID() { return "Zdb.Buf"; }

template <typename T>
using BufCache = ZmPolyHash<Buf_<T>, ZmPolyHashHeapID<ZdbBufHeapID<T>::id>>;

template <typename T> struct Buf : public BufCache<T>::Node {
  using Base = BufCache<T>::Node;
  using Base::Base;
};

struct Count__ {
  using Result = ZuUnion<void, uint64_t>;

  ZmFn<void(Result)> fn;
};
inline constexpr const char *Count_HeapID() { return "Zdb.Count"; }
template <typename Heap>
struct Count_ : public Heap, public ZmPolymorph, public Count__ {
  using Base = Count__;
  using Base::Base;
  template <typename... Args>
  Count_(Args &&...args) : Base{ZuFwd<Args>(args)...} { }
};
using Count_Heap = ZmHeap<Count_HeapID, Count_<ZuEmpty>>;
using Count = Count_<Count_Heap>;

template <typename Tuple> struct Select__ {
  using Result = ZuUnion<void, Tuple>;

  ZmFn<void(Result, unsigned)> fn;
};
inline constexpr const char *Select_HeapID() { return "Zdb.Select"; }
template <typename Tuple, typename Heap>
struct Select_ : public Heap, public ZmPolymorph, public Select__<Tuple> {
  using Base = Select__<Tuple>;
  using Base::Base;
  template <typename... Args>
  Select_(Args &&...args) : Base{ZuFwd<Args>(args)...} { }
};
template <typename Tuple>
using Select_Heap = ZmHeap<Select_HeapID, Select_<Tuple, ZuEmpty>>;
template <typename Tuple> using Select = Select_<Tuple, Select_Heap<Tuple>>;

template <typename T, typename Key> struct Find__ {
  Table<T> *table;
  unsigned shard;
  Key key;
  ZmFn<void(ZmRef<Object<T>>)> fn;
  ZmFn<ZmRef<Object<T>>(Table<T> *)> ctor;
};
inline constexpr const char *Find_HeapID() { return "Zdb.Find"; }
template <typename T, typename Key, typename Heap>
struct Find_ : public Heap, public ZmPolymorph, public Find__<T, Key> {
  using Base = Find__<T, Key>;
  using Base::Base;
  template <typename... Args>
  Find_(Args &&...args) : Base{ZuFwd<Args>(args)...} { }
};
template <typename T, typename Key>
using Find_Heap = ZmHeap<Find_HeapID, Find_<T, Key, ZuEmpty>>;
template <typename T, typename Key>
using Find = Find_<T, Key, Find_Heap<T, Key>>;

template <typename O, unsigned KeyID> struct SplitKey {
  using Key = ZuFieldKeyT<O, KeyID>;
  using KeyFields = ZuFields<Key>;

  template <typename Field>
  using IsGroup = ZuFieldProp::IsGroup<typename Field::Props, KeyID>;

  template <typename Field> using NotGroup = ZuBool<!IsGroup<Field>{}>;

  using GroupFields = ZuTypeGrep<IsGroup, KeyFields>;

  using GroupKey = ZuFieldTupleT<Key, ZuMkCRef, ZuDecay, GroupFields>;

  using MemberFields = ZuTypeGrep<NotGroup, KeyFields>;

  using MemberKey = ZuFieldTupleT<Key, ZuMkCRef, ZuDecay, MemberFields>;

  using IsGroupKey = ZuBool<GroupFields::N>;
};

template <typename T> class Table : public AnyTable {
  friend DB;
  friend Cxn_;
  friend Object_<T>;

public:
  enum { BufSize = ZdbBufSize<T>{} };

  using Fields = Zdb_::Fields<T>;
  using Keys = ZuFieldKeys<T>;
  using KeyIDs = ZuFieldKeyIDs<T>;
  template <int KeyID> using Key = ZuFieldKeyT<T, KeyID>;
  using Tuple = ZuFieldTuple<T>;

  static_assert((Fields::N < maxFields()), "Fields::N < maxFields()");
  static_assert((KeyIDs::N < maxKeys()), "KeyIDs::N < maxKeys()");

private:
  template <unsigned KeyID>
  using GroupKey = typename SplitKey<T, KeyID>::GroupKey;

  template <unsigned KeyID>
  using MemberKey = typename SplitKey<T, KeyID>::MemberKey;

public:
  static ZmRef<IOBuf> allocBuf() { return new IOBufAlloc<T>{}; }

  Table(DB *db, TableCf *cf) : AnyTable{db, cf, Table::allocBuf} {
    unsigned n = cf->nShards;
    ZmIDString cacheID = "Zdb.Cache.";
    cacheID << cf->id;
    ZmIDString bufCacheID = "Zdb.BufCache.";
    bufCacheID << cf->id;
    m_cache.size(n);
    m_bufCache.size(n);
    for (unsigned i = 0; i < n; i++) {
      new (m_cache.push()) Cache<T>{cacheID};
      new (m_bufCache.push()) BufCache<T>{bufCacheID};
    }
  }
  ~Table() = default;

private:
  ZmRef<Object<T>>
  objLoad(const IOBuf *buf, ZmFn<ZmRef<Object<T>>(Table *)> ctor) {
    using namespace Zfb::Load;

    auto record = record_(msg_(buf->hdr()));
    if (record->vn() < 0) return {};
    auto data = bytes(record->data());
    if (__builtin_expect(!!(!data), 0)) return {};
    auto fbo = ZfbField::root<T>(&data[0]);
    if (__builtin_expect(!!(!fbo), 0)) return {};
    ZmRef<Object<T>> object = ctor(this);
    ZfbField::ctor<T>(object->ptr(), fbo);
    object->init(
      record->shard(), record->un(), uint128(record->sn()), record->vn()
    );
    return object;
  }

  Zfb::Offset<void> objSave(Zfb::Builder &fbb, const void *ptr) const {
    return ZfbField::save<T>(fbb, *static_cast<const T *>(ptr)).Union();
  }
  Zfb::Offset<void> objSaveUpd(Zfb::Builder &fbb, const void *ptr) const {
    return ZfbField::saveUpd<T>(fbb, *static_cast<const T *>(ptr)).Union();
  }
  Zfb::Offset<void> objSaveDel(Zfb::Builder &fbb, const void *ptr) const {
    return ZfbField::saveDel<T>(fbb, *static_cast<const T *>(ptr)).Union();
  }

  void objRecover(const fbs::Record *record) {
    auto fbo = ZfbField::verify<T>(Zfb::Load::bytes(record->data()));
    if (!fbo) return;
    auto shard = record->shard();

    ZuUnroll::all<KeyIDs>([this, shard, fbo](auto KeyID) {
      auto key = ZuFieldKey<KeyID>(*fbo);
      auto i = m_bufCache[shard].template iterator<KeyID>(ZuMv(key));
      while (auto typedBuf = i.iterate()) {
	if (!typedBuf->stale) {
	  typedBuf->stale = true;
	  break;
	}
      }
    });

    if (record->vn() >= 0) {
      if constexpr (KeyIDs::N > 1)

	if (ZmRef<Object<T>> object = m_cache[shard].find(ZuFieldKey<0>(*fbo)))
	  m_cache[shard].template update<ZuTypeTail<1, KeyIDs>>(
	    ZuMv(object),
	    [fbo](const ZmRef<Object<T>> &object) {
	    ZfbField::update(object->data(), fbo);
	  }
	  );
    } else {
      m_cache[shard].template del<0>(ZuFieldKey<0>(*fbo));
    }
  }

  ZtVFieldArray objFields() const { return ZtVFields<T>(); }

  ZtVKeyFieldArray objKeyFields() const { return ZtVKeyFields<T>(); }

  const reflection::Schema *objSchema() const {
    return reflection::GetSchema(ZfbSchema<T>::data());
  }

  void objPrint(ZuVStream &s, const void *ptr) const {
    ZtFieldPrint::print(s, *static_cast<const T *>(ptr));
  }

  void objPrintFB(ZuVStream &s, ZuBytes data) const {
    auto fbo = ZfbField::verify<T>(data);
    if (!fbo) return;
    s << *fbo;
  }

  template <unsigned KeyID>
  ZuTuple<ZmRef<const IOBuf>, bool>
  findBuf(Shard shard, const Key<KeyID> &key) const {
    auto i = m_bufCache[shard].template iterator<KeyID>(key);
    bool found = false;
    while (auto typedBuf = i.iterate()) {
      if (!typedBuf->stale) return {typedBuf->buf, true};
      found = true;
    }
    return {ZmRef<const IOBuf>{}, found};
  }

  template <
    unsigned KeyID, bool UpdateLRU, bool Evict, typename L, typename Ctor>
  void find_(Shard shard, Key<KeyID>, L l, Ctor ctor);

  template <unsigned KeyID, typename L, typename Ctor>
  void retrieve(Shard shard, Key<KeyID>, L, Ctor);
  template <unsigned KeyID> void retrieve_(ZmRef<Find<T, Key<KeyID>>> context);

  void cacheBuf_(Shard shard, ZmRef<const IOBuf> buf) {
    m_bufCache[shard].add(new Buf<T>{ZuMv(buf)});
  }
  ZmRef<const IOBuf> evictBuf_(Shard shard, IOBuf *buf) {
    if (auto typedBuf = m_bufCache[shard].delNode(
	  static_cast<Buf<T> *>(static_cast<Buf_<T> *>(buf->typed))
	))
      return ZuMv(typedBuf->buf);
    return nullptr;
  }

  void cacheStats(Shard shard, ZmCacheStats &stats) const {
    m_cache[shard].stats(stats);
  }

  void warmup(ZmFn<ZmRef<Object<T>>()> ctorFn) {
    AnyTable::warmup();
    unsigned n = config().nShards;
    for (unsigned i = 0; i < n; i++)
      run(i, [this, i, ctorFn]() mutable { warmup_(i, ZuMv(ctorFn)); });
  }
  void warmup() {
    return warmup([](Table *this_) { return new Object<T>{this_}; });
  }

private:
  void warmup_(Shard shard, ZmFn<ZmRef<Object<T>>()> ctorFn) {
    ZmRef<Object<T>> object = ctorFn(this);
    object->init(shard, 0, 0, 0);
    new (object->ptr()) T{};

    m_cache[shard].add(object);
    m_cache[shard].delNode(object);

    cacheUN(shard, 0, object);
    evictUN(shard, 0);

    ZmRef<const IOBuf> buf = object->replicate(int(fbs::Body::Replication));
    cacheBuf(shard, buf);
    evictBuf(shard, 0);
  }

  template <
    unsigned KeyID, typename SelectKey, typename Tuple_, bool SelectRow,
    bool SelectNext, typename L>
  void select_(SelectKey selectKey, bool inclusive, unsigned limit, L l);

  static auto defltCtor(Shard shard) {
    return [shard](Table *this_) { return new Object<T>{this_, shard}; };
  }

public:
  uint64_t count() const { return AnyTable::count(); }

  template <unsigned KeyID, typename L>
  void count(GroupKey<KeyID> groupKey, L l);

  template <unsigned KeyID, typename L>
  void selectKeys(GroupKey<KeyID> groupKey, unsigned limit, L l) {
    select_<KeyID, GroupKey<KeyID>, Key<KeyID>, 0, 0>(
      ZuMv(groupKey), false, limit, ZuMv(l)
    );
  }
  template <unsigned KeyID, typename L>
  void nextKeys(Key<KeyID> key, bool inclusive, unsigned limit, L l) {
    select_<KeyID, Key<KeyID>, Key<KeyID>, 0, 1>(
      ZuMv(key), inclusive, limit, ZuMv(l)
    );
  }
  template <unsigned KeyID, typename L>
  void selectRows(GroupKey<KeyID> groupKey, unsigned limit, L l) {
    select_<KeyID, GroupKey<KeyID>, Tuple, 1, 0>(
      ZuMv(groupKey), false, limit, ZuMv(l)
    );
  }
  template <unsigned KeyID, typename L>
  void nextRows(Key<KeyID> key, bool inclusive, unsigned limit, L l) {
    select_<KeyID, Key<KeyID>, Tuple, 1, 1>(
      ZuMv(key), inclusive, limit, ZuMv(l)
    );
  }

  template <unsigned KeyID, typename L, typename Ctor>
  inline void find(Shard shard, Key<KeyID> key, L l, Ctor ctor) {
    config().cacheMode == CacheMode::All ?
      find_<KeyID, true, false>(shard, ZuMv(key), ZuMv(l), ZuMv(ctor)) :
      find_<KeyID, true, true>(shard, ZuMv(key), ZuMv(l), ZuMv(ctor));
  }

public:
  template <unsigned KeyID, typename L>
  inline void find(Shard shard, Key<KeyID> key, L l) {
    find<KeyID>(shard, ZuMv(key), ZuMv(l), defltCtor(shard));
  }

private:
  template <unsigned KeyID, typename L, typename Ctor>
  void findUpd_(Shard shard, Key<KeyID> key, L l, Ctor ctor) {
    config().cacheMode == CacheMode::All ?
      find_<KeyID, false, false>(shard, ZuMv(key), ZuMv(l), ZuMv(ctor)) :
      find_<KeyID, false, true>(shard, ZuMv(key), ZuMv(l), ZuMv(ctor));
  }

public:
  template <unsigned KeyID> void evict(Shard shard, const Key<KeyID> &key) {
    ((invoked(shard)) ? void() :
			ZmAssert_fail(
			  "invoked(shard)", "../../zdb/src/zlib/Zdb.hh", 1167,
			  __PRETTY_FUNCTION__
			));

    ZmRef<Object<T>> object = m_cache[shard].template del<KeyID>(key);
    if (object) {
      object->unpin();
      evictUN(shard, object->un());
      object->evict();
    }
  }
  void evict(Object<T> *object) {
    auto shard = object->shard();

    ((invoked(shard)) ? void() :
			ZmAssert_fail(
			  "invoked(shard)", "../../zdb/src/zlib/Zdb.hh", 1179,
			  __PRETTY_FUNCTION__
			));

    m_cache[shard].delNode(object);
    object->unpin();
    evictUN(shard, object->un());
    object->evict();
  }

public:
  template <typename L> void insert(ZmRef<Object<T>> object, L l) {
    auto shard = object->shard();

    ((invoked(shard)) ? void() :
			ZmAssert_fail(
			  "invoked(shard)", "../../zdb/src/zlib/Zdb.hh", 1194,
			  __PRETTY_FUNCTION__
			));

    object->insert_(nextUN(shard));
    try {
      l(object);
    } catch (...) {
      object->abort();
      throw;
    }
    object->abort();
  }

  template <typename L> void insert(UN un, ZmRef<Object<T>> object, L l) {
    auto shard = object->shard();

    ((invoked(shard)) ? void() :
			ZmAssert_fail(
			  "invoked(shard)", "../../zdb/src/zlib/Zdb.hh", 1207,
			  __PRETTY_FUNCTION__
			));

    if (un != nullUN() && __builtin_expect(!!(nextUN(shard) > un), 0)) {
      l(nullptr);
      return;
    }
    insert(ZuMv(object), ZuMv(l));
  }

  template <typename KeyIDs_ = ZuSeq<>, typename L>
  void update(ZmRef<Object<T>> object, L l) {
    auto shard = object->shard();

    ((invoked(shard)) ? void() :
			ZmAssert_fail(
			  "invoked(shard)", "../../zdb/src/zlib/Zdb.hh", 1223,
			  __PRETTY_FUNCTION__
			));

    if (!update_(object.ptr(), nextUN(object->shard()))) {
      l(nullptr);
      return;
    }
    auto bufs = ZmAlloc_<ZmRef<Buf<T>>>{static_cast<ZmRef<Buf<T>> *>(
      !(KeyIDs::N) ?
	nullptr :
	(((ZmStackAvail() >> 1) < ((KeyIDs::N) * sizeof(ZmRef<Buf<T>>))) ?
	   Zm::alignedAlloc<alignof(ZmRef<Buf<T>>)>(
	     (KeyIDs::N) * sizeof(ZmRef<Buf<T>>)
	   ) :
	   __builtin_alloca_with_align(
	     (KeyIDs::N) * sizeof(ZmRef<Buf<T>>), (alignof(ZmRef<Buf<T>>)) << 3
	   ))
    )};
    auto nBufs = 0;
    auto abort = [&object, &bufs, &nBufs]() {
      if (!object->abort()) return;
      for (unsigned i = 0; i < nBufs; i++) {
	bufs[i]->stale = false;
	bufs[i].~ZmRef<Buf<T>>();
      }
    };
    ZuUnroll::all<KeyIDs>([this, shard, &object, &bufs, &nBufs](auto KeyID) {
      auto key = ZuFieldKey<KeyID>(object->data());
      auto i = m_bufCache[shard].template iterator<KeyID>(ZuMv(key));
      while (auto typedBuf = i.iterate()) {
	if (!typedBuf->stale) {
	  typedBuf->stale = true;
	  new (&bufs[nBufs++]) ZmRef<Buf<T>>{ZuMv(typedBuf)};

	  break;
	}
      }
    });
    try {
      m_cache[shard].template update<KeyIDs_>(
	object,
	[l = ZuMv(l)](typename Cache<T>::Node *node) mutable {
	l(static_cast<Object<T> *>(node));
      }
      );
    } catch (...) {
      abort();
      throw;
    }
    abort();
  }

  template <typename KeyIDs_ = ZuSeq<>, typename L>
  void update(ZmRef<Object<T>> object, UN un, L l) {
    ((invoked(object->shard())) ?
       void() :
       ZmAssert_fail(
	 "invoked(object->shard())", "../../zdb/src/zlib/Zdb.hh", 1262,
	 __PRETTY_FUNCTION__
       ));

    if (un != nullUN() &&
	__builtin_expect(!!(nextUN(object->shard()) > un), 0)) {
      l(nullptr);
      return;
    }
    update<KeyIDs_>(ZuMv(object), ZuMv(l));
  }

  template <
    unsigned KeyID, typename KeyIDs_ = ZuSeq<>, typename L, typename Ctor>
  inline void findUpd(Shard shard, Key<KeyID> key, L l, Ctor ctor) {
    findUpd_<KeyID>(
      shard, ZuMv(key),
      [this, l = ZuMv(l)](ZmRef<Object<T>> object) mutable {
      if (__builtin_expect(!!(!object), 0)) {
	l(object);
	return;
      }
      update<KeyIDs_>(ZuMv(object), ZuMv(l));
    }, ZuMv(ctor)
    );
  }
  template <unsigned KeyID, typename KeyIDs = ZuSeq<>, typename L>
  inline void findUpd(Shard shard, Key<KeyID> key, L l) {
    findUpd<KeyID, KeyIDs>(shard, ZuMv(key), ZuMv(l), defltCtor(shard));
  }

  template <
    unsigned KeyID, typename KeyIDs_ = ZuSeq<>, typename L, typename Ctor>
  inline void findUpd(Shard shard, Key<KeyID> key, UN un, L l, Ctor ctor) {
    findUpd_<KeyID>(
      shard, ZuMv(key),
      [this, un, l = ZuMv(l)](ZmRef<Object<T>> object) mutable {
      if (__builtin_expect(!!(!object), 0)) {
	l(object);
	return;
      }
      update<KeyIDs_>(ZuMv(object), un, ZuMv(l));
    }, ZuMv(ctor)
    );
  }
  template <unsigned KeyID, typename KeyIDs_ = ZuSeq<>, typename L>
  inline void findUpd(Shard shard, Key<KeyID> key, UN un, L l) {
    findUpd<KeyID, KeyIDs>(shard, ZuMv(key), un, ZuMv(l), defltCtor(shard));
  }

  template <typename L> void del(ZmRef<Object<T>> object, L l) {
    auto shard = object->shard();

    ((invoked(shard)) ? void() :
			ZmAssert_fail(
			  "invoked(shard)", "../../zdb/src/zlib/Zdb.hh", 1307,
			  __PRETTY_FUNCTION__
			));

    if (!del_(object.ptr(), nextUN(object->shard()))) {
      l(nullptr);
      return;
    }

    auto bufs = ZmAlloc_<ZmRef<Buf<T>>>{static_cast<ZmRef<Buf<T>> *>(
      !(KeyIDs::N) ?
	nullptr :
	(((ZmStackAvail() >> 1) < ((KeyIDs::N) * sizeof(ZmRef<Buf<T>>))) ?
	   Zm::alignedAlloc<alignof(ZmRef<Buf<T>>)>(
	     (KeyIDs::N) * sizeof(ZmRef<Buf<T>>)
	   ) :
	   __builtin_alloca_with_align(
	     (KeyIDs::N) * sizeof(ZmRef<Buf<T>>), (alignof(ZmRef<Buf<T>>)) << 3
	   ))
    )};
    auto nBufs = 0;
    auto abort = [&object, &bufs, &nBufs]() {
      if (!object->abort()) return;
      for (unsigned i = 0; i < nBufs; i++) {
	bufs[i]->stale = false;
	bufs[i].~ZmRef<Buf<T>>();
      }
    };
    ZuUnroll::all<KeyIDs>([this, shard, &object, &bufs, &nBufs](auto KeyID) {
      auto key = ZuFieldKey<KeyID>(object->data());
      auto i = m_bufCache[shard].template iterator<KeyID>(ZuMv(key));
      while (auto typedBuf = i.iterate()) {
	if (!typedBuf->stale) {
	  typedBuf->stale = true;
	  new (&bufs[nBufs++]) ZmRef<Buf<T>>{ZuMv(typedBuf)};
	  break;
	}
      }
    });
    try {
      l(object);
    } catch (...) {
      abort();
      throw;
    }
    abort();
  }

  template <typename L> void del(ZmRef<AnyObject> object, UN un, L l) {
    if (un != nullUN() &&
	__builtin_expect(!!(nextUN(object->shard()) > un), 0)) {
      l(nullptr);
      return;
    }
    del(ZuMv(object), ZuMv(l));
  }

  template <unsigned KeyID, typename L, typename Ctor>
  inline void findDel(Shard shard, const Key<KeyID> &key, L l, Ctor ctor) {
    findUpd_<KeyID>(
      shard, key,
      [this, l = ZuMv(l)](ZmRef<Object<T>> object) mutable {
      if (__builtin_expect(!!(!object), 0)) {
	l(object);
	return;
      }
      del(ZuMv(object), ZuMv(l));
    }, ZuMv(ctor)
    );
  }
  template <unsigned KeyID, typename L>
  inline void findDel(Shard shard, const Key<KeyID> &key, L l) {
    findDel<KeyID>(shard, key, ZuMv(l), defltCtor(shard));
  }

  template <unsigned KeyID, typename L, typename Ctor>
  inline void
  findDel(Shard shard, const Key<KeyID> &key, UN un, L l, Ctor ctor) {
    findUpd_<KeyID>(
      shard, key,
      [this, un, l = ZuMv(l)](ZmRef<Object<T>> object) mutable {
      if (__builtin_expect(!!(!object), 0)) {
	l(object);
	return;
      }
      del(ZuMv(object), un, ZuMv(l));
    }, ZuMv(ctor)
    );
  }
  template <unsigned KeyID, typename L>
  inline void findDel(Shard shard, const Key<KeyID> &key, UN un, L l) {
    findDel<KeyID>(shard, key, un, ZuMv(l), defltCtor(shard));
  }

private:
  bool commit(AnyObject *object) {
    auto shard = object->shard();

    ((invoked(shard)) ? void() :
			ZmAssert_fail(
			  "invoked(shard)", "../../zdb/src/zlib/Zdb.hh", 1390,
			  __PRETTY_FUNCTION__
			));

    int origState = object->state();
    if (!object->commit_()) return false;
    switch (origState) {
    case ObjState::Insert:
      if (writeCache()) {
	m_cache[shard].add(object, [this](AnyObject *object) {
	  if (object->pinned()) return false;
	  evictUN(object->shard(), object->un());
	  object->evict();
	  return true;
	});
	cacheUN(shard, object->un(), object);
      }
      incCount();
      break;
    case ObjState::Update:

      if (writeCache()) cacheUN(shard, object->un(), object);
      break;
    case ObjState::Delete:

      if (m_cache[shard].delNode(static_cast<Object<T> *>(object)))
	object->evict();
      decCount();
      break;
    }
    write(shard, object->replicate(int(fbs::Body::Replication)), true);
    return true;
  }

  bool abort(AnyObject *object) {
    ((invoked(object->shard())) ?
       void() :
       ZmAssert_fail(
	 "invoked(object->shard())", "../../zdb/src/zlib/Zdb.hh", 1425,
	 __PRETTY_FUNCTION__
       ));

    return object->abort_();
  }

  bool update_(Object<T> *object, UN un) {
    evictUN(object->shard(), object->un());
    return object->update_(un);
  }

  bool del_(Object<T> *object, UN un) {
    evictUN(object->shard(), object->un());
    return object->del_(un);
  }

private:
  using CacheArray = ZtArray<Cache<T>>;
  CacheArray m_cache;

  using BufCacheArray = ZtArray<BufCache<T>>;
  BufCacheArray m_bufCache;
};

template <typename T> inline void Object_<T>::commit() {
  this->table()->commit(static_cast<AnyObject *>(this));
}
template <typename T> inline bool Object_<T>::abort() {
  return this->table()->abort(static_cast<AnyObject *>(this));
}

inline constexpr const char *Tables_HeapID() { return "Zdb.Table"; }
using Tables = ZmRBTree<
  ZmRef<AnyTable>,
  ZmRBTreeKey<
    AnyTable::IDAxor, ZmRBTreeUnique<true, ZmRBTreeHeapID<Tables_HeapID>>>>;

struct HostCf {
  ZuID id;
  int priority = 0;
  ZiIP ip;
  uint16_t port = 0;
  bool standalone = false;
  ZtString up;
  ZtString down;

  HostCf(ZuID id_) : id{id_}, standalone{true} { }
  HostCf(ZuID id_, const ZvCf *cf) : id{id_} {
    if (!(standalone = cf->getBool("standalone", false))) {
      priority = cf->getInt<true>("priority", 0, 1 << 30);
      ip = cf->get<true>("ip");
      port = cf->getInt<true>("port", 1, (1 << 16) - 1);
    }
    up = cf->get("up");
    down = cf->get("down");
  }

  static ZuID IDAxor(const HostCf &cfg) { return cfg.id; }
};

inline constexpr const char *HostCfs_HeapID() { return "Zdb.HostCf"; }
using HostCfs = ZmRBTree<
  HostCf,
  ZmRBTreeKey<
    HostCf::IDAxor, ZmRBTreeUnique<true, ZmRBTreeHeapID<HostCfs_HeapID>>>>;

class Host {
  friend Cxn_;
  friend DB;

protected:
  Host(DB *db, const HostCf *cf, unsigned dbCount);

public:
  const HostCf &config() const { return *m_cf; }

  ZuID id() const { return m_cf->id; }
  int priority() const { return m_cf->priority; }
  bool standalone() const { return m_cf->standalone; }
  ZiIP ip() const { return m_cf->ip; }
  uint16_t port() const { return m_cf->port; }

  bool voted() const { return m_voted; }
  int state() const { return m_state; }

  bool replicating() const { return m_cxn; }
  static bool replicating(const Host *host) {
    return host ? host->replicating() : false;
  }

  static const char *stateName(int);

  template <typename S> void print(S &s) const {
    s << "{id=" << id() << ", priority=" << priority() << ", voted=" << voted()
      << ", state=" << state() << ", dbState=" << dbState() << '}';
  }
  friend ZuPrintFn ZuPrintType(Host *);

  static ZuID IDAxor(const Host &h) { return h.id(); }
  static ZuTuple<int, ZuID> IndexAxor(const Host &h) {
    return ZuFwdTuple(h.priority(), h.id());
  }

  Zfb::Offset<void> telemetry(Zfb::Builder &fbb, bool update) const;

private:
  ZmRef<Cxn> cxn() const { return m_cxn; }

  void state(int s) { m_state = s; }

  const DBState &dbState() const { return m_dbState; }
  DBState &dbState() { return m_dbState; }

  bool active() const { return m_state == HostState::Active; }

  int cmp(const Host *host) const {
    if (__builtin_expect(!!(host == this), 0)) return 0;
    int i;
    if (i = m_dbState.cmp(host->m_dbState)) return i;
    if (i = ZuCmp<bool>::cmp(active(), host->active())) return i;
    return ZuCmp<int>::cmp(priority(), host->priority());
  }

  void voted(bool v) { m_voted = v; }

  void connect();
  void connectFailed(bool transient);
  void reconnect();
  void reconnect2();
  void cancelConnect();
  ZiConnection *connected(const ZiCxnInfo &ci);
  void associate(Cxn *cxn);
  void disconnected();

  void reactivate();

  DB *m_db;
  const HostCf *m_cf;
  ZiMultiplex *m_mx;

  ZmScheduler::Timer m_connectTimer;

  ZmRef<Cxn> m_cxn;
  int m_state = HostState::Instantiated;
  DBState m_dbState;
  bool m_voted = false;
};

using HostIndex = ZmRBTree<
  Host,
  ZmRBTreeNode<
    Host,
    ZmRBTreeShadow<true, ZmRBTreeKey<Host::IndexAxor, ZmRBTreeUnique<true>>>>>;
inline constexpr const char *Hosts_HeapID() { return "Zdb.Host"; }
using Hosts = ZmHash<
  HostIndex::Node,
  ZmHashNode<
    HostIndex::Node, ZmHashKey<Host::IDAxor, ZmHashHeapID<Hosts_HeapID>>>>;

typedef void (*UpFn)(DB *, Host *);

typedef void (*DownFn)(DB *, bool);

struct DBHandler {
  UpFn upFn = [](DB *, Host *) {};
  DownFn downFn = [](DB *, bool failed) {};
};

struct DBCf {
  ZmThreadName thread;
  mutable unsigned sid = 0;
  ZmRef<ZvCf> storeCf;
  TableCfs tableCfs;
  HostCfs hostCfs;
  ZuID hostID;
  unsigned nAccepts = 0;
  unsigned heartbeatFreq = 0;
  unsigned heartbeatTimeout = 0;
  unsigned reconnectFreq = 0;
  unsigned electionTimeout = 0;
  ZmHashParams cxnHash;

  bool debug = 0;

  DBCf() = default;
  DBCf(const ZvCf *cf) {
    thread = cf->get<true>("thread");
    storeCf = cf->getCf("store");
    cf->getCf<true>("tables")->all([this](ZvCfNode *node) {
      if (auto tableCf = node->getCf())
	tableCfs.addNode(new TableCfs::Node{node->key, ZuMv(tableCf)});
    });
    cf->getCf<true>("hosts")->all([this](ZvCfNode *node) {
      if (auto hostCf = node->getCf())
	hostCfs.addNode(new HostCfs::Node{node->key, ZuMv(hostCf)});
    });
    hostID = cf->get("hostID");
    nAccepts = cf->getInt("nAccepts", 1, 1 << 10, 8);
    heartbeatFreq = cf->getInt("heartbeatFreq", 1, 3600, 1);
    heartbeatTimeout = cf->getInt("heartbeatTimeout", 1, 14400, 4);
    reconnectFreq = cf->getInt("reconnectFreq", 1, 3600, 1);
    electionTimeout = cf->getInt("electionTimeout", 1, 3600, 8);

    debug = cf->getBool("debug");
  }
  DBCf(DBCf &&) = default;
  DBCf &operator=(DBCf &&) = default;

  const TableCf *tableCf(ZuCSpan id) const {
    if (auto node = tableCfs.findPtr(id)) return &node->val();
    return nullptr;
  }
  TableCf *tableCf(ZuCSpan id) {
    auto node = tableCfs.findPtr(id);
    if (!node) tableCfs.addNode(node = new TableCfs::Node{id});
    return &node->val();
  }

  const HostCf *hostCf(ZuID id) const {
    if (auto node = hostCfs.findPtr(id)) return &node->val();
    return nullptr;
  }
  HostCf *hostCf(ZuID id) {
    auto node = hostCfs.findPtr(id);
    if (!node) hostCfs.addNode(node = new HostCfs::Node{id});
    return &node->val();
  }
};

class DB : public ZmPolymorph, public ZmEngine<DB> {
  DB(const DB &);
  DB &operator=(const DB &);

public:
  using Engine = ZmEngine<DB>;

  using Engine::start;
  using Engine::stop;

  friend Engine;
  friend Cxn_;
  friend Host;
  friend AnyTable;
  friend AnyObject;

private:
  using Lock = ZmLock;
  using Guard = ZmGuard<Lock>;
  using ReadGuard = ZmReadGuard<Lock>;

private:
  static const char *CxnHash_HeapID() { return "Zdb.CxnHash"; }
  using CxnHash =
    ZmHash<ZmRef<Cxn>, ZmHashLock<ZmPLock, ZmHashHeapID<CxnHash_HeapID>>>;

public:
  bool debug() const { return m_cf.debug; }

  DB() { }
  ~DB() { }

  void init(
    DBCf config, ZiMultiplex *mx, DBHandler handler, ZmRef<Store> store = {}
  );
  void final();

  template <typename T> ZmRef<Table<T>> initTable(ZtString id) {
    return initTable_(ZuMv(id), [](DB *db, TableCf *tableCf) mutable {
      return static_cast<AnyTable *>(new Table<T>{db, tableCf});
    });
  }

private:
  ZmRef<AnyTable>
  initTable_(ZtString, ZmFn<AnyTable *(DB *, TableCf *)> ctorFn);

public:
  template <typename... Args> void run(Args &&...args) const {
    m_mx->run(m_cf.sid, ZuFwd<Args>(args)...);
  }
  template <typename... Args> void invoke(Args &&...args) const {
    m_mx->invoke(m_cf.sid, ZuFwd<Args>(args)...);
  }
  bool invoked() const { return m_mx->invoked(m_cf.sid); }

  const DBCf &config() const { return m_cf; }
  ZiMultiplex *mx() const { return m_mx; }
  auto sid() const { return config().sid; }

  int state() const {
    return __builtin_expect(!!(m_self), 1) ? m_self->state() :
					     HostState::Instantiated;
  }

private:
  void state(int n) {
    if (__builtin_expect(!!(!m_self), 0)) {
      ZeLogEvent(ZeMkEvent(
	Ze::Fatal, "../../zdb/src/zlib/Zdb.hh", 1759, __PRETTY_FUNCTION__,
	([n](auto &s) {
	s << "Zdb::state(" << HostState::name(n) << ") called out of order";
      })
      ));
      return;
    }
    m_self->state(n);
  }

public:
  bool active() const { return state() == HostState::Active; }

  Host *self() const { return m_self; }
  template <typename L> void allHosts(L l) const {
    auto i = m_hosts->readIterator();
    while (auto node = i.iterate()) l(node);
  }

  Store *store() const { return m_store; }

  void fail();

  ZmRef<AnyTable> table(ZuCSpan id) {
    ((invoked()) ?
       void() :
       ZmAssert_fail(
	 "invoked()", "../../zdb/src/zlib/Zdb.hh", 1784, __PRETTY_FUNCTION__
       ));

    return m_tables.findVal(id);
  }

  using AllFn = ZmFn<void(AnyTable *, ZmFn<void(bool)>)>;
  using AllDoneFn = ZmFn<void(DB *, bool)>;

  void all(AllFn fn, AllDoneFn doneFn = AllDoneFn{});

  Zfb::Offset<void> telemetry(Zfb::Builder &fbb, bool update) const;

private:
  void storeFailed(ZeVEvent e) {
    ZeLogEvent(ZeMkEvent(
      Ze::Fatal, "../../zdb/src/zlib/Zdb.hh", 1798, __PRETTY_FUNCTION__, ZuMv(e)
    ));
    run([this]() { fail(); });
  }

  void allDone(bool ok);

  template <typename L> void all_(L l) const {
    auto i = m_tables.readIterator();
    while (auto table = i.iterateVal()) l(table);
  }

  template <typename S> void print(S &);
  friend ZuPrintFn ZuPrintType(DB *);

  void start_();
  void stop_();
  template <typename L> bool spawn(L l) {
    if (!m_mx || !m_mx->running()) return false;
    m_mx->run(m_cf.sid, ZuMv(l));
    return true;
  }
  void wake();

  void start_1();
  void start_2();
  void stop_1();
  void stop_2();
  void stop_3();

  void holdElection();
  void deactivate(bool failed);
  void reactivate(Host *host);

  void up_(Host *oldMaster);
  void down_(bool failed);

  void listen();
  void listening(const ZiListenInfo &);
  void listenFailed(bool transient);
  void stopListening();

  bool disconnectAll();

  ZiConnection *accepted(const ZiCxnInfo &ci);
  void connected(ZmRef<Cxn> cxn);
  void disconnected(ZmRef<Cxn> cxn);
  void associate(Cxn *cxn, ZuID hostID);
  void associate(Cxn *cxn, Host *host);

  void hbRcvd(Host *host, const fbs::Heartbeat *hb);
  void vote(Host *host);

  void hbStart();
  void hbSend();
  void hbSend_();
  void hbSend_(Cxn *cxn);

  void dbStateRefresh();

  Host *setMaster();
  void setNext(Host *host);
  void setNext();

  void repStart();
  void repStop();
  void recEnd();

  bool replicate(ZmRef<const IOBuf> buf);

  void replicated(Host *host, ZuCSpan tblID, Shard shard, UN un, SN sn);

  bool isStandalone() const { return m_standalone; }

  SN allocSN() { return m_nextSN++; }
  void recoveredSN(SN sn) {
    if (__builtin_expect(!!(sn == nullSN()), 0)) return;
    m_nextSN.maximum(sn + 1);
  }

  bool repStore() const { return m_repStore; }

  DBCf m_cf;
  ZiMultiplex *m_mx = nullptr;
  ZmRef<Store> m_store;
  bool m_repStore = false;

  DBHandler m_handler;
  ZmRef<Hosts> m_hosts;
  HostIndex m_hostIndex;

  ZmAtomic<SN> m_nextSN = 0;

  Tables m_tables;
  CxnList m_cxns;
  AllFn m_allFn;
  AllDoneFn m_allDoneFn;
  unsigned m_allCount = 0;
  unsigned m_allNotOK = 0;

  bool m_appActive = false;
  Host *m_self = nullptr;
  Host *m_leader = nullptr;
  Host *m_prev = nullptr;
  Host *m_next = nullptr;
  unsigned m_recovering = 0;
  DBState m_recover{4};
  DBState m_recoverEnd{4};
  int m_nPeers = 0;

  ZuTime m_hbSendTime;

  bool m_standalone = false;

  ZmScheduler::Timer m_hbSendTimer;
  ZmScheduler::Timer m_electTimer;

  ZuID m_selfID, m_leaderID, m_prevID, m_nextID;
};

template <typename S> inline void DB::print(S &s) {
  s << "self=" << ZuPrintPtr{m_self} << '\n'
    << " prev=" << ZuPrintPtr{m_prev} << '\n'
    << " next=" << ZuPrintPtr{m_next} << '\n'
    << " recovering=" << m_recovering
    << " replicating=" << Host::replicating(m_next);

  auto i = m_hostIndex.readIterator();

  while (Host *host = i.iterate()) {
    do {
      if ((this)->debug())
	ZeLogEvent(ZeMkEvent(
	  Ze::Debug, "../../zdb/src/zlib/Zdb.hh", 1945, __PRETTY_FUNCTION__,
	  (ZtString{} << " host=" << ZuPrintPtr{host} << '\n'
		      << " leader=" << ZuPrintPtr{m_leader})
	));
    } while (0);

    if (host->voted()) {
      if (host != m_self) ++m_nPeers;
      if (!m_leader) {
	m_leader = host;
	continue;
      }
      if (host->cmp(m_leader) > 0) m_leader = host;
    }
  }
}

template <typename T>
template <unsigned KeyID, typename L>
inline void Table<T>::count(GroupKey<KeyID> key, L l) {
  using Context = Count;

  auto context = ZmMkRef(new Context{ZuMv(l)});

  using Key = GroupKey<KeyID>;

  Zfb::IOBuilder fbb{allocBuf()};
  fbb.Finish(ZfbField::SaveFieldsFn<Key, ZuFields<Key>>::save(fbb, key).Union()
  );
  auto keyBuf = fbb.buf();

  auto countFn = CountFn::mvFn(
    ZuMv(context),
    [](ZmRef<Context> context, CountResult result) {
    if (__builtin_expect(!!(result.is<Event>()), 0)) {
      ZeLogEvent(ZuMv(result).p<Event>());
      context->fn(typename Context::Result{});
      return;
    }
    context->fn(typename Context::Result{result.p<CountData>().count});
  }
  );

  storeTbl()->count(KeyID, ZuMv(keyBuf).constRef(), ZuMv(countFn));
}

template <typename T>
template <
  unsigned KeyID, typename SelectKey, typename Tuple_, bool SelectRow,
  bool SelectNext, typename L>
inline void
Table<T>::select_(SelectKey selectKey, bool inclusive, unsigned limit, L l) {
  using Context = Select<Tuple_>;

  auto context = ZmMkRef(new Context{ZuMv(l)});

  Zfb::IOBuilder fbb{allocBuf()};
  fbb.Finish(
    ZfbField::SaveFieldsFn<SelectKey, ZuFields<SelectKey>>::save(fbb, selectKey)
      .Union()
  );
  auto keyBuf = fbb.buf();

  auto tupleFn = TupleFn::mvFn(
    ZuMv(context),
    [](ZmRef<Context> context, TupleResult result) {
    if (__builtin_expect(!!(result.is<Event>()), 0)) {
      ZeLogEvent(ZuMv(result).p<Event>());
      context->fn(typename Context::Result{}, 0);
      return;
    }
    if (__builtin_expect(!!(!result.is<TupleData>()), 0)) {
      context->fn(typename Context::Result{}, 0);
      return;
    }
    auto tupleData = result.p<TupleData>();
    auto fbo = ZfbField::root<T>(tupleData.buf->data());
    auto tuple = ZfbField::ctor<Tuple_>(fbo);
    context->fn(typename Context::Result{ZuMv(tuple)}, tupleData.count);
  }
  );

  storeTbl()->select(
    SelectRow, SelectNext, inclusive, KeyID, ZuMv(keyBuf).constRef(), limit,
    ZuMv(tupleFn)
  );
}

template <typename T>
template <unsigned KeyID, bool UpdateLRU, bool Evict, typename L, typename Ctor>
inline void Table<T>::find_(Shard shard, Key<KeyID> key, L l, Ctor ctor) {
  ((invoked(shard)) ?
     void() :
     ZmAssert_fail(
       "invoked(shard)", "../../zdb/src/zlib/Zdb.hh", 2032, __PRETTY_FUNCTION__
     ));

  auto load = [this, shard, ctor = ZuMv(ctor)]<typename L_>(
		const Key<KeyID> &key, L_ l
	      ) mutable {
    auto [buf, found] = findBuf<KeyID>(shard, key);
    if (buf) {
      l(objLoad(buf, ZuMv(ctor)));
      return;
    }
    if (found) {
      l(nullptr);
      return;
    }
    retrieve<KeyID>(shard, key, ZuMv(l), ZuMv(ctor));
  };
  if constexpr (Evict) {
    m_cache[shard].template find<KeyID, UpdateLRU>(
      ZuMv(key), ZuMv(l), ZuMv(load),
      [this](AnyObject *object) {
      if (object->pinned()) return false;
      evictUN(object->shard(), object->un());
      object->evict();
      return true;
    }
    );
  } else
    m_cache[shard].template find<KeyID, UpdateLRU, false>(
      ZuMv(key), ZuMv(l), ZuMv(load)
    );
}

template <typename T>
template <unsigned KeyID, typename L, typename Ctor>
inline void Table<T>::retrieve(Shard shard, Key<KeyID> key, L l, Ctor ctor) {
  using Key_ = Key<KeyID>;
  using Context = Find<T, Key_>;

  auto context =
    ZmMkRef(new Context{this, shard, ZuMv(key), ZuMv(l), ZuMv(ctor)});

  retrieve_<KeyID>(ZuMv(context));
}
template <typename T>
template <unsigned KeyID>
inline void Table<T>::retrieve_(ZmRef<Find<T, ZuFieldKeyT<T, KeyID>>> context) {
  using Key_ = Key<KeyID>;
  using Context = Find<T, Key_>;

  Zfb::IOBuilder fbb{allocBuf()};
  fbb.Finish(ZfbField::save(fbb, context->key));
  auto keyBuf = fbb.buf();

  storeTbl()->find(
    KeyID, ZuMv(keyBuf).constRef(),
    RowFn::mvFn(
      ZuMv(context),
      [](ZmRef<Context> context, RowResult result) {
    auto table = context->table;
    if (__builtin_expect(!!(result.is<Event>()), 0)) {
      ZeLogEvent(ZuMv(result).p<Event>());
      auto db = context->table->db();
      ZeLogEvent(ZeMkEvent(
	Ze::Fatal, "../../zdb/src/zlib/Zdb.hh", 2091, __PRETTY_FUNCTION__,
	([context = ZuMv(context)](auto &s) {
	s << "Zdb find of " << context->table->id() << '/' << context->key
	  << " failed";
      })
      ));
      db->run([db]() { db->fail(); });
      return;
    }
    if (__builtin_expect(!!(result.is<RowData>()), 1)) {
      auto buf = ZuMv(ZuMv(result).p<RowData>().buf);
      auto shard = context->shard;
      table->run(
	shard,
	[table, context = ZuMv(context), buf = ZuMv(buf)]() mutable {
	ZmRef<Object<T>> object =
	  table->objLoad(ZuMv(buf), ZuMv(context->ctor));
	if (object->shard() != context->shard) {
	  auto fn = ZuMv(context->fn);

	  ZeLogEvent(ZeMkEvent(
	    Ze::Fatal, "../../zdb/src/zlib/Zdb.hh", 2111, __PRETTY_FUNCTION__,
	    ([context = ZuMv(context), object = ZuMv(object)](auto &s) {
	    s << "Zdb find of " << context->table->id() << '/' << context->key
	      << " failed: object " << *object
	      << " shard != find context shard " << context->shard;
	  })
	  ));
	  fn(nullptr);
	} else
	  context->fn(ZuMv(object));
      }
      );
    } else
      table->run(context->shard, [fn = ZuMv(context->fn)]() mutable {
	fn(nullptr);
      });
  }
    )
  );
}

template <typename S> inline void DBState::print(S &s) const {
  s << "{sn=" << ZuBoxed(sn) << " dbs=[";
  unsigned n = count_();
  if (__builtin_expect(!!(n), 1)) {
    unsigned j = 0;
    auto i = readIterator();
    while (auto state = i.iterate()) {
      if (j++) s << ',';
      s << '{' << state->template p<0>().template p<0>() << '.'
	<< ZuBoxed(state->template p<0>().template p<1>()) << ','
	<< ZuBoxed(state->template p<1>()) << '}';
    }
  }
  s << "]}";
}

struct Record_Print {
  const fbs::Record *record = nullptr;
  const AnyTable *table = nullptr;
  template <typename S> void print(S &s) const {
    auto id = Zfb::Load::str(record->table());
    auto data = Zfb::Load::bytes(record->data());
    s << "{db=" << id << " shard=" << ZuBoxed(record->shard())
      << " un=" << record->un()
      << " sn=" << ZuBoxed(Zfb::Load::uint128(record->sn()))
      << " vn=" << record->vn() << "}";
    if (data) {
      s << " data=";
      if (table) {
	ZuVStream s_{s};
	table->objPrintFB(s_, data);
      } else {
	s << "{...}";
      }
    } else {
      s << " data=(null)}";
    }
  }
  friend ZuPrintFn ZuPrintType(Record_Print *);
};

struct HB_Print {
  const fbs::Heartbeat *hb = nullptr;
  template <typename S> void print(S &s) const {
    auto id = Zfb::Load::id(hb->host());
    s << "{host=" << id << " state=" << HostState::name(hb->state())
      << " dbState=" << DBState{hb->dbState()} << "}";
  }
  friend ZuPrintFn ZuPrintType(HB_Print *);
};

template <typename S> void IOBuf_::Print::print(S &s) const {
  auto msg = Zdb_::msg(buf->ptr<Hdr>());
  if (!msg) {
    s << "corrupt{}";
    return;
  }
  if (auto record = Zdb_::record(msg)) {
    s << "record=" << Record_Print{record, table};
    return;
  }
  if (auto hb = Zdb_::hb(msg)) {
    s << "heartbeat=" << HB_Print{hb};
    return;
  }
  s << "unknown{}";
}

template <typename S> void AnyObject::print(S &s) const {
  s << "{table=" << m_table->id() << " state=" << ObjState::name(m_state)
    << " shard=" << ZuBoxed(m_shard) << " un=" << m_un << " sn=" << m_sn
    << " vn=" << m_vn;
  if (m_origUN != nullUN()) s << " origUN=" << m_origUN;
  s << " data=";
  {
    ZuVStream s_{s};
    m_table->objPrint(s_, ptr_());
  }
  s << '}';
}

} // namespace Zdb_

using ZdbAnyObject = Zdb_::AnyObject;
template <typename T> using ZdbObject = Zdb_::Object<T>;
template <typename T> using ZdbObjRef = ZmRef<ZdbObject<T>>;
namespace ZdbObjState = Zdb_::ObjState;

using ZdbAnyTable = Zdb_::AnyTable;
template <typename T> using ZdbTable = Zdb_::Table<T>;
using ZdbTableCf = Zdb_::TableCf;
template <typename T> using ZdbTblRef = ZmRef<ZdbTable<T>>;

using Zdb = Zdb_::DB;
using ZdbHandler = Zdb_::DBHandler;
using ZdbCf = Zdb_::DBCf;

using ZdbUpFn = Zdb_::UpFn;
using ZdbDownFn = Zdb_::DownFn;
using ZdbHandler = Zdb_::DBHandler;

using ZdbHost = Zdb_::Host;

static_assert(

  24

      == 24 &&

    3

      == 3 &&

    25

      == 25,
  "Non-compatible flatbuffers version included"
);

namespace Zdf { namespace DB { namespace fbs {

struct SeriesFixedSchema {
  static const uint8_t *data() {
    static const uint8_t bfbsData[2064] = {
      0x20, 0x00, 0x00, 0x00, 0x42, 0x46, 0x42, 0x53, 0x00, 0x00, 0x00, 0x00,
      0x14, 0x00, 0x2C, 0x00, 0x04, 0x00, 0x08, 0x00, 0x0C, 0x00, 0x10, 0x00,
      0x14, 0x00, 0x18, 0x00, 0x20, 0x00, 0x1C, 0x00, 0x14, 0x00, 0x00, 0x00,
      0x40, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x2C, 0x00, 0x00, 0x00,
      0x20, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00,
      0x58, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x5C, 0x00, 0x00, 0x00,
      0x90, 0x06, 0x00, 0x00, 0xF4, 0x06, 0x00, 0x00, 0xD0, 0x02, 0x00, 0x00,
      0x14, 0x04, 0x00, 0x00, 0x94, 0x04, 0x00, 0x00, 0xE8, 0x01, 0x00, 0x00,
      0x3C, 0x02, 0x00, 0x00, 0x34, 0x05, 0x00, 0x00, 0x68, 0x03, 0x00, 0x00,
      0xC4, 0x05, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0xE0, 0xF9, 0xFF, 0xFF, 0x34, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xC8, 0x06, 0x00, 0x00,
      0xF4, 0xF9, 0xFF, 0xFF, 0xC0, 0x06, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x74, 0xF9, 0xFF, 0xFF, 0x48, 0x00, 0x00, 0x00,
      0x28, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0x16, 0x00, 0x00, 0x00, 0x2F, 0x2F, 0x7A, 0x64, 0x66, 0x5F, 0x73, 0x65,
      0x72, 0x69, 0x65, 0x73, 0x5F, 0x66, 0x69, 0x78, 0x65, 0x64, 0x2E, 0x66,
      0x62, 0x73, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00,
      0x60, 0x00, 0x00, 0x00, 0xC4, 0x00, 0x00, 0x00, 0x40, 0x01, 0x00, 0x00,
      0x04, 0x01, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00,
      0x5A, 0x64, 0x66, 0x2E, 0x44, 0x42, 0x2E, 0x66, 0x62, 0x73, 0x2E, 0x53,
      0x65, 0x72, 0x69, 0x65, 0x73, 0x46, 0x69, 0x78, 0x65, 0x64, 0x00, 0x00,
      0xA0, 0xFA, 0xFF, 0xFF, 0x05, 0x00, 0x0E, 0x00, 0x18, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x68, 0xFA, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x0A,
      0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00,
      0x62, 0x6C, 0x6B, 0x5F, 0x6F, 0x66, 0x66, 0x73, 0x65, 0x74, 0x00, 0x00,
      0x6C, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x01, 0x04, 0x00, 0x0C, 0x00,
      0x28, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x10, 0x00, 0x10, 0x00,
      0x07, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00,
      0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x03, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x65, 0x70, 0x6F, 0x63,
      0x68, 0x00, 0x00, 0x00, 0x10, 0xFB, 0xFF, 0xFF, 0x03, 0x00, 0x0A, 0x00,
      0x18, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xD8, 0xFA, 0xFF, 0xFF,
      0x00, 0x00, 0x00, 0x04, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x03, 0x00, 0x00, 0x00, 0x6E, 0x64, 0x70, 0x00, 0x38, 0xFB, 0xFF, 0xFF,
      0x02, 0x00, 0x08, 0x00, 0x18, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0x00, 0xFB, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x09, 0x08, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x66, 0x69, 0x72, 0x73,
      0x74, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x14, 0x00, 0x0C, 0x00, 0x10, 0x00,
      0x08, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x1C, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x06, 0x00, 0x14, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0xE0, 0xFD, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x0D,
      0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x6E, 0x61, 0x6D, 0x65,
      0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x10, 0x00, 0x08, 0x00, 0x0C, 0x00,
      0x00, 0x00, 0x06, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,
      0x14, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x14, 0xFE, 0xFF, 0xFF,
      0x00, 0x00, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
      0x69, 0x64, 0x00, 0x00, 0x28, 0xFC, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x01,
      0x1C, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x08, 0x00, 0x00, 0x00, 0xF8, 0x04, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x10, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x5A, 0x66, 0x62, 0x2E,
      0x49, 0x44, 0x00, 0x00, 0xA8, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x01,
      0x14, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x8C, 0xFF, 0xFF, 0xFF,
      0x11, 0x04, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0x00, 0x00, 0x80, 0xFC, 0xFF, 0xFF,
      0x00, 0x00, 0x00, 0x01, 0x1C, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xA0, 0x04, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x2C, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
      0x5A, 0x66, 0x62, 0x2E, 0x49, 0x50, 0x00, 0x00, 0x1C, 0x00, 0x10, 0x00,
      0x08, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00,
      0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x24, 0x00, 0x00, 0x00,
      0x14, 0x00, 0x00, 0x00, 0x10, 0x00, 0x0C, 0x00, 0x04, 0x00, 0x05, 0x00,
      0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x08, 0x00, 0x10, 0x00, 0x00, 0x00,
      0x11, 0x04, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0x61, 0x64, 0x64, 0x72, 0x00, 0x00, 0x00, 0x00, 0x04, 0xFD, 0xFF, 0xFF,
      0x00, 0x00, 0x00, 0x01, 0x24, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x1C, 0x04, 0x00, 0x00,
      0x03, 0x00, 0x00, 0x00, 0x6C, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00,
      0x40, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x5A, 0x66, 0x62, 0x2E,
      0x44, 0x61, 0x74, 0x65, 0x54, 0x69, 0x6D, 0x65, 0x00, 0x00, 0x00, 0x00,
      0xF8, 0xFC, 0xFF, 0xFF, 0x02, 0x00, 0x08, 0x00, 0x14, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x54, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x07,
      0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x6E, 0x73, 0x65, 0x63,
      0x00, 0x00, 0x00, 0x00, 0x20, 0xFD, 0xFF, 0xFF, 0x01, 0x00, 0x04, 0x00,
      0x14, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x7C, 0xFF, 0xFF, 0xFF,
      0x00, 0x00, 0x00, 0x07, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
      0x73, 0x65, 0x63, 0x00, 0x10, 0xFD, 0xFF, 0xFF, 0x14, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x9C, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x07,
      0x01, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x6A, 0x75, 0x6C, 0x69,
      0x61, 0x6E, 0x00, 0x00, 0xB4, 0xFD, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x01,
      0x20, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
      0x10, 0x00, 0x00, 0x00, 0x6C, 0x03, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
      0x18, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
      0x5A, 0x66, 0x62, 0x2E, 0x54, 0x69, 0x6D, 0x65, 0x00, 0x00, 0x00, 0x00,
      0xE6, 0xFE, 0xFF, 0xFF, 0x00, 0x00, 0x01, 0x00, 0x08, 0x00, 0x04, 0x00,
      0x24, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x10, 0x00, 0x0C, 0x00,
      0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
      0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x01, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x6E, 0x73, 0x65, 0x63, 0x00, 0x00, 0x00, 0x00,
      0xA8, 0xFD, 0xFF, 0xFF, 0x18, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0xA0, 0xFD, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x09, 0x08, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x73, 0x65, 0x63, 0x00,
      0x4C, 0xFE, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x01, 0x20, 0x00, 0x00, 0x00,
      0x10, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
      0xD4, 0x02, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
      0x14, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x5A, 0x66, 0x62, 0x2E,
      0x44, 0x65, 0x63, 0x69, 0x6D, 0x61, 0x6C, 0x00, 0x38, 0xFE, 0xFF, 0xFF,
      0x01, 0x00, 0x08, 0x00, 0x18, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0x00, 0xFE, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x0A, 0x08, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x6C, 0x00, 0x00, 0x00,
      0x2C, 0xFE, 0xFF, 0xFF, 0x18, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0x24, 0xFE, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x0A, 0x08, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x68, 0x00, 0x00, 0x00,
      0xD0, 0xFE, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x01, 0x20, 0x00, 0x00, 0x00,
      0x10, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
      0x50, 0x02, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
      0x30, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x5A, 0x66, 0x62, 0x2E,
      0x46, 0x69, 0x78, 0x65, 0x64, 0x00, 0x1E, 0x00, 0x14, 0x00, 0x0C, 0x00,
      0x10, 0x00, 0x06, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x00,
      0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x08, 0x00, 0x07, 0x00,
      0x18, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xA4, 0xFE, 0xFF, 0xFF,
      0x00, 0x00, 0x00, 0x04, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x03, 0x00, 0x00, 0x00, 0x6E, 0x64, 0x70, 0x00, 0xD0, 0xFE, 0xFF, 0xFF,
      0x18, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xC8, 0xFE, 0xFF, 0xFF,
      0x00, 0x00, 0x00, 0x09, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x08, 0x00, 0x00, 0x00, 0x6D, 0x61, 0x6E, 0x74, 0x69, 0x73, 0x73, 0x61,
      0x00, 0x00, 0x00, 0x00, 0x7C, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x01,
      0x20, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
      0x10, 0x00, 0x00, 0x00, 0xA4, 0x01, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
      0x40, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00,
      0x5A, 0x66, 0x62, 0x2E, 0x49, 0x6E, 0x74, 0x31, 0x32, 0x38, 0x00, 0x00,
      0x68, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x08, 0x00, 0x18, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x30, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x0A,
      0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x6C, 0x00, 0x00, 0x00, 0x5C, 0xFF, 0xFF, 0xFF, 0x18, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x54, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x0A,
      0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x68, 0x00, 0x00, 0x00, 0x14, 0x00, 0x1C, 0x00, 0x08, 0x00, 0x0C, 0x00,
      0x07, 0x00, 0x10, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00,
      0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x20, 0x00, 0x00, 0x00,
      0x10, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
      0x0C, 0x01, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00,
      0x20, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x5A, 0x66, 0x62, 0x2E,
      0x55, 0x49, 0x6E, 0x74, 0x31, 0x32, 0x38, 0x00, 0x0C, 0x00, 0x10, 0x00,
      0x08, 0x00, 0x0C, 0x00, 0x04, 0x00, 0x06, 0x00, 0x0C, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x08, 0x00, 0x18, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0xD4, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x0A, 0x08, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x6C, 0x00, 0x00, 0x00,
      0x08, 0x00, 0x0C, 0x00, 0x04, 0x00, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00,
      0x28, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x10, 0x00, 0x10, 0x00,
      0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x0C, 0x00,
      0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x08, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x68, 0x00, 0x00, 0x00,
      0xAC, 0xFF, 0xFF, 0xFF, 0x18, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x6C, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x14, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x5A, 0x66, 0x62, 0x2E,
      0x42, 0x69, 0x74, 0x6D, 0x61, 0x70, 0x00, 0x00, 0x6C, 0xFF, 0xFF, 0xFF,
      0x00, 0x01, 0x04, 0x00, 0x14, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0x50, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x0E, 0x0A, 0x08, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0x00, 0x00,
      0x14, 0x00, 0x14, 0x00, 0x04, 0x00, 0x08, 0x00, 0x00, 0x00, 0x0C, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x14, 0x00, 0x00, 0x00,
      0x44, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x2F, 0x2F, 0x2E, 0x2E,
      0x2F, 0x2E, 0x2E, 0x2F, 0x2E, 0x2E, 0x2F, 0x7A, 0x66, 0x62, 0x2F, 0x73,
      0x72, 0x63, 0x2F, 0x66, 0x62, 0x73, 0x2F, 0x7A, 0x66, 0x62, 0x5F, 0x74,
      0x79, 0x70, 0x65, 0x73, 0x2E, 0x66, 0x62, 0x73, 0x00, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00,
      0x5A, 0x66, 0x62, 0x2E, 0x42, 0x79, 0x74, 0x65, 0x73, 0x00, 0x00, 0x00,
      0x1C, 0x00, 0x10, 0x00, 0x08, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x06, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x05, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x01, 0x04, 0x00,
      0x24, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x10, 0x00, 0x0C, 0x00,
      0x06, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
      0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x04, 0x01, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0x00, 0x00
    };
    return bfbsData;
  }
  static size_t size() { return 2064; }
  const uint8_t *begin() { return data(); }
  const uint8_t *end() { return data() + size(); }
};

}}} // namespace Zdf::DB::fbs

namespace Zdf { namespace DB { namespace fbs {

struct SeriesFixed;
struct SeriesFixedBuilder;

struct SeriesFixed

  final

  : private ::flatbuffers::Table {
  typedef SeriesFixedBuilder Builder;
  typedef Zdf::DB::fbs::SeriesFixedSchema BinarySchema;
  struct Traits;
  enum FlatBuffersVTableOffset

    : ::flatbuffers::voffset_t

  {
    VT_ID = 4,
    VT_NAME = 6,
    VT_FIRST = 8,
    VT_NDP = 10,
    VT_EPOCH = 12,
    VT_BLKOFFSET = 14
  };
  uint32_t id() const { return GetField<uint32_t>(VT_ID, 0); }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  int64_t first() const { return GetField<int64_t>(VT_FIRST, 0); }
  uint8_t ndp() const { return GetField<uint8_t>(VT_NDP, 0); }
  const Zfb::DateTime *epoch() const {
    return GetStruct<const Zfb::DateTime *>(VT_EPOCH);
  }
  uint64_t blkOffset() const { return GetField<uint64_t>(VT_BLKOFFSET, 0); }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
      VerifyField<uint32_t>(verifier, VT_ID, 4) &&
      VerifyOffset(verifier, VT_NAME) && verifier.VerifyString(name()) &&
      VerifyField<int64_t>(verifier, VT_FIRST, 8) &&
      VerifyField<uint8_t>(verifier, VT_NDP, 1) &&
      VerifyField<Zfb::DateTime>(verifier, VT_EPOCH, 4) &&
      VerifyField<uint64_t>(verifier, VT_BLKOFFSET, 8) && verifier.EndTable();
  }
};

struct SeriesFixedBuilder {
  typedef SeriesFixed Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(SeriesFixed::VT_ID, id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(SeriesFixed::VT_NAME, name);
  }
  void add_first(int64_t first) {
    fbb_.AddElement<int64_t>(SeriesFixed::VT_FIRST, first, 0);
  }
  void add_ndp(uint8_t ndp) {
    fbb_.AddElement<uint8_t>(SeriesFixed::VT_NDP, ndp, 0);
  }
  void add_epoch(const Zfb::DateTime *epoch) {
    fbb_.AddStruct(SeriesFixed::VT_EPOCH, epoch);
  }
  void add_blkOffset(uint64_t blkOffset) {
    fbb_.AddElement<uint64_t>(SeriesFixed::VT_BLKOFFSET, blkOffset, 0);
  }
  explicit SeriesFixedBuilder(::flatbuffers::FlatBufferBuilder &_fbb) :
    fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SeriesFixed> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SeriesFixed>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SeriesFixed> CreateSeriesFixed(
  ::flatbuffers::FlatBufferBuilder &_fbb, uint32_t id = 0,
  ::flatbuffers::Offset<::flatbuffers::String> name = 0, int64_t first = 0,
  uint8_t ndp = 0, const Zfb::DateTime *epoch = nullptr, uint64_t blkOffset = 0
) {
  SeriesFixedBuilder builder_(_fbb);
  builder_.add_blkOffset(blkOffset);
  builder_.add_first(first);
  builder_.add_epoch(epoch);
  builder_.add_name(name);
  builder_.add_id(id);
  builder_.add_ndp(ndp);
  return builder_.Finish();
}

struct SeriesFixed::Traits {
  using type = SeriesFixed;
  static constexpr auto Create = CreateSeriesFixed;
};

inline ::flatbuffers::Offset<SeriesFixed> CreateSeriesFixedDirect(
  ::flatbuffers::FlatBufferBuilder &_fbb, uint32_t id = 0,
  const char *name = nullptr, int64_t first = 0, uint8_t ndp = 0,
  const Zfb::DateTime *epoch = nullptr, uint64_t blkOffset = 0
) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return Zdf::DB::fbs::CreateSeriesFixed(
    _fbb, id, name__, first, ndp, epoch, blkOffset
  );
}

inline const Zdf::DB::fbs::SeriesFixed *GetSeriesFixed(const void *buf) {
  return ::flatbuffers::GetRoot<Zdf::DB::fbs::SeriesFixed>(buf);
}

inline const Zdf::DB::fbs::SeriesFixed *
GetSizePrefixedSeriesFixed(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Zdf::DB::fbs::SeriesFixed>(buf);
}

inline bool VerifySeriesFixedBuffer(::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Zdf::DB::fbs::SeriesFixed>(nullptr);
}

inline bool
VerifySizePrefixedSeriesFixedBuffer(::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Zdf::DB::fbs::SeriesFixed>(nullptr);
}

inline const char *SeriesFixedExtension() { return "bfbs"; }

inline void FinishSeriesFixedBuffer(
  ::flatbuffers::FlatBufferBuilder &fbb,
  ::flatbuffers::Offset<Zdf::DB::fbs::SeriesFixed> root
) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedSeriesFixedBuffer(
  ::flatbuffers::FlatBufferBuilder &fbb,
  ::flatbuffers::Offset<Zdf::DB::fbs::SeriesFixed> root
) {
  fbb.FinishSizePrefixed(root);
}

}}} // namespace Zdf::DB::fbs

static_assert(

  24

      == 24 &&

    3

      == 3 &&

    25

      == 25,
  "Non-compatible flatbuffers version included"
);

namespace Zdf { namespace DB { namespace fbs {

struct SeriesFloatSchema {
  static const uint8_t *data() {
    static const uint8_t bfbsData[2016] = {
      0x20, 0x00, 0x00, 0x00, 0x42, 0x46, 0x42, 0x53, 0x00, 0x00, 0x00, 0x00,
      0x14, 0x00, 0x28, 0x00, 0x04, 0x00, 0x08, 0x00, 0x0C, 0x00, 0x10, 0x00,
      0x14, 0x00, 0x18, 0x00, 0x20, 0x00, 0x1C, 0x00, 0x14, 0x00, 0x00, 0x00,
      0x3C, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00,
      0x1C, 0x00, 0x00, 0x00, 0x8C, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
      0x54, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x0B, 0x00, 0x00, 0x00, 0x5C, 0x00, 0x00, 0x00, 0x64, 0x06, 0x00, 0x00,
      0xC8, 0x06, 0x00, 0x00, 0xA4, 0x02, 0x00, 0x00, 0xE8, 0x03, 0x00, 0x00,
      0x68, 0x04, 0x00, 0x00, 0xBC, 0x01, 0x00, 0x00, 0x10, 0x02, 0x00, 0x00,
      0x08, 0x05, 0x00, 0x00, 0x3C, 0x03, 0x00, 0x00, 0x98, 0x05, 0x00, 0x00,
      0x02, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0x0C, 0xFA, 0xFF, 0xFF, 0x34, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x9C, 0x06, 0x00, 0x00, 0x20, 0xFA, 0xFF, 0xFF,
      0x94, 0x06, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0xA0, 0xF9, 0xFF, 0xFF, 0x44, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00,
      0x2F, 0x2F, 0x7A, 0x64, 0x66, 0x5F, 0x73, 0x65, 0x72, 0x69, 0x65, 0x73,
      0x5F, 0x66, 0x6C, 0x6F, 0x61, 0x74, 0x2E, 0x66, 0x62, 0x73, 0x00, 0x00,
      0x05, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x5C, 0x00, 0x00, 0x00,
      0x98, 0x00, 0x00, 0x00, 0x14, 0x01, 0x00, 0x00, 0xD8, 0x00, 0x00, 0x00,
      0x16, 0x00, 0x00, 0x00, 0x5A, 0x64, 0x66, 0x2E, 0x44, 0x42, 0x2E, 0x66,
      0x62, 0x73, 0x2E, 0x53, 0x65, 0x72, 0x69, 0x65, 0x73, 0x46, 0x6C, 0x6F,
      0x61, 0x74, 0x00, 0x00, 0xC8, 0xFA, 0xFF, 0xFF, 0x04, 0x00, 0x0C, 0x00,
      0x18, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x90, 0xFA, 0xFF, 0xFF,
      0x00, 0x00, 0x00, 0x0A, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x0A, 0x00, 0x00, 0x00, 0x62, 0x6C, 0x6B, 0x5F, 0x6F, 0x66, 0x66, 0x73,
      0x65, 0x74, 0x00, 0x00, 0x94, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x01,
      0x03, 0x00, 0x0A, 0x00, 0x28, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00,
      0x10, 0x00, 0x10, 0x00, 0x07, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x0C, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F,
      0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
      0x65, 0x70, 0x6F, 0x63, 0x68, 0x00, 0x00, 0x00, 0x38, 0xFB, 0xFF, 0xFF,
      0x02, 0x00, 0x08, 0x00, 0x18, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0x00, 0xFB, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x0C, 0x08, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x66, 0x69, 0x72, 0x73,
      0x74, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x14, 0x00, 0x0C, 0x00, 0x10, 0x00,
      0x08, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x1C, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x06, 0x00, 0x14, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0xE0, 0xFD, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x0D,
      0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x6E, 0x61, 0x6D, 0x65,
      0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x10, 0x00, 0x08, 0x00, 0x0C, 0x00,
      0x00, 0x00, 0x06, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,
      0x14, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x14, 0xFE, 0xFF, 0xFF,
      0x00, 0x00, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
      0x69, 0x64, 0x00, 0x00, 0x28, 0xFC, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x01,
      0x1C, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x08, 0x00, 0x00, 0x00, 0xF8, 0x04, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x10, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x5A, 0x66, 0x62, 0x2E,
      0x49, 0x44, 0x00, 0x00, 0xA8, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x01,
      0x14, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x8C, 0xFF, 0xFF, 0xFF,
      0x11, 0x04, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0x00, 0x00, 0x80, 0xFC, 0xFF, 0xFF,
      0x00, 0x00, 0x00, 0x01, 0x1C, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xA0, 0x04, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x2C, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
      0x5A, 0x66, 0x62, 0x2E, 0x49, 0x50, 0x00, 0x00, 0x1C, 0x00, 0x10, 0x00,
      0x08, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00,
      0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x24, 0x00, 0x00, 0x00,
      0x14, 0x00, 0x00, 0x00, 0x10, 0x00, 0x0C, 0x00, 0x04, 0x00, 0x05, 0x00,
      0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x08, 0x00, 0x10, 0x00, 0x00, 0x00,
      0x11, 0x04, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0x61, 0x64, 0x64, 0x72, 0x00, 0x00, 0x00, 0x00, 0x04, 0xFD, 0xFF, 0xFF,
      0x00, 0x00, 0x00, 0x01, 0x24, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x1C, 0x04, 0x00, 0x00,
      0x03, 0x00, 0x00, 0x00, 0x6C, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00,
      0x40, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x5A, 0x66, 0x62, 0x2E,
      0x44, 0x61, 0x74, 0x65, 0x54, 0x69, 0x6D, 0x65, 0x00, 0x00, 0x00, 0x00,
      0xF8, 0xFC, 0xFF, 0xFF, 0x02, 0x00, 0x08, 0x00, 0x14, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x54, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x07,
      0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x6E, 0x73, 0x65, 0x63,
      0x00, 0x00, 0x00, 0x00, 0x20, 0xFD, 0xFF, 0xFF, 0x01, 0x00, 0x04, 0x00,
      0x14, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x7C, 0xFF, 0xFF, 0xFF,
      0x00, 0x00, 0x00, 0x07, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
      0x73, 0x65, 0x63, 0x00, 0x10, 0xFD, 0xFF, 0xFF, 0x14, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x9C, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x07,
      0x01, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x6A, 0x75, 0x6C, 0x69,
      0x61, 0x6E, 0x00, 0x00, 0xB4, 0xFD, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x01,
      0x20, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
      0x10, 0x00, 0x00, 0x00, 0x6C, 0x03, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
      0x18, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
      0x5A, 0x66, 0x62, 0x2E, 0x54, 0x69, 0x6D, 0x65, 0x00, 0x00, 0x00, 0x00,
      0xE6, 0xFE, 0xFF, 0xFF, 0x00, 0x00, 0x01, 0x00, 0x08, 0x00, 0x04, 0x00,
      0x24, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x10, 0x00, 0x0C, 0x00,
      0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
      0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x01, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x6E, 0x73, 0x65, 0x63, 0x00, 0x00, 0x00, 0x00,
      0xA8, 0xFD, 0xFF, 0xFF, 0x18, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0xA0, 0xFD, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x09, 0x08, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x73, 0x65, 0x63, 0x00,
      0x4C, 0xFE, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x01, 0x20, 0x00, 0x00, 0x00,
      0x10, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
      0xD4, 0x02, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
      0x14, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x5A, 0x66, 0x62, 0x2E,
      0x44, 0x65, 0x63, 0x69, 0x6D, 0x61, 0x6C, 0x00, 0x38, 0xFE, 0xFF, 0xFF,
      0x01, 0x00, 0x08, 0x00, 0x18, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0x00, 0xFE, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x0A, 0x08, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x6C, 0x00, 0x00, 0x00,
      0x2C, 0xFE, 0xFF, 0xFF, 0x18, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0x24, 0xFE, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x0A, 0x08, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x68, 0x00, 0x00, 0x00,
      0xD0, 0xFE, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x01, 0x20, 0x00, 0x00, 0x00,
      0x10, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
      0x50, 0x02, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
      0x30, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x5A, 0x66, 0x62, 0x2E,
      0x46, 0x69, 0x78, 0x65, 0x64, 0x00, 0x1E, 0x00, 0x14, 0x00, 0x0C, 0x00,
      0x10, 0x00, 0x06, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x00,
      0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x08, 0x00, 0x07, 0x00,
      0x18, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xA4, 0xFE, 0xFF, 0xFF,
      0x00, 0x00, 0x00, 0x04, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x03, 0x00, 0x00, 0x00, 0x6E, 0x64, 0x70, 0x00, 0xD0, 0xFE, 0xFF, 0xFF,
      0x18, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xC8, 0xFE, 0xFF, 0xFF,
      0x00, 0x00, 0x00, 0x09, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x08, 0x00, 0x00, 0x00, 0x6D, 0x61, 0x6E, 0x74, 0x69, 0x73, 0x73, 0x61,
      0x00, 0x00, 0x00, 0x00, 0x7C, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x01,
      0x20, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
      0x10, 0x00, 0x00, 0x00, 0xA4, 0x01, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
      0x40, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00,
      0x5A, 0x66, 0x62, 0x2E, 0x49, 0x6E, 0x74, 0x31, 0x32, 0x38, 0x00, 0x00,
      0x68, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x08, 0x00, 0x18, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x30, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x0A,
      0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x6C, 0x00, 0x00, 0x00, 0x5C, 0xFF, 0xFF, 0xFF, 0x18, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x54, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x0A,
      0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x68, 0x00, 0x00, 0x00, 0x14, 0x00, 0x1C, 0x00, 0x08, 0x00, 0x0C, 0x00,
      0x07, 0x00, 0x10, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00,
      0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x20, 0x00, 0x00, 0x00,
      0x10, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
      0x0C, 0x01, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00,
      0x20, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x5A, 0x66, 0x62, 0x2E,
      0x55, 0x49, 0x6E, 0x74, 0x31, 0x32, 0x38, 0x00, 0x0C, 0x00, 0x10, 0x00,
      0x08, 0x00, 0x0C, 0x00, 0x04, 0x00, 0x06, 0x00, 0x0C, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x08, 0x00, 0x18, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0xD4, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x0A, 0x08, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x6C, 0x00, 0x00, 0x00,
      0x08, 0x00, 0x0C, 0x00, 0x04, 0x00, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00,
      0x28, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x10, 0x00, 0x10, 0x00,
      0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x0C, 0x00,
      0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x08, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x68, 0x00, 0x00, 0x00,
      0xAC, 0xFF, 0xFF, 0xFF, 0x18, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x6C, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x14, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x5A, 0x66, 0x62, 0x2E,
      0x42, 0x69, 0x74, 0x6D, 0x61, 0x70, 0x00, 0x00, 0x6C, 0xFF, 0xFF, 0xFF,
      0x00, 0x01, 0x04, 0x00, 0x14, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0x50, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x0E, 0x0A, 0x08, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0x00, 0x00,
      0x14, 0x00, 0x14, 0x00, 0x04, 0x00, 0x08, 0x00, 0x00, 0x00, 0x0C, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x14, 0x00, 0x00, 0x00,
      0x44, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x2F, 0x2F, 0x2E, 0x2E,
      0x2F, 0x2E, 0x2E, 0x2F, 0x2E, 0x2E, 0x2F, 0x7A, 0x66, 0x62, 0x2F, 0x73,
      0x72, 0x63, 0x2F, 0x66, 0x62, 0x73, 0x2F, 0x7A, 0x66, 0x62, 0x5F, 0x74,
      0x79, 0x70, 0x65, 0x73, 0x2E, 0x66, 0x62, 0x73, 0x00, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00,
      0x5A, 0x66, 0x62, 0x2E, 0x42, 0x79, 0x74, 0x65, 0x73, 0x00, 0x00, 0x00,
      0x1C, 0x00, 0x10, 0x00, 0x08, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x06, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x05, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x01, 0x04, 0x00,
      0x24, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x10, 0x00, 0x0C, 0x00,
      0x06, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
      0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x04, 0x01, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0x00, 0x00
    };
    return bfbsData;
  }
  static size_t size() { return 2016; }
  const uint8_t *begin() { return data(); }
  const uint8_t *end() { return data() + size(); }
};

}}} // namespace Zdf::DB::fbs

namespace Zdf { namespace DB { namespace fbs {

struct SeriesFloat;
struct SeriesFloatBuilder;

struct SeriesFloat

  final

  : private ::flatbuffers::Table {
  typedef SeriesFloatBuilder Builder;
  typedef Zdf::DB::fbs::SeriesFloatSchema BinarySchema;
  struct Traits;
  enum FlatBuffersVTableOffset

    : ::flatbuffers::voffset_t

  {
    VT_ID = 4,
    VT_NAME = 6,
    VT_FIRST = 8,
    VT_EPOCH = 10,
    VT_BLKOFFSET = 12
  };
  uint32_t id() const { return GetField<uint32_t>(VT_ID, 0); }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  double first() const { return GetField<double>(VT_FIRST, 0.0); }
  const Zfb::DateTime *epoch() const {
    return GetStruct<const Zfb::DateTime *>(VT_EPOCH);
  }
  uint64_t blkOffset() const { return GetField<uint64_t>(VT_BLKOFFSET, 0); }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
      VerifyField<uint32_t>(verifier, VT_ID, 4) &&
      VerifyOffset(verifier, VT_NAME) && verifier.VerifyString(name()) &&
      VerifyField<double>(verifier, VT_FIRST, 8) &&
      VerifyField<Zfb::DateTime>(verifier, VT_EPOCH, 4) &&
      VerifyField<uint64_t>(verifier, VT_BLKOFFSET, 8) && verifier.EndTable();
  }
};

struct SeriesFloatBuilder {
  typedef SeriesFloat Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(SeriesFloat::VT_ID, id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(SeriesFloat::VT_NAME, name);
  }
  void add_first(double first) {
    fbb_.AddElement<double>(SeriesFloat::VT_FIRST, first, 0.0);
  }
  void add_epoch(const Zfb::DateTime *epoch) {
    fbb_.AddStruct(SeriesFloat::VT_EPOCH, epoch);
  }
  void add_blkOffset(uint64_t blkOffset) {
    fbb_.AddElement<uint64_t>(SeriesFloat::VT_BLKOFFSET, blkOffset, 0);
  }
  explicit SeriesFloatBuilder(::flatbuffers::FlatBufferBuilder &_fbb) :
    fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SeriesFloat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SeriesFloat>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SeriesFloat> CreateSeriesFloat(
  ::flatbuffers::FlatBufferBuilder &_fbb, uint32_t id = 0,
  ::flatbuffers::Offset<::flatbuffers::String> name = 0, double first = 0.0,
  const Zfb::DateTime *epoch = nullptr, uint64_t blkOffset = 0
) {
  SeriesFloatBuilder builder_(_fbb);
  builder_.add_blkOffset(blkOffset);
  builder_.add_first(first);
  builder_.add_epoch(epoch);
  builder_.add_name(name);
  builder_.add_id(id);
  return builder_.Finish();
}

struct SeriesFloat::Traits {
  using type = SeriesFloat;
  static constexpr auto Create = CreateSeriesFloat;
};

inline ::flatbuffers::Offset<SeriesFloat> CreateSeriesFloatDirect(
  ::flatbuffers::FlatBufferBuilder &_fbb, uint32_t id = 0,
  const char *name = nullptr, double first = 0.0,
  const Zfb::DateTime *epoch = nullptr, uint64_t blkOffset = 0
) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return Zdf::DB::fbs::CreateSeriesFloat(
    _fbb, id, name__, first, epoch, blkOffset
  );
}

inline const Zdf::DB::fbs::SeriesFloat *GetSeriesFloat(const void *buf) {
  return ::flatbuffers::GetRoot<Zdf::DB::fbs::SeriesFloat>(buf);
}

inline const Zdf::DB::fbs::SeriesFloat *
GetSizePrefixedSeriesFloat(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Zdf::DB::fbs::SeriesFloat>(buf);
}

inline bool VerifySeriesFloatBuffer(::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Zdf::DB::fbs::SeriesFloat>(nullptr);
}

inline bool
VerifySizePrefixedSeriesFloatBuffer(::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Zdf::DB::fbs::SeriesFloat>(nullptr);
}

inline const char *SeriesFloatExtension() { return "bfbs"; }

inline void FinishSeriesFloatBuffer(
  ::flatbuffers::FlatBufferBuilder &fbb,
  ::flatbuffers::Offset<Zdf::DB::fbs::SeriesFloat> root
) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedSeriesFloatBuffer(
  ::flatbuffers::FlatBufferBuilder &fbb,
  ::flatbuffers::Offset<Zdf::DB::fbs::SeriesFloat> root
) {
  fbb.FinishSizePrefixed(root);
}

}}} // namespace Zdf::DB::fbs

static_assert(

  24

      == 24 &&

    3

      == 3 &&

    25

      == 25,
  "Non-compatible flatbuffers version included"
);

namespace Zdf { namespace DB { namespace fbs {

struct BlkFixedSchema {
  static const uint8_t *data() {
    static const uint8_t bfbsData[2016] = {
      0x20, 0x00, 0x00, 0x00, 0x42, 0x46, 0x42, 0x53, 0x00, 0x00, 0x00, 0x00,
      0x14, 0x00, 0x2C, 0x00, 0x04, 0x00, 0x08, 0x00, 0x0C, 0x00, 0x10, 0x00,
      0x14, 0x00, 0x18, 0x00, 0x20, 0x00, 0x1C, 0x00, 0x14, 0x00, 0x00, 0x00,
      0x40, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x2C, 0x00, 0x00, 0x00,
      0x20, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00,
      0x58, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x5C, 0x00, 0x00, 0x00,
      0x60, 0x06, 0x00, 0x00, 0xC4, 0x06, 0x00, 0x00, 0xA0, 0x02, 0x00, 0x00,
      0xE4, 0x03, 0x00, 0x00, 0x64, 0x04, 0x00, 0x00, 0xB8, 0x01, 0x00, 0x00,
      0x0C, 0x02, 0x00, 0x00, 0x04, 0x05, 0x00, 0x00, 0x38, 0x03, 0x00, 0x00,
      0x94, 0x05, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x10, 0xFA, 0xFF, 0xFF, 0x34, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x98, 0x06, 0x00, 0x00,
      0x24, 0xFA, 0xFF, 0xFF, 0x90, 0x06, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0xA4, 0xF9, 0xFF, 0xFF, 0x44, 0x00, 0x00, 0x00,
      0x24, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0x13, 0x00, 0x00, 0x00, 0x2F, 0x2F, 0x7A, 0x64, 0x66, 0x5F, 0x62, 0x6C,
      0x6B, 0x5F, 0x66, 0x69, 0x78, 0x65, 0x64, 0x2E, 0x66, 0x62, 0x73, 0x00,
      0x06, 0x00, 0x00, 0x00, 0x14, 0x01, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00,
      0xA8, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0xCC, 0x00, 0x00, 0x00,
      0x70, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x5A, 0x64, 0x66, 0x2E,
      0x44, 0x42, 0x2E, 0x66, 0x62, 0x73, 0x2E, 0x42, 0x6C, 0x6B, 0x46, 0x69,
      0x78, 0x65, 0x64, 0x00, 0xC8, 0xFA, 0xFF, 0xFF, 0x05, 0x00, 0x0E, 0x00,
      0x18, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x90, 0xFA, 0xFF, 0xFF,
      0x00, 0x00, 0x00, 0x04, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x03, 0x00, 0x00, 0x00, 0x6E, 0x64, 0x70, 0x00, 0xF0, 0xFA, 0xFF, 0xFF,
      0x04, 0x00, 0x0C, 0x00, 0x18, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0xB8, 0xFA, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x06, 0x02, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x63, 0x6F, 0x75, 0x6E,
      0x74, 0x00, 0x00, 0x00, 0x1C, 0xFB, 0xFF, 0xFF, 0x03, 0x00, 0x0A, 0x00,
      0x14, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x78, 0xFD, 0xFF, 0xFF,
      0x00, 0x00, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00,
      0x73, 0x65, 0x72, 0x69, 0x65, 0x73, 0x5F, 0x69, 0x5F, 0x64, 0x00, 0x00,
      0x48, 0xFB, 0xFF, 0xFF, 0x02, 0x00, 0x08, 0x00, 0x18, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x10, 0xFB, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x09,
      0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0x6C, 0x61, 0x73, 0x74, 0x00, 0x00, 0x00, 0x00, 0x74, 0xFB, 0xFF, 0xFF,
      0x01, 0x00, 0x06, 0x00, 0x18, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0x3C, 0xFB, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x0A, 0x08, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x6F, 0x66, 0x66, 0x73,
      0x65, 0x74, 0x00, 0x00, 0x0C, 0x00, 0x10, 0x00, 0x08, 0x00, 0x0C, 0x00,
      0x00, 0x00, 0x06, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,
      0x18, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x74, 0xFB, 0xFF, 0xFF,
      0x00, 0x00, 0x00, 0x0A, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x0A, 0x00, 0x00, 0x00, 0x62, 0x6C, 0x6B, 0x5F, 0x6F, 0x66, 0x66, 0x73,
      0x65, 0x74, 0x00, 0x00, 0x28, 0xFC, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x01,
      0x1C, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x08, 0x00, 0x00, 0x00, 0xF8, 0x04, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x10, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x5A, 0x66, 0x62, 0x2E,
      0x49, 0x44, 0x00, 0x00, 0xA8, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x01,
      0x14, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x8C, 0xFF, 0xFF, 0xFF,
      0x11, 0x04, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0x00, 0x00, 0x80, 0xFC, 0xFF, 0xFF,
      0x00, 0x00, 0x00, 0x01, 0x1C, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xA0, 0x04, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x2C, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
      0x5A, 0x66, 0x62, 0x2E, 0x49, 0x50, 0x00, 0x00, 0x1C, 0x00, 0x10, 0x00,
      0x08, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00,
      0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x24, 0x00, 0x00, 0x00,
      0x14, 0x00, 0x00, 0x00, 0x10, 0x00, 0x0C, 0x00, 0x04, 0x00, 0x05, 0x00,
      0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x08, 0x00, 0x10, 0x00, 0x00, 0x00,
      0x11, 0x04, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0x61, 0x64, 0x64, 0x72, 0x00, 0x00, 0x00, 0x00, 0x04, 0xFD, 0xFF, 0xFF,
      0x00, 0x00, 0x00, 0x01, 0x24, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x1C, 0x04, 0x00, 0x00,
      0x03, 0x00, 0x00, 0x00, 0x6C, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00,
      0x40, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x5A, 0x66, 0x62, 0x2E,
      0x44, 0x61, 0x74, 0x65, 0x54, 0x69, 0x6D, 0x65, 0x00, 0x00, 0x00, 0x00,
      0xF8, 0xFC, 0xFF, 0xFF, 0x02, 0x00, 0x08, 0x00, 0x14, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x54, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x07,
      0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x6E, 0x73, 0x65, 0x63,
      0x00, 0x00, 0x00, 0x00, 0x20, 0xFD, 0xFF, 0xFF, 0x01, 0x00, 0x04, 0x00,
      0x14, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x7C, 0xFF, 0xFF, 0xFF,
      0x00, 0x00, 0x00, 0x07, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
      0x73, 0x65, 0x63, 0x00, 0x10, 0xFD, 0xFF, 0xFF, 0x14, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x9C, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x07,
      0x01, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x6A, 0x75, 0x6C, 0x69,
      0x61, 0x6E, 0x00, 0x00, 0xB4, 0xFD, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x01,
      0x20, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
      0x10, 0x00, 0x00, 0x00, 0x6C, 0x03, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
      0x18, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
      0x5A, 0x66, 0x62, 0x2E, 0x54, 0x69, 0x6D, 0x65, 0x00, 0x00, 0x00, 0x00,
      0xE6, 0xFE, 0xFF, 0xFF, 0x00, 0x00, 0x01, 0x00, 0x08, 0x00, 0x04, 0x00,
      0x24, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x10, 0x00, 0x0C, 0x00,
      0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
      0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x01, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x6E, 0x73, 0x65, 0x63, 0x00, 0x00, 0x00, 0x00,
      0xA8, 0xFD, 0xFF, 0xFF, 0x18, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0xA0, 0xFD, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x09, 0x08, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x73, 0x65, 0x63, 0x00,
      0x4C, 0xFE, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x01, 0x20, 0x00, 0x00, 0x00,
      0x10, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
      0xD4, 0x02, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
      0x14, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x5A, 0x66, 0x62, 0x2E,
      0x44, 0x65, 0x63, 0x69, 0x6D, 0x61, 0x6C, 0x00, 0x38, 0xFE, 0xFF, 0xFF,
      0x01, 0x00, 0x08, 0x00, 0x18, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0x00, 0xFE, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x0A, 0x08, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x6C, 0x00, 0x00, 0x00,
      0x2C, 0xFE, 0xFF, 0xFF, 0x18, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0x24, 0xFE, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x0A, 0x08, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x68, 0x00, 0x00, 0x00,
      0xD0, 0xFE, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x01, 0x20, 0x00, 0x00, 0x00,
      0x10, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
      0x50, 0x02, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
      0x30, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x5A, 0x66, 0x62, 0x2E,
      0x46, 0x69, 0x78, 0x65, 0x64, 0x00, 0x1E, 0x00, 0x14, 0x00, 0x0C, 0x00,
      0x10, 0x00, 0x06, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x00,
      0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x08, 0x00, 0x07, 0x00,
      0x18, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xA4, 0xFE, 0xFF, 0xFF,
      0x00, 0x00, 0x00, 0x04, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x03, 0x00, 0x00, 0x00, 0x6E, 0x64, 0x70, 0x00, 0xD0, 0xFE, 0xFF, 0xFF,
      0x18, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xC8, 0xFE, 0xFF, 0xFF,
      0x00, 0x00, 0x00, 0x09, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x08, 0x00, 0x00, 0x00, 0x6D, 0x61, 0x6E, 0x74, 0x69, 0x73, 0x73, 0x61,
      0x00, 0x00, 0x00, 0x00, 0x7C, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x01,
      0x20, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
      0x10, 0x00, 0x00, 0x00, 0xA4, 0x01, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
      0x40, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00,
      0x5A, 0x66, 0x62, 0x2E, 0x49, 0x6E, 0x74, 0x31, 0x32, 0x38, 0x00, 0x00,
      0x68, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x08, 0x00, 0x18, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x30, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x0A,
      0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x6C, 0x00, 0x00, 0x00, 0x5C, 0xFF, 0xFF, 0xFF, 0x18, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x54, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x0A,
      0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x68, 0x00, 0x00, 0x00, 0x14, 0x00, 0x1C, 0x00, 0x08, 0x00, 0x0C, 0x00,
      0x07, 0x00, 0x10, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00,
      0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x20, 0x00, 0x00, 0x00,
      0x10, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
      0x0C, 0x01, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00,
      0x20, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x5A, 0x66, 0x62, 0x2E,
      0x55, 0x49, 0x6E, 0x74, 0x31, 0x32, 0x38, 0x00, 0x0C, 0x00, 0x10, 0x00,
      0x08, 0x00, 0x0C, 0x00, 0x04, 0x00, 0x06, 0x00, 0x0C, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x08, 0x00, 0x18, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0xD4, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x0A, 0x08, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x6C, 0x00, 0x00, 0x00,
      0x08, 0x00, 0x0C, 0x00, 0x04, 0x00, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00,
      0x28, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x10, 0x00, 0x10, 0x00,
      0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x0C, 0x00,
      0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x08, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x68, 0x00, 0x00, 0x00,
      0xAC, 0xFF, 0xFF, 0xFF, 0x18, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x6C, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x14, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x5A, 0x66, 0x62, 0x2E,
      0x42, 0x69, 0x74, 0x6D, 0x61, 0x70, 0x00, 0x00, 0x6C, 0xFF, 0xFF, 0xFF,
      0x00, 0x01, 0x04, 0x00, 0x14, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0x50, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x0E, 0x0A, 0x08, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0x00, 0x00,
      0x14, 0x00, 0x14, 0x00, 0x04, 0x00, 0x08, 0x00, 0x00, 0x00, 0x0C, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x14, 0x00, 0x00, 0x00,
      0x44, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x2F, 0x2F, 0x2E, 0x2E,
      0x2F, 0x2E, 0x2E, 0x2F, 0x2E, 0x2E, 0x2F, 0x7A, 0x66, 0x62, 0x2F, 0x73,
      0x72, 0x63, 0x2F, 0x66, 0x62, 0x73, 0x2F, 0x7A, 0x66, 0x62, 0x5F, 0x74,
      0x79, 0x70, 0x65, 0x73, 0x2E, 0x66, 0x62, 0x73, 0x00, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00,
      0x5A, 0x66, 0x62, 0x2E, 0x42, 0x79, 0x74, 0x65, 0x73, 0x00, 0x00, 0x00,
      0x1C, 0x00, 0x10, 0x00, 0x08, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x06, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x05, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x01, 0x04, 0x00,
      0x24, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x10, 0x00, 0x0C, 0x00,
      0x06, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
      0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x04, 0x01, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0x00, 0x00
    };
    return bfbsData;
  }
  static size_t size() { return 2016; }
  const uint8_t *begin() { return data(); }
  const uint8_t *end() { return data() + size(); }
};

}}} // namespace Zdf::DB::fbs

namespace Zdf { namespace DB { namespace fbs {

struct BlkFixed;
struct BlkFixedBuilder;

struct BlkFixed

  final

  : private ::flatbuffers::Table {
  typedef BlkFixedBuilder Builder;
  typedef Zdf::DB::fbs::BlkFixedSchema BinarySchema;
  struct Traits;
  enum FlatBuffersVTableOffset

    : ::flatbuffers::voffset_t

  {
    VT_BLKOFFSET = 4,
    VT_OFFSET = 6,
    VT_LAST = 8,
    VT_SERIESID = 10,
    VT_COUNT = 12,
    VT_NDP = 14
  };
  uint64_t blkOffset() const { return GetField<uint64_t>(VT_BLKOFFSET, 0); }
  uint64_t offset() const { return GetField<uint64_t>(VT_OFFSET, 0); }
  int64_t last() const { return GetField<int64_t>(VT_LAST, 0); }
  uint32_t seriesID() const { return GetField<uint32_t>(VT_SERIESID, 0); }
  uint16_t count() const { return GetField<uint16_t>(VT_COUNT, 0); }
  uint8_t ndp() const { return GetField<uint8_t>(VT_NDP, 0); }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
      VerifyField<uint64_t>(verifier, VT_BLKOFFSET, 8) &&
      VerifyField<uint64_t>(verifier, VT_OFFSET, 8) &&
      VerifyField<int64_t>(verifier, VT_LAST, 8) &&
      VerifyField<uint32_t>(verifier, VT_SERIESID, 4) &&
      VerifyField<uint16_t>(verifier, VT_COUNT, 2) &&
      VerifyField<uint8_t>(verifier, VT_NDP, 1) && verifier.EndTable();
  }
};

struct BlkFixedBuilder {
  typedef BlkFixed Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_blkOffset(uint64_t blkOffset) {
    fbb_.AddElement<uint64_t>(BlkFixed::VT_BLKOFFSET, blkOffset, 0);
  }
  void add_offset(uint64_t offset) {
    fbb_.AddElement<uint64_t>(BlkFixed::VT_OFFSET, offset, 0);
  }
  void add_last(int64_t last) {
    fbb_.AddElement<int64_t>(BlkFixed::VT_LAST, last, 0);
  }
  void add_seriesID(uint32_t seriesID) {
    fbb_.AddElement<uint32_t>(BlkFixed::VT_SERIESID, seriesID, 0);
  }
  void add_count(uint16_t count) {
    fbb_.AddElement<uint16_t>(BlkFixed::VT_COUNT, count, 0);
  }
  void add_ndp(uint8_t ndp) {
    fbb_.AddElement<uint8_t>(BlkFixed::VT_NDP, ndp, 0);
  }
  explicit BlkFixedBuilder(::flatbuffers::FlatBufferBuilder &_fbb) :
    fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BlkFixed> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BlkFixed>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BlkFixed> CreateBlkFixed(
  ::flatbuffers::FlatBufferBuilder &_fbb, uint64_t blkOffset = 0,
  uint64_t offset = 0, int64_t last = 0, uint32_t seriesID = 0,
  uint16_t count = 0, uint8_t ndp = 0
) {
  BlkFixedBuilder builder_(_fbb);
  builder_.add_last(last);
  builder_.add_offset(offset);
  builder_.add_blkOffset(blkOffset);
  builder_.add_seriesID(seriesID);
  builder_.add_count(count);
  builder_.add_ndp(ndp);
  return builder_.Finish();
}

struct BlkFixed::Traits {
  using type = BlkFixed;
  static constexpr auto Create = CreateBlkFixed;
};

inline const Zdf::DB::fbs::BlkFixed *GetBlkFixed(const void *buf) {
  return ::flatbuffers::GetRoot<Zdf::DB::fbs::BlkFixed>(buf);
}

inline const Zdf::DB::fbs::BlkFixed *GetSizePrefixedBlkFixed(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Zdf::DB::fbs::BlkFixed>(buf);
}

inline bool VerifyBlkFixedBuffer(::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Zdf::DB::fbs::BlkFixed>(nullptr);
}

inline bool
VerifySizePrefixedBlkFixedBuffer(::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Zdf::DB::fbs::BlkFixed>(nullptr);
}

inline const char *BlkFixedExtension() { return "bfbs"; }

inline void FinishBlkFixedBuffer(
  ::flatbuffers::FlatBufferBuilder &fbb,
  ::flatbuffers::Offset<Zdf::DB::fbs::BlkFixed> root
) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedBlkFixedBuffer(
  ::flatbuffers::FlatBufferBuilder &fbb,
  ::flatbuffers::Offset<Zdf::DB::fbs::BlkFixed> root
) {
  fbb.FinishSizePrefixed(root);
}

}}} // namespace Zdf::DB::fbs

static_assert(

  24

      == 24 &&

    3

      == 3 &&

    25

      == 25,
  "Non-compatible flatbuffers version included"
);

namespace Zdf { namespace DB { namespace fbs {

struct BlkFloatSchema {
  static const uint8_t *data() {
    static const uint8_t bfbsData[1968] = {
      0x20, 0x00, 0x00, 0x00, 0x42, 0x46, 0x42, 0x53, 0x00, 0x00, 0x00, 0x00,
      0x14, 0x00, 0x28, 0x00, 0x04, 0x00, 0x08, 0x00, 0x0C, 0x00, 0x10, 0x00,
      0x14, 0x00, 0x18, 0x00, 0x20, 0x00, 0x1C, 0x00, 0x14, 0x00, 0x00, 0x00,
      0x3C, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00,
      0x1C, 0x00, 0x00, 0x00, 0x8C, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
      0x54, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x0B, 0x00, 0x00, 0x00, 0x5C, 0x00, 0x00, 0x00, 0x34, 0x06, 0x00, 0x00,
      0x98, 0x06, 0x00, 0x00, 0x74, 0x02, 0x00, 0x00, 0xB8, 0x03, 0x00, 0x00,
      0x38, 0x04, 0x00, 0x00, 0x8C, 0x01, 0x00, 0x00, 0xE0, 0x01, 0x00, 0x00,
      0xD8, 0x04, 0x00, 0x00, 0x0C, 0x03, 0x00, 0x00, 0x68, 0x05, 0x00, 0x00,
      0x02, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0x3C, 0xFA, 0xFF, 0xFF, 0x34, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x6C, 0x06, 0x00, 0x00, 0x50, 0xFA, 0xFF, 0xFF,
      0x64, 0x06, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0xD0, 0xF9, 0xFF, 0xFF, 0x40, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00,
      0x2F, 0x2F, 0x7A, 0x64, 0x66, 0x5F, 0x62, 0x6C, 0x6B, 0x5F, 0x66, 0x6C,
      0x6F, 0x61, 0x74, 0x2E, 0x66, 0x62, 0x73, 0x00, 0x05, 0x00, 0x00, 0x00,
      0xE8, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x7C, 0x00, 0x00, 0x00,
      0xA4, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00,
      0x5A, 0x64, 0x66, 0x2E, 0x44, 0x42, 0x2E, 0x66, 0x62, 0x73, 0x2E, 0x42,
      0x6C, 0x6B, 0x46, 0x6C, 0x6F, 0x61, 0x74, 0x00, 0xF0, 0xFA, 0xFF, 0xFF,
      0x04, 0x00, 0x0C, 0x00, 0x18, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0xB8, 0xFA, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x06, 0x02, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x63, 0x6F, 0x75, 0x6E,
      0x74, 0x00, 0x00, 0x00, 0x1C, 0xFB, 0xFF, 0xFF, 0x03, 0x00, 0x0A, 0x00,
      0x14, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x78, 0xFD, 0xFF, 0xFF,
      0x00, 0x00, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00,
      0x73, 0x65, 0x72, 0x69, 0x65, 0x73, 0x5F, 0x69, 0x5F, 0x64, 0x00, 0x00,
      0x48, 0xFB, 0xFF, 0xFF, 0x02, 0x00, 0x08, 0x00, 0x18, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x10, 0xFB, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x0C,
      0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0x6C, 0x61, 0x73, 0x74, 0x00, 0x00, 0x00, 0x00, 0x74, 0xFB, 0xFF, 0xFF,
      0x01, 0x00, 0x06, 0x00, 0x18, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0x3C, 0xFB, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x0A, 0x08, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x6F, 0x66, 0x66, 0x73,
      0x65, 0x74, 0x00, 0x00, 0x0C, 0x00, 0x10, 0x00, 0x08, 0x00, 0x0C, 0x00,
      0x00, 0x00, 0x06, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,
      0x18, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x74, 0xFB, 0xFF, 0xFF,
      0x00, 0x00, 0x00, 0x0A, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x0A, 0x00, 0x00, 0x00, 0x62, 0x6C, 0x6B, 0x5F, 0x6F, 0x66, 0x66, 0x73,
      0x65, 0x74, 0x00, 0x00, 0x28, 0xFC, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x01,
      0x1C, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x08, 0x00, 0x00, 0x00, 0xF8, 0x04, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x10, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x5A, 0x66, 0x62, 0x2E,
      0x49, 0x44, 0x00, 0x00, 0xA8, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x01,
      0x14, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x8C, 0xFF, 0xFF, 0xFF,
      0x11, 0x04, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0x00, 0x00, 0x80, 0xFC, 0xFF, 0xFF,
      0x00, 0x00, 0x00, 0x01, 0x1C, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xA0, 0x04, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x2C, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
      0x5A, 0x66, 0x62, 0x2E, 0x49, 0x50, 0x00, 0x00, 0x1C, 0x00, 0x10, 0x00,
      0x08, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00,
      0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x24, 0x00, 0x00, 0x00,
      0x14, 0x00, 0x00, 0x00, 0x10, 0x00, 0x0C, 0x00, 0x04, 0x00, 0x05, 0x00,
      0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x08, 0x00, 0x10, 0x00, 0x00, 0x00,
      0x11, 0x04, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0x61, 0x64, 0x64, 0x72, 0x00, 0x00, 0x00, 0x00, 0x04, 0xFD, 0xFF, 0xFF,
      0x00, 0x00, 0x00, 0x01, 0x24, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x1C, 0x04, 0x00, 0x00,
      0x03, 0x00, 0x00, 0x00, 0x6C, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00,
      0x40, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x5A, 0x66, 0x62, 0x2E,
      0x44, 0x61, 0x74, 0x65, 0x54, 0x69, 0x6D, 0x65, 0x00, 0x00, 0x00, 0x00,
      0xF8, 0xFC, 0xFF, 0xFF, 0x02, 0x00, 0x08, 0x00, 0x14, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x54, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x07,
      0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x6E, 0x73, 0x65, 0x63,
      0x00, 0x00, 0x00, 0x00, 0x20, 0xFD, 0xFF, 0xFF, 0x01, 0x00, 0x04, 0x00,
      0x14, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x7C, 0xFF, 0xFF, 0xFF,
      0x00, 0x00, 0x00, 0x07, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
      0x73, 0x65, 0x63, 0x00, 0x10, 0xFD, 0xFF, 0xFF, 0x14, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x9C, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x07,
      0x01, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x6A, 0x75, 0x6C, 0x69,
      0x61, 0x6E, 0x00, 0x00, 0xB4, 0xFD, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x01,
      0x20, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
      0x10, 0x00, 0x00, 0x00, 0x6C, 0x03, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
      0x18, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
      0x5A, 0x66, 0x62, 0x2E, 0x54, 0x69, 0x6D, 0x65, 0x00, 0x00, 0x00, 0x00,
      0xE6, 0xFE, 0xFF, 0xFF, 0x00, 0x00, 0x01, 0x00, 0x08, 0x00, 0x04, 0x00,
      0x24, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x10, 0x00, 0x0C, 0x00,
      0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
      0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x01, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x6E, 0x73, 0x65, 0x63, 0x00, 0x00, 0x00, 0x00,
      0xA8, 0xFD, 0xFF, 0xFF, 0x18, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0xA0, 0xFD, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x09, 0x08, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x73, 0x65, 0x63, 0x00,
      0x4C, 0xFE, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x01, 0x20, 0x00, 0x00, 0x00,
      0x10, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
      0xD4, 0x02, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
      0x14, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x5A, 0x66, 0x62, 0x2E,
      0x44, 0x65, 0x63, 0x69, 0x6D, 0x61, 0x6C, 0x00, 0x38, 0xFE, 0xFF, 0xFF,
      0x01, 0x00, 0x08, 0x00, 0x18, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0x00, 0xFE, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x0A, 0x08, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x6C, 0x00, 0x00, 0x00,
      0x2C, 0xFE, 0xFF, 0xFF, 0x18, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0x24, 0xFE, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x0A, 0x08, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x68, 0x00, 0x00, 0x00,
      0xD0, 0xFE, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x01, 0x20, 0x00, 0x00, 0x00,
      0x10, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
      0x50, 0x02, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
      0x30, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x5A, 0x66, 0x62, 0x2E,
      0x46, 0x69, 0x78, 0x65, 0x64, 0x00, 0x1E, 0x00, 0x14, 0x00, 0x0C, 0x00,
      0x10, 0x00, 0x06, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x00,
      0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x08, 0x00, 0x07, 0x00,
      0x18, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xA4, 0xFE, 0xFF, 0xFF,
      0x00, 0x00, 0x00, 0x04, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x03, 0x00, 0x00, 0x00, 0x6E, 0x64, 0x70, 0x00, 0xD0, 0xFE, 0xFF, 0xFF,
      0x18, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xC8, 0xFE, 0xFF, 0xFF,
      0x00, 0x00, 0x00, 0x09, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x08, 0x00, 0x00, 0x00, 0x6D, 0x61, 0x6E, 0x74, 0x69, 0x73, 0x73, 0x61,
      0x00, 0x00, 0x00, 0x00, 0x7C, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x01,
      0x20, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
      0x10, 0x00, 0x00, 0x00, 0xA4, 0x01, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
      0x40, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00,
      0x5A, 0x66, 0x62, 0x2E, 0x49, 0x6E, 0x74, 0x31, 0x32, 0x38, 0x00, 0x00,
      0x68, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x08, 0x00, 0x18, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x30, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x0A,
      0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x6C, 0x00, 0x00, 0x00, 0x5C, 0xFF, 0xFF, 0xFF, 0x18, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x54, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x0A,
      0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x68, 0x00, 0x00, 0x00, 0x14, 0x00, 0x1C, 0x00, 0x08, 0x00, 0x0C, 0x00,
      0x07, 0x00, 0x10, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00,
      0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x20, 0x00, 0x00, 0x00,
      0x10, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
      0x0C, 0x01, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00,
      0x20, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x5A, 0x66, 0x62, 0x2E,
      0x55, 0x49, 0x6E, 0x74, 0x31, 0x32, 0x38, 0x00, 0x0C, 0x00, 0x10, 0x00,
      0x08, 0x00, 0x0C, 0x00, 0x04, 0x00, 0x06, 0x00, 0x0C, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x08, 0x00, 0x18, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0xD4, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x0A, 0x08, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x6C, 0x00, 0x00, 0x00,
      0x08, 0x00, 0x0C, 0x00, 0x04, 0x00, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00,
      0x28, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x10, 0x00, 0x10, 0x00,
      0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x0C, 0x00,
      0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x08, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x68, 0x00, 0x00, 0x00,
      0xAC, 0xFF, 0xFF, 0xFF, 0x18, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x6C, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x14, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x5A, 0x66, 0x62, 0x2E,
      0x42, 0x69, 0x74, 0x6D, 0x61, 0x70, 0x00, 0x00, 0x6C, 0xFF, 0xFF, 0xFF,
      0x00, 0x01, 0x04, 0x00, 0x14, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0x50, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x0E, 0x0A, 0x08, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0x00, 0x00,
      0x14, 0x00, 0x14, 0x00, 0x04, 0x00, 0x08, 0x00, 0x00, 0x00, 0x0C, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x14, 0x00, 0x00, 0x00,
      0x44, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x2F, 0x2F, 0x2E, 0x2E,
      0x2F, 0x2E, 0x2E, 0x2F, 0x2E, 0x2E, 0x2F, 0x7A, 0x66, 0x62, 0x2F, 0x73,
      0x72, 0x63, 0x2F, 0x66, 0x62, 0x73, 0x2F, 0x7A, 0x66, 0x62, 0x5F, 0x74,
      0x79, 0x70, 0x65, 0x73, 0x2E, 0x66, 0x62, 0x73, 0x00, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00,
      0x5A, 0x66, 0x62, 0x2E, 0x42, 0x79, 0x74, 0x65, 0x73, 0x00, 0x00, 0x00,
      0x1C, 0x00, 0x10, 0x00, 0x08, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x06, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x05, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x01, 0x04, 0x00,
      0x24, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x10, 0x00, 0x0C, 0x00,
      0x06, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
      0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x04, 0x01, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0x00, 0x00
    };
    return bfbsData;
  }
  static size_t size() { return 1968; }
  const uint8_t *begin() { return data(); }
  const uint8_t *end() { return data() + size(); }
};

}}} // namespace Zdf::DB::fbs

namespace Zdf { namespace DB { namespace fbs {

struct BlkFloat;
struct BlkFloatBuilder;

struct BlkFloat

  final

  : private ::flatbuffers::Table {
  typedef BlkFloatBuilder Builder;
  typedef Zdf::DB::fbs::BlkFloatSchema BinarySchema;
  struct Traits;
  enum FlatBuffersVTableOffset

    : ::flatbuffers::voffset_t

  {
    VT_BLKOFFSET = 4,
    VT_OFFSET = 6,
    VT_LAST = 8,
    VT_SERIESID = 10,
    VT_COUNT = 12
  };
  uint64_t blkOffset() const { return GetField<uint64_t>(VT_BLKOFFSET, 0); }
  uint64_t offset() const { return GetField<uint64_t>(VT_OFFSET, 0); }
  double last() const { return GetField<double>(VT_LAST, 0.0); }
  uint32_t seriesID() const { return GetField<uint32_t>(VT_SERIESID, 0); }
  uint16_t count() const { return GetField<uint16_t>(VT_COUNT, 0); }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
      VerifyField<uint64_t>(verifier, VT_BLKOFFSET, 8) &&
      VerifyField<uint64_t>(verifier, VT_OFFSET, 8) &&
      VerifyField<double>(verifier, VT_LAST, 8) &&
      VerifyField<uint32_t>(verifier, VT_SERIESID, 4) &&
      VerifyField<uint16_t>(verifier, VT_COUNT, 2) && verifier.EndTable();
  }
};

struct BlkFloatBuilder {
  typedef BlkFloat Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_blkOffset(uint64_t blkOffset) {
    fbb_.AddElement<uint64_t>(BlkFloat::VT_BLKOFFSET, blkOffset, 0);
  }
  void add_offset(uint64_t offset) {
    fbb_.AddElement<uint64_t>(BlkFloat::VT_OFFSET, offset, 0);
  }
  void add_last(double last) {
    fbb_.AddElement<double>(BlkFloat::VT_LAST, last, 0.0);
  }
  void add_seriesID(uint32_t seriesID) {
    fbb_.AddElement<uint32_t>(BlkFloat::VT_SERIESID, seriesID, 0);
  }
  void add_count(uint16_t count) {
    fbb_.AddElement<uint16_t>(BlkFloat::VT_COUNT, count, 0);
  }
  explicit BlkFloatBuilder(::flatbuffers::FlatBufferBuilder &_fbb) :
    fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BlkFloat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BlkFloat>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BlkFloat> CreateBlkFloat(
  ::flatbuffers::FlatBufferBuilder &_fbb, uint64_t blkOffset = 0,
  uint64_t offset = 0, double last = 0.0, uint32_t seriesID = 0,
  uint16_t count = 0
) {
  BlkFloatBuilder builder_(_fbb);
  builder_.add_last(last);
  builder_.add_offset(offset);
  builder_.add_blkOffset(blkOffset);
  builder_.add_seriesID(seriesID);
  builder_.add_count(count);
  return builder_.Finish();
}

struct BlkFloat::Traits {
  using type = BlkFloat;
  static constexpr auto Create = CreateBlkFloat;
};

inline const Zdf::DB::fbs::BlkFloat *GetBlkFloat(const void *buf) {
  return ::flatbuffers::GetRoot<Zdf::DB::fbs::BlkFloat>(buf);
}

inline const Zdf::DB::fbs::BlkFloat *GetSizePrefixedBlkFloat(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Zdf::DB::fbs::BlkFloat>(buf);
}

inline bool VerifyBlkFloatBuffer(::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Zdf::DB::fbs::BlkFloat>(nullptr);
}

inline bool
VerifySizePrefixedBlkFloatBuffer(::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Zdf::DB::fbs::BlkFloat>(nullptr);
}

inline const char *BlkFloatExtension() { return "bfbs"; }

inline void FinishBlkFloatBuffer(
  ::flatbuffers::FlatBufferBuilder &fbb,
  ::flatbuffers::Offset<Zdf::DB::fbs::BlkFloat> root
) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedBlkFloatBuffer(
  ::flatbuffers::FlatBufferBuilder &fbb,
  ::flatbuffers::Offset<Zdf::DB::fbs::BlkFloat> root
) {
  fbb.FinishSizePrefixed(root);
}

}}} // namespace Zdf::DB::fbs

static_assert(

  24

      == 24 &&

    3

      == 3 &&

    25

      == 25,
  "Non-compatible flatbuffers version included"
);

namespace Zdf { namespace DB { namespace fbs {

struct BlkDataSchema {
  static const uint8_t *data() {
    static const uint8_t bfbsData[1896] = {
      0x20, 0x00, 0x00, 0x00, 0x42, 0x46, 0x42, 0x53, 0x00, 0x00, 0x00, 0x00,
      0x14, 0x00, 0x28, 0x00, 0x04, 0x00, 0x08, 0x00, 0x0C, 0x00, 0x10, 0x00,
      0x14, 0x00, 0x18, 0x00, 0x20, 0x00, 0x1C, 0x00, 0x14, 0x00, 0x00, 0x00,
      0x3C, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00,
      0x1C, 0x00, 0x00, 0x00, 0x8C, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
      0x54, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x0B, 0x00, 0x00, 0x00, 0x5C, 0x00, 0x00, 0x00, 0xEC, 0x05, 0x00, 0x00,
      0x50, 0x06, 0x00, 0x00, 0x2C, 0x02, 0x00, 0x00, 0x70, 0x03, 0x00, 0x00,
      0xF0, 0x03, 0x00, 0x00, 0x44, 0x01, 0x00, 0x00, 0x98, 0x01, 0x00, 0x00,
      0x90, 0x04, 0x00, 0x00, 0xC4, 0x02, 0x00, 0x00, 0x20, 0x05, 0x00, 0x00,
      0x02, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0x84, 0xFA, 0xFF, 0xFF, 0x34, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x24, 0x06, 0x00, 0x00, 0x98, 0xFA, 0xFF, 0xFF,
      0x1C, 0x06, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x18, 0xFA, 0xFF, 0xFF, 0x38, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00,
      0x2F, 0x2F, 0x7A, 0x64, 0x66, 0x5F, 0x62, 0x6C, 0x6B, 0x5F, 0x64, 0x61,
      0x74, 0x61, 0x2E, 0x66, 0x62, 0x73, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
      0xA0, 0x00, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
      0x12, 0x00, 0x00, 0x00, 0x5A, 0x64, 0x66, 0x2E, 0x44, 0x42, 0x2E, 0x66,
      0x62, 0x73, 0x2E, 0x42, 0x6C, 0x6B, 0x44, 0x61, 0x74, 0x61, 0x00, 0x00,
      0x1C, 0x00, 0x14, 0x00, 0x0C, 0x00, 0x10, 0x00, 0x08, 0x00, 0x0A, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x07, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
      0x02, 0x00, 0x08, 0x00, 0x14, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0x04, 0xFA, 0xFF, 0xFF, 0x00, 0x00, 0x0E, 0x04, 0x01, 0x00, 0x00, 0x00,
      0x03, 0x00, 0x00, 0x00, 0x62, 0x75, 0x66, 0x00, 0x74, 0xFB, 0xFF, 0xFF,
      0x01, 0x00, 0x06, 0x00, 0x14, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0xD0, 0xFD, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00,
      0x0A, 0x00, 0x00, 0x00, 0x73, 0x65, 0x72, 0x69, 0x65, 0x73, 0x5F, 0x69,
      0x5F, 0x64, 0x00, 0x00, 0x0C, 0x00, 0x10, 0x00, 0x08, 0x00, 0x0C, 0x00,
      0x00, 0x00, 0x06, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,
      0x18, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x74, 0xFB, 0xFF, 0xFF,
      0x00, 0x00, 0x00, 0x0A, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x0A, 0x00, 0x00, 0x00, 0x62, 0x6C, 0x6B, 0x5F, 0x6F, 0x66, 0x66, 0x73,
      0x65, 0x74, 0x00, 0x00, 0x28, 0xFC, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x01,
      0x1C, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x08, 0x00, 0x00, 0x00, 0xF8, 0x04, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x10, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x5A, 0x66, 0x62, 0x2E,
      0x49, 0x44, 0x00, 0x00, 0xA8, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x01,
      0x14, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x8C, 0xFF, 0xFF, 0xFF,
      0x11, 0x04, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0x00, 0x00, 0x80, 0xFC, 0xFF, 0xFF,
      0x00, 0x00, 0x00, 0x01, 0x1C, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xA0, 0x04, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x2C, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
      0x5A, 0x66, 0x62, 0x2E, 0x49, 0x50, 0x00, 0x00, 0x1C, 0x00, 0x10, 0x00,
      0x08, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00,
      0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x24, 0x00, 0x00, 0x00,
      0x14, 0x00, 0x00, 0x00, 0x10, 0x00, 0x0C, 0x00, 0x04, 0x00, 0x05, 0x00,
      0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x08, 0x00, 0x10, 0x00, 0x00, 0x00,
      0x11, 0x04, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0x61, 0x64, 0x64, 0x72, 0x00, 0x00, 0x00, 0x00, 0x04, 0xFD, 0xFF, 0xFF,
      0x00, 0x00, 0x00, 0x01, 0x24, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x1C, 0x04, 0x00, 0x00,
      0x03, 0x00, 0x00, 0x00, 0x6C, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00,
      0x40, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x5A, 0x66, 0x62, 0x2E,
      0x44, 0x61, 0x74, 0x65, 0x54, 0x69, 0x6D, 0x65, 0x00, 0x00, 0x00, 0x00,
      0xF8, 0xFC, 0xFF, 0xFF, 0x02, 0x00, 0x08, 0x00, 0x14, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x54, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x07,
      0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x6E, 0x73, 0x65, 0x63,
      0x00, 0x00, 0x00, 0x00, 0x20, 0xFD, 0xFF, 0xFF, 0x01, 0x00, 0x04, 0x00,
      0x14, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x7C, 0xFF, 0xFF, 0xFF,
      0x00, 0x00, 0x00, 0x07, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
      0x73, 0x65, 0x63, 0x00, 0x10, 0xFD, 0xFF, 0xFF, 0x14, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x9C, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x07,
      0x01, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x6A, 0x75, 0x6C, 0x69,
      0x61, 0x6E, 0x00, 0x00, 0xB4, 0xFD, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x01,
      0x20, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
      0x10, 0x00, 0x00, 0x00, 0x6C, 0x03, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
      0x18, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
      0x5A, 0x66, 0x62, 0x2E, 0x54, 0x69, 0x6D, 0x65, 0x00, 0x00, 0x00, 0x00,
      0xE6, 0xFE, 0xFF, 0xFF, 0x00, 0x00, 0x01, 0x00, 0x08, 0x00, 0x04, 0x00,
      0x24, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x10, 0x00, 0x0C, 0x00,
      0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
      0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x01, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x6E, 0x73, 0x65, 0x63, 0x00, 0x00, 0x00, 0x00,
      0xA8, 0xFD, 0xFF, 0xFF, 0x18, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0xA0, 0xFD, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x09, 0x08, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x73, 0x65, 0x63, 0x00,
      0x4C, 0xFE, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x01, 0x20, 0x00, 0x00, 0x00,
      0x10, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
      0xD4, 0x02, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
      0x14, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x5A, 0x66, 0x62, 0x2E,
      0x44, 0x65, 0x63, 0x69, 0x6D, 0x61, 0x6C, 0x00, 0x38, 0xFE, 0xFF, 0xFF,
      0x01, 0x00, 0x08, 0x00, 0x18, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0x00, 0xFE, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x0A, 0x08, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x6C, 0x00, 0x00, 0x00,
      0x2C, 0xFE, 0xFF, 0xFF, 0x18, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0x24, 0xFE, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x0A, 0x08, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x68, 0x00, 0x00, 0x00,
      0xD0, 0xFE, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x01, 0x20, 0x00, 0x00, 0x00,
      0x10, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
      0x50, 0x02, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
      0x30, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x5A, 0x66, 0x62, 0x2E,
      0x46, 0x69, 0x78, 0x65, 0x64, 0x00, 0x1E, 0x00, 0x14, 0x00, 0x0C, 0x00,
      0x10, 0x00, 0x06, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x00,
      0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x08, 0x00, 0x07, 0x00,
      0x18, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xA4, 0xFE, 0xFF, 0xFF,
      0x00, 0x00, 0x00, 0x04, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x03, 0x00, 0x00, 0x00, 0x6E, 0x64, 0x70, 0x00, 0xD0, 0xFE, 0xFF, 0xFF,
      0x18, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xC8, 0xFE, 0xFF, 0xFF,
      0x00, 0x00, 0x00, 0x09, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x08, 0x00, 0x00, 0x00, 0x6D, 0x61, 0x6E, 0x74, 0x69, 0x73, 0x73, 0x61,
      0x00, 0x00, 0x00, 0x00, 0x7C, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x01,
      0x20, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
      0x10, 0x00, 0x00, 0x00, 0xA4, 0x01, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
      0x40, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00,
      0x5A, 0x66, 0x62, 0x2E, 0x49, 0x6E, 0x74, 0x31, 0x32, 0x38, 0x00, 0x00,
      0x68, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x08, 0x00, 0x18, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x30, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x0A,
      0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x6C, 0x00, 0x00, 0x00, 0x5C, 0xFF, 0xFF, 0xFF, 0x18, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x54, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x0A,
      0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x68, 0x00, 0x00, 0x00, 0x14, 0x00, 0x1C, 0x00, 0x08, 0x00, 0x0C, 0x00,
      0x07, 0x00, 0x10, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00,
      0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x20, 0x00, 0x00, 0x00,
      0x10, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
      0x0C, 0x01, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00,
      0x20, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x5A, 0x66, 0x62, 0x2E,
      0x55, 0x49, 0x6E, 0x74, 0x31, 0x32, 0x38, 0x00, 0x0C, 0x00, 0x10, 0x00,
      0x08, 0x00, 0x0C, 0x00, 0x04, 0x00, 0x06, 0x00, 0x0C, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x08, 0x00, 0x18, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0xD4, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x0A, 0x08, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x6C, 0x00, 0x00, 0x00,
      0x08, 0x00, 0x0C, 0x00, 0x04, 0x00, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00,
      0x28, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x10, 0x00, 0x10, 0x00,
      0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x0C, 0x00,
      0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x08, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x68, 0x00, 0x00, 0x00,
      0xAC, 0xFF, 0xFF, 0xFF, 0x18, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x6C, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x14, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x5A, 0x66, 0x62, 0x2E,
      0x42, 0x69, 0x74, 0x6D, 0x61, 0x70, 0x00, 0x00, 0x6C, 0xFF, 0xFF, 0xFF,
      0x00, 0x01, 0x04, 0x00, 0x14, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0x50, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x0E, 0x0A, 0x08, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0x00, 0x00,
      0x14, 0x00, 0x14, 0x00, 0x04, 0x00, 0x08, 0x00, 0x00, 0x00, 0x0C, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x14, 0x00, 0x00, 0x00,
      0x44, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x2F, 0x2F, 0x2E, 0x2E,
      0x2F, 0x2E, 0x2E, 0x2F, 0x2E, 0x2E, 0x2F, 0x7A, 0x66, 0x62, 0x2F, 0x73,
      0x72, 0x63, 0x2F, 0x66, 0x62, 0x73, 0x2F, 0x7A, 0x66, 0x62, 0x5F, 0x74,
      0x79, 0x70, 0x65, 0x73, 0x2E, 0x66, 0x62, 0x73, 0x00, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00,
      0x5A, 0x66, 0x62, 0x2E, 0x42, 0x79, 0x74, 0x65, 0x73, 0x00, 0x00, 0x00,
      0x1C, 0x00, 0x10, 0x00, 0x08, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x06, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x05, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x01, 0x04, 0x00,
      0x24, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x10, 0x00, 0x0C, 0x00,
      0x06, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
      0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x04, 0x01, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0x00, 0x00
    };
    return bfbsData;
  }
  static size_t size() { return 1896; }
  const uint8_t *begin() { return data(); }
  const uint8_t *end() { return data() + size(); }
};

}}} // namespace Zdf::DB::fbs

namespace Zdf { namespace DB { namespace fbs {

struct BlkData;
struct BlkDataBuilder;

struct BlkData

  final

  : private ::flatbuffers::Table {
  typedef BlkDataBuilder Builder;
  typedef Zdf::DB::fbs::BlkDataSchema BinarySchema;
  struct Traits;
  enum FlatBuffersVTableOffset

    : ::flatbuffers::voffset_t

  {
    VT_BLKOFFSET = 4,
    VT_SERIESID = 6,
    VT_BUF = 8
  };
  uint64_t blkOffset() const { return GetField<uint64_t>(VT_BLKOFFSET, 0); }
  uint32_t seriesID() const { return GetField<uint32_t>(VT_SERIESID, 0); }
  const ::flatbuffers::Vector<uint8_t> *buf() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_BUF);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
      VerifyField<uint64_t>(verifier, VT_BLKOFFSET, 8) &&
      VerifyField<uint32_t>(verifier, VT_SERIESID, 4) &&
      VerifyOffset(verifier, VT_BUF) && verifier.VerifyVector(buf()) &&
      verifier.EndTable();
  }
};

struct BlkDataBuilder {
  typedef BlkData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_blkOffset(uint64_t blkOffset) {
    fbb_.AddElement<uint64_t>(BlkData::VT_BLKOFFSET, blkOffset, 0);
  }
  void add_seriesID(uint32_t seriesID) {
    fbb_.AddElement<uint32_t>(BlkData::VT_SERIESID, seriesID, 0);
  }
  void add_buf(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> buf) {
    fbb_.AddOffset(BlkData::VT_BUF, buf);
  }
  explicit BlkDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BlkData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BlkData>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BlkData> CreateBlkData(
  ::flatbuffers::FlatBufferBuilder &_fbb, uint64_t blkOffset = 0,
  uint32_t seriesID = 0,
  ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> buf = 0
) {
  BlkDataBuilder builder_(_fbb);
  builder_.add_blkOffset(blkOffset);
  builder_.add_buf(buf);
  builder_.add_seriesID(seriesID);
  return builder_.Finish();
}

struct BlkData::Traits {
  using type = BlkData;
  static constexpr auto Create = CreateBlkData;
};

inline ::flatbuffers::Offset<BlkData> CreateBlkDataDirect(
  ::flatbuffers::FlatBufferBuilder &_fbb, uint64_t blkOffset = 0,
  uint32_t seriesID = 0, const std::vector<uint8_t> *buf = nullptr
) {
  auto buf__ = buf ? _fbb.CreateVector<uint8_t>(*buf) : 0;
  return Zdf::DB::fbs::CreateBlkData(_fbb, blkOffset, seriesID, buf__);
}

inline const Zdf::DB::fbs::BlkData *GetBlkData(const void *buf) {
  return ::flatbuffers::GetRoot<Zdf::DB::fbs::BlkData>(buf);
}

inline const Zdf::DB::fbs::BlkData *GetSizePrefixedBlkData(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Zdf::DB::fbs::BlkData>(buf);
}

inline bool VerifyBlkDataBuffer(::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Zdf::DB::fbs::BlkData>(nullptr);
}

inline bool VerifySizePrefixedBlkDataBuffer(::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Zdf::DB::fbs::BlkData>(nullptr);
}

inline const char *BlkDataExtension() { return "bfbs"; }

inline void FinishBlkDataBuffer(
  ::flatbuffers::FlatBufferBuilder &fbb,
  ::flatbuffers::Offset<Zdf::DB::fbs::BlkData> root
) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedBlkDataBuffer(
  ::flatbuffers::FlatBufferBuilder &fbb,
  ::flatbuffers::Offset<Zdf::DB::fbs::BlkData> root
) {
  fbb.FinishSizePrefixed(root);
}

}}} // namespace Zdf::DB::fbs

namespace Zdf::DB {

struct SeriesFixed {
  SeriesID id;
  ZtString name;
  Fixed0 first;
  ZuDateTime epoch;
  BlkOffset blkOffset;
  NDP ndp;
};
namespace ZuSchema {
struct ZuField_SeriesFixed_id {
  using Orig = ZuField_SeriesFixed_id;
  template <template <typename> typename Override> using Adapt = Override<Orig>;
  enum { ReadOnly = 0 };
  using O = SeriesFixed;
  static constexpr const char *id() { return "id"; }
  using Props = ZuTypeList<
    ZuFieldProp::Ctor<0>, ZuFieldProp::Keys<0>, ZuFieldProp::Descend<0>>;
  using T = ZuDecay<decltype(ZuDeclVal<const SeriesFixed &>().id)>;
  static const T &get(const SeriesFixed &o) { return o.id; }
  static T &get(SeriesFixed &o) { return o.id; }
  static T &&get(SeriesFixed &&o) { return ZuMv(o.id); }
  template <typename P> static void set(SeriesFixed &o, P &&v) {
    o.id = ZuFwd<P>(v);
  }
};
using ZtField_SeriesFixed_id = ZtField_UInt32<ZuSchema::ZuField_SeriesFixed_id>;
template <
  typename O = SeriesFixed, typename Base = ZtField_SeriesFixed_id,
  typename Under_ = O, bool = Base::ReadOnly, typename = void>
struct ZfbField_SeriesFixed_id_ : public Base {
  static_assert(
    ZuTypeIn<ZuFieldProp::Synthetic, typename Base::Props>{},
    "SeriesFixed"
    "/"
    "id"
    " - flatbuffers / C++ mismatch"
  );
};
template <typename O, typename Base, typename Under_>
struct ZfbField_SeriesFixed_id_<
  O, Base, Under_, true, decltype(&Zfb_Type<Under_>::id, void())> :
  public Base {
  using Under = Under_;
  template <template <typename> typename Override>
  using Adapt = ZfbField_SeriesFixed_id_<
    typename Override<ZuFieldOrig<Base>>::O,
    typename Base::template Adapt<Override>, Under>;
  using FBType = Zfb_Type<Under>;
  enum { Inline = 1 };
  template <typename Builder> static void save(Builder &fbb, const O &o) {
    using P = ZuType<0, typename ZuDeduce<decltype(&Builder::add_id)>::Args>;
    fbb.add_id(static_cast<P>(Base::get(o)));
  }
  template <typename FBType_> static auto load_(const FBType_ *fbo) {
    return static_cast<typename Base::T>(fbo->id());
  }
  static void load(O &, const FBType *) { }
};
template <typename O, typename Base, typename Under_>
struct ZfbField_SeriesFixed_id_<
  O, Base, Under_, false, decltype(&Zfb_Type<Under_>::id, void())> :
  public ZfbField_SeriesFixed_id_<O, Base, Under_, true> {
  using Under = Under_;
  using FBType = Zfb_Type<Under>;
  using ZfbField_SeriesFixed_id_<O, Base, Under, true>::load_;
  static void load(O &o, const FBType *fbo) { Base::set(o, load_(fbo)); }
};
using ZfbField_SeriesFixed_id = ZfbField_SeriesFixed_id_<>;
struct ZuField_SeriesFixed_name {
  using Orig = ZuField_SeriesFixed_name;
  template <template <typename> typename Override> using Adapt = Override<Orig>;
  enum { ReadOnly = 0 };
  using O = SeriesFixed;
  static constexpr const char *id() { return "name"; }
  using Props = ZuTypeList<ZuFieldProp::Ctor<1>, ZuFieldProp::Keys<1>>;
  using T = ZuDecay<decltype(ZuDeclVal<const SeriesFixed &>().name)>;
  static const T &get(const SeriesFixed &o) { return o.name; }
  static T &get(SeriesFixed &o) { return o.name; }
  static T &&get(SeriesFixed &&o) { return ZuMv(o.name); }
  template <typename P> static void set(SeriesFixed &o, P &&v) {
    o.name = ZuFwd<P>(v);
  }
};
using ZtField_SeriesFixed_name =
  ZtField_String<ZuSchema::ZuField_SeriesFixed_name>;
template <
  typename O = SeriesFixed, typename Base = ZtField_SeriesFixed_name,
  typename Under_ = O, bool = Base::ReadOnly, typename = void>
struct ZfbField_SeriesFixed_name_ : public Base {
  static_assert(
    ZuTypeIn<ZuFieldProp::Synthetic, typename Base::Props>{},
    "SeriesFixed"
    "/"
    "name"
    " - flatbuffers / C++ mismatch"
  );
};
template <typename O, typename Base, typename Under_>
struct ZfbField_SeriesFixed_name_<
  O, Base, Under_, true, decltype(&Zfb_Type<Under_>::name, void())> :
  public Base {
  using Under = Under_;
  template <template <typename> typename Override>
  using Adapt = ZfbField_SeriesFixed_name_<
    typename Override<ZuFieldOrig<Base>>::O,
    typename Base::template Adapt<Override>, Under>;
  using Builder = Zfb_Builder<Under>;
  using FBType = Zfb_Type<Under>;
  enum { Inline = 0 };
  static Zfb::Offset<void> save(Zfb::Builder &fbb, const O &o) {
    return Zfb::Save::str(fbb, Base::get(o)).Union();
  }
  template <typename Builder>
  static void save(Builder &fbb, Zfb::Offset<void> offset) {
    fbb.add_name(offset.o);
  }
  template <typename FBType_> static decltype(auto) load_(const FBType_ *fbo) {
    return Zfb::Load::str(fbo->name());
  }
  static void load(O &, const FBType *) { }
};
template <typename O, typename Base, typename Under_>
struct ZfbField_SeriesFixed_name_<
  O, Base, Under_, false, decltype(&Zfb_Type<Under_>::name, void())> :
  public ZfbField_SeriesFixed_name_<O, Base, Under_, true> {
  using Under = Under_;
  using FBType = Zfb_Type<Under>;
  using ZfbField_SeriesFixed_name_<O, Base, Under, true>::load_;
  static void load(O &o, const FBType *fbo) { Base::set(o, load_(fbo)); }
};
using ZfbField_SeriesFixed_name = ZfbField_SeriesFixed_name_<>;
struct ZuField_SeriesFixed_first {
  using Orig = ZuField_SeriesFixed_first;
  template <template <typename> typename Override> using Adapt = Override<Orig>;
  enum { ReadOnly = 0 };
  using O = SeriesFixed;
  static constexpr const char *id() { return "first"; }
  using Props = ZuTypeList<ZuFieldProp::Ctor<2>, ZuFieldProp::Mutable>;
  using T = ZuDecay<decltype(ZuDeclVal<const SeriesFixed &>().first)>;
  static const T &get(const SeriesFixed &o) { return o.first; }
  static T &get(SeriesFixed &o) { return o.first; }
  static T &&get(SeriesFixed &&o) { return ZuMv(o.first); }
  template <typename P> static void set(SeriesFixed &o, P &&v) {
    o.first = ZuFwd<P>(v);
  }
};
using ZtField_SeriesFixed_first =
  ZtField_Int64<ZuSchema::ZuField_SeriesFixed_first>;
template <
  typename O = SeriesFixed, typename Base = ZtField_SeriesFixed_first,
  typename Under_ = O, bool = Base::ReadOnly, typename = void>
struct ZfbField_SeriesFixed_first_ : public Base {
  static_assert(
    ZuTypeIn<ZuFieldProp::Synthetic, typename Base::Props>{},
    "SeriesFixed"
    "/"
    "first"
    " - flatbuffers / C++ mismatch"
  );
};
template <typename O, typename Base, typename Under_>
struct ZfbField_SeriesFixed_first_<
  O, Base, Under_, true, decltype(&Zfb_Type<Under_>::first, void())> :
  public Base {
  using Under = Under_;
  template <template <typename> typename Override>
  using Adapt = ZfbField_SeriesFixed_first_<
    typename Override<ZuFieldOrig<Base>>::O,
    typename Base::template Adapt<Override>, Under>;
  using FBType = Zfb_Type<Under>;
  enum { Inline = 1 };
  template <typename Builder> static void save(Builder &fbb, const O &o) {
    using P = ZuType<0, typename ZuDeduce<decltype(&Builder::add_first)>::Args>;
    fbb.add_first(static_cast<P>(Base::get(o)));
  }
  template <typename FBType_> static auto load_(const FBType_ *fbo) {
    return static_cast<typename Base::T>(fbo->first());
  }
  static void load(O &, const FBType *) { }
};
template <typename O, typename Base, typename Under_>
struct ZfbField_SeriesFixed_first_<
  O, Base, Under_, false, decltype(&Zfb_Type<Under_>::first, void())> :
  public ZfbField_SeriesFixed_first_<O, Base, Under_, true> {
  using Under = Under_;
  using FBType = Zfb_Type<Under>;
  using ZfbField_SeriesFixed_first_<O, Base, Under, true>::load_;
  static void load(O &o, const FBType *fbo) { Base::set(o, load_(fbo)); }
};
using ZfbField_SeriesFixed_first = ZfbField_SeriesFixed_first_<>;
struct ZuField_SeriesFixed_ndp {
  using Orig = ZuField_SeriesFixed_ndp;
  template <template <typename> typename Override> using Adapt = Override<Orig>;
  enum { ReadOnly = 0 };
  using O = SeriesFixed;
  static constexpr const char *id() { return "ndp"; }
  using Props = ZuTypeList<ZuFieldProp::Ctor<5>, ZuFieldProp::Mutable>;
  using T = ZuDecay<decltype(ZuDeclVal<const SeriesFixed &>().ndp)>;
  static const T &get(const SeriesFixed &o) { return o.ndp; }
  static T &get(SeriesFixed &o) { return o.ndp; }
  static T &&get(SeriesFixed &&o) { return ZuMv(o.ndp); }
  template <typename P> static void set(SeriesFixed &o, P &&v) {
    o.ndp = ZuFwd<P>(v);
  }
};
using ZtField_SeriesFixed_ndp =
  ZtField_UInt8<ZuSchema::ZuField_SeriesFixed_ndp>;
template <
  typename O = SeriesFixed, typename Base = ZtField_SeriesFixed_ndp,
  typename Under_ = O, bool = Base::ReadOnly, typename = void>
struct ZfbField_SeriesFixed_ndp_ : public Base {
  static_assert(
    ZuTypeIn<ZuFieldProp::Synthetic, typename Base::Props>{},
    "SeriesFixed"
    "/"
    "ndp"
    " - flatbuffers / C++ mismatch"
  );
};
template <typename O, typename Base, typename Under_>
struct ZfbField_SeriesFixed_ndp_<
  O, Base, Under_, true, decltype(&Zfb_Type<Under_>::ndp, void())> :
  public Base {
  using Under = Under_;
  template <template <typename> typename Override>
  using Adapt = ZfbField_SeriesFixed_ndp_<
    typename Override<ZuFieldOrig<Base>>::O,
    typename Base::template Adapt<Override>, Under>;
  using FBType = Zfb_Type<Under>;
  enum { Inline = 1 };
  template <typename Builder> static void save(Builder &fbb, const O &o) {
    using P = ZuType<0, typename ZuDeduce<decltype(&Builder::add_ndp)>::Args>;
    fbb.add_ndp(static_cast<P>(Base::get(o)));
  }
  template <typename FBType_> static auto load_(const FBType_ *fbo) {
    return static_cast<typename Base::T>(fbo->ndp());
  }
  static void load(O &, const FBType *) { }
};
template <typename O, typename Base, typename Under_>
struct ZfbField_SeriesFixed_ndp_<
  O, Base, Under_, false, decltype(&Zfb_Type<Under_>::ndp, void())> :
  public ZfbField_SeriesFixed_ndp_<O, Base, Under_, true> {
  using Under = Under_;
  using FBType = Zfb_Type<Under>;
  using ZfbField_SeriesFixed_ndp_<O, Base, Under, true>::load_;
  static void load(O &o, const FBType *fbo) { Base::set(o, load_(fbo)); }
};
using ZfbField_SeriesFixed_ndp = ZfbField_SeriesFixed_ndp_<>;
struct ZuField_SeriesFixed_epoch {
  using Orig = ZuField_SeriesFixed_epoch;
  template <template <typename> typename Override> using Adapt = Override<Orig>;
  enum { ReadOnly = 0 };
  using O = SeriesFixed;
  static constexpr const char *id() { return "epoch"; }
  using Props = ZuTypeList<ZuFieldProp::Ctor<3>>;
  using T = ZuDecay<decltype(ZuDeclVal<const SeriesFixed &>().epoch)>;
  static const T &get(const SeriesFixed &o) { return o.epoch; }
  static T &get(SeriesFixed &o) { return o.epoch; }
  static T &&get(SeriesFixed &&o) { return ZuMv(o.epoch); }
  template <typename P> static void set(SeriesFixed &o, P &&v) {
    o.epoch = ZuFwd<P>(v);
  }
};
using ZtField_SeriesFixed_epoch =
  ZtField_DateTime<ZuSchema::ZuField_SeriesFixed_epoch>;
template <
  typename O = SeriesFixed, typename Base = ZtField_SeriesFixed_epoch,
  typename Under_ = O, bool = Base::ReadOnly, typename = void>
struct ZfbField_SeriesFixed_epoch_ : public Base {
  static_assert(
    ZuTypeIn<ZuFieldProp::Synthetic, typename Base::Props>{},
    "SeriesFixed"
    "/"
    "epoch"
    " - flatbuffers / C++ mismatch"
  );
};
template <typename O, typename Base, typename Under_>
struct ZfbField_SeriesFixed_epoch_<
  O, Base, Under_, true, decltype(&Zfb_Type<Under_>::epoch, void())> :
  public Base {
  using Under = Under_;
  template <template <typename> typename Override>
  using Adapt = ZfbField_SeriesFixed_epoch_<
    typename Override<ZuFieldOrig<Base>>::O,
    typename Base::template Adapt<Override>, Under>;
  using Builder = Zfb_Builder<Under>;
  using FBType = Zfb_Type<Under>;
  enum { Inline = 1 };
  template <typename Builder> static void save(Builder &fbb, const O &o) {
    auto v = Zfb::Save::dateTime(Base::get(o));
    fbb.add_epoch(&v);
  }
  template <typename FBType_> static decltype(auto) load_(const FBType_ *fbo) {
    auto v = fbo->epoch();
    return Zfb::Load::dateTime(v);
  }
  static void load(O &, const FBType *) { }
};
template <typename O, typename Base, typename Under_>
struct ZfbField_SeriesFixed_epoch_<
  O, Base, Under_, false, decltype(&Zfb_Type<Under_>::epoch, void())> :
  public ZfbField_SeriesFixed_epoch_<O, Base, Under_, true> {
  using Under = Under_;
  using FBType = Zfb_Type<Under>;
  using ZfbField_SeriesFixed_epoch_<O, Base, Under, true>::load_;
  static void load(O &o, const FBType *fbo) { Base::set(o, load_(fbo)); }
};
using ZfbField_SeriesFixed_epoch = ZfbField_SeriesFixed_epoch_<>;
struct ZuField_SeriesFixed_blkOffset {
  using Orig = ZuField_SeriesFixed_blkOffset;
  template <template <typename> typename Override> using Adapt = Override<Orig>;
  enum { ReadOnly = 0 };
  using O = SeriesFixed;
  static constexpr const char *id() { return "blkOffset"; }
  using Props = ZuTypeList<ZuFieldProp::Ctor<4>, ZuFieldProp::Mutable>;
  using T = ZuDecay<decltype(ZuDeclVal<const SeriesFixed &>().blkOffset)>;
  static const T &get(const SeriesFixed &o) { return o.blkOffset; }
  static T &get(SeriesFixed &o) { return o.blkOffset; }
  static T &&get(SeriesFixed &&o) { return ZuMv(o.blkOffset); }
  template <typename P> static void set(SeriesFixed &o, P &&v) {
    o.blkOffset = ZuFwd<P>(v);
  }
};
using ZtField_SeriesFixed_blkOffset =
  ZtField_UInt64<ZuSchema::ZuField_SeriesFixed_blkOffset>;
template <
  typename O = SeriesFixed, typename Base = ZtField_SeriesFixed_blkOffset,
  typename Under_ = O, bool = Base::ReadOnly, typename = void>
struct ZfbField_SeriesFixed_blkOffset_ : public Base {
  static_assert(
    ZuTypeIn<ZuFieldProp::Synthetic, typename Base::Props>{},
    "SeriesFixed"
    "/"
    "blkOffset"
    " - flatbuffers / C++ mismatch"
  );
};
template <typename O, typename Base, typename Under_>
struct ZfbField_SeriesFixed_blkOffset_<
  O, Base, Under_, true, decltype(&Zfb_Type<Under_>::blkOffset, void())> :
  public Base {
  using Under = Under_;
  template <template <typename> typename Override>
  using Adapt = ZfbField_SeriesFixed_blkOffset_<
    typename Override<ZuFieldOrig<Base>>::O,
    typename Base::template Adapt<Override>, Under>;
  using FBType = Zfb_Type<Under>;
  enum { Inline = 1 };
  template <typename Builder> static void save(Builder &fbb, const O &o) {
    using P =
      ZuType<0, typename ZuDeduce<decltype(&Builder::add_blkOffset)>::Args>;
    fbb.add_blkOffset(static_cast<P>(Base::get(o)));
  }
  template <typename FBType_> static auto load_(const FBType_ *fbo) {
    return static_cast<typename Base::T>(fbo->blkOffset());
  }
  static void load(O &, const FBType *) { }
};
template <typename O, typename Base, typename Under_>
struct ZfbField_SeriesFixed_blkOffset_<
  O, Base, Under_, false, decltype(&Zfb_Type<Under_>::blkOffset, void())> :
  public ZfbField_SeriesFixed_blkOffset_<O, Base, Under_, true> {
  using Under = Under_;
  using FBType = Zfb_Type<Under>;
  using ZfbField_SeriesFixed_blkOffset_<O, Base, Under, true>::load_;
  static void load(O &o, const FBType *fbo) { Base::set(o, load_(fbo)); }
};
using ZfbField_SeriesFixed_blkOffset = ZfbField_SeriesFixed_blkOffset_<>;
using SeriesFixed = ZuTypeList<
  ZfbField_SeriesFixed_id, ZfbField_SeriesFixed_name,
  ZfbField_SeriesFixed_first, ZfbField_SeriesFixed_ndp,
  ZfbField_SeriesFixed_epoch, ZfbField_SeriesFixed_blkOffset>;
} // namespace ZuSchema
SeriesFixed ZuFielded_(SeriesFixed *);
ZuSchema::SeriesFixed ZuFields_(SeriesFixed *);
fbs::SeriesFixedBuilder ZfbBuilder_(SeriesFixed *);
fbs::SeriesFixed ZfbType_(SeriesFixed *);
SeriesFixed ZfbUnder_(SeriesFixed *);
namespace Zfb_Under_ {
using SeriesFixed = SeriesFixed;
}
namespace fbs {
Zfb_Under_::SeriesFixed ZfbUnder_(SeriesFixed *);
}
using SeriesFixed_FBFields = ZfbField::Fields<SeriesFixed>;
namespace fbs {
SeriesFixed ZuFielded_(SeriesFixed *);
SeriesFixed_FBFields ZuFields_(SeriesFixed *);
ZtFieldPrint ZuPrintType(SeriesFixed *);
};
fbs::SeriesFixedSchema ZfbSchema_(SeriesFixed *);

struct SeriesFloat {
  SeriesID id;
  ZtString name;
  Float0 first;
  ZuDateTime epoch;
  BlkOffset blkOffset;
};
namespace ZuSchema {
struct ZuField_SeriesFloat_id {
  using Orig = ZuField_SeriesFloat_id;
  template <template <typename> typename Override> using Adapt = Override<Orig>;
  enum { ReadOnly = 0 };
  using O = SeriesFloat;
  static constexpr const char *id() { return "id"; }
  using Props = ZuTypeList<
    ZuFieldProp::Ctor<0>, ZuFieldProp::Keys<0>, ZuFieldProp::Descend<0>>;
  using T = ZuDecay<decltype(ZuDeclVal<const SeriesFloat &>().id)>;
  static const T &get(const SeriesFloat &o) { return o.id; }
  static T &get(SeriesFloat &o) { return o.id; }
  static T &&get(SeriesFloat &&o) { return ZuMv(o.id); }
  template <typename P> static void set(SeriesFloat &o, P &&v) {
    o.id = ZuFwd<P>(v);
  }
};
using ZtField_SeriesFloat_id = ZtField_UInt32<ZuSchema::ZuField_SeriesFloat_id>;
template <
  typename O = SeriesFloat, typename Base = ZtField_SeriesFloat_id,
  typename Under_ = O, bool = Base::ReadOnly, typename = void>
struct ZfbField_SeriesFloat_id_ : public Base {
  static_assert(
    ZuTypeIn<ZuFieldProp::Synthetic, typename Base::Props>{},
    "SeriesFloat"
    "/"
    "id"
    " - flatbuffers / C++ mismatch"
  );
};
template <typename O, typename Base, typename Under_>
struct ZfbField_SeriesFloat_id_<
  O, Base, Under_, true, decltype(&Zfb_Type<Under_>::id, void())> :
  public Base {
  using Under = Under_;
  template <template <typename> typename Override>
  using Adapt = ZfbField_SeriesFloat_id_<
    typename Override<ZuFieldOrig<Base>>::O,
    typename Base::template Adapt<Override>, Under>;
  using FBType = Zfb_Type<Under>;
  enum { Inline = 1 };
  template <typename Builder> static void save(Builder &fbb, const O &o) {
    using P = ZuType<0, typename ZuDeduce<decltype(&Builder::add_id)>::Args>;
    fbb.add_id(static_cast<P>(Base::get(o)));
  }
  template <typename FBType_> static auto load_(const FBType_ *fbo) {
    return static_cast<typename Base::T>(fbo->id());
  }
  static void load(O &, const FBType *) { }
};
template <typename O, typename Base, typename Under_>
struct ZfbField_SeriesFloat_id_<
  O, Base, Under_, false, decltype(&Zfb_Type<Under_>::id, void())> :
  public ZfbField_SeriesFloat_id_<O, Base, Under_, true> {
  using Under = Under_;
  using FBType = Zfb_Type<Under>;
  using ZfbField_SeriesFloat_id_<O, Base, Under, true>::load_;
  static void load(O &o, const FBType *fbo) { Base::set(o, load_(fbo)); }
};
using ZfbField_SeriesFloat_id = ZfbField_SeriesFloat_id_<>;
struct ZuField_SeriesFloat_name {
  using Orig = ZuField_SeriesFloat_name;
  template <template <typename> typename Override> using Adapt = Override<Orig>;
  enum { ReadOnly = 0 };
  using O = SeriesFloat;
  static constexpr const char *id() { return "name"; }
  using Props = ZuTypeList<ZuFieldProp::Ctor<1>, ZuFieldProp::Keys<1>>;
  using T = ZuDecay<decltype(ZuDeclVal<const SeriesFloat &>().name)>;
  static const T &get(const SeriesFloat &o) { return o.name; }
  static T &get(SeriesFloat &o) { return o.name; }
  static T &&get(SeriesFloat &&o) { return ZuMv(o.name); }
  template <typename P> static void set(SeriesFloat &o, P &&v) {
    o.name = ZuFwd<P>(v);
  }
};
using ZtField_SeriesFloat_name =
  ZtField_String<ZuSchema::ZuField_SeriesFloat_name>;
template <
  typename O = SeriesFloat, typename Base = ZtField_SeriesFloat_name,
  typename Under_ = O, bool = Base::ReadOnly, typename = void>
struct ZfbField_SeriesFloat_name_ : public Base {
  static_assert(
    ZuTypeIn<ZuFieldProp::Synthetic, typename Base::Props>{},
    "SeriesFloat"
    "/"
    "name"
    " - flatbuffers / C++ mismatch"
  );
};
template <typename O, typename Base, typename Under_>
struct ZfbField_SeriesFloat_name_<
  O, Base, Under_, true, decltype(&Zfb_Type<Under_>::name, void())> :
  public Base {
  using Under = Under_;
  template <template <typename> typename Override>
  using Adapt = ZfbField_SeriesFloat_name_<
    typename Override<ZuFieldOrig<Base>>::O,
    typename Base::template Adapt<Override>, Under>;
  using Builder = Zfb_Builder<Under>;
  using FBType = Zfb_Type<Under>;
  enum { Inline = 0 };
  static Zfb::Offset<void> save(Zfb::Builder &fbb, const O &o) {
    return Zfb::Save::str(fbb, Base::get(o)).Union();
  }
  template <typename Builder>
  static void save(Builder &fbb, Zfb::Offset<void> offset) {
    fbb.add_name(offset.o);
  }
  template <typename FBType_> static decltype(auto) load_(const FBType_ *fbo) {
    return Zfb::Load::str(fbo->name());
  }
  static void load(O &, const FBType *) { }
};
template <typename O, typename Base, typename Under_>
struct ZfbField_SeriesFloat_name_<
  O, Base, Under_, false, decltype(&Zfb_Type<Under_>::name, void())> :
  public ZfbField_SeriesFloat_name_<O, Base, Under_, true> {
  using Under = Under_;
  using FBType = Zfb_Type<Under>;
  using ZfbField_SeriesFloat_name_<O, Base, Under, true>::load_;
  static void load(O &o, const FBType *fbo) { Base::set(o, load_(fbo)); }
};
using ZfbField_SeriesFloat_name = ZfbField_SeriesFloat_name_<>;
struct ZuField_SeriesFloat_first {
  using Orig = ZuField_SeriesFloat_first;
  template <template <typename> typename Override> using Adapt = Override<Orig>;
  enum { ReadOnly = 0 };
  using O = SeriesFloat;
  static constexpr const char *id() { return "first"; }
  using Props = ZuTypeList<ZuFieldProp::Ctor<2>, ZuFieldProp::Mutable>;
  using T = ZuDecay<decltype(ZuDeclVal<const SeriesFloat &>().first)>;
  static const T &get(const SeriesFloat &o) { return o.first; }
  static T &get(SeriesFloat &o) { return o.first; }
  static T &&get(SeriesFloat &&o) { return ZuMv(o.first); }
  template <typename P> static void set(SeriesFloat &o, P &&v) {
    o.first = ZuFwd<P>(v);
  }
};
using ZtField_SeriesFloat_first =
  ZtField_Float<ZuSchema::ZuField_SeriesFloat_first>;
template <
  typename O = SeriesFloat, typename Base = ZtField_SeriesFloat_first,
  typename Under_ = O, bool = Base::ReadOnly, typename = void>
struct ZfbField_SeriesFloat_first_ : public Base {
  static_assert(
    ZuTypeIn<ZuFieldProp::Synthetic, typename Base::Props>{},
    "SeriesFloat"
    "/"
    "first"
    " - flatbuffers / C++ mismatch"
  );
};
template <typename O, typename Base, typename Under_>
struct ZfbField_SeriesFloat_first_<
  O, Base, Under_, true, decltype(&Zfb_Type<Under_>::first, void())> :
  public Base {
  using Under = Under_;
  template <template <typename> typename Override>
  using Adapt = ZfbField_SeriesFloat_first_<
    typename Override<ZuFieldOrig<Base>>::O,
    typename Base::template Adapt<Override>, Under>;
  using FBType = Zfb_Type<Under>;
  enum { Inline = 1 };
  template <typename Builder> static void save(Builder &fbb, const O &o) {
    using P = ZuType<0, typename ZuDeduce<decltype(&Builder::add_first)>::Args>;
    fbb.add_first(static_cast<P>(Base::get(o)));
  }
  template <typename FBType_> static auto load_(const FBType_ *fbo) {
    return static_cast<typename Base::T>(fbo->first());
  }
  static void load(O &, const FBType *) { }
};
template <typename O, typename Base, typename Under_>
struct ZfbField_SeriesFloat_first_<
  O, Base, Under_, false, decltype(&Zfb_Type<Under_>::first, void())> :
  public ZfbField_SeriesFloat_first_<O, Base, Under_, true> {
  using Under = Under_;
  using FBType = Zfb_Type<Under>;
  using ZfbField_SeriesFloat_first_<O, Base, Under, true>::load_;
  static void load(O &o, const FBType *fbo) { Base::set(o, load_(fbo)); }
};
using ZfbField_SeriesFloat_first = ZfbField_SeriesFloat_first_<>;
struct ZuField_SeriesFloat_epoch {
  using Orig = ZuField_SeriesFloat_epoch;
  template <template <typename> typename Override> using Adapt = Override<Orig>;
  enum { ReadOnly = 0 };
  using O = SeriesFloat;
  static constexpr const char *id() { return "epoch"; }
  using Props = ZuTypeList<ZuFieldProp::Ctor<3>>;
  using T = ZuDecay<decltype(ZuDeclVal<const SeriesFloat &>().epoch)>;
  static const T &get(const SeriesFloat &o) { return o.epoch; }
  static T &get(SeriesFloat &o) { return o.epoch; }
  static T &&get(SeriesFloat &&o) { return ZuMv(o.epoch); }
  template <typename P> static void set(SeriesFloat &o, P &&v) {
    o.epoch = ZuFwd<P>(v);
  }
};
using ZtField_SeriesFloat_epoch =
  ZtField_DateTime<ZuSchema::ZuField_SeriesFloat_epoch>;
template <
  typename O = SeriesFloat, typename Base = ZtField_SeriesFloat_epoch,
  typename Under_ = O, bool = Base::ReadOnly, typename = void>
struct ZfbField_SeriesFloat_epoch_ : public Base {
  static_assert(
    ZuTypeIn<ZuFieldProp::Synthetic, typename Base::Props>{},
    "SeriesFloat"
    "/"
    "epoch"
    " - flatbuffers / C++ mismatch"
  );
};
template <typename O, typename Base, typename Under_>
struct ZfbField_SeriesFloat_epoch_<
  O, Base, Under_, true, decltype(&Zfb_Type<Under_>::epoch, void())> :
  public Base {
  using Under = Under_;
  template <template <typename> typename Override>
  using Adapt = ZfbField_SeriesFloat_epoch_<
    typename Override<ZuFieldOrig<Base>>::O,
    typename Base::template Adapt<Override>, Under>;
  using Builder = Zfb_Builder<Under>;
  using FBType = Zfb_Type<Under>;
  enum { Inline = 1 };
  template <typename Builder> static void save(Builder &fbb, const O &o) {
    auto v = Zfb::Save::dateTime(Base::get(o));
    fbb.add_epoch(&v);
  }
  template <typename FBType_> static decltype(auto) load_(const FBType_ *fbo) {
    auto v = fbo->epoch();
    return Zfb::Load::dateTime(v);
  }
  static void load(O &, const FBType *) { }
};
template <typename O, typename Base, typename Under_>
struct ZfbField_SeriesFloat_epoch_<
  O, Base, Under_, false, decltype(&Zfb_Type<Under_>::epoch, void())> :
  public ZfbField_SeriesFloat_epoch_<O, Base, Under_, true> {
  using Under = Under_;
  using FBType = Zfb_Type<Under>;
  using ZfbField_SeriesFloat_epoch_<O, Base, Under, true>::load_;
  static void load(O &o, const FBType *fbo) { Base::set(o, load_(fbo)); }
};
using ZfbField_SeriesFloat_epoch = ZfbField_SeriesFloat_epoch_<>;
struct ZuField_SeriesFloat_blkOffset {
  using Orig = ZuField_SeriesFloat_blkOffset;
  template <template <typename> typename Override> using Adapt = Override<Orig>;
  enum { ReadOnly = 0 };
  using O = SeriesFloat;
  static constexpr const char *id() { return "blkOffset"; }
  using Props = ZuTypeList<ZuFieldProp::Ctor<4>, ZuFieldProp::Mutable>;
  using T = ZuDecay<decltype(ZuDeclVal<const SeriesFloat &>().blkOffset)>;
  static const T &get(const SeriesFloat &o) { return o.blkOffset; }
  static T &get(SeriesFloat &o) { return o.blkOffset; }
  static T &&get(SeriesFloat &&o) { return ZuMv(o.blkOffset); }
  template <typename P> static void set(SeriesFloat &o, P &&v) {
    o.blkOffset = ZuFwd<P>(v);
  }
};
using ZtField_SeriesFloat_blkOffset =
  ZtField_UInt64<ZuSchema::ZuField_SeriesFloat_blkOffset>;
template <
  typename O = SeriesFloat, typename Base = ZtField_SeriesFloat_blkOffset,
  typename Under_ = O, bool = Base::ReadOnly, typename = void>
struct ZfbField_SeriesFloat_blkOffset_ : public Base {
  static_assert(
    ZuTypeIn<ZuFieldProp::Synthetic, typename Base::Props>{},
    "SeriesFloat"
    "/"
    "blkOffset"
    " - flatbuffers / C++ mismatch"
  );
};
template <typename O, typename Base, typename Under_>
struct ZfbField_SeriesFloat_blkOffset_<
  O, Base, Under_, true, decltype(&Zfb_Type<Under_>::blkOffset, void())> :
  public Base {
  using Under = Under_;
  template <template <typename> typename Override>
  using Adapt = ZfbField_SeriesFloat_blkOffset_<
    typename Override<ZuFieldOrig<Base>>::O,
    typename Base::template Adapt<Override>, Under>;
  using FBType = Zfb_Type<Under>;
  enum { Inline = 1 };
  template <typename Builder> static void save(Builder &fbb, const O &o) {
    using P =
      ZuType<0, typename ZuDeduce<decltype(&Builder::add_blkOffset)>::Args>;
    fbb.add_blkOffset(static_cast<P>(Base::get(o)));
  }
  template <typename FBType_> static auto load_(const FBType_ *fbo) {
    return static_cast<typename Base::T>(fbo->blkOffset());
  }
  static void load(O &, const FBType *) { }
};
template <typename O, typename Base, typename Under_>
struct ZfbField_SeriesFloat_blkOffset_<
  O, Base, Under_, false, decltype(&Zfb_Type<Under_>::blkOffset, void())> :
  public ZfbField_SeriesFloat_blkOffset_<O, Base, Under_, true> {
  using Under = Under_;
  using FBType = Zfb_Type<Under>;
  using ZfbField_SeriesFloat_blkOffset_<O, Base, Under, true>::load_;
  static void load(O &o, const FBType *fbo) { Base::set(o, load_(fbo)); }
};
using ZfbField_SeriesFloat_blkOffset = ZfbField_SeriesFloat_blkOffset_<>;
using SeriesFloat = ZuTypeList<
  ZfbField_SeriesFloat_id, ZfbField_SeriesFloat_name,
  ZfbField_SeriesFloat_first, ZfbField_SeriesFloat_epoch,
  ZfbField_SeriesFloat_blkOffset>;
} // namespace ZuSchema
SeriesFloat ZuFielded_(SeriesFloat *);
ZuSchema::SeriesFloat ZuFields_(SeriesFloat *);
fbs::SeriesFloatBuilder ZfbBuilder_(SeriesFloat *);
fbs::SeriesFloat ZfbType_(SeriesFloat *);
SeriesFloat ZfbUnder_(SeriesFloat *);
namespace Zfb_Under_ {
using SeriesFloat = SeriesFloat;
}
namespace fbs {
Zfb_Under_::SeriesFloat ZfbUnder_(SeriesFloat *);
}
using SeriesFloat_FBFields = ZfbField::Fields<SeriesFloat>;
namespace fbs {
SeriesFloat ZuFielded_(SeriesFloat *);
SeriesFloat_FBFields ZuFields_(SeriesFloat *);
ZtFieldPrint ZuPrintType(SeriesFloat *);
};
fbs::SeriesFloatSchema ZfbSchema_(SeriesFloat *);

struct BlkFixed {
  BlkOffset blkOffset;
  Offset offset;
  Fixed0 last;
  SeriesID seriesID;
  BlkCount count;
  NDP ndp;
};
namespace ZuSchema {
struct ZuField_BlkFixed_seriesID {
  using Orig = ZuField_BlkFixed_seriesID;
  template <template <typename> typename Override> using Adapt = Override<Orig>;
  enum { ReadOnly = 0 };
  using O = BlkFixed;
  static constexpr const char *id() { return "seriesID"; }
  using Props = ZuTypeList<
    ZuFieldProp::Ctor<3>, ZuFieldProp::Keys<0>, ZuFieldProp::Group<0>,
    ZuFieldProp::Descend<0>>;
  using T = ZuDecay<decltype(ZuDeclVal<const BlkFixed &>().seriesID)>;
  static const T &get(const BlkFixed &o) { return o.seriesID; }
  static T &get(BlkFixed &o) { return o.seriesID; }
  static T &&get(BlkFixed &&o) { return ZuMv(o.seriesID); }
  template <typename P> static void set(BlkFixed &o, P &&v) {
    o.seriesID = ZuFwd<P>(v);
  }
};
using ZtField_BlkFixed_seriesID =
  ZtField_UInt32<ZuSchema::ZuField_BlkFixed_seriesID>;
template <
  typename O = BlkFixed, typename Base = ZtField_BlkFixed_seriesID,
  typename Under_ = O, bool = Base::ReadOnly, typename = void>
struct ZfbField_BlkFixed_seriesID_ : public Base {
  static_assert(
    ZuTypeIn<ZuFieldProp::Synthetic, typename Base::Props>{},
    "BlkFixed"
    "/"
    "seriesID"
    " - flatbuffers / C++ mismatch"
  );
};
template <typename O, typename Base, typename Under_>
struct ZfbField_BlkFixed_seriesID_<
  O, Base, Under_, true, decltype(&Zfb_Type<Under_>::seriesID, void())> :
  public Base {
  using Under = Under_;
  template <template <typename> typename Override>
  using Adapt = ZfbField_BlkFixed_seriesID_<
    typename Override<ZuFieldOrig<Base>>::O,
    typename Base::template Adapt<Override>, Under>;
  using FBType = Zfb_Type<Under>;
  enum { Inline = 1 };
  template <typename Builder> static void save(Builder &fbb, const O &o) {
    using P =
      ZuType<0, typename ZuDeduce<decltype(&Builder::add_seriesID)>::Args>;
    fbb.add_seriesID(static_cast<P>(Base::get(o)));
  }
  template <typename FBType_> static auto load_(const FBType_ *fbo) {
    return static_cast<typename Base::T>(fbo->seriesID());
  }
  static void load(O &, const FBType *) { }
};
template <typename O, typename Base, typename Under_>
struct ZfbField_BlkFixed_seriesID_<
  O, Base, Under_, false, decltype(&Zfb_Type<Under_>::seriesID, void())> :
  public ZfbField_BlkFixed_seriesID_<O, Base, Under_, true> {
  using Under = Under_;
  using FBType = Zfb_Type<Under>;
  using ZfbField_BlkFixed_seriesID_<O, Base, Under, true>::load_;
  static void load(O &o, const FBType *fbo) { Base::set(o, load_(fbo)); }
};
using ZfbField_BlkFixed_seriesID = ZfbField_BlkFixed_seriesID_<>;
struct ZuField_BlkFixed_blkOffset {
  using Orig = ZuField_BlkFixed_blkOffset;
  template <template <typename> typename Override> using Adapt = Override<Orig>;
  enum { ReadOnly = 0 };
  using O = BlkFixed;
  static constexpr const char *id() { return "blkOffset"; }
  using Props = ZuTypeList<
    ZuFieldProp::Ctor<0>, ZuFieldProp::Keys<0>, ZuFieldProp::Descend<0>>;
  using T = ZuDecay<decltype(ZuDeclVal<const BlkFixed &>().blkOffset)>;
  static const T &get(const BlkFixed &o) { return o.blkOffset; }
  static T &get(BlkFixed &o) { return o.blkOffset; }
  static T &&get(BlkFixed &&o) { return ZuMv(o.blkOffset); }
  template <typename P> static void set(BlkFixed &o, P &&v) {
    o.blkOffset = ZuFwd<P>(v);
  }
};
using ZtField_BlkFixed_blkOffset =
  ZtField_UInt64<ZuSchema::ZuField_BlkFixed_blkOffset>;
template <
  typename O = BlkFixed, typename Base = ZtField_BlkFixed_blkOffset,
  typename Under_ = O, bool = Base::ReadOnly, typename = void>
struct ZfbField_BlkFixed_blkOffset_ : public Base {
  static_assert(
    ZuTypeIn<ZuFieldProp::Synthetic, typename Base::Props>{},
    "BlkFixed"
    "/"
    "blkOffset"
    " - flatbuffers / C++ mismatch"
  );
};
template <typename O, typename Base, typename Under_>
struct ZfbField_BlkFixed_blkOffset_<
  O, Base, Under_, true, decltype(&Zfb_Type<Under_>::blkOffset, void())> :
  public Base {
  using Under = Under_;
  template <template <typename> typename Override>
  using Adapt = ZfbField_BlkFixed_blkOffset_<
    typename Override<ZuFieldOrig<Base>>::O,
    typename Base::template Adapt<Override>, Under>;
  using FBType = Zfb_Type<Under>;
  enum { Inline = 1 };
  template <typename Builder> static void save(Builder &fbb, const O &o) {
    using P =
      ZuType<0, typename ZuDeduce<decltype(&Builder::add_blkOffset)>::Args>;
    fbb.add_blkOffset(static_cast<P>(Base::get(o)));
  }
  template <typename FBType_> static auto load_(const FBType_ *fbo) {
    return static_cast<typename Base::T>(fbo->blkOffset());
  }
  static void load(O &, const FBType *) { }
};
template <typename O, typename Base, typename Under_>
struct ZfbField_BlkFixed_blkOffset_<
  O, Base, Under_, false, decltype(&Zfb_Type<Under_>::blkOffset, void())> :
  public ZfbField_BlkFixed_blkOffset_<O, Base, Under_, true> {
  using Under = Under_;
  using FBType = Zfb_Type<Under>;
  using ZfbField_BlkFixed_blkOffset_<O, Base, Under, true>::load_;
  static void load(O &o, const FBType *fbo) { Base::set(o, load_(fbo)); }
};
using ZfbField_BlkFixed_blkOffset = ZfbField_BlkFixed_blkOffset_<>;
struct ZuField_BlkFixed_offset {
  using Orig = ZuField_BlkFixed_offset;
  template <template <typename> typename Override> using Adapt = Override<Orig>;
  enum { ReadOnly = 0 };
  using O = BlkFixed;
  static constexpr const char *id() { return "offset"; }
  using Props = ZuTypeList<ZuFieldProp::Ctor<1>, ZuFieldProp::Mutable>;
  using T = ZuDecay<decltype(ZuDeclVal<const BlkFixed &>().offset)>;
  static const T &get(const BlkFixed &o) { return o.offset; }
  static T &get(BlkFixed &o) { return o.offset; }
  static T &&get(BlkFixed &&o) { return ZuMv(o.offset); }
  template <typename P> static void set(BlkFixed &o, P &&v) {
    o.offset = ZuFwd<P>(v);
  }
};
using ZtField_BlkFixed_offset =
  ZtField_UInt64<ZuSchema::ZuField_BlkFixed_offset>;
template <
  typename O = BlkFixed, typename Base = ZtField_BlkFixed_offset,
  typename Under_ = O, bool = Base::ReadOnly, typename = void>
struct ZfbField_BlkFixed_offset_ : public Base {
  static_assert(
    ZuTypeIn<ZuFieldProp::Synthetic, typename Base::Props>{},
    "BlkFixed"
    "/"
    "offset"
    " - flatbuffers / C++ mismatch"
  );
};
template <typename O, typename Base, typename Under_>
struct ZfbField_BlkFixed_offset_<
  O, Base, Under_, true, decltype(&Zfb_Type<Under_>::offset, void())> :
  public Base {
  using Under = Under_;
  template <template <typename> typename Override>
  using Adapt = ZfbField_BlkFixed_offset_<
    typename Override<ZuFieldOrig<Base>>::O,
    typename Base::template Adapt<Override>, Under>;
  using FBType = Zfb_Type<Under>;
  enum { Inline = 1 };
  template <typename Builder> static void save(Builder &fbb, const O &o) {
    using P =
      ZuType<0, typename ZuDeduce<decltype(&Builder::add_offset)>::Args>;
    fbb.add_offset(static_cast<P>(Base::get(o)));
  }
  template <typename FBType_> static auto load_(const FBType_ *fbo) {
    return static_cast<typename Base::T>(fbo->offset());
  }
  static void load(O &, const FBType *) { }
};
template <typename O, typename Base, typename Under_>
struct ZfbField_BlkFixed_offset_<
  O, Base, Under_, false, decltype(&Zfb_Type<Under_>::offset, void())> :
  public ZfbField_BlkFixed_offset_<O, Base, Under_, true> {
  using Under = Under_;
  using FBType = Zfb_Type<Under>;
  using ZfbField_BlkFixed_offset_<O, Base, Under, true>::load_;
  static void load(O &o, const FBType *fbo) { Base::set(o, load_(fbo)); }
};
using ZfbField_BlkFixed_offset = ZfbField_BlkFixed_offset_<>;
struct ZuField_BlkFixed_last {
  using Orig = ZuField_BlkFixed_last;
  template <template <typename> typename Override> using Adapt = Override<Orig>;
  enum { ReadOnly = 0 };
  using O = BlkFixed;
  static constexpr const char *id() { return "last"; }
  using Props = ZuTypeList<ZuFieldProp::Ctor<2>, ZuFieldProp::Mutable>;
  using T = ZuDecay<decltype(ZuDeclVal<const BlkFixed &>().last)>;
  static const T &get(const BlkFixed &o) { return o.last; }
  static T &get(BlkFixed &o) { return o.last; }
  static T &&get(BlkFixed &&o) { return ZuMv(o.last); }
  template <typename P> static void set(BlkFixed &o, P &&v) {
    o.last = ZuFwd<P>(v);
  }
};
using ZtField_BlkFixed_last = ZtField_Int64<ZuSchema::ZuField_BlkFixed_last>;
template <
  typename O = BlkFixed, typename Base = ZtField_BlkFixed_last,
  typename Under_ = O, bool = Base::ReadOnly, typename = void>
struct ZfbField_BlkFixed_last_ : public Base {
  static_assert(
    ZuTypeIn<ZuFieldProp::Synthetic, typename Base::Props>{},
    "BlkFixed"
    "/"
    "last"
    " - flatbuffers / C++ mismatch"
  );
};
template <typename O, typename Base, typename Under_>
struct ZfbField_BlkFixed_last_<
  O, Base, Under_, true, decltype(&Zfb_Type<Under_>::last, void())> :
  public Base {
  using Under = Under_;
  template <template <typename> typename Override>
  using Adapt = ZfbField_BlkFixed_last_<
    typename Override<ZuFieldOrig<Base>>::O,
    typename Base::template Adapt<Override>, Under>;
  using FBType = Zfb_Type<Under>;
  enum { Inline = 1 };
  template <typename Builder> static void save(Builder &fbb, const O &o) {
    using P = ZuType<0, typename ZuDeduce<decltype(&Builder::add_last)>::Args>;
    fbb.add_last(static_cast<P>(Base::get(o)));
  }
  template <typename FBType_> static auto load_(const FBType_ *fbo) {
    return static_cast<typename Base::T>(fbo->last());
  }
  static void load(O &, const FBType *) { }
};
template <typename O, typename Base, typename Under_>
struct ZfbField_BlkFixed_last_<
  O, Base, Under_, false, decltype(&Zfb_Type<Under_>::last, void())> :
  public ZfbField_BlkFixed_last_<O, Base, Under_, true> {
  using Under = Under_;
  using FBType = Zfb_Type<Under>;
  using ZfbField_BlkFixed_last_<O, Base, Under, true>::load_;
  static void load(O &o, const FBType *fbo) { Base::set(o, load_(fbo)); }
};
using ZfbField_BlkFixed_last = ZfbField_BlkFixed_last_<>;
struct ZuField_BlkFixed_count {
  using Orig = ZuField_BlkFixed_count;
  template <template <typename> typename Override> using Adapt = Override<Orig>;
  enum { ReadOnly = 0 };
  using O = BlkFixed;
  static constexpr const char *id() { return "count"; }
  using Props = ZuTypeList<ZuFieldProp::Ctor<4>, ZuFieldProp::Mutable>;
  using T = ZuDecay<decltype(ZuDeclVal<const BlkFixed &>().count)>;
  static const T &get(const BlkFixed &o) { return o.count; }
  static T &get(BlkFixed &o) { return o.count; }
  static T &&get(BlkFixed &&o) { return ZuMv(o.count); }
  template <typename P> static void set(BlkFixed &o, P &&v) {
    o.count = ZuFwd<P>(v);
  }
};
using ZtField_BlkFixed_count = ZtField_UInt16<ZuSchema::ZuField_BlkFixed_count>;
template <
  typename O = BlkFixed, typename Base = ZtField_BlkFixed_count,
  typename Under_ = O, bool = Base::ReadOnly, typename = void>
struct ZfbField_BlkFixed_count_ : public Base {
  static_assert(
    ZuTypeIn<ZuFieldProp::Synthetic, typename Base::Props>{},
    "BlkFixed"
    "/"
    "count"
    " - flatbuffers / C++ mismatch"
  );
};
template <typename O, typename Base, typename Under_>
struct ZfbField_BlkFixed_count_<
  O, Base, Under_, true, decltype(&Zfb_Type<Under_>::count, void())> :
  public Base {
  using Under = Under_;
  template <template <typename> typename Override>
  using Adapt = ZfbField_BlkFixed_count_<
    typename Override<ZuFieldOrig<Base>>::O,
    typename Base::template Adapt<Override>, Under>;
  using FBType = Zfb_Type<Under>;
  enum { Inline = 1 };
  template <typename Builder> static void save(Builder &fbb, const O &o) {
    using P = ZuType<0, typename ZuDeduce<decltype(&Builder::add_count)>::Args>;
    fbb.add_count(static_cast<P>(Base::get(o)));
  }
  template <typename FBType_> static auto load_(const FBType_ *fbo) {
    return static_cast<typename Base::T>(fbo->count());
  }
  static void load(O &, const FBType *) { }
};
template <typename O, typename Base, typename Under_>
struct ZfbField_BlkFixed_count_<
  O, Base, Under_, false, decltype(&Zfb_Type<Under_>::count, void())> :
  public ZfbField_BlkFixed_count_<O, Base, Under_, true> {
  using Under = Under_;
  using FBType = Zfb_Type<Under>;
  using ZfbField_BlkFixed_count_<O, Base, Under, true>::load_;
  static void load(O &o, const FBType *fbo) { Base::set(o, load_(fbo)); }
};
using ZfbField_BlkFixed_count = ZfbField_BlkFixed_count_<>;
struct ZuField_BlkFixed_ndp {
  using Orig = ZuField_BlkFixed_ndp;
  template <template <typename> typename Override> using Adapt = Override<Orig>;
  enum { ReadOnly = 0 };
  using O = BlkFixed;
  static constexpr const char *id() { return "ndp"; }
  using Props = ZuTypeList<ZuFieldProp::Ctor<5>, ZuFieldProp::Mutable>;
  using T = ZuDecay<decltype(ZuDeclVal<const BlkFixed &>().ndp)>;
  static const T &get(const BlkFixed &o) { return o.ndp; }
  static T &get(BlkFixed &o) { return o.ndp; }
  static T &&get(BlkFixed &&o) { return ZuMv(o.ndp); }
  template <typename P> static void set(BlkFixed &o, P &&v) {
    o.ndp = ZuFwd<P>(v);
  }
};
using ZtField_BlkFixed_ndp = ZtField_UInt8<ZuSchema::ZuField_BlkFixed_ndp>;
template <
  typename O = BlkFixed, typename Base = ZtField_BlkFixed_ndp,
  typename Under_ = O, bool = Base::ReadOnly, typename = void>
struct ZfbField_BlkFixed_ndp_ : public Base {
  static_assert(
    ZuTypeIn<ZuFieldProp::Synthetic, typename Base::Props>{},
    "BlkFixed"
    "/"
    "ndp"
    " - flatbuffers / C++ mismatch"
  );
};
template <typename O, typename Base, typename Under_>
struct ZfbField_BlkFixed_ndp_<
  O, Base, Under_, true, decltype(&Zfb_Type<Under_>::ndp, void())> :
  public Base {
  using Under = Under_;
  template <template <typename> typename Override>
  using Adapt = ZfbField_BlkFixed_ndp_<
    typename Override<ZuFieldOrig<Base>>::O,
    typename Base::template Adapt<Override>, Under>;
  using FBType = Zfb_Type<Under>;
  enum { Inline = 1 };
  template <typename Builder> static void save(Builder &fbb, const O &o) {
    using P = ZuType<0, typename ZuDeduce<decltype(&Builder::add_ndp)>::Args>;
    fbb.add_ndp(static_cast<P>(Base::get(o)));
  }
  template <typename FBType_> static auto load_(const FBType_ *fbo) {
    return static_cast<typename Base::T>(fbo->ndp());
  }
  static void load(O &, const FBType *) { }
};
template <typename O, typename Base, typename Under_>
struct ZfbField_BlkFixed_ndp_<
  O, Base, Under_, false, decltype(&Zfb_Type<Under_>::ndp, void())> :
  public ZfbField_BlkFixed_ndp_<O, Base, Under_, true> {
  using Under = Under_;
  using FBType = Zfb_Type<Under>;
  using ZfbField_BlkFixed_ndp_<O, Base, Under, true>::load_;
  static void load(O &o, const FBType *fbo) { Base::set(o, load_(fbo)); }
};
using ZfbField_BlkFixed_ndp = ZfbField_BlkFixed_ndp_<>;
using BlkFixed = ZuTypeList<
  ZfbField_BlkFixed_seriesID, ZfbField_BlkFixed_blkOffset,
  ZfbField_BlkFixed_offset, ZfbField_BlkFixed_last, ZfbField_BlkFixed_count,
  ZfbField_BlkFixed_ndp>;
} // namespace ZuSchema
BlkFixed ZuFielded_(BlkFixed *);
ZuSchema::BlkFixed ZuFields_(BlkFixed *);
fbs::BlkFixedBuilder ZfbBuilder_(BlkFixed *);
fbs::BlkFixed ZfbType_(BlkFixed *);
BlkFixed ZfbUnder_(BlkFixed *);
namespace Zfb_Under_ {
using BlkFixed = BlkFixed;
}
namespace fbs {
Zfb_Under_::BlkFixed ZfbUnder_(BlkFixed *);
}
using BlkFixed_FBFields = ZfbField::Fields<BlkFixed>;
namespace fbs {
BlkFixed ZuFielded_(BlkFixed *);
BlkFixed_FBFields ZuFields_(BlkFixed *);
ZtFieldPrint ZuPrintType(BlkFixed *);
};
fbs::BlkFixedSchema ZfbSchema_(BlkFixed *);

struct BlkFloat {
  BlkOffset blkOffset;
  Offset offset;
  Float0 last;
  SeriesID seriesID;
  BlkCount count;
};
namespace ZuSchema {
struct ZuField_BlkFloat_seriesID {
  using Orig = ZuField_BlkFloat_seriesID;
  template <template <typename> typename Override> using Adapt = Override<Orig>;
  enum { ReadOnly = 0 };
  using O = BlkFloat;
  static constexpr const char *id() { return "seriesID"; }
  using Props = ZuTypeList<
    ZuFieldProp::Ctor<3>, ZuFieldProp::Keys<0>, ZuFieldProp::Group<0>,
    ZuFieldProp::Descend<0>>;
  using T = ZuDecay<decltype(ZuDeclVal<const BlkFloat &>().seriesID)>;
  static const T &get(const BlkFloat &o) { return o.seriesID; }
  static T &get(BlkFloat &o) { return o.seriesID; }
  static T &&get(BlkFloat &&o) { return ZuMv(o.seriesID); }
  template <typename P> static void set(BlkFloat &o, P &&v) {
    o.seriesID = ZuFwd<P>(v);
  }
};
using ZtField_BlkFloat_seriesID =
  ZtField_UInt32<ZuSchema::ZuField_BlkFloat_seriesID>;
template <
  typename O = BlkFloat, typename Base = ZtField_BlkFloat_seriesID,
  typename Under_ = O, bool = Base::ReadOnly, typename = void>
struct ZfbField_BlkFloat_seriesID_ : public Base {
  static_assert(
    ZuTypeIn<ZuFieldProp::Synthetic, typename Base::Props>{},
    "BlkFloat"
    "/"
    "seriesID"
    " - flatbuffers / C++ mismatch"
  );
};
template <typename O, typename Base, typename Under_>
struct ZfbField_BlkFloat_seriesID_<
  O, Base, Under_, true, decltype(&Zfb_Type<Under_>::seriesID, void())> :
  public Base {
  using Under = Under_;
  template <template <typename> typename Override>
  using Adapt = ZfbField_BlkFloat_seriesID_<
    typename Override<ZuFieldOrig<Base>>::O,
    typename Base::template Adapt<Override>, Under>;
  using FBType = Zfb_Type<Under>;
  enum { Inline = 1 };
  template <typename Builder> static void save(Builder &fbb, const O &o) {
    using P =
      ZuType<0, typename ZuDeduce<decltype(&Builder::add_seriesID)>::Args>;
    fbb.add_seriesID(static_cast<P>(Base::get(o)));
  }
  template <typename FBType_> static auto load_(const FBType_ *fbo) {
    return static_cast<typename Base::T>(fbo->seriesID());
  }
  static void load(O &, const FBType *) { }
};
template <typename O, typename Base, typename Under_>
struct ZfbField_BlkFloat_seriesID_<
  O, Base, Under_, false, decltype(&Zfb_Type<Under_>::seriesID, void())> :
  public ZfbField_BlkFloat_seriesID_<O, Base, Under_, true> {
  using Under = Under_;
  using FBType = Zfb_Type<Under>;
  using ZfbField_BlkFloat_seriesID_<O, Base, Under, true>::load_;
  static void load(O &o, const FBType *fbo) { Base::set(o, load_(fbo)); }
};
using ZfbField_BlkFloat_seriesID = ZfbField_BlkFloat_seriesID_<>;
struct ZuField_BlkFloat_blkOffset {
  using Orig = ZuField_BlkFloat_blkOffset;
  template <template <typename> typename Override> using Adapt = Override<Orig>;
  enum { ReadOnly = 0 };
  using O = BlkFloat;
  static constexpr const char *id() { return "blkOffset"; }
  using Props = ZuTypeList<
    ZuFieldProp::Ctor<0>, ZuFieldProp::Keys<0>, ZuFieldProp::Descend<0>>;
  using T = ZuDecay<decltype(ZuDeclVal<const BlkFloat &>().blkOffset)>;
  static const T &get(const BlkFloat &o) { return o.blkOffset; }
  static T &get(BlkFloat &o) { return o.blkOffset; }
  static T &&get(BlkFloat &&o) { return ZuMv(o.blkOffset); }
  template <typename P> static void set(BlkFloat &o, P &&v) {
    o.blkOffset = ZuFwd<P>(v);
  }
};
using ZtField_BlkFloat_blkOffset =
  ZtField_UInt64<ZuSchema::ZuField_BlkFloat_blkOffset>;
template <
  typename O = BlkFloat, typename Base = ZtField_BlkFloat_blkOffset,
  typename Under_ = O, bool = Base::ReadOnly, typename = void>
struct ZfbField_BlkFloat_blkOffset_ : public Base {
  static_assert(
    ZuTypeIn<ZuFieldProp::Synthetic, typename Base::Props>{},
    "BlkFloat"
    "/"
    "blkOffset"
    " - flatbuffers / C++ mismatch"
  );
};
template <typename O, typename Base, typename Under_>
struct ZfbField_BlkFloat_blkOffset_<
  O, Base, Under_, true, decltype(&Zfb_Type<Under_>::blkOffset, void())> :
  public Base {
  using Under = Under_;
  template <template <typename> typename Override>
  using Adapt = ZfbField_BlkFloat_blkOffset_<
    typename Override<ZuFieldOrig<Base>>::O,
    typename Base::template Adapt<Override>, Under>;
  using FBType = Zfb_Type<Under>;
  enum { Inline = 1 };
  template <typename Builder> static void save(Builder &fbb, const O &o) {
    using P =
      ZuType<0, typename ZuDeduce<decltype(&Builder::add_blkOffset)>::Args>;
    fbb.add_blkOffset(static_cast<P>(Base::get(o)));
  }
  template <typename FBType_> static auto load_(const FBType_ *fbo) {
    return static_cast<typename Base::T>(fbo->blkOffset());
  }
  static void load(O &, const FBType *) { }
};
template <typename O, typename Base, typename Under_>
struct ZfbField_BlkFloat_blkOffset_<
  O, Base, Under_, false, decltype(&Zfb_Type<Under_>::blkOffset, void())> :
  public ZfbField_BlkFloat_blkOffset_<O, Base, Under_, true> {
  using Under = Under_;
  using FBType = Zfb_Type<Under>;
  using ZfbField_BlkFloat_blkOffset_<O, Base, Under, true>::load_;
  static void load(O &o, const FBType *fbo) { Base::set(o, load_(fbo)); }
};
using ZfbField_BlkFloat_blkOffset = ZfbField_BlkFloat_blkOffset_<>;
struct ZuField_BlkFloat_offset {
  using Orig = ZuField_BlkFloat_offset;
  template <template <typename> typename Override> using Adapt = Override<Orig>;
  enum { ReadOnly = 0 };
  using O = BlkFloat;
  static constexpr const char *id() { return "offset"; }
  using Props = ZuTypeList<ZuFieldProp::Ctor<1>, ZuFieldProp::Mutable>;
  using T = ZuDecay<decltype(ZuDeclVal<const BlkFloat &>().offset)>;
  static const T &get(const BlkFloat &o) { return o.offset; }
  static T &get(BlkFloat &o) { return o.offset; }
  static T &&get(BlkFloat &&o) { return ZuMv(o.offset); }
  template <typename P> static void set(BlkFloat &o, P &&v) {
    o.offset = ZuFwd<P>(v);
  }
};
using ZtField_BlkFloat_offset =
  ZtField_UInt64<ZuSchema::ZuField_BlkFloat_offset>;
template <
  typename O = BlkFloat, typename Base = ZtField_BlkFloat_offset,
  typename Under_ = O, bool = Base::ReadOnly, typename = void>
struct ZfbField_BlkFloat_offset_ : public Base {
  static_assert(
    ZuTypeIn<ZuFieldProp::Synthetic, typename Base::Props>{},
    "BlkFloat"
    "/"
    "offset"
    " - flatbuffers / C++ mismatch"
  );
};
template <typename O, typename Base, typename Under_>
struct ZfbField_BlkFloat_offset_<
  O, Base, Under_, true, decltype(&Zfb_Type<Under_>::offset, void())> :
  public Base {
  using Under = Under_;
  template <template <typename> typename Override>
  using Adapt = ZfbField_BlkFloat_offset_<
    typename Override<ZuFieldOrig<Base>>::O,
    typename Base::template Adapt<Override>, Under>;
  using FBType = Zfb_Type<Under>;
  enum { Inline = 1 };
  template <typename Builder> static void save(Builder &fbb, const O &o) {
    using P =
      ZuType<0, typename ZuDeduce<decltype(&Builder::add_offset)>::Args>;
    fbb.add_offset(static_cast<P>(Base::get(o)));
  }
  template <typename FBType_> static auto load_(const FBType_ *fbo) {
    return static_cast<typename Base::T>(fbo->offset());
  }
  static void load(O &, const FBType *) { }
};
template <typename O, typename Base, typename Under_>
struct ZfbField_BlkFloat_offset_<
  O, Base, Under_, false, decltype(&Zfb_Type<Under_>::offset, void())> :
  public ZfbField_BlkFloat_offset_<O, Base, Under_, true> {
  using Under = Under_;
  using FBType = Zfb_Type<Under>;
  using ZfbField_BlkFloat_offset_<O, Base, Under, true>::load_;
  static void load(O &o, const FBType *fbo) { Base::set(o, load_(fbo)); }
};
using ZfbField_BlkFloat_offset = ZfbField_BlkFloat_offset_<>;
struct ZuField_BlkFloat_last {
  using Orig = ZuField_BlkFloat_last;
  template <template <typename> typename Override> using Adapt = Override<Orig>;
  enum { ReadOnly = 0 };
  using O = BlkFloat;
  static constexpr const char *id() { return "last"; }
  using Props = ZuTypeList<ZuFieldProp::Ctor<2>, ZuFieldProp::Mutable>;
  using T = ZuDecay<decltype(ZuDeclVal<const BlkFloat &>().last)>;
  static const T &get(const BlkFloat &o) { return o.last; }
  static T &get(BlkFloat &o) { return o.last; }
  static T &&get(BlkFloat &&o) { return ZuMv(o.last); }
  template <typename P> static void set(BlkFloat &o, P &&v) {
    o.last = ZuFwd<P>(v);
  }
};
using ZtField_BlkFloat_last = ZtField_Float<ZuSchema::ZuField_BlkFloat_last>;
template <
  typename O = BlkFloat, typename Base = ZtField_BlkFloat_last,
  typename Under_ = O, bool = Base::ReadOnly, typename = void>
struct ZfbField_BlkFloat_last_ : public Base {
  static_assert(
    ZuTypeIn<ZuFieldProp::Synthetic, typename Base::Props>{},
    "BlkFloat"
    "/"
    "last"
    " - flatbuffers / C++ mismatch"
  );
};
template <typename O, typename Base, typename Under_>
struct ZfbField_BlkFloat_last_<
  O, Base, Under_, true, decltype(&Zfb_Type<Under_>::last, void())> :
  public Base {
  using Under = Under_;
  template <template <typename> typename Override>
  using Adapt = ZfbField_BlkFloat_last_<
    typename Override<ZuFieldOrig<Base>>::O,
    typename Base::template Adapt<Override>, Under>;
  using FBType = Zfb_Type<Under>;
  enum { Inline = 1 };
  template <typename Builder> static void save(Builder &fbb, const O &o) {
    using P = ZuType<0, typename ZuDeduce<decltype(&Builder::add_last)>::Args>;
    fbb.add_last(static_cast<P>(Base::get(o)));
  }
  template <typename FBType_> static auto load_(const FBType_ *fbo) {
    return static_cast<typename Base::T>(fbo->last());
  }
  static void load(O &, const FBType *) { }
};
template <typename O, typename Base, typename Under_>
struct ZfbField_BlkFloat_last_<
  O, Base, Under_, false, decltype(&Zfb_Type<Under_>::last, void())> :
  public ZfbField_BlkFloat_last_<O, Base, Under_, true> {
  using Under = Under_;
  using FBType = Zfb_Type<Under>;
  using ZfbField_BlkFloat_last_<O, Base, Under, true>::load_;
  static void load(O &o, const FBType *fbo) { Base::set(o, load_(fbo)); }
};
using ZfbField_BlkFloat_last = ZfbField_BlkFloat_last_<>;
struct ZuField_BlkFloat_count {
  using Orig = ZuField_BlkFloat_count;
  template <template <typename> typename Override> using Adapt = Override<Orig>;
  enum { ReadOnly = 0 };
  using O = BlkFloat;
  static constexpr const char *id() { return "count"; }
  using Props = ZuTypeList<ZuFieldProp::Ctor<4>, ZuFieldProp::Mutable>;
  using T = ZuDecay<decltype(ZuDeclVal<const BlkFloat &>().count)>;
  static const T &get(const BlkFloat &o) { return o.count; }
  static T &get(BlkFloat &o) { return o.count; }
  static T &&get(BlkFloat &&o) { return ZuMv(o.count); }
  template <typename P> static void set(BlkFloat &o, P &&v) {
    o.count = ZuFwd<P>(v);
  }
};
using ZtField_BlkFloat_count = ZtField_UInt16<ZuSchema::ZuField_BlkFloat_count>;
template <
  typename O = BlkFloat, typename Base = ZtField_BlkFloat_count,
  typename Under_ = O, bool = Base::ReadOnly, typename = void>
struct ZfbField_BlkFloat_count_ : public Base {
  static_assert(
    ZuTypeIn<ZuFieldProp::Synthetic, typename Base::Props>{},
    "BlkFloat"
    "/"
    "count"
    " - flatbuffers / C++ mismatch"
  );
};
template <typename O, typename Base, typename Under_>
struct ZfbField_BlkFloat_count_<
  O, Base, Under_, true, decltype(&Zfb_Type<Under_>::count, void())> :
  public Base {
  using Under = Under_;
  template <template <typename> typename Override>
  using Adapt = ZfbField_BlkFloat_count_<
    typename Override<ZuFieldOrig<Base>>::O,
    typename Base::template Adapt<Override>, Under>;
  using FBType = Zfb_Type<Under>;
  enum { Inline = 1 };
  template <typename Builder> static void save(Builder &fbb, const O &o) {
    using P = ZuType<0, typename ZuDeduce<decltype(&Builder::add_count)>::Args>;
    fbb.add_count(static_cast<P>(Base::get(o)));
  }
  template <typename FBType_> static auto load_(const FBType_ *fbo) {
    return static_cast<typename Base::T>(fbo->count());
  }
  static void load(O &, const FBType *) { }
};
template <typename O, typename Base, typename Under_>
struct ZfbField_BlkFloat_count_<
  O, Base, Under_, false, decltype(&Zfb_Type<Under_>::count, void())> :
  public ZfbField_BlkFloat_count_<O, Base, Under_, true> {
  using Under = Under_;
  using FBType = Zfb_Type<Under>;
  using ZfbField_BlkFloat_count_<O, Base, Under, true>::load_;
  static void load(O &o, const FBType *fbo) { Base::set(o, load_(fbo)); }
};
using ZfbField_BlkFloat_count = ZfbField_BlkFloat_count_<>;
using BlkFloat = ZuTypeList<
  ZfbField_BlkFloat_seriesID, ZfbField_BlkFloat_blkOffset,
  ZfbField_BlkFloat_offset, ZfbField_BlkFloat_last, ZfbField_BlkFloat_count>;
} // namespace ZuSchema
BlkFloat ZuFielded_(BlkFloat *);
ZuSchema::BlkFloat ZuFields_(BlkFloat *);
fbs::BlkFloatBuilder ZfbBuilder_(BlkFloat *);
fbs::BlkFloat ZfbType_(BlkFloat *);
BlkFloat ZfbUnder_(BlkFloat *);
namespace Zfb_Under_ {
using BlkFloat = BlkFloat;
}
namespace fbs {
Zfb_Under_::BlkFloat ZfbUnder_(BlkFloat *);
}
using BlkFloat_FBFields = ZfbField::Fields<BlkFloat>;
namespace fbs {
BlkFloat ZuFielded_(BlkFloat *);
BlkFloat_FBFields ZuFields_(BlkFloat *);
ZtFieldPrint ZuPrintType(BlkFloat *);
};
fbs::BlkFloatSchema ZfbSchema_(BlkFloat *);

using BlkDataBuf = ZuArray<uint8_t, BlkSize>;

struct BlkData {
  BlkOffset blkOffset;
  SeriesID seriesID;
  BlkDataBuf buf;
};
namespace ZuSchema {
struct ZuField_BlkData_seriesID {
  using Orig = ZuField_BlkData_seriesID;
  template <template <typename> typename Override> using Adapt = Override<Orig>;
  enum { ReadOnly = 0 };
  using O = BlkData;
  static constexpr const char *id() { return "seriesID"; }
  using Props = ZuTypeList<
    ZuFieldProp::Ctor<1>, ZuFieldProp::Keys<0>, ZuFieldProp::Group<0>,
    ZuFieldProp::Descend<0>>;
  using T = ZuDecay<decltype(ZuDeclVal<const BlkData &>().seriesID)>;
  static const T &get(const BlkData &o) { return o.seriesID; }
  static T &get(BlkData &o) { return o.seriesID; }
  static T &&get(BlkData &&o) { return ZuMv(o.seriesID); }
  template <typename P> static void set(BlkData &o, P &&v) {
    o.seriesID = ZuFwd<P>(v);
  }
};
using ZtField_BlkData_seriesID =
  ZtField_UInt32<ZuSchema::ZuField_BlkData_seriesID>;
template <
  typename O = BlkData, typename Base = ZtField_BlkData_seriesID,
  typename Under_ = O, bool = Base::ReadOnly, typename = void>
struct ZfbField_BlkData_seriesID_ : public Base {
  static_assert(
    ZuTypeIn<ZuFieldProp::Synthetic, typename Base::Props>{},
    "BlkData"
    "/"
    "seriesID"
    " - flatbuffers / C++ mismatch"
  );
};
template <typename O, typename Base, typename Under_>
struct ZfbField_BlkData_seriesID_<
  O, Base, Under_, true, decltype(&Zfb_Type<Under_>::seriesID, void())> :
  public Base {
  using Under = Under_;
  template <template <typename> typename Override>
  using Adapt = ZfbField_BlkData_seriesID_<
    typename Override<ZuFieldOrig<Base>>::O,
    typename Base::template Adapt<Override>, Under>;
  using FBType = Zfb_Type<Under>;
  enum { Inline = 1 };
  template <typename Builder> static void save(Builder &fbb, const O &o) {
    using P =
      ZuType<0, typename ZuDeduce<decltype(&Builder::add_seriesID)>::Args>;
    fbb.add_seriesID(static_cast<P>(Base::get(o)));
  }
  template <typename FBType_> static auto load_(const FBType_ *fbo) {
    return static_cast<typename Base::T>(fbo->seriesID());
  }
  static void load(O &, const FBType *) { }
};
template <typename O, typename Base, typename Under_>
struct ZfbField_BlkData_seriesID_<
  O, Base, Under_, false, decltype(&Zfb_Type<Under_>::seriesID, void())> :
  public ZfbField_BlkData_seriesID_<O, Base, Under_, true> {
  using Under = Under_;
  using FBType = Zfb_Type<Under>;
  using ZfbField_BlkData_seriesID_<O, Base, Under, true>::load_;
  static void load(O &o, const FBType *fbo) { Base::set(o, load_(fbo)); }
};
using ZfbField_BlkData_seriesID = ZfbField_BlkData_seriesID_<>;
struct ZuField_BlkData_blkOffset {
  using Orig = ZuField_BlkData_blkOffset;
  template <template <typename> typename Override> using Adapt = Override<Orig>;
  enum { ReadOnly = 0 };
  using O = BlkData;
  static constexpr const char *id() { return "blkOffset"; }
  using Props = ZuTypeList<
    ZuFieldProp::Ctor<0>, ZuFieldProp::Keys<0>, ZuFieldProp::Descend<0>>;
  using T = ZuDecay<decltype(ZuDeclVal<const BlkData &>().blkOffset)>;
  static const T &get(const BlkData &o) { return o.blkOffset; }
  static T &get(BlkData &o) { return o.blkOffset; }
  static T &&get(BlkData &&o) { return ZuMv(o.blkOffset); }
  template <typename P> static void set(BlkData &o, P &&v) {
    o.blkOffset = ZuFwd<P>(v);
  }
};
using ZtField_BlkData_blkOffset =
  ZtField_UInt64<ZuSchema::ZuField_BlkData_blkOffset>;
template <
  typename O = BlkData, typename Base = ZtField_BlkData_blkOffset,
  typename Under_ = O, bool = Base::ReadOnly, typename = void>
struct ZfbField_BlkData_blkOffset_ : public Base {
  static_assert(
    ZuTypeIn<ZuFieldProp::Synthetic, typename Base::Props>{},
    "BlkData"
    "/"
    "blkOffset"
    " - flatbuffers / C++ mismatch"
  );
};
template <typename O, typename Base, typename Under_>
struct ZfbField_BlkData_blkOffset_<
  O, Base, Under_, true, decltype(&Zfb_Type<Under_>::blkOffset, void())> :
  public Base {
  using Under = Under_;
  template <template <typename> typename Override>
  using Adapt = ZfbField_BlkData_blkOffset_<
    typename Override<ZuFieldOrig<Base>>::O,
    typename Base::template Adapt<Override>, Under>;
  using FBType = Zfb_Type<Under>;
  enum { Inline = 1 };
  template <typename Builder> static void save(Builder &fbb, const O &o) {
    using P =
      ZuType<0, typename ZuDeduce<decltype(&Builder::add_blkOffset)>::Args>;
    fbb.add_blkOffset(static_cast<P>(Base::get(o)));
  }
  template <typename FBType_> static auto load_(const FBType_ *fbo) {
    return static_cast<typename Base::T>(fbo->blkOffset());
  }
  static void load(O &, const FBType *) { }
};
template <typename O, typename Base, typename Under_>
struct ZfbField_BlkData_blkOffset_<
  O, Base, Under_, false, decltype(&Zfb_Type<Under_>::blkOffset, void())> :
  public ZfbField_BlkData_blkOffset_<O, Base, Under_, true> {
  using Under = Under_;
  using FBType = Zfb_Type<Under>;
  using ZfbField_BlkData_blkOffset_<O, Base, Under, true>::load_;
  static void load(O &o, const FBType *fbo) { Base::set(o, load_(fbo)); }
};
using ZfbField_BlkData_blkOffset = ZfbField_BlkData_blkOffset_<>;
struct ZuField_BlkData_buf {
  using Orig = ZuField_BlkData_buf;
  template <template <typename> typename Override> using Adapt = Override<Orig>;
  enum { ReadOnly = 0 };
  using O = BlkData;
  static constexpr const char *id() { return "buf"; }
  using Props = ZuTypeList<ZuFieldProp::Mutable>;
  using T = ZuDecay<decltype(ZuDeclVal<const BlkData &>().buf)>;
  static const T &get(const BlkData &o) { return o.buf; }
  static T &get(BlkData &o) { return o.buf; }
  static T &&get(BlkData &&o) { return ZuMv(o.buf); }
  template <typename P> static void set(BlkData &o, P &&v) {
    o.buf = ZuFwd<P>(v);
  }
};
using ZtField_BlkData_buf = ZtField_Bytes<ZuSchema::ZuField_BlkData_buf>;
template <
  typename O = BlkData, typename Base = ZtField_BlkData_buf,
  typename Under_ = O, bool = Base::ReadOnly, typename = void>
struct ZfbField_BlkData_buf_ : public Base {
  static_assert(
    ZuTypeIn<ZuFieldProp::Synthetic, typename Base::Props>{},
    "BlkData"
    "/"
    "buf"
    " - flatbuffers / C++ mismatch"
  );
};
template <typename O, typename Base, typename Under_>
struct ZfbField_BlkData_buf_<
  O, Base, Under_, true, decltype(&Zfb_Type<Under_>::buf, void())> :
  public Base {
  using Under = Under_;
  template <template <typename> typename Override>
  using Adapt = ZfbField_BlkData_buf_<
    typename Override<ZuFieldOrig<Base>>::O,
    typename Base::template Adapt<Override>, Under>;
  using Builder = Zfb_Builder<Under>;
  using FBType = Zfb_Type<Under>;
  enum { Inline = 0 };
  static Zfb::Offset<void> save(Zfb::Builder &fbb, const O &o) {
    return Zfb::Save::bytes(fbb, Base::get(o)).Union();
  }
  template <typename Builder>
  static void save(Builder &fbb, Zfb::Offset<void> offset) {
    fbb.add_buf(offset.o);
  }
  template <typename FBType_> static decltype(auto) load_(const FBType_ *fbo) {
    return Zfb::Load::bytes(fbo->buf());
  }
  static void load(O &, const FBType *) { }
};
template <typename O, typename Base, typename Under_>
struct ZfbField_BlkData_buf_<
  O, Base, Under_, false, decltype(&Zfb_Type<Under_>::buf, void())> :
  public ZfbField_BlkData_buf_<O, Base, Under_, true> {
  using Under = Under_;
  using FBType = Zfb_Type<Under>;
  using ZfbField_BlkData_buf_<O, Base, Under, true>::load_;
  static void load(O &o, const FBType *fbo) { Base::set(o, load_(fbo)); }
};
using ZfbField_BlkData_buf = ZfbField_BlkData_buf_<>;
using BlkData = ZuTypeList<
  ZfbField_BlkData_seriesID, ZfbField_BlkData_blkOffset, ZfbField_BlkData_buf>;
} // namespace ZuSchema
BlkData ZuFielded_(BlkData *);
ZuSchema::BlkData ZuFields_(BlkData *);
fbs::BlkDataBuilder ZfbBuilder_(BlkData *);
fbs::BlkData ZfbType_(BlkData *);
BlkData ZfbUnder_(BlkData *);
namespace Zfb_Under_ {
using BlkData = BlkData;
}
namespace fbs {
Zfb_Under_::BlkData ZfbUnder_(BlkData *);
}
using BlkData_FBFields = ZfbField::Fields<BlkData>;
namespace fbs {
BlkData ZuFielded_(BlkData *);
BlkData_FBFields ZuFields_(BlkData *);
ZtFieldPrint ZuPrintType(BlkData *);
};
fbs::BlkDataSchema ZfbSchema_(BlkData *);

} // namespace Zdf::DB

namespace Zdf {

template <typename> class Series;

class BlkData : public ZdbObject<DB::BlkData> {
public:
  using EvictFn = ZmFn<void(BlkData *)>;

  BlkData(EvictFn evictFn, ZdbTable<DB::BlkData> *tbl, Shard shard) :
    ZdbObject<DB::BlkData>{tbl, shard}, m_evictFn{ZuMv(evictFn)} { }

  void evict() {
    auto fn = ZuMv(m_evictFn);
    fn(this);
    ZdbAnyObject::evict();
  }

private:
  EvictFn m_evictFn;
};

union Last {
  int64_t fixed;
  double float_;
};

struct Blk {
  uint64_t ocn = 0;
  Last last{.fixed = 0};
  ZmRef<BlkData> blkData;

  static constexpr const uint64_t OffsetMask() {
    return (uint64_t(1) << 47) - 1;
  }
  static constexpr const unsigned CountShift() { return 47; }
  static constexpr const uint64_t CountMask() { return uint64_t(0xfff); }
  static constexpr const unsigned NDPShift() { return 59; }
  static constexpr const uint64_t NDPMask() { return uint64_t(0x1f); }

  void init(uint64_t offset, uint64_t count, uint64_t ndp, int64_t last_) {
    ocn = offset | (count << CountShift()) | (ndp << NDPShift());
    last.fixed = last_;
  }
  void init(uint64_t offset, uint64_t count, double last_) {
    ocn = offset | (count << CountShift());
    last.float_ = last_;
  }

  inline uint64_t offset() const { return ocn & OffsetMask(); }
  inline BlkCount count() const { return (ocn >> CountShift()) & CountMask(); }
  inline NDP ndp() const { return (ocn >> NDPShift()) & NDPMask(); }

  inline bool operator!() const { return !count(); }

  inline void offset(uint64_t v) { ocn = (ocn & ~OffsetMask()) | v; }
  inline void count(uint64_t v) {
    ocn = (ocn & ~(CountMask() << CountShift())) | (v << CountShift());
  }
  inline void ndp(uint64_t v) {
    ocn = (ocn & ~(NDPMask() << NDPShift())) | (v << NDPShift());
  }
  inline void count_ndp(uint64_t count_, uint64_t ndp_) {
    ocn =
      (ocn & OffsetMask()) | (count_ << CountShift()) | (ndp_ << NDPShift());
  }

  template <typename Decoder> Decoder decoder() const {
    ((blkData) ?
       void() :
       ZmAssert_fail(
	 "blkData", "../../zdf/src/zlib/ZdfBlk.hh", 90, __PRETTY_FUNCTION__
       ));
    const auto &buf = blkData->data().buf;
    auto start = buf.data();
    return Decoder{start, start + buf.length()};
  }

  template <typename Decoder>
  Encoder<Decoder> encoder(Series<Decoder> *series) {
    ((blkData) ?
       void() :
       ZmAssert_fail(
	 "blkData", "../../zdf/src/zlib/ZdfBlk.hh", 98, __PRETTY_FUNCTION__
       ));
    auto &buf = blkData->data().buf;
    auto start = buf.data();
    return {start, start + BlkSize};
  }

  template <typename Encoder> void sync(const Encoder &encoder, int64_t last_) {
    count(encoder.offset());
    last.fixed = last_;
    ((blkData) ?
       void() :
       ZmAssert_fail(
	 "blkData", "../../zdf/src/zlib/ZdfBlk.hh", 108, __PRETTY_FUNCTION__
       ));
    auto &buf = blkData->data().buf;
    buf.length(encoder.pos() - buf.data());
  }
  template <typename Encoder> void sync(const Encoder &encoder, double last_) {
    offset(encoder.offset());
    last.float_ = last_;
    ((blkData) ?
       void() :
       ZmAssert_fail(
	 "blkData", "../../zdf/src/zlib/ZdfBlk.hh", 116, __PRETTY_FUNCTION__
       ));
    auto &buf = blkData->data().buf;
    buf.length(encoder.pos() - buf.data());
  }

  unsigned space() const {
    ((blkData) ?
       void() :
       ZmAssert_fail(
	 "blkData", "../../zdf/src/zlib/ZdfBlk.hh", 122, __PRETTY_FUNCTION__
       ));
    const auto &buf = blkData->data().buf;
    return BlkSize - buf.length();
  }
};

} // namespace Zdf

namespace Zdf {

template <typename> class Series;

namespace RdrState {
using T = int8_t;
enum {
  Invalid = -1,
  Stopped = 0,
  Loading = 1,
  Reading = 2,
  Live = 3,
  Stopping = 4,
  N
};
static_assert((N <= 1024), "N <= 1024");
enum {
  Bits = N <= 2 ? 1 :
    N <= 4      ? 2 :
    N <= 8      ? 3 :
    N <= 16     ? 4 :
    N <= 32     ? 5 :
    N <= 64     ? 6 :
    N <= 128    ? 7 :
    N <= 256    ? 8 :
    N <= 512    ? 9 :
		  10
};
template <typename Impl> struct Map_ : public ZuObject {
private:
  using V2S = ZmLHashKV<T, ZuCSpan, ZmLHashStatic<Bits, ZmLHashLocal<>>>;
  using S2V = ZmLHashKV<ZuCSpan, T, ZmLHashStatic<Bits, ZmLHashLocal<>>>;

protected:
  void init(const char *s, int v, ...) {
    if (__builtin_expect(!!(!s), 0)) return;
    add(s, v);
    va_list args;

    __builtin_va_start(

      args

      ,

      v

    );
    while (s =

	     __builtin_va_arg(

	       args

	       ,

	       const char *

	     )

    )
      add(
	s,
	v =

	  __builtin_va_arg(

	    args

	    ,

	    int

	  )

      );

    __builtin_va_end(

      args

    );
  }
  void add(ZuCSpan s, T v) {
    m_s2v.add(s, v);
    m_v2s.add(v, s);
  }
  static Impl *instance() { return ZmSingleton<Impl>::instance(); }

private:
  T s2v_(ZuCSpan s) const { return m_s2v.findVal(s); }
  ZuCSpan v2s_(T v) const { return m_v2s.findVal(v); }
  template <typename L> void all_(L l) const {
    auto i = m_s2v.readIterator();
    while (auto kv = i.iterate()) {
      l(kv->template p<0>(), kv->template p<1>());
    }
  }

public:
  Map_() = default;
  static T s2v(ZuCSpan s) { return instance()->s2v_(s); }
  static ZuCSpan v2s(T v) { return instance()->v2s_(v); }
  template <typename L> static void all(L l) { instance()->all_(ZuMv(l)); }

private:
  S2V m_s2v;
  V2S m_v2s;
};
inline ZuTuple<const char *const *const, unsigned> names() {
  static const char *names[] = {
    "Stopped = 0", "Loading = 1", "Reading = 2", "Live = 3", "Stopping = 4"
  };
  return ZuTuple<const char *const *const, unsigned>{
    names, static_cast<unsigned>(sizeof(names) / sizeof(names[0]))
  };
}
inline const char *name(int i) {
  ZuTuple<const char *const *const, unsigned> names_ = names();
  if (i >= (int)names_.p<1>()) return "Unknown";
  if (i < 0) return "";
  return names_.p<0>()[i];
}
struct Map : public Map_<Map> {
  static constexpr const char *id() { return "RdrState"; }
  Map() {
    for (unsigned i = 0; i < N; i++) this->add(name(i), i);
  }
};
template <typename S> inline T lookup(const S &s) { return Map::s2v(s); };

constexpr const bool stopped(T v) { return v == Stopped; }
constexpr const bool reading(T v) { return v >= Loading; }
constexpr const bool live(T v) { return v == Live; }
} // namespace RdrState

namespace RdrResult {
using T = int8_t;
enum { Invalid = -1, OK = 0, Load, EOS, Stopped, Failed, N };
static_assert((N <= 1024), "N <= 1024");
enum {
  Bits = N <= 2 ? 1 :
    N <= 4      ? 2 :
    N <= 8      ? 3 :
    N <= 16     ? 4 :
    N <= 32     ? 5 :
    N <= 64     ? 6 :
    N <= 128    ? 7 :
    N <= 256    ? 8 :
    N <= 512    ? 9 :
		  10
};
template <typename Impl> struct Map_ : public ZuObject {
private:
  using V2S = ZmLHashKV<T, ZuCSpan, ZmLHashStatic<Bits, ZmLHashLocal<>>>;
  using S2V = ZmLHashKV<ZuCSpan, T, ZmLHashStatic<Bits, ZmLHashLocal<>>>;

protected:
  void init(const char *s, int v, ...) {
    if (__builtin_expect(!!(!s), 0)) return;
    add(s, v);
    va_list args;

    __builtin_va_start(

      args

      ,

      v

    );
    while (s =

	     __builtin_va_arg(

	       args

	       ,

	       const char *

	     )

    )
      add(
	s,
	v =

	  __builtin_va_arg(

	    args

	    ,

	    int

	  )

      );

    __builtin_va_end(

      args

    );
  }
  void add(ZuCSpan s, T v) {
    m_s2v.add(s, v);
    m_v2s.add(v, s);
  }
  static Impl *instance() { return ZmSingleton<Impl>::instance(); }

private:
  T s2v_(ZuCSpan s) const { return m_s2v.findVal(s); }
  ZuCSpan v2s_(T v) const { return m_v2s.findVal(v); }
  template <typename L> void all_(L l) const {
    auto i = m_s2v.readIterator();
    while (auto kv = i.iterate()) {
      l(kv->template p<0>(), kv->template p<1>());
    }
  }

public:
  Map_() = default;
  static T s2v(ZuCSpan s) { return instance()->s2v_(s); }
  static ZuCSpan v2s(T v) { return instance()->v2s_(v); }
  template <typename L> static void all(L l) { instance()->all_(ZuMv(l)); }

private:
  S2V m_s2v;
  V2S m_v2s;
};
inline ZuTuple<const char *const *const, unsigned> names() {
  static const char *names[] = {"OK = 0", "Load", "EOS", "Stopped", "Failed"};
  return ZuTuple<const char *const *const, unsigned>{
    names, static_cast<unsigned>(sizeof(names) / sizeof(names[0]))
  };
}
inline const char *name(int i) {
  ZuTuple<const char *const *const, unsigned> names_ = names();
  if (i >= (int)names_.p<1>()) return "Unknown";
  if (i < 0) return "";
  return names_.p<0>()[i];
}
struct Map : public Map_<Map> {
  static constexpr const char *id() { return "RdrResult"; }
  Map() {
    for (unsigned i = 0; i < N; i++) this->add(name(i), i);
  }
};
template <typename S> inline T lookup(const S &s) { return Map::s2v(s); };
} // namespace RdrResult

using ErrorFn = ZmFn<void()>;
using StopFn = ZmFn<void()>;

template <typename Decoder_> class Reader : public ZmObject {
public:
  using Decoder = Decoder_;
  using Series = Zdf::Series<Decoder>;
  using PValue = typename Decoder::Value;
  enum { Fixed = ZuIsExact<PValue, int64_t>{} };
  using Value = ZuIf<Fixed, ZuFixed, double>;

private:
  friend Series;

  static_assert(
    ((!ZuIsExact<Offset, Value>{})), "(!ZuIsExact<Offset, Value>{})"
  );
  using Target = ZuUnion<void, Offset, Value>;

  Reader() = delete;
  Reader(const Reader &) = delete;
  Reader &operator=(const Reader &) = delete;
  Reader(Reader &&) = delete;
  Reader &operator=(Reader &&) = delete;

public:
  ~Reader() { }

  const Series *series() const { return m_series; }
  bool stopped() const { return RdrState::stopped(m_state); }
  bool reading() const { return RdrState::reading(m_state); }
  bool live() const { return m_state == RdrState::Live; }
  bool failed() const { return m_failed; }
  NDP ndp() const { return m_blk ? m_blk->ndp() : NDP(0); }
  Offset offset() const;

  class Ctrl;
  friend Ctrl;
  class Ctrl {
    friend Reader;

    Ctrl(Reader &reader_) : reader{reader_} { }

  public:
    Reader &reader;

    void yield();

    void seekFwd(Offset offset);

    void seekRev(Offset offset);

    void findFwd(Value value);

    void findRev(Value value);

    void purge();

    void stop(StopFn = {});
  };

  using Fn = ZmFn<void(Ctrl, Value)>;

  void stop(StopFn = {});

protected:
  Reader(
    const Series *series, BlkOffset blkOffset, const Blk *blk, Target target,
    Fn fn, ErrorFn errorFn
  ) :
    m_series{series}, m_blkOffset{blkOffset}, m_blk{blk}, m_target{target},
    m_fn{ZuMv(fn)}, m_errorFn{ZuMv(errorFn)} {
    ((m_blk) ?
       void() :
       ZmAssert_fail(
	 "m_blk", "../../zdf/src/zlib/ZdfSeries.hh", 191, __PRETTY_FUNCTION__
       ));
  }

private:
  bool init(BlkOffset, Blk *, Target);

  void yield() { m_yield = true; }

  void loadBlk();
  void loaded(const Blk *blk);
  int nextBlk();
  int nextValue();

  void stopped();

  void fail();

private:
  const Series *m_series = nullptr;
  BlkOffset m_blkOffset = 0;
  const Blk *m_blk = nullptr;
  RdrState::T m_state = RdrState::Stopped;
  Target m_target;
  Decoder m_decoder;
  Fn m_fn;
  ErrorFn m_errorFn;
  StopFn m_stopFn;
  bool m_yield = false;
  bool m_failed = false;
};

inline constexpr const char *Reader_HeapID() { return "Zdf.Reader"; }
template <typename Decoder>
using ReaderList = ZmList<
  Reader<Decoder>, ZmListNode<Reader<Decoder>, ZmListHeapID<Reader_HeapID>>>;

template <typename Decoder> using RdrNode = typename ReaderList<Decoder>::Node;

template <typename Decoder> inline auto node(Reader<Decoder> *ptr) {
  return static_cast<RdrNode<Decoder> *>(ptr);
}

template <typename Decoder, typename Heap, typename PValue_>
class Writer__ : public Heap, public ZmObject {
public:
  using Encoder = Zdf::Encoder<Decoder>;
  using Series = Zdf::Series<Decoder>;
  using PValue = PValue_;

private:
  friend Series;

public:
  Writer__(Series *series, Offset offset, ErrorFn errorFn) :
    m_series{series}, m_offset{offset}, m_errorFn{ZuMv(errorFn)} { }

  Series *series() const { return m_series; }
  Offset offset() const { return m_offset; }
  bool failed() const { return m_failed; }

  bool write(PValue);

  void stop();

private:
  void fail() {
    m_failed = true;
    auto errorFn = ZuMv(m_errorFn);
    m_errorFn = ErrorFn{};
    errorFn();
    stop();
  }

  template <typename L> void encoder(L l) { m_encoder = l(); }
  bool encode(PValue value) { return m_encoder.write(value); }
  void finish(Blk *lastBlk) {
    m_encoder.finish();
    lastBlk->sync(m_encoder, m_encoder.last());
  }

  Series *m_series = nullptr;
  Offset m_offset = 0;
  Encoder m_encoder;
  ErrorFn m_errorFn;
  bool m_failed = false;
};
template <typename Decoder, typename Heap, typename PValue = Decoder::Value>
class Writer_ : public Writer__<Decoder, Heap, PValue> { };
template <typename Decoder, typename Heap>
class Writer_<Decoder, Heap, int64_t> :
  public Writer__<Decoder, Heap, int64_t> {
  using Base = Writer__<Decoder, Heap, int64_t>;

public:
  using typename Base::Series;

  Writer_(Series *series, Offset offset, ErrorFn errorFn, NDP ndp) :
    Base{series, offset, ZuMv(errorFn)}, m_ndp{ndp} { }

  NDP ndp() const { return m_ndp; }

private:
  NDP m_ndp;
};
inline constexpr const char *Writer_HeapID() { return "Zdf.Writer"; }
template <typename Decoder>
using Writer_Heap = ZmHeap<Writer_HeapID, Writer_<Decoder, ZuEmpty>>;
template <typename Decoder>
using Writer = Writer_<Decoder, Writer_Heap<Decoder>>;

class Store;

inline constexpr const unsigned IndexBlkShift() { return 9; }
inline constexpr const unsigned IndexBlkSize() { return 1 << IndexBlkShift(); }
inline constexpr const unsigned IndexBlkMask() {
  return ~((~0U) << IndexBlkShift());
}

struct IndexBlk_ : public ZuObject {
  Offset offset;
  Blk blks[IndexBlkSize()];

  IndexBlk_(Offset offset_) : offset{offset_} { }
};
struct IndexBlk_Fn {
  IndexBlk_ &indexBlk;

  using Key = Offset;
  static Key KeyAxor(const IndexBlk_ &indexBlk) { return indexBlk.offset; }

  inline Offset key() const { return indexBlk.offset; }
  static constexpr const unsigned length() { return IndexBlkSize(); }
};
inline constexpr const char *IndexBlk_HeapID() { return "Zdf.IndexBlk"; }
using Index = ZmPQueue<
  IndexBlk_,
  ZmPQueueFn<
    IndexBlk_Fn,
    ZmPQueueNode<
      IndexBlk_,
      ZmPQueueStats<
	false,
	ZmPQueueOverlap<
	  false,
	  ZmPQueueBits<
	    3, ZmPQueueLevels<3, ZmPQueueHeapID<IndexBlk_HeapID>>>>>>>>;
using IndexBlk = Index::Node;

struct InternalError { };

template <typename Decoder_> class Series : public ZmObject {
public:
  using Decoder = Decoder_;
  using Encoder = Zdf::Encoder<Decoder>;
  using Reader = Zdf::Reader<Decoder>;
  using ReadFn = typename Reader::Fn;
  using Writer = Zdf::Writer<Decoder>;
  using PValue = typename Decoder::Value;
  enum { Fixed = ZuIsExact<PValue, int64_t>{} };
  using Value = ZuIf<Fixed, ZuFixed, double>;

private:
  using ReaderList = Zdf::ReaderList<Decoder>;
  using RdrNode = Zdf::RdrNode<Decoder>;

  using DBSeries = ZuIf<Fixed, DB::SeriesFixed, DB::SeriesFloat>;
  using DBBlk = ZuIf<Fixed, DB::BlkFixed, DB::BlkFloat>;

  friend Store;
  template <typename> friend class Zdf::Reader;
  template <typename, typename, typename> friend class Writer__;

  using ID = uint32_t;

private:
  Series(Store *store, ZdbObjRef<DBSeries> dbSeries) :
    m_store{store}, m_dbSeries{ZuMv(dbSeries)} {
    m_dbSeries->pin();

    m_shard = m_dbSeries->shard();
    m_id = m_dbSeries->data().id;
    m_name = m_dbSeries->data().name;
    m_epoch = m_dbSeries->data().epoch.as_time();
  }

public:
  ~Series() { m_dbSeries->unpin(); }

  Store *store() const { return m_store; }
  bool opened() const { return m_opened; }
  ZdbObject<DBSeries> *dbSeries() const { return m_dbSeries; }
  unsigned shard() const { return m_shard; }
  SeriesID id() const { return m_id; }
  ZuCSpan name() const { return m_name; }
  ZuTime epoch() const { return m_epoch; }

private:
  static constexpr const uint64_t pow10_9() { return 1000000000UL; }

public:
  ZuFixed nsecs(ZuTime t) {
    t -= m_epoch;
    return ZuFixed{static_cast<uint64_t>(t.sec()) * pow10_9() + t.nsec(), 9};
  }
  ZuTime time(ZuFixed v) {
    auto n = v.adjust(9);
    auto p = pow10_9();
    return ZuTime{int64_t(n / p), int32_t(n % p)} + m_epoch;
  }

  template <typename... Args> void run(Args &&...args) const;
  template <typename... Args> void invoke(Args &&...args) const;
  bool invoked() const;

  BlkOffset head() const { return m_index.head(); }

  unsigned blkCount() const { return (m_lastBlkOffset + 1) - head(); }

  bool lastBlk(const Blk *blk) const { return blk == m_lastBlk; }

  Offset count() const {
    if (__builtin_expect(!!(!blkCount()), 0)) return 0;
    auto blk = lastBlk();
    if (__builtin_expect(!!(!blk), 0)) return 0;
    return blk->offset() + blk->count();
  }

  uint64_t length() const {
    unsigned n = blkCount();
    if (__builtin_expect(!!(!n), 0)) return 0;
    auto blk = lastBlk();
    if (__builtin_expect(!!(!blk), 0)) return 0;
    ((blk->blkData) ? void() :
		      ZmAssert_fail(
			"blk->blkData", "../../zdf/src/zlib/ZdfSeries.hh", 442,
			__PRETTY_FUNCTION__
		      ));
    return (n - 1) * BlkSize + blk->blkData->data().buf.length();
  }

  void seek(Offset offset, ReadFn readFn, ErrorFn errorFn = {}) const {
    BlkOffset blkOffset;
    if (offset == maxOffset())
      blkOffset = m_lastBlkOffset;
    else {
      uint64_t result;
      try {
	result = ZuInterSearch(blkCount(), seekFn(m_index.head(), offset));
      } catch (InternalError) {
	errorFn();
	return;
      }
      blkOffset = ZuSearchPos(result);
      if (blkOffset > m_lastBlkOffset) blkOffset = m_lastBlkOffset;
    }
    ZmRef<Reader> reader = new RdrNode{this,   blkOffset,    getBlk(blkOffset),
				       offset, ZuMv(readFn), ZuMv(errorFn)};
    addHistReader(reader);
    reader->loadBlk();
  }

  void find(Value value, ReadFn readFn, ErrorFn errorFn = {}) const {
    uint64_t result;
    try {
      result = ZuInterSearch(blkCount(), findFn(m_index.head(), value));
    } catch (InternalError) {
      errorFn();
      return;
    }
    BlkOffset blkOffset = ZuSearchPos(result);
    if (blkOffset > m_lastBlkOffset) blkOffset = m_lastBlkOffset;
    ZmRef<Reader> reader = new RdrNode{this,  blkOffset,    getBlk(blkOffset),
				       value, ZuMv(readFn), ZuMv(errorFn)};
    addHistReader(reader);
    reader->loadBlk();
  }

private:
  void seekFwd(Reader *reader, BlkOffset blkOffset, Offset offset) const {
    uint64_t result;
    try {
      result = ZuInterSearch(
	(m_lastBlkOffset + 1) - blkOffset, seekFn(blkOffset, offset)
      );
    } catch (InternalError) {
      reader->fail();
      return;
    }
    blkOffset = ZuSearchPos(result);
    if (blkOffset > m_lastBlkOffset) blkOffset = m_lastBlkOffset;
    reader->init(blkOffset, getBlk(blkOffset), offset);
    reader->loadBlk();
  }
  void seekRev(Reader *reader, BlkOffset blkOffset, Offset offset) const {
    uint64_t result;
    try {
      result = ZuInterSearch(
	(blkOffset + 1) - m_index.head(), seekFn(m_index.head(), offset)
      );
    } catch (InternalError) {
      reader->fail();
      return;
    }
    blkOffset = ZuSearchPos(result);
    reader->init(blkOffset, getBlk(blkOffset), offset);
    reader->loadBlk();
  }

  void findFwd(Reader *reader, BlkOffset blkOffset, Value value) const {
    uint64_t result;
    try {
      result = ZuInterSearch(
	(m_lastBlkOffset + 1) - blkOffset, findFn(blkOffset, value)
      );
    } catch (InternalError) {
      reader->fail();
      return;
    }
    blkOffset = ZuSearchPos(result);
    if (blkOffset > m_lastBlkOffset) blkOffset = m_lastBlkOffset;
    reader->init(blkOffset, getBlk(blkOffset), value);
    reader->loadBlk();
  }
  void findRev(Reader *reader, BlkOffset blkOffset, Value value) const {
    uint64_t result;
    try {
      result = ZuInterSearch(
	(blkOffset + 1) - m_index.head(), findFn(m_index.head(), value)
      );
    } catch (InternalError) {
      reader->fail();
      return;
    }
    blkOffset = ZuSearchPos(result);
    reader->init(blkOffset, getBlk(blkOffset), value);
    reader->loadBlk();
  }

  void open(ZmFn<void(ZmRef<Series>)> fn) {
    m_index.head(m_dbSeries->data().blkOffset);
    blkTbl()->template selectRows<0>(
      ZuFwdTuple(m_dbSeries->data().id), IndexBlkSize(),
      ZuLambda{[this_ = ZmMkRef(this), fn = ZuMv(fn),
		rowRcvd = false](auto &&self, auto result, unsigned) mutable {
      if (this_->m_opened) return;
      using Row = ZuFieldTuple<DBBlk>;
      if (result.template is<Row>()) {
	if (!this_->open_loadBlk(result.template p<Row>())) goto opened;
	rowRcvd = true;
      } else {
	if (!rowRcvd) goto opened;
	rowRcvd = false;
	this_->blkTbl()->template nextRows<0>(
	  ZuFwdTuple(this_->m_dbSeries->data().id, this_->m_lastBlkOffset),
	  false, IndexBlkSize(), ZuMv(self)
	);
      }
      return;
opened:
      this_->m_opened = true;
      fn(ZuMv(this_));
    }}
    );
  }

  template <typename Row> bool open_loadBlk(const Row &row) {
    BlkOffset blkOffset = row.template p<1>();
    auto blk = setBlk(blkOffset);
    if (!blk) return false;
    blk->init(
      row.template p<2>(), row.template p<4>(), row.template p<5>(),
      row.template p<3>()
    );
    m_lastBlk = blk;
    m_lastBlkOffset = blkOffset;
    return true;
  }

  ZdbTable<DB::BlkData> *blkDataTbl() const;
  ZuIf<Fixed, ZdbTable<DB::SeriesFixed> *, ZdbTable<DB::SeriesFloat> *>
  seriesTbl() const;
  ZuIf<Fixed, ZdbTable<DB::BlkFixed> *, ZdbTable<DB::BlkFloat> *>
  blkTbl() const;

  BlkData *newBlkData(BlkOffset blkOffset) const {
    return newBlkData(blkOffset, blkDataTbl());
  }
  BlkData *newBlkData(BlkOffset blkOffset, ZdbTable<DB::BlkData> *tbl) const {
    auto blkData = new BlkData{
      BlkData::EvictFn{
		       this, [](auto *this_, BlkData *blkData) {
      const_cast<Series *>(this_)->unloadBlkData(blkData);
    }
      },
      tbl, m_shard
    };
    new (blkData->ptr_()) DB::BlkData{.blkOffset = blkOffset, .seriesID = m_id};
    return blkData;
  }

public:
  template <typename... NDP>
  ZuIfT<sizeof...(NDP) == Fixed, void>
  write(ZmFn<void(ZmRef<Writer>)> fn, ErrorFn errorFn, NDP... ndp) {
    if constexpr (Fixed)
      static_assert(
	(ZuTraits<NDP...>::IsIntegral), "ZuTraits<NDP...>::IsIntegral"
      );

    if (m_writer) {
      errorFn();
      return;
    }
    if (!m_lastBlk) {
      m_writer = new Writer{this, 0, ZuMv(errorFn), ndp...};
      pushFirstBlk();
      write_newWriter(ZuMv(fn), ndp...);
    } else {
      auto lastBlkCount = m_lastBlk->count();
      m_writer = new Writer{
	this, m_lastBlk->offset() + lastBlkCount, ZuMv(errorFn), ndp...
      };
      if (lastBlkCount) {
	if (m_lastBlk->blkData) {
	  write_loadedBlk(ZuMv(fn), ndp...);
	  return;
	}
	ZmRef<IndexBlk> indexBlk = m_index.find(m_lastBlkOffset);
	loadBlk(
	  m_lastBlkOffset,
	  [this, fn = ZuMv(fn), ndp...,
	   indexBlk = ZuMv(indexBlk)](ZmRef<BlkData> blkData) mutable {
	  if (__builtin_expect(!!(!blkData), 0)) {
	    m_writer->fail();
	    return;
	  }
	  blkData->pin();
	  m_lastBlk->blkData = ZuMv(blkData);
	  write_loadedBlk(ZuMv(fn), ndp...);
	}
	);
      } else {
	if (!m_lastBlk->blkData)
	  m_lastBlk->blkData = newBlkData(m_lastBlkOffset);
	m_lastBlk->blkData->pin();
	write_newWriter(ZuMv(fn), ndp...);
      }
    }
  }

private:
  template <typename... NDP>
  ZuIfT<sizeof...(NDP) == Fixed, void>
  write_loadedBlk(ZmFn<void(ZmRef<Writer>)> fn, NDP... ndp) {
    if (!m_lastBlk->count()) {
      write_newWriter(ZuMv(fn), ndp...);
      return;
    }
    bool newBlk = m_lastBlk->space() < 3;
    if constexpr (Fixed)
      if (!newBlk && m_lastBlk->ndp() != (..., ndp)) newBlk = true;
    if (newBlk) {
      pushBlk();
      write_newWriter(ZuMv(fn), ndp...);
      return;
    }

    auto &buf = m_lastBlk->blkData->data().buf;
    Decoder decoder{buf.data(), buf.data() + buf.length()};
    while (decoder.skip());

    m_writer->encoder([&decoder, &buf] {
      return Encoder{decoder, buf.data() + BlkSize};
    });
    fn(ZmRef<Writer>{m_writer});
  }
  template <typename... NDP>
  ZuIfT<sizeof...(NDP) == Fixed, void>
  write_newWriter(ZmFn<void(ZmRef<Writer>)> fn, NDP... ndp) {
    if constexpr (Fixed) m_lastBlk->ndp(ndp...);
    m_writer->encoder([this] { return m_lastBlk->encoder<Decoder>(this); });

    run([this_ = ZmMkRef(this), fn = ZuMv(fn)]() mutable {
      ZuMv(fn)(ZmRef<Writer>{this_->m_writer});
    });
  }

  void pushFirstBlk() {
    m_lastBlkOffset = 0;
    IndexBlk *indexBlk = new IndexBlk{0};
    m_index.add(indexBlk);
    m_lastBlk = &indexBlk->blks[0];

    m_lastBlk->blkData = newBlkData(m_lastBlkOffset);
    m_lastBlk->blkData->pin();
  }

  void pushBlk() {
    auto offset = m_lastBlk->offset() + m_lastBlk->count();
    ++m_lastBlkOffset;
    IndexBlk *indexBlk = m_index.find(m_lastBlkOffset);
    if (!indexBlk)
      m_index.add(indexBlk = new IndexBlk{m_lastBlkOffset & ~IndexBlkMask()});
    m_lastBlk = &indexBlk->blks[m_lastBlkOffset - indexBlk->offset];
    m_lastBlk->offset(offset);
    m_lastBlk->blkData = newBlkData(m_lastBlkOffset);
    m_lastBlk->blkData->pin();
  }

  const Blk *getBlk(BlkOffset blkOffset) const {
    ZmRef<IndexBlk> indexBlk = m_index.find(blkOffset);
    if (!indexBlk) return nullptr;
    return &indexBlk->blks[blkOffset - indexBlk->offset];
  }

  Blk *setBlk(BlkOffset blkOffset) {
    if (__builtin_expect(!!(blkOffset < m_index.head()), 0)) return nullptr;
    ZmRef<IndexBlk> indexBlk = m_index.find(blkOffset);
    if (!indexBlk)
      m_index.add(indexBlk = new IndexBlk{blkOffset & ~IndexBlkMask()});
    return &indexBlk->blks[blkOffset - indexBlk->offset];
  }

  void purgeBlks(BlkOffset blkOffset) {
    blkOffset &= ~IndexBlkMask();
    if (blkOffset < m_index.head()) return;
    if (blkOffset >= m_lastBlkOffset) return;
    m_index.head(blkOffset);
  }

  void write_firstValue(Value value) {
    auto &data = m_dbSeries->data();
    if constexpr (Fixed) {
      data.first = value.mantissa;
      data.ndp = value.ndp;
    } else {
      data.first = value;
    }
    seriesTbl()->template update<>(
      m_dbSeries,
      [](ZdbObject<DBSeries> *dbSeries) {
      if (dbSeries) dbSeries->commit();
    }
    );
  }

  bool write_(Writer *writer, PValue value) {
    if (__builtin_expect(!!(!writer->offset()), 0)) {
      if constexpr (Fixed) {
	auto ndp = writer->ndp();
	write_firstValue(ZuFixed{value, ndp});
	m_lastBlk->ndp(ndp);
      } else {
	write_firstValue(value);
      }
    }
    if (writer->encode(value)) return true;
    writer->finish(m_lastBlk);
    saveBlk();
    pushBlk();
    writer->encoder([this]() { return m_lastBlk->encoder<Decoder>(this); });
    if constexpr (Fixed) m_lastBlk->ndp(writer->ndp());
    return writer->encode(value);
  }

  void write_notify() {
    auto i = m_liveReaders.iterator();
    while (auto reader = i.iterate()) switch (reader->nextValue()) {
      case RdrResult::Stopped:
      case RdrResult::Failed:
	m_histReaders.pushNode(reader);
	i.del();
      }
  }

  bool write(Writer *writer, PValue value) {
    bool ok = write_(writer, value);
    if (ok) write_notify();
    return ok;
  }

  void stop(Encoder &encoder) {
    encoder.finish();
    m_lastBlk->sync(encoder, encoder.last());
    saveBlk();
    encoder = {};
    m_writer = {};
  }

  void saveBlk() {
    ((m_lastBlk) ? void() :
		   ZmAssert_fail(
		     "m_lastBlk", "../../zdf/src/zlib/ZdfSeries.hh", 790,
		     __PRETTY_FUNCTION__
		   ));
    ((m_lastBlk->blkData) ?
       void() :
       ZmAssert_fail(
	 "m_lastBlk->blkData", "../../zdf/src/zlib/ZdfSeries.hh", 791,
	 __PRETTY_FUNCTION__
       ));

    static auto lastFn = [](const Blk *blk) {
      if constexpr (Fixed)
	return blk->last.fixed;
      else
	return blk->last.float_;
    };

    if (m_lastBlk->blkData->state() == ZdbObjState::Undefined) {
      ZdbObjRef<DBBlk> dbBlk = new ZdbObject<DBBlk>{blkTbl(), m_shard};
      new (dbBlk->ptr_()) DBBlk{
	.blkOffset = m_lastBlkOffset,
	.offset = m_lastBlk->offset(),
	.last = lastFn(m_lastBlk),
	.seriesID = id(),
	.count = m_lastBlk->count(),
	.ndp = m_lastBlk->ndp()
      };
      blkTbl()->insert(shard(), ZuMv(dbBlk), [](ZdbObject<DBBlk> *dbBlk) {
	if (dbBlk) dbBlk->commit();
      });
      blkDataTbl()->insert(
	shard(), m_lastBlk->blkData,
	[](ZdbObject<DB::BlkData> *blkData) mutable {
	if (blkData) {
	  blkData->commit();
	  blkData->unpin();
	}
      }
      );
    } else {
      blkTbl()->template findUpd<0>(
	shard(), ZuFwdTuple(id(), m_lastBlkOffset),
	[this_ = ZmMkRef(this)](ZdbObject<DBBlk> *dbBlk) {
	if (!dbBlk || !this_->m_lastBlk) return;
	auto &data = dbBlk->data();
	data.offset = this_->m_lastBlk->offset();
	data.last = lastFn(this_->m_lastBlk);
	data.count = this_->m_lastBlk->count();
	data.ndp = this_->m_lastBlk->ndp();
	dbBlk->commit();
      }
      );
      blkDataTbl()->template update<>(
	m_lastBlk->blkData,
	[](ZdbObject<DB::BlkData> *blkData) mutable {
	if (blkData) {
	  blkData->commit();
	  blkData->unpin();
	}
      }
      );
    }
  }

  template <typename L> void loadBlk(BlkOffset blkOffset, L l) const {
    blkDataTbl()->template find<0>(
      shard(), ZuFwdTuple(id(), blkOffset), ZuMv(l),
      [this, blkOffset](ZdbTable<DB::BlkData> *tbl) {
      return newBlkData(blkOffset, tbl);
    }
    );
  }

  template <typename L> void loadBlkData(BlkOffset blkOffset, L l) const {
    ZmRef<IndexBlk> indexBlk = m_index.find(blkOffset);
    if (!indexBlk) {
      l(nullptr);
      return;
    }
    auto blk = &indexBlk->blks[blkOffset - indexBlk->offset];
    if (blk->blkData) {
      l(blk);
      return;
    }
    loadBlk(
      blkOffset,
      [indexBlk = ZuMv(indexBlk), blk,
       l = ZuMv(l)](ZmRef<BlkData> blkData) mutable {
      if (__builtin_expect(!!(!blkData), 0)) {
	l(nullptr);
	return;
      }
      blk->blkData = ZuMv(blkData);
      l(blk);
    }
    );
  }

  void unloadBlkData(BlkData *blkData) const {
    BlkOffset blkOffset = blkData->data().blkOffset;
    ZmRef<IndexBlk> indexBlk = m_index.find(blkOffset);
    if (!indexBlk) return;
    auto blk = &indexBlk->blks[blkOffset - indexBlk->offset];
    blk->blkData = nullptr;
  }

  void addHistReader(Reader *reader) const {
    m_histReaders.pushNode(node(reader));
  }
  void delHistReader(Reader *reader) const {
    m_histReaders.delNode(node(reader));
  }
  void addLiveReader(Reader *reader) const {
    m_liveReaders.pushNode(node(reader));
  }
  void delLiveReader(Reader *reader) const {
    m_liveReaders.delNode(node(reader));
  }

  auto seekFn(BlkOffset blkOffset, Offset target) const {
    return [this, blkOffset, target](uint64_t i) -> double {
      i += blkOffset;
      auto blk = getBlk(i);
      ((blk) ?
	 void() :
	 ZmAssert_fail(
	   "blk", "../../zdf/src/zlib/ZdfSeries.hh", 897, __PRETTY_FUNCTION__
	 ));
      Offset offset = blk->offset();
      if (target < offset) return double(target) - double(offset);
      auto n = blk->count();
      ((n) ? void() :
	     ZmAssert_fail(
	       "n", "../../zdf/src/zlib/ZdfSeries.hh", 901, __PRETTY_FUNCTION__
	     ));
      offset += (n - 1);
      if (target > offset) return double(target) - double(offset);
      return 0;
    };
  }

  auto findFn(uint64_t blkOffset, Value target) const {
    return [this, blkOffset, target](uint64_t i) -> double {
      Value value;
      i += blkOffset;
      if (i <= m_index.head()) {
	const auto &data = m_dbSeries->data();
	if constexpr (Fixed)
	  value = ZuFixed{data.first, data.ndp};
	else
	  value = data.first;
      } else {
	auto blk = getBlk(i - 1);
	((blk) ?
	   void() :
	   ZmAssert_fail(
	     "blk", "../../zdf/src/zlib/ZdfSeries.hh", 921, __PRETTY_FUNCTION__
	   ));
	if constexpr (Fixed)
	  value = ZuFixed{blk->last.fixed, blk->ndp()};
	else
	  value = blk->last.float_;
      }
      if constexpr (Fixed) {
	double target_ = target.fp(), value_ = value.fp();
	if (target_ < value_) return target_ - value_;
      } else {
	if (target < value) return target - value;
      }

      auto blk = getBlk(i);
      ((blk) ?
	 void() :
	 ZmAssert_fail(
	   "blk", "../../zdf/src/zlib/ZdfSeries.hh", 935, __PRETTY_FUNCTION__
	 ));
      value = ZuFixed{blk->last.fixed, blk->ndp()};
      if constexpr (Fixed) {
	double target_ = target.fp(), value_ = value.fp();
	if (target_ > value_) return target_ - value_;
      } else {
	if (target > value) return target - value;
      }
      return 0;
    };
  }

  void purge(Reader *reader, BlkOffset blkOffset) {
    blkOffset &= ~IndexBlkMask();
    if (__builtin_expect(!!(!blkOffset), 0)) return;
    auto blk = getBlk(blkOffset - 1);
    if (__builtin_expect(!!(!blk), 0)) return;
    if constexpr (Fixed)
      write_firstValue(ZuFixed{blk->last.fixed, blk->ndp()});
    else
      write_firstValue(blk->last.float_);
    purgeBlks(blkOffset);
  }

private:
  Store *m_store = nullptr;
  ZdbObjRef<DBSeries> m_dbSeries;
  Shard m_shard;
  SeriesID m_id;
  ZuCSpan m_name;
  ZuTime m_epoch;
  mutable Index m_index;
  Blk *m_lastBlk = nullptr;
  BlkOffset m_lastBlkOffset = 0;
  mutable ReaderList m_liveReaders;
  mutable ReaderList m_histReaders;
  ZmRef<Writer> m_writer;
  bool m_opened = false;
};

template <typename Decoder> inline Offset Reader<Decoder>::offset() const {
  using namespace RdrState;

  switch (m_state) {
  case Loading:
    if (m_target.template is<Offset>()) return m_target.template p<Offset>();
    ((m_blk) ?
       void() :
       ZmAssert_fail(
	 "m_blk", "../../zdf/src/zlib/ZdfSeries.hh", 987, __PRETTY_FUNCTION__
       ));
    return m_blk->offset();
  case Stopped:
  case Stopping:
  case Reading:
  case Live:
    if (!m_decoder) return 0;
    return m_blk->offset() + m_decoder.offset();
  default:
    ((false) ?
       void() :
       ZmAssert_fail(
	 "false", "../../zdf/src/zlib/ZdfSeries.hh", 996, __PRETTY_FUNCTION__
       ));
    return 0;
  }
}

template <typename Decoder> inline void Reader<Decoder>::Ctrl::yield() {
  reader.yield();
}

template <typename Decoder>
inline void Reader<Decoder>::Ctrl::seekFwd(Offset offset) {
  reader.yield();
  reader.series()->seekFwd(&reader, reader.m_blkOffset, offset);
}

template <typename Decoder>
inline void Reader<Decoder>::Ctrl::seekRev(Offset offset) {
  reader.yield();
  reader.series()->seekRev(&reader, reader.m_blkOffset, offset);
}

template <typename Decoder>
inline void Reader<Decoder>::Ctrl::findFwd(Value value) {
  reader.yield();
  reader.series()->findFwd(&reader, reader.m_blkOffset, value);
}

template <typename Decoder>
inline void Reader<Decoder>::Ctrl::findRev(Value value) {
  reader.yield();
  reader.series()->findRev(&reader, reader.m_blkOffset, value);
}

template <typename Decoder>
inline bool
Reader<Decoder>::init(BlkOffset blkOffset, Blk *blk, Target target) {
  using namespace RdrState;

  ((blk) ? void() :
	   ZmAssert_fail(
	     "blk", "../../zdf/src/zlib/ZdfSeries.hh", 1041, __PRETTY_FUNCTION__
	   ));

  m_failed = false;

  switch (m_state) {
  case Stopped:
    break;
  case Loading:
  case Reading:
  case Live:
  case Stopping:
    return false;
  default:
    ((false) ?
       void() :
       ZmAssert_fail(
	 "false", "../../zdf/src/zlib/ZdfSeries.hh", 1054, __PRETTY_FUNCTION__
       ));
  }

  m_blkOffset = blkOffset;
  m_blk = blk;
  m_target = target;
  m_decoder = {};
  return true;
}

template <typename Decoder> inline void Reader<Decoder>::Ctrl::stop(StopFn fn) {
  reader.yield();
  reader.stop(ZuMv(fn));
}

template <typename Decoder> inline void Reader<Decoder>::stop(StopFn fn) {
  using namespace RdrState;

  auto unpin = [this] {
    ((m_blk) ?
       void() :
       ZmAssert_fail(
	 "m_blk", "../../zdf/src/zlib/ZdfSeries.hh", 1078, __PRETTY_FUNCTION__
       ));
    ((m_blk->blkData) ? void() :
			ZmAssert_fail(
			  "m_blk->blkData", "../../zdf/src/zlib/ZdfSeries.hh",
			  1079, __PRETTY_FUNCTION__
			));
    ((m_decoder) ? void() :
		   ZmAssert_fail(
		     "m_decoder", "../../zdf/src/zlib/ZdfSeries.hh", 1080,
		     __PRETTY_FUNCTION__
		   ));
    m_decoder = {};
    m_blk->blkData->unpin();
  };
  switch (m_state) {
  case Stopped:
  case Stopping:
    fn();
    return;
  case Loading:
    ((m_blk) ?
       void() :
       ZmAssert_fail(
	 "m_blk", "../../zdf/src/zlib/ZdfSeries.hh", 1090, __PRETTY_FUNCTION__
       ));
    break;
  case Live:
    unpin();
    m_series->delLiveReader(this);
    break;
  case Reading:
    unpin();
    m_series->delHistReader(this);
    break;
  default:
    ((false) ?
       void() :
       ZmAssert_fail(
	 "false", "../../zdf/src/zlib/ZdfSeries.hh", 1101, __PRETTY_FUNCTION__
       ));
  }

  m_state = Stopping;
  m_stopFn = ZuMv(fn);
  m_fn = Fn{};
  m_errorFn = ErrorFn{};
  m_series->run([this_ = ZmMkRef(node(this))]() mutable { this_->stopped(); });
}

template <typename Decoder> inline void Reader<Decoder>::loadBlk() {
  using namespace RdrState;

  if (__builtin_expect(!!(m_failed), 0)) return;

  switch (m_state) {
  case Stopping:
    return;
  case Stopped:
  case Reading:
    break;
  default:
    ((false) ?
       void() :
       ZmAssert_fail(
	 "false", "../../zdf/src/zlib/ZdfSeries.hh", 1128, __PRETTY_FUNCTION__
       ));
  }

  ((m_blk) ?
     void() :
     ZmAssert_fail(
       "m_blk", "../../zdf/src/zlib/ZdfSeries.hh", 1132, __PRETTY_FUNCTION__
     ));

  if (m_blk->blkData) {
    m_series->run([this_ = ZmMkRef(node(this))]() {
      this_->loaded(this_->m_blk);
    });
    return;
  }

  m_state = Loading;
  m_series->loadBlkData(
    m_blkOffset,
    [this_ = ZmMkRef(node(this))](Blk *blk) mutable { this_->loaded(blk); }
  );
}

template <typename Decoder>
inline void Reader<Decoder>::loaded(const Blk *blk) {
  using namespace RdrState;

  if (__builtin_expect(!!(m_failed), 0)) return;

  switch (m_state) {
  case Stopping:
    return;
  case Stopped:
  case Loading:
  case Reading:
  case Live:
    break;
  default:
    ((false) ?
       void() :
       ZmAssert_fail(
	 "false", "../../zdf/src/zlib/ZdfSeries.hh", 1167, __PRETTY_FUNCTION__
       ));
  }

  ((blk) ? void() :
	   ZmAssert_fail(
	     "blk", "../../zdf/src/zlib/ZdfSeries.hh", 1171, __PRETTY_FUNCTION__
	   ));
  ((blk == m_blk) ? void() :
		    ZmAssert_fail(
		      "blk == m_blk", "../../zdf/src/zlib/ZdfSeries.hh", 1172,
		      __PRETTY_FUNCTION__
		    ));

  m_state = m_state == Live ? Live : Reading;
  m_blk->blkData->pin();
  m_decoder = m_blk->decoder<Decoder>();

  if (__builtin_expect(!!(!m_target.template is<void>()), 0)) {
    if (m_target.template is<Offset>()) {
      auto offset = m_blk->offset();
      auto targetOffset = m_target.template p<Offset>();
      m_target = {};
      if (targetOffset > offset) m_decoder.seek(targetOffset - offset);
    } else {
      auto value = m_target.template p<Value>();
      m_target = {};
      bool found = false;
      PValue pvalue;
      auto ndp = m_blk->ndp();
      if constexpr (ZuIsExact<Value, ZuFixed>{})
	pvalue = value.adjust(ndp);
      else
	pvalue = value;
      m_decoder.search([pvalue, &found](PValue skip, unsigned rle) -> unsigned {
	if (skip < pvalue) return rle;
	if (!(skip > pvalue)) found = true;
	return 0;
      });
      if (found) {
	if constexpr (ZuIsExact<Value, ZuFixed>{})
	  m_fn(Ctrl{*this}, ZuFixed{pvalue, ndp});
	else
	  m_fn(Ctrl{*this}, pvalue);
	if (m_yield) {
	  m_yield = false;
	  if (m_state == Reading || m_state == Live)
	    m_series->run([this]() { nextValue(); });
	  return;
	}
      }
    }
  }

  nextValue();
}

template <typename Decoder> inline int Reader<Decoder>::nextBlk() {
  using namespace RdrState;

  if (m_series->lastBlk(m_blk)) {
    if (m_state == Reading) {
      m_state = Live;
      m_series->delHistReader(this);
      m_series->addLiveReader(this);
    }
    return RdrResult::EOS;
  }
  m_decoder = {};
  m_blk->blkData->unpin();
  m_blk = m_series->getBlk(++m_blkOffset);
  if (__builtin_expect(!!(m_blk->blkData), 1)) {
    m_blk->blkData->pin();
    m_decoder = m_blk->decoder<Decoder>();
    return RdrResult::OK;
  }
  m_series->run([this_ = ZmMkRef(node(this))]() mutable { this_->loadBlk(); });
  return RdrResult::Load;
}

template <typename Decoder> inline int Reader<Decoder>::nextValue() {
  using namespace RdrState;

  if (__builtin_expect(!!(m_failed), 0)) return RdrResult::Failed;

  switch (m_state) {
  case Stopping:
    break;
  case Reading:
  case Live:
    ((m_blk) ?
       void() :
       ZmAssert_fail(
	 "m_blk", "../../zdf/src/zlib/ZdfSeries.hh", 1259, __PRETTY_FUNCTION__
       ));
    ((m_blk->blkData) ? void() :
			ZmAssert_fail(
			  "m_blk->blkData", "../../zdf/src/zlib/ZdfSeries.hh",
			  1260, __PRETTY_FUNCTION__
			));
    ((m_decoder) ? void() :
		   ZmAssert_fail(
		     "m_decoder", "../../zdf/src/zlib/ZdfSeries.hh", 1261,
		     __PRETTY_FUNCTION__
		   ));
    break;
  default:
    ((false) ?
       void() :
       ZmAssert_fail(
	 "false", "../../zdf/src/zlib/ZdfSeries.hh", 1264, __PRETTY_FUNCTION__
       ));
  }

  while (m_state == Reading || m_state == Live) {
    typename Decoder::Value value;
    if (__builtin_expect(!!(!m_decoder.read(value)), 0)) {
      int r = nextBlk();
      if (__builtin_expect(!!(r == RdrResult::OK), 1)) continue;
      if (r != RdrResult::EOS) return r;
      if constexpr (ZuIsExact<Value, ZuFixed>{})
	m_fn(Ctrl{*this}, ZuFixed{});
      else
	m_fn(Ctrl{*this}, ZuFP<double>::nan());
      if (m_state != Stopping) return r;
      break;
    }

    if constexpr (ZuIsExact<Value, ZuFixed>{})
      m_fn(Ctrl{*this}, ZuFixed{value, ndp()});
    else
      m_fn(Ctrl{*this}, value);
    if (m_yield) {
      m_yield = false;
      if (m_state == Reading || m_state == Live)
	m_series->run([this]() { nextValue(); });
      return RdrResult::OK;
    }
  }

  return RdrResult::Stopped;
}

template <typename Decoder> inline void Reader<Decoder>::stopped() {
  using namespace RdrState;

  ((m_state == Stopping) ?
     void() :
     ZmAssert_fail(
       "m_state == Stopping", "../../zdf/src/zlib/ZdfSeries.hh", 1302,
       __PRETTY_FUNCTION__
     ));

  m_state = Stopped;
  auto stopFn = ZuMv(m_stopFn);
  m_stopFn = StopFn{};
  stopFn();
}

template <typename Decoder> inline void Reader<Decoder>::fail() {
  using namespace RdrState;

  m_failed = true;

  if (m_state == Live) {
    m_state = Reading;
    m_series->delLiveReader(this);
    m_series->addHistReader(this);
  }

  if (m_blk && m_blk->blkData) m_blk->blkData->unpin();

  auto errorFn = ZuMv(m_errorFn);
  m_fn = Fn{};
  m_errorFn = ErrorFn{};
  errorFn();
}

template <typename Decoder> inline void Reader<Decoder>::Ctrl::purge() {
  const_cast<Series *>(reader.series())->purge(&reader, reader.m_blkOffset);
}

inline constexpr const char *closedWriter() {
  return "attempt to use closed Writer";
}

template <typename Decoder, typename Heap, typename Value>
inline bool Writer__<Decoder, Heap, Value>::write(Value value) {
  if (__builtin_expect(!!(m_failed), 0)) return false;

  ((m_series) ?
     void() :
     ZmAssert_fail(
       "m_series", "../../zdf/src/zlib/ZdfSeries.hh", 1348, __PRETTY_FUNCTION__
     ));

  bool ok = m_series->write(static_cast<Writer<Decoder> *>(this), value);
  if (ok) ++m_offset;
  return ok;
}

template <typename Decoder, typename Heap, typename Value>
inline void Writer__<Decoder, Heap, Value>::stop() {
  if (auto series = m_series) {
    m_series = nullptr;
    series->stop(m_encoder);
  }
}

} // namespace Zdf

namespace Zdf {

template <typename O_, bool TimeIndex_> struct WrapType {
  using O = O_;
  enum { TimeIndex = TimeIndex_ };
};

using TimeType = ZtFieldType_Time<ZuTime, ZuTypeList<ZuFieldProp::NDP<9>>>;
template <typename O_> struct TimeField_ {
  using O = O_;
  using T = ZuTime;
  using Props = ZuTypeList<
    ZuFieldProp::NDP<9>, ZuFieldProp::Synthetic, ZuFieldProp::Series>;
  enum { ReadOnly = 1 };
  static constexpr const char *id() { return "_time"; }
  ZuTime get(const O &) { return Zm::now(); }
  template <typename P> static void set(O &, P &&) { }
};
template <typename O> using TimeField = ZtField_Time<TimeField_<O>>;

template <typename Field>
using FieldFilter = ZuTypeIn<ZuFieldProp::Series, typename Field::Props>;
template <typename O, bool TimeIndex> struct Fields_ {
  using T = ZuTypeGrep<FieldFilter, ZuFields<O>>;
};

template <typename O> struct Fields_<O, true> {
  using T = Fields_<O, false>::T::template Unshift<TimeField<O>>;
};
template <typename W>
using Fields = typename Fields_<typename W::O, W::TimeIndex>::T;

template <typename Field, typename Props = typename Field::Props>
using FieldDecoderFlags_ = ZuUnsigned<
  ((Field::Type::Code == ZtFieldTypeCode::Float) ? 4 : 0) |
  (ZuTypeIn<ZuFieldProp::Delta2, Props>{} ? 2 : 0) |
  (ZuTypeIn<ZuFieldProp::Delta, Props>{} ? 1 : 0)>;
template <typename Field, unsigned = FieldDecoderFlags_<Field>{}>
struct FieldDecoder_;
template <typename Field> struct FieldDecoder_<Field, 0U> {
  using T = Decoder;
};
template <typename Field> struct FieldDecoder_<Field, 1U> {
  using T = DeltaDecoder<>;
};
template <typename Field> struct FieldDecoder_<Field, 2U> {
  using T = DeltaDecoder<DeltaDecoder<>>;
};
template <typename Field> struct FieldDecoder_<Field, 4U> {
  using T = FloatDecoder;
};
template <typename Field> using FieldDecoder = typename FieldDecoder_<Field>::T;

template <typename Field> using FieldSeries = Series<FieldDecoder<Field>>;
template <typename Field> using FieldSeriesRef = ZmRef<FieldSeries<Field>>;
template <typename Field> using FieldReader = Reader<FieldDecoder<Field>>;

template <typename Decoder> class WrRef : public ZmRef<Writer<Decoder>> {
  WrRef(const WrRef &) = delete;
  WrRef &operator=(const WrRef &) = delete;

public:
  using Writer = Zdf::Writer<Decoder>;
  using Ref = ZmRef<Writer>;

  using Ref::operator Writer *;
  using Ref::operator->;

  WrRef() = default;
  WrRef(WrRef &&h) : Ref{ZuMv(h)} { }
  WrRef &operator=(WrRef &&h) {
    stop_();
    Ref::operator=(ZuMv(h));
    return *this;
  }
  template <typename Arg> WrRef(Arg &&arg) : Ref{ZuFwd<Arg>(arg)} { }
  template <typename Arg> WrRef &operator=(Arg &&arg) {
    stop_();
    Ref::operator=(ZuFwd<Arg>(arg));
    return *this;
  }
  ~WrRef() { stop_(); }

private:
  void stop_() {
    if (auto ptr = this->ptr_()) ptr->stop();
  }
};

template <typename Field> using FieldWrRef = WrRef<FieldDecoder<Field>>;

template <typename W>
using SeriesRefs = ZuTypeApply<ZuTuple, ZuTypeMap<FieldSeriesRef, Fields<W>>>;
template <typename W>
using WrRefTuple = ZuTypeApply<ZuTuple, ZuTypeMap<FieldWrRef, Fields<W>>>;

template <typename O, bool TimeIndex> class DataFrame;

template <
  typename Field, typename Props = typename Field::Props,
  bool HasNDP = ZuFieldProp::HasNDP<Props>{}>
struct GetNDP_ {
  using T = ZuFieldProp::GetNDP<Props>;
};
template <typename Field, typename Props> struct GetNDP_<Field, Props, false> {
  using T = ZuUnsigned<0>;
};
template <typename Field> using GetNDP = typename GetNDP_<Field>::T;

template <typename W, typename Heap>
class DFWriter_ : public Heap, public ZmObject {
  DFWriter_(const DFWriter_ &) = delete;
  DFWriter_ &operator=(const DFWriter_ &) = delete;

public:
  using O = typename W::O;
  enum { TimeIndex = W::TimeIndex };
  using DataFrame = Zdf::DataFrame<O, TimeIndex>;

private:
  friend DataFrame;

  using Fields = Zdf::Fields<W>;
  using WrRefs = WrRefTuple<W>;

  DFWriter_() = default;
  DFWriter_(DataFrame *df, ErrorFn errorFn) :
    m_df{df}, m_errorFn{ZuMv(errorFn)} { }

public:
  DFWriter_(DFWriter_ &&) = default;
  DFWriter_ &operator=(DFWriter_ &&) = default;
  ~DFWriter_() = default;

  bool failed() const { return m_failed; }

private:
  template <unsigned I, typename WrRef> void writer(WrRef wrRef) {
    m_wrRefs.template p<I>(ZuMv(wrRef));
  }

public:
  void write(const O &o) {
    using namespace ZtFieldTypeCode;

    bool ok = true;
    ZuUnroll::all<WrRefs::N>([this, &o, &ok](auto I) {
      if (!ok) return;
      using Field = ZuType<I, Fields>;
      enum { NDP = GetNDP<Field>{} };
      if constexpr (Field::Code == Float)
	ok = ok && m_wrRefs.template p<I>()->write(Field::get(o));
      else if constexpr (Field::Code == Fixed)
	ok = ok && m_wrRefs.template p<I>()->write(Field::get(o).adjust(NDP));
      else if constexpr (Field::Code == Int8 || Field::Code == UInt8 ||
			 Field::Code == Int16 || Field::Code == UInt16 ||
			 Field::Code == Int32 || Field::Code == UInt32 ||
			 Field::Code == Int64 || Field::Code == UInt64)
	ok = ok && m_wrRefs.template p<I>()->write(Field::get(o));
      else if constexpr (Field::Code == Decimal)
	ok = ok && m_wrRefs.template p<I>()->write(ZuFixed{Field::get(o), NDP});
      else if constexpr (Field::Code == Time)
	ok = ok &&
	  m_wrRefs.template p<I>()->write(
	    m_df->template series<I>()->nsecs(Field::get(o))
	  );
    });
    if (!ok) fail();
  }

  using StopFn = ZmFn<void()>;

private:
  struct StopContext : public ZmObject {
    StopFn fn;

    ~StopContext() { fn(); }
  };

public:
  void stop(StopFn fn) {
    ZmRef<StopContext> context = new StopContext{ZuMv(fn)};
    ZuUnroll::all<WrRefs::N>([this, &context](auto I) {
      m_wrRefs.template p<I>()->stop([context]() {});
    });
  }

  void fail() {
    if (__builtin_expect(!!(m_failed), 0)) return;
    m_failed = true;
    m_wrRefs = {};
    ErrorFn errorFn = ZuMv(m_errorFn);
    errorFn();
  }

private:
  DataFrame *m_df = nullptr;
  ErrorFn m_errorFn;
  WrRefs m_wrRefs;
  bool m_failed = false;
};
inline constexpr const char *DFWriter_HeapID() { return "Zdf.DFWriter"; }
template <typename W>
using DFWriter = DFWriter_<W, ZmHeap<DFWriter_HeapID, DFWriter_<W, ZuEmpty>>>;

class Store;

template <typename O_, bool TimeIndex_ = false>
class DataFrame : public ZmObject {
public:
  using O = O_;
  enum { TimeIndex = TimeIndex_ };

private:
  using W = WrapType<O, TimeIndex>;

public:
  using Writer = DFWriter<W>;

private:
  friend Store;

  using Fields = Zdf::Fields<W>;
  using SeriesRefs = Zdf::SeriesRefs<W>;
  using WrRefs = WrRefTuple<W>;

  DataFrame(Store *store, Shard shard, ZtString name, SeriesRefs seriesRefs) :
    m_store{store}, m_shard{shard}, m_name{ZuMv(name)},
    m_seriesRefs{ZuMv(seriesRefs)} { }

public:
  ~DataFrame() = default;

  Shard shard() const { return m_shard; }
  const ZtString &name() const { return m_name; }

  template <typename... Args> void run(Args &&...args) const;
  template <typename... Args> void invoke(Args &&...args) const;
  bool invoked() const;

  template <typename Field> auto series() const {
    using I = ZuTypeIndex<Field, Fields>;
    return m_seriesRefs.template p<I>();
  }

  struct WriteContext {
    WrRefs writers;
  };

  void write(ZmFn<void(ZmRef<Writer>)> fn, ErrorFn errorFn) {
    ZmRef<Writer> dfw = new Writer{this, ZuMv(errorFn)};
    ZuLambda{[this, fn = ZuMv(fn),
	      dfw = ZuMv(dfw)](auto &&self, auto I, auto wrRef) mutable {
      if constexpr (I >= 0) dfw->template writer<I>(ZuMv(wrRef));
      enum { J = I + 1 };
      if constexpr (J >= SeriesRefs::N) {
	fn(ZuMv(dfw));
      } else {
	using Field = ZuType<J, Fields>;
	auto seriesRefs = &m_seriesRefs;
	auto next = [self = ZuMv(self)](auto wrRef) mutable {
	  ZuMv(self).template operator()(ZuInt<J>{}, ZuMv(wrRef));
	};
	auto error = [dfw = dfw.ptr()]() { dfw->fail(); };
	if constexpr (Field::Code == ZtFieldTypeCode::Float)
	  seriesRefs->template p<J>()->write(ZuMv(next), ZuMv(error));
	else
	  seriesRefs->template p<J>()->write(
	    ZuMv(next), ZuMv(error), GetNDP<Field>{}
	  );
      }
    }}(ZuInt<-1>{}, static_cast<void *>(nullptr));
  }

public:
  template <typename Field>
  void seek(
    Offset offset, typename FieldReader<Field>::Fn readFn, ErrorFn errorFn = {}
  ) const {
    using I = ZuTypeIndex<Field, Fields>;
    m_seriesRefs.template p<I{}>()->seek(offset, ZuMv(readFn), ZuMv(errorFn));
  }
  template <typename Field>
  void find(
    typename FieldSeries<Field>::Value value,
    typename FieldReader<Field>::Fn readFn, ErrorFn errorFn = {}
  ) const {
    using I = ZuTypeIndex<Field, Fields>;
    m_seriesRefs.template p<I{}>()->find(value, ZuMv(readFn), ZuMv(errorFn));
  }

private:
  Store *m_store = nullptr;
  Shard m_shard;
  ZtString m_name;
  SeriesRefs m_seriesRefs;
};

} // namespace Zdf

namespace Zdf {

namespace StoreState {
using T = int;
enum {
  Invalid = -1,
  Uninitialized = 0,
  Initialized,
  Opening,
  Opened,
  OpenFailed,
  N
};
static_assert((N <= 1024), "N <= 1024");
enum {
  Bits = N <= 2 ? 1 :
    N <= 4      ? 2 :
    N <= 8      ? 3 :
    N <= 16     ? 4 :
    N <= 32     ? 5 :
    N <= 64     ? 6 :
    N <= 128    ? 7 :
    N <= 256    ? 8 :
    N <= 512    ? 9 :
		  10
};
template <typename Impl> struct Map_ : public ZuObject {
private:
  using V2S = ZmLHashKV<T, ZuCSpan, ZmLHashStatic<Bits, ZmLHashLocal<>>>;
  using S2V = ZmLHashKV<ZuCSpan, T, ZmLHashStatic<Bits, ZmLHashLocal<>>>;

protected:
  void init(const char *s, int v, ...) {
    if (__builtin_expect(!!(!s), 0)) return;
    add(s, v);
    va_list args;

    __builtin_va_start(

      args

      ,

      v

    );
    while (s =

	     __builtin_va_arg(

	       args

	       ,

	       const char *

	     )

    )
      add(
	s,
	v =

	  __builtin_va_arg(

	    args

	    ,

	    int

	  )

      );

    __builtin_va_end(

      args

    );
  }
  void add(ZuCSpan s, T v) {
    m_s2v.add(s, v);
    m_v2s.add(v, s);
  }
  static Impl *instance() { return ZmSingleton<Impl>::instance(); }

private:
  T s2v_(ZuCSpan s) const { return m_s2v.findVal(s); }
  ZuCSpan v2s_(T v) const { return m_v2s.findVal(v); }
  template <typename L> void all_(L l) const {
    auto i = m_s2v.readIterator();
    while (auto kv = i.iterate()) {
      l(kv->template p<0>(), kv->template p<1>());
    }
  }

public:
  Map_() = default;
  static T s2v(ZuCSpan s) { return instance()->s2v_(s); }
  static ZuCSpan v2s(T v) { return instance()->v2s_(v); }
  template <typename L> static void all(L l) { instance()->all_(ZuMv(l)); }

private:
  S2V m_s2v;
  V2S m_v2s;
};
inline ZuTuple<const char *const *const, unsigned> names() {
  static const char *names[] = {
    "Uninitialized = 0", "Initialized", "Opening", "Opened", "OpenFailed"
  };
  return ZuTuple<const char *const *const, unsigned>{
    names, static_cast<unsigned>(sizeof(names) / sizeof(names[0]))
  };
}
inline const char *name(int i) {
  ZuTuple<const char *const *const, unsigned> names_ = names();
  if (i >= (int)names_.p<1>()) return "Unknown";
  if (i < 0) return "";
  return names_.p<0>()[i];
}
struct Map : public Map_<Map> {
  static constexpr const char *id() { return "StoreState"; }
  Map() {
    for (unsigned i = 0; i < N; i++) this->add(name(i), i);
  }
};
template <typename S> inline T lookup(const S &s) { return Map::s2v(s); };
} // namespace StoreState

using OpenFn = ZmFn<void(bool)>;

class Store {
public:
  static void dbCf(const ZvCf *, ZdbCf &dbCf);
  void init(Zdb *);
  void final();

  auto sid(Shard shard) const { return m_sids[shard & (m_sids.length() - 1)]; }

  template <typename... Args> void run(Shard shard, Args &&...args) const {
    m_mx->run(sid(shard), ZuFwd<Args>(args)...);
  }
  template <typename... Args> void invoke(Shard shard, Args &&...args) const {
    m_mx->invoke(sid(shard), ZuFwd<Args>(args)...);
  }
  bool invoked(Shard shard) const { return m_mx->invoked(sid(shard)); }

  void open(OpenFn);
  void close();

  template <typename O, bool TimeIndex, bool Create>
  void openDF(
    Shard shard, ZtString name, ZmFn<void(ZmRef<DataFrame<O, TimeIndex>>)> fn
  ) {
    using DataFrame = Zdf::DataFrame<O, TimeIndex>;
    using DFRef = ZmRef<DataFrame>;
    using W = WrapType<O, TimeIndex>;
    using Fields = Zdf::Fields<W>;
    using SeriesRefs = Zdf::SeriesRefs<W>;

    ZuLambda{[this, shard, name = ZuMv(name), fn = ZuMv(fn),
	      seriesRefs =
		SeriesRefs{}](auto &&self, auto I, auto series) mutable {
      if constexpr (I >= 0) {
	if (__builtin_expect(!!(!series), 0)) {
	  fn(DFRef{});
	  return;
	}
	seriesRefs.template p<I>() = ZuMv(series);
      }
      enum { J = I + 1 };
      if constexpr (J >= SeriesRefs::N) {
	fn(DFRef{
	  new DataFrame{this, shard, ZuMv(name), ZuMv(seriesRefs)}
	});
      } else {
	using Field = ZuType<J, Fields>;
	using Decoder = FieldDecoder<Field>;
	auto next = [self = ZuMv(self)](auto series) mutable {
	  ZuMv(self).template operator()(ZuInt<J>{}, ZuMv(series));
	};
	ZtString seriesName{name.length() + strlen(Field::id()) + 2};
	seriesName << name << '/' << Field::id();
	openSeries<Decoder, Create>(shard, ZuMv(seriesName), ZuMv(next));
      }
    }}(ZuInt<-1>{}, static_cast<void *>(nullptr));
  }

  template <typename Decoder, bool Create>
  void openSeries(
    Shard shard, ZtString name, ZmFn<void(ZmRef<Series<Decoder>>)> fn
  ) {
    using Series = Zdf::Series<Decoder>;
    using DBSeries = typename Series::DBSeries;
    enum { Fixed = Series::Fixed };

    static auto seriesTbl = [](const Store *this_) {
      if constexpr (Fixed)
	return this_->m_seriesFixedTbl;
      else
	return this_->m_seriesFloatTbl;
    };

    run(shard, [this, shard, name = ZuMv(name), fn = ZuMv(fn)]() mutable {
      auto findFn = [this, shard, name,
		     fn = ZuMv(fn)](ZdbObjRef<DBSeries> dbSeries) mutable {
	if (dbSeries) {
	  ZmRef<Series> series = new Series{this, ZuMv(dbSeries)};
	  series->open(ZuMv(fn));
	  return;
	}
	if (!Create) {
	  fn(nullptr);
	  return;
	}
	dbSeries = new ZdbObject<DBSeries>{seriesTbl(this), shard};
	new (dbSeries->ptr_()) DBSeries{
	  .id = m_nextSeriesID++,
	  .name = ZuMv(name),
	  .epoch = Zm::now(),
	  .blkOffset = 0
	};
	auto insertFn = [this,
			 fn = ZuMv(fn)](ZdbObjRef<DBSeries> dbSeries) mutable {
	  if (!dbSeries) {
	    fn(nullptr);
	    return;
	  }
	  dbSeries->commit();
	  ZmRef<Series> series = new Series{this, ZuMv(dbSeries)};
	  series->open(ZuMv(fn));
	};
	seriesTbl(this)->insert(dbSeries, ZuMv(insertFn));
      };
      seriesTbl(this)->template find<1>(shard, ZuMvTuple(name), ZuMv(findFn));
    });
  }

  ZdbTable<DB::SeriesFixed> *seriesFixedTbl() const { return m_seriesFixedTbl; }
  ZdbTable<DB::SeriesFloat> *seriesFloatTbl() const { return m_seriesFloatTbl; }
  ZdbTable<DB::BlkFixed> *blkFixedTbl() const { return m_blkFixedTbl; }
  ZdbTable<DB::BlkFloat> *blkFloatTbl() const { return m_blkFloatTbl; }
  ZdbTable<DB::BlkData> *blkDataTbl() const { return m_blkDataTbl; }

private:
  void open_recoverNextSeriesID_Fixed();
  void open_recoverNextSeriesID_Float();
  void opened(bool ok);

private:
  ZiMultiplex *m_mx = nullptr;
  StoreState::T m_state = StoreState::Uninitialized;
  ZdbTblRef<DB::SeriesFixed> m_seriesFixedTbl;
  ZdbTblRef<DB::SeriesFloat> m_seriesFloatTbl;
  ZdbTblRef<DB::BlkFixed> m_blkFixedTbl;
  ZdbTblRef<DB::BlkFloat> m_blkFloatTbl;
  ZdbTblRef<DB::BlkData> m_blkDataTbl;
  ZdbTableCf::SIDArray m_sids;
  ZmAtomic<uint32_t> m_nextSeriesID = 1;
  OpenFn m_openFn;
};

template <typename O, bool TimeIndex>
template <typename... Args>
inline void DataFrame<O, TimeIndex>::run(Args &&...args) const {
  m_store->run(m_shard, ZuFwd<Args>(args)...);
}
template <typename O, bool TimeIndex>
template <typename... Args>
inline void DataFrame<O, TimeIndex>::invoke(Args &&...args) const {
  m_store->invoke(m_shard, ZuFwd<Args>(args)...);
}
template <typename O, bool TimeIndex>
inline bool DataFrame<O, TimeIndex>::invoked() const {
  return m_store->invoked(m_shard);
}

template <typename Decoder>
template <typename... Args>
inline void Series<Decoder>::run(Args &&...args) const {
  m_store->run(m_shard, ZuFwd<Args>(args)...);
}
template <typename Decoder>
template <typename... Args>
inline void Series<Decoder>::invoke(Args &&...args) const {
  m_store->invoke(m_shard, ZuFwd<Args>(args)...);
}
template <typename Decoder> inline bool Series<Decoder>::invoked() const {
  return m_store->invoked(m_shard);
}

template <typename Decoder>
ZdbTable<DB::BlkData> *Series<Decoder>::blkDataTbl() const {
  return m_store->blkDataTbl();
}
template <typename Decoder>
auto Series<Decoder>::seriesTbl() const
  -> ZuIf<Fixed, ZdbTable<DB::SeriesFixed> *, ZdbTable<DB::SeriesFloat> *> {
  if constexpr (Fixed)
    return m_store->seriesFixedTbl();
  else
    return m_store->seriesFloatTbl();
}
template <typename Decoder>
auto Series<Decoder>::blkTbl(
) const -> ZuIf<Fixed, ZdbTable<DB::BlkFixed> *, ZdbTable<DB::BlkFloat> *> {
  if constexpr (Fixed)
    return m_store->blkFixedTbl();
  else
    return m_store->blkFloatTbl();
}

} // namespace Zdf

void print(const char *s) { std::cout << s << '\n' << std::flush; }
void print(const char *s, int64_t i) {
  std::cout << s << ' ' << i << '\n' << std::flush;
}
void ok(const char *s) { print(s); }
void ok(const char *s, int64_t i) { print(s, i); }
void fail(const char *s) { print(s); }
void fail(const char *s, int64_t i) { print(s, i); }

ZmRef<Zdb> db;

ZuPtr<Zdf::Store> store;

ZuPtr<ZiMultiplex> mx;

ZmSemaphore done;

void sigint() {
  std::cerr << "SIGINT\n" << std::flush;
  done.post();
}

ZmRef<ZvCf> inlineCf(ZuCSpan s) {
  ZmRef<ZvCf> cf = new ZvCf{};
  cf->fromString(s);
  return cf;
}

void gtfo() {
  if (mx) mx->stop();
  ZeLog::stop();
  Zm::exit(1);
}

struct Frame {
  uint64_t v1;
  int64_t v2_;

  ZuFixed v2() const { return ZuFixed{v2_, 9}; }
  void v2(ZuFixed v) { v2_ = v.adjust(9); }
};
namespace ZuSchema {
struct ZuField_Frame_v1 {
  using Orig = ZuField_Frame_v1;
  template <template <typename> typename Override> using Adapt = Override<Orig>;
  enum { ReadOnly = 0 };
  using O = Frame;
  static constexpr const char *id() { return "v1"; }
  using Props = ZuTypeList<
    ZuFieldProp::Ctor<0>, ZuFieldProp::Series, ZuFieldProp::Index,
    ZuFieldProp::Delta>;
  using T = ZuDecay<decltype(ZuDeclVal<const Frame &>().v1)>;
  static const T &get(const Frame &o) { return o.v1; }
  static T &get(Frame &o) { return o.v1; }
  static T &&get(Frame &&o) { return ZuMv(o.v1); }
  template <typename P> static void set(Frame &o, P &&v) { o.v1 = ZuFwd<P>(v); }
};
using ZtField_Frame_v1 = ZtField_UInt64<ZuSchema::ZuField_Frame_v1>;
struct ZuField_Frame_v2 {
  using Orig = ZuField_Frame_v2;
  template <template <typename> typename Override> using Adapt = Override<Orig>;
  enum { ReadOnly = 0 };
  using O = Frame;
  static constexpr const char *id() { return "v2"; }
  using Props =
    ZuTypeList<ZuFieldProp::Series, ZuFieldProp::Delta, ZuFieldProp::NDP<9>>;
  using T = ZuDecay<decltype(ZuDeclVal<const Frame &>().v2())>;
  static decltype(auto) get(const Frame &o) { return o.v2(); }
  static decltype(auto) get(Frame &o) { return o.v2(); }
  static decltype(auto) get(Frame &&o) { return ZuMv(o).v2(); }
  template <typename V> static void set(Frame &o, V &&v) { o.v2(ZuFwd<V>(v)); }
};
using ZtField_Frame_v2 = ZtField_Fixed<ZuSchema::ZuField_Frame_v2>;
using Frame = ZuTypeList<ZtField_Frame_v1, ZtField_Frame_v2>;
} // namespace ZuSchema
Frame ZuFielded_(Frame *);
ZuSchema::Frame ZuFields_(Frame *);

void usage() {
  std::cerr << "Usage: zdftest\n" << std::flush;
  ::exit(1);
}

using DF = Zdf::DataFrame<Frame, false>;
using DFWriter = DF::Writer;

struct Test {
  ZmRef<DF> df;

  void run() {
    store->openDF<Frame, false, true>(0, "frame", [this](ZmRef<DF> df_) {
      run_opened(ZuMv(df_));
    });
  }
  void run_opened(ZmRef<DF> df_) {
    if (!df_) {
      ZeLogEvent(ZeMkEvent(
	Ze::Fatal, "zdftest.cc", 94, __PRETTY_FUNCTION__,
	"data frame open failed"
      ));
      done.post();
      return;
    }
    df = ZuMv(df_);
    df->write([this](ZmRef<DFWriter> w) { run_write(ZuMv(w)); }, []() {
      ZeLogEvent(ZeMkEvent(
	Ze::Fatal, "zdftest.cc", 102, __PRETTY_FUNCTION__,
	"data frame write failed"
      ));
      done.post();
    });
  }
  void run_write(ZmRef<DFWriter> w) {
    Frame frame;
    for (uint64_t i = 0; i < 300; i++) {
      frame.v1 = i;
      frame.v2_ = i * 42;
      w->write(frame);
    }
    df->run([this]() { run_read1(); });
  }
  void run_read1() {
    df->find<ZuSchema::ZtField_Frame_v1>(
      ZuFixed{20, 0}, [this](auto rc, ZuFixed v) { run_read2(ZuMv(rc), v); },
      []() {
      ZeLogEvent(ZeMkEvent(
	Ze::Fatal, "zdftest.cc", 119, __PRETTY_FUNCTION__,
	"data frame read1 failed"
      ));
      done.post();
    }
    );
  }
  template <typename Ctrl> void run_read2(Ctrl rc, ZuFixed v) {
    rc.stop();
    df->seek<ZuSchema::ZtField_Frame_v2>(
      rc.reader.offset(),
      [this](auto rc, ZuFixed v) { run_read3(ZuMv(rc), v); },
      []() {
      ZeLogEvent(ZeMkEvent(
	Ze::Fatal, "zdftest.cc", 130, __PRETTY_FUNCTION__,
	"data frame read2 failed"
      ));
      done.post();
    }
    );
  }
  template <typename Ctrl> void run_read3(Ctrl rc, ZuFixed v) {
    rc.stop();
    ((v.mantissa == 20 * 42) ? ok("OK  "
				  "v.mantissa == 20 * 42") :
			       fail("NOK "
				    "v.mantissa == 20 * 42"));
    ((v.ndp == 9) ? ok("OK  "
		       "v.ndp == 9") :
		    fail("NOK "
			 "v.ndp == 9"));
    done.post();
  }
};

Test test;

int main(int argc, char **argv) {
  ZmRef<ZvCf> cf;

  try {
    cf = inlineCf(
      "zdb {\n"
      "  thread zdb\n"
      "  store { thread zdb_mem }\n"
      "  hostID 0\n"
      "  hosts {\n"
      "    0 { standalone 1 }\n"
      "  }\n"
      "  tables { }\n"
      "  debug 1\n"
      "}\n"
      "mx {\n"
      "  nThreads 4\n"
      "  threads {\n"
      "    1 { name rx isolated true }\n"
      "    2 { name tx isolated true }\n"
      "    3 { name zdb isolated true }\n"
      "    4 { name zdb_mem isolated true }\n"
      "  }\n"
      "  rxThread rx\n"
      "  txThread tx\n"
      "}\n"
    );

  } catch (const ZvError &e) {
    std::cerr << e << '\n' << std::flush;
    Zm::exit(1);
  } catch (const ZeError &e) {
    std::cerr << e << '\n' << std::flush;
    Zm::exit(1);
  } catch (...) { Zm::exit(1); }

  ZeLog::init("zdftest");
  ZeLog::level(0);
  ZeLog::sink(ZeLog::fileSink(ZeSinkOptions{}.path("&2")));
  ZeLog::start();

  ZmTrap::sigintFn(sigint);
  ZmTrap::trap();

  try {
    ZeError e;

    mx = new ZiMultiplex{
      ZvMxParams{"mx", cf->getCf<true>("mx")}
    };

    if (!mx->start())
      throw ZeMkEvent(
	Ze::Fatal, "zdftest.cc", 228, __PRETTY_FUNCTION__,
	"multiplexer start failed"
      );

    db = new Zdb();

    ZdbCf dbCf{cf->getCf<true>("zdb")};

    Zdf::Store::dbCf(cf, dbCf);

    db->init(
      ZuMv(dbCf), mx,
      ZdbHandler{
	.upFn =
	  [](Zdb *, ZdbHost *host) {
      ZeLogEvent(ZeMkEvent(
	Ze::Info, "zdftest.cc", 238, __PRETTY_FUNCTION__,
	([id = host ? host->id() : ZuID{"unset"}](auto &s) {
	s << "ACTIVE (was " << id << ')';
      })
      ));
      done.post();
    },
	.downFn =
	  [](Zdb *, bool) {
      ZeLogEvent(
	ZeMkEvent(Ze::Info, "zdftest.cc", 244, __PRETTY_FUNCTION__, "INACTIVE")
      );
    }
      },
      new ZdbMem::Store()
    );

    store = new Zdf::Store{};
    store->init(db);

    db->start();
    done.wait();

    store->run(0, []() {
      store->open([](bool ok) {
	std::cout << "open(): " << (ok ? "OK" : "NOT OK") << '\n';
	if (ok)
	  test.run();
	else
	  done.post();
      });
    });

    done.wait();

    db->stop();

    db->final();

    mx->stop();

    ZeLogEvent(ZeMkEvent(
      Ze::Debug, "zdftest.cc", 272, __PRETTY_FUNCTION__,
      (ZtString{} << '\n'
		  << ZmHashMgr::csv())
    ));

    db = {};
    store = {};

  } catch (const ZvError &e) {
    ZeLogEvent(
      ZeMkEvent(Ze::Fatal, "zdftest.cc", 278, __PRETTY_FUNCTION__, ZtString{e})
    );
    gtfo();
  } catch (const ZeError &e) {
    ZeLogEvent(
      ZeMkEvent(Ze::Fatal, "zdftest.cc", 281, __PRETTY_FUNCTION__, ZtString{e})
    );
    gtfo();
  } catch (const ZeAnyEvent &e) {
    ZeLogEvent(ZeVEvent{e});
    gtfo();
  } catch (...) {
    ZeLogEvent(ZeMkEvent(
      Ze::Fatal, "zdftest.cc", 287, __PRETTY_FUNCTION__, "unknown exception"
    ));
    gtfo();
  }

  mx = {};

  ZeLog::stop();

  std::cout << ZmHeapMgr::csv();

  return 0;
}
